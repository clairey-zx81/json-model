//
// Generated by JSON Model Compiler version 2
// see https://github.com/clairey-zx81/json-model
//

// regular expression engine
#include <stddef.h>
#include <cre2.h>

#include <json-model.h>
#define JSON_MODEL_VERSION "2"

static INLINE bool _jm_cst_0_str_test(const char *);
static bool json_model_1(const json_t *val, jm_path_t *path, jm_report_t *rep);
jm_propmap_t check_model_map_tab[1];
const size_t check_model_map_size = 1;

static INLINE bool _jm_cst_0_str_test(const char *s)
{
    uint32_t hash = (*((uint32_t *) (s))) & 0xffffff;
    return 
        (hash <= 0x3737) ? (
        (hash <= 0x3337) ? (
           jm_str_eq_3(s, 0x00003030)  // "00"
        || jm_str_eq_3(s, 0x00003130)  // "01"
        || jm_str_eq_3(s, 0x00003230)  // "02"
        || jm_str_eq_3(s, 0x00003330)  // "03"
        || jm_str_eq_3(s, 0x00003031)  // "10"
        || jm_str_eq_3(s, 0x00003131)  // "11"
        || jm_str_eq_3(s, 0x00003231)  // "12"
        || jm_str_eq_3(s, 0x00003331)  // "13"
        || jm_str_eq_3(s, 0x00003032)  // "20"
        || jm_str_eq_3(s, 0x00003132)  // "21"
        || jm_str_eq_3(s, 0x00003232)  // "22"
        || jm_str_eq_3(s, 0x00003332)  // "23"
        || jm_str_eq_3(s, 0x00003033)  // "30"
        || jm_str_eq_3(s, 0x00003133)  // "31"
        || jm_str_eq_3(s, 0x00003233)  // "32"
        || jm_str_eq_3(s, 0x00003333)  // "33"
        || jm_str_eq_3(s, 0x00003034)  // "40"
        || jm_str_eq_3(s, 0x00003134)  // "41"
        || jm_str_eq_3(s, 0x00003234)  // "42"
        || jm_str_eq_3(s, 0x00003334)  // "43"
        || jm_str_eq_3(s, 0x00003035)  // "50"
        || jm_str_eq_3(s, 0x00003135)  // "51"
        || jm_str_eq_3(s, 0x00003235)  // "52"
        || jm_str_eq_3(s, 0x00003335)  // "53"
        || jm_str_eq_3(s, 0x00003036)  // "60"
        || jm_str_eq_3(s, 0x00003136)  // "61"
        || jm_str_eq_3(s, 0x00003236)  // "62"
        || jm_str_eq_3(s, 0x00003336)  // "63"
        || jm_str_eq_3(s, 0x00003037)  // "70"
        || jm_str_eq_3(s, 0x00003137)  // "71"
        || jm_str_eq_3(s, 0x00003237)  // "72"
        || jm_str_eq_3(s, 0x00003337)  // "73"
        ) : (
           jm_str_eq_3(s, 0x00003430)  // "04"
        || jm_str_eq_3(s, 0x00003530)  // "05"
        || jm_str_eq_3(s, 0x00003630)  // "06"
        || jm_str_eq_3(s, 0x00003730)  // "07"
        || jm_str_eq_3(s, 0x00003431)  // "14"
        || jm_str_eq_3(s, 0x00003531)  // "15"
        || jm_str_eq_3(s, 0x00003631)  // "16"
        || jm_str_eq_3(s, 0x00003731)  // "17"
        || jm_str_eq_3(s, 0x00003432)  // "24"
        || jm_str_eq_3(s, 0x00003532)  // "25"
        || jm_str_eq_3(s, 0x00003632)  // "26"
        || jm_str_eq_3(s, 0x00003732)  // "27"
        || jm_str_eq_3(s, 0x00003433)  // "34"
        || jm_str_eq_3(s, 0x00003533)  // "35"
        || jm_str_eq_3(s, 0x00003633)  // "36"
        || jm_str_eq_3(s, 0x00003733)  // "37"
        || jm_str_eq_3(s, 0x00003434)  // "44"
        || jm_str_eq_3(s, 0x00003534)  // "45"
        || jm_str_eq_3(s, 0x00003634)  // "46"
        || jm_str_eq_3(s, 0x00003734)  // "47"
        || jm_str_eq_3(s, 0x00003435)  // "54"
        || jm_str_eq_3(s, 0x00003535)  // "55"
        || jm_str_eq_3(s, 0x00003635)  // "56"
        || jm_str_eq_3(s, 0x00003735)  // "57"
        || jm_str_eq_3(s, 0x00003436)  // "64"
        || jm_str_eq_3(s, 0x00003536)  // "65"
        || jm_str_eq_3(s, 0x00003636)  // "66"
        || jm_str_eq_3(s, 0x00003736)  // "67"
        || jm_str_eq_3(s, 0x00003437)  // "74"
        || jm_str_eq_3(s, 0x00003537)  // "75"
        || jm_str_eq_3(s, 0x00003637)  // "76"
        || jm_str_eq_3(s, 0x00003737)  // "77"
        )) : (
        (hash <= 0x6237) ? (
           jm_str_eq_3(s, 0x00003830)  // "08"
        || jm_str_eq_3(s, 0x00003930)  // "09"
        || jm_str_eq_3(s, 0x00006130)  // "0a"
        || jm_str_eq_3(s, 0x00006230)  // "0b"
        || jm_str_eq_3(s, 0x00003831)  // "18"
        || jm_str_eq_3(s, 0x00003931)  // "19"
        || jm_str_eq_3(s, 0x00006131)  // "1a"
        || jm_str_eq_3(s, 0x00006231)  // "1b"
        || jm_str_eq_3(s, 0x00003832)  // "28"
        || jm_str_eq_3(s, 0x00003932)  // "29"
        || jm_str_eq_3(s, 0x00006132)  // "2a"
        || jm_str_eq_3(s, 0x00006232)  // "2b"
        || jm_str_eq_3(s, 0x00003833)  // "38"
        || jm_str_eq_3(s, 0x00003933)  // "39"
        || jm_str_eq_3(s, 0x00006133)  // "3a"
        || jm_str_eq_3(s, 0x00006233)  // "3b"
        || jm_str_eq_3(s, 0x00003834)  // "48"
        || jm_str_eq_3(s, 0x00003934)  // "49"
        || jm_str_eq_3(s, 0x00006134)  // "4a"
        || jm_str_eq_3(s, 0x00006234)  // "4b"
        || jm_str_eq_3(s, 0x00003835)  // "58"
        || jm_str_eq_3(s, 0x00003935)  // "59"
        || jm_str_eq_3(s, 0x00006135)  // "5a"
        || jm_str_eq_3(s, 0x00006235)  // "5b"
        || jm_str_eq_3(s, 0x00003836)  // "68"
        || jm_str_eq_3(s, 0x00003936)  // "69"
        || jm_str_eq_3(s, 0x00006136)  // "6a"
        || jm_str_eq_3(s, 0x00006236)  // "6b"
        || jm_str_eq_3(s, 0x00003837)  // "78"
        || jm_str_eq_3(s, 0x00003937)  // "79"
        || jm_str_eq_3(s, 0x00006137)  // "7a"
        || jm_str_eq_3(s, 0x00006237)  // "7b"
        ) : (
           jm_str_eq_3(s, 0x00006330)  // "0c"
        || jm_str_eq_3(s, 0x00006430)  // "0d"
        || jm_str_eq_3(s, 0x00006530)  // "0e"
        || jm_str_eq_3(s, 0x00006630)  // "0f"
        || jm_str_eq_3(s, 0x00006331)  // "1c"
        || jm_str_eq_3(s, 0x00006431)  // "1d"
        || jm_str_eq_3(s, 0x00006531)  // "1e"
        || jm_str_eq_3(s, 0x00006631)  // "1f"
        || jm_str_eq_3(s, 0x00006332)  // "2c"
        || jm_str_eq_3(s, 0x00006432)  // "2d"
        || jm_str_eq_3(s, 0x00006532)  // "2e"
        || jm_str_eq_3(s, 0x00006632)  // "2f"
        || jm_str_eq_3(s, 0x00006333)  // "3c"
        || jm_str_eq_3(s, 0x00006433)  // "3d"
        || jm_str_eq_3(s, 0x00006533)  // "3e"
        || jm_str_eq_3(s, 0x00006633)  // "3f"
        || jm_str_eq_3(s, 0x00006334)  // "4c"
        || jm_str_eq_3(s, 0x00006434)  // "4d"
        || jm_str_eq_3(s, 0x00006534)  // "4e"
        || jm_str_eq_3(s, 0x00006634)  // "4f"
        || jm_str_eq_3(s, 0x00006335)  // "5c"
        || jm_str_eq_3(s, 0x00006435)  // "5d"
        || jm_str_eq_3(s, 0x00006535)  // "5e"
        || jm_str_eq_3(s, 0x00006635)  // "5f"
        || jm_str_eq_3(s, 0x00006336)  // "6c"
        || jm_str_eq_3(s, 0x00006436)  // "6d"
        || jm_str_eq_3(s, 0x00006536)  // "6e"
        || jm_str_eq_3(s, 0x00006636)  // "6f"
        || jm_str_eq_3(s, 0x00006337)  // "7c"
        || jm_str_eq_3(s, 0x00006437)  // "7d"
        || jm_str_eq_3(s, 0x00006537)  // "7e"
        || jm_str_eq_3(s, 0x00006637)  // "7f"
        ))
    ;
}

// check $ (.)
static bool json_model_1(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    // 256 string constants to partitionâ€¦
    // .
    return json_is_string(val) && _jm_cst_0_str_test(json_string_value(val));
}

jm_check_fun_t check_model_map(const char *pname)
{
    return jm_search_propmap(pname, check_model_map_tab, 1);
}

static bool initialized = false;

const char *check_model_init(void)
{
    if (!initialized)
    {
        initialized = true;
        jm_version_string = JSON_MODEL_VERSION;
        check_model_map_tab[0] = (jm_propmap_t) { "", json_model_1 };
        jm_sort_propmap(check_model_map_tab, 1);
    }
    return NULL;
}

void check_model_free(void)
{
    if (initialized)
        initialized = false;

        // cleanup code
}

/*
 * # API
 *
 * ```c
 * bool error;
 * char *message;
 *
 * bool valid = check(json_value, "model-name", &error, &message);
 *
 * if (message)
 *    free(message), message = NULL;
 * ```
 *
 * - `error` is set of there was an error during initialization or if the model does not exists.
 * - `message` is provided if a non NULL pointer is passed, and must be freed by the caller.
 */
bool
check_model(const json_t *val, const char *name, bool *error, char **reasons)
{
    return jm_generic_entry(check_model_init, check_model_map, val, name, error, reasons);
}
