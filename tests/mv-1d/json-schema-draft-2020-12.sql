--
-- Generated by JSON Model Compiler version 2
-- see https://github.com/clairey-zx81/json-model
--
-- JSON_MODEL_VERSION is 2
CREATE EXTENSION IF NOT EXISTS json_model;

-- check $URI-REFERENCE (.'$URI-REFERENCE')
CREATE OR REPLACE FUNCTION json_model_2(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .'$URI-REFERENCE'
  RETURN JSONB_TYPEOF(val) = 'string';
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_3_map_$comment (.'$core'.'$comment')
CREATE OR REPLACE FUNCTION _jm_f_0(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .'$core'.'$comment'
  RETURN JSONB_TYPEOF(val) = 'string';
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_3_map_$defs (.'$core'.'$defs')
CREATE OR REPLACE FUNCTION _jm_f_1(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
BEGIN
  -- .'$core'.'$defs'
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    -- handle other props
    -- .'$core'.'$defs'.''
    res := json_model_16(pval, NULL, NULL);
    IF NOT res THEN
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_3_map_$schema (.'$core'.'$schema')
CREATE OR REPLACE FUNCTION _jm_f_2(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .'$core'.'$schema'
  RETURN JSONB_TYPEOF(val) = 'string' AND JSON_VALUE(val, '$' RETURNING TEXT) = 'https://json-schema.org/draft/2020-12/schema';
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_3_map_$vocabulary (.'$core'.'$vocabulary')
CREATE OR REPLACE FUNCTION _jm_f_3(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
BEGIN
  -- .'$core'.'$vocabulary'
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF jm_is_valid_url(prop, NULL, NULL) THEN
      -- handle 1 key props
      -- .'$core'.'$vocabulary'.'$URI'
      res := JSONB_TYPEOF(pval) = 'boolean';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION json_model_3_map(name TEXT)
RETURNS TEXT STRICT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  map JSONB := JSONB '{"$anchor":"json_model_2","$comment":"_jm_f_0","$defs":"_jm_f_1","$dynamicAnchor":"json_model_2","$dynamicRef":"json_model_2","$id":"json_model_2","$ref":"json_model_2","$schema":"_jm_f_2","$vocabulary":"_jm_f_3"}';
BEGIN
  RETURN map->>name;
END;
$$ LANGUAGE plpgsql;

-- check $core (.'$core')
CREATE OR REPLACE FUNCTION json_model_3(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  pfun TEXT;
  prop TEXT;
  pval JSONB;
BEGIN
  -- .'$core'
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF json_model_3_map(prop) IS NOT NULL THEN
      -- handle 9 may props
      pfun := json_model_3_map(prop);
      IF NOT jm_call(pfun, pval, NULL, NULL) THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check $meta (.'$meta')
CREATE OR REPLACE FUNCTION json_model_4(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
BEGIN
  -- .'$meta'
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = 'title' THEN
      -- handle may title property
      -- .'$meta'.title
      res := JSONB_TYPEOF(pval) = 'string';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'default' THEN
      -- handle may default property
      -- .'$meta'.default
      res := TRUE;
    ELSEIF prop = 'examples' THEN
      -- handle may examples property
      -- .'$meta'.examples
      res := JSONB_TYPEOF(pval) = 'array';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'readOnly' THEN
      -- handle may readOnly property
      -- .'$meta'.readOnly
      res := JSONB_TYPEOF(pval) = 'boolean';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'writeOnly' THEN
      -- handle may writeOnly property
      -- .'$meta'.writeOnly
      res := JSONB_TYPEOF(pval) = 'boolean';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'deprecated' THEN
      -- handle may deprecated property
      -- .'$meta'.deprecated
      res := JSONB_TYPEOF(pval) = 'boolean';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'description' THEN
      -- handle may description property
      -- .'$meta'.description
      res := JSONB_TYPEOF(pval) = 'string';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check $content (.'$content')
CREATE OR REPLACE FUNCTION json_model_5(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
BEGIN
  -- .'$content'
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = 'contentSchema' THEN
      -- handle may contentSchema property
      -- .'$content'.contentSchema
      res := json_model_16(pval, NULL, NULL);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'contentEncoding' THEN
      -- handle may contentEncoding property
      -- .'$content'.contentEncoding
      res := JSONB_TYPEOF(pval) = 'string';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'contentMediaType' THEN
      -- handle may contentMediaType property
      -- .'$content'.contentMediaType
      res := JSONB_TYPEOF(pval) = 'string';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check $unevaluated (.'$unevaluated')
CREATE OR REPLACE FUNCTION json_model_6(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
BEGIN
  -- .'$unevaluated'
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = 'unevaluatedItems' THEN
      -- handle may unevaluatedItems property
      -- .'$unevaluated'.unevaluatedItems
      res := json_model_16(pval, NULL, NULL);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'unevaluatedProperties' THEN
      -- handle may unevaluatedProperties property
      -- .'$unevaluated'.unevaluatedProperties
      res := json_model_16(pval, NULL, NULL);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check $format (.'$format')
CREATE OR REPLACE FUNCTION json_model_7(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
BEGIN
  -- .'$format'
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = 'format' THEN
      -- handle may format property
      -- .'$format'.format
      res := JSONB_TYPEOF(pval) = 'string';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION _jm_cst_0(value JSONB)
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  constants JSONB = JSONB '["array","boolean","integer","null","number","object","string"]';
BEGIN
  RETURN constants @> value;
END;
$$ LANGUAGE plpgsql;

-- check $simpleTypes (.'$simpleTypes')
CREATE OR REPLACE FUNCTION json_model_8(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .'$simpleTypes'
  RETURN JSONB_TYPEOF(val) IN ('null', 'boolean', 'number', 'string') AND _jm_cst_0(val);
END;
$$ LANGUAGE PLpgSQL;

-- check $simpleTypesArray (.'$simpleTypesArray')
CREATE OR REPLACE FUNCTION json_model_9(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  arr_0_idx INT8;
  arr_0_item JSONB;
  ival_0 int;
BEGIN
  -- .'$simpleTypesArray'
  -- .'$simpleTypesArray'.'@'
  res := JSONB_TYPEOF(val) = 'array';
  IF res THEN
    FOR arr_0_idx IN 0 .. JSONB_ARRAY_LENGTH(val) - 1 LOOP
      arr_0_item := val -> arr_0_idx;
      -- .'$simpleTypesArray'.'@'.0
      res := json_model_8(arr_0_item, NULL, NULL);
      IF NOT res THEN
        EXIT;
      END IF;
    END LOOP;
  END IF;
  IF res THEN
    ival_0 := JSONB_ARRAY_LENGTH(val);
    res := jm_array_is_unique(val, NULL, NULL) AND ival_0 >= 1;
  END IF;
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check $stringArray (.'$stringArray')
CREATE OR REPLACE FUNCTION json_model_10(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  arr_1_idx INT8;
  arr_1_item JSONB;
BEGIN
  -- .'$stringArray'
  -- .'$stringArray'.'@'
  res := JSONB_TYPEOF(val) = 'array';
  IF res THEN
    FOR arr_1_idx IN 0 .. JSONB_ARRAY_LENGTH(val) - 1 LOOP
      arr_1_item := val -> arr_1_idx;
      -- .'$stringArray'.'@'.0
      res := JSONB_TYPEOF(arr_1_item) = 'string';
      IF NOT res THEN
        EXIT;
      END IF;
    END LOOP;
  END IF;
  IF res THEN
    res := jm_array_is_unique(val, NULL, NULL);
  END IF;
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check $nonNegativeInteger (.'$nonNegativeInteger')
CREATE OR REPLACE FUNCTION json_model_11(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .'$nonNegativeInteger'
  RETURN JSONB_TYPEOF(val) = 'number' AND (val)::INT8 = (val)::FLOAT8 AND (val)::FLOAT8 >= 0;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_12_map_const (.'$validation'.const)
CREATE OR REPLACE FUNCTION _jm_f_4(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .'$validation'.const
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_12_map_dependentRequired (.'$validation'.dependentRequired)
CREATE OR REPLACE FUNCTION _jm_f_5(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
BEGIN
  -- .'$validation'.dependentRequired
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    -- handle other props
    -- .'$validation'.dependentRequired.''
    res := json_model_10(pval, NULL, NULL);
    IF NOT res THEN
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_12_map_enum (.'$validation'.enum)
CREATE OR REPLACE FUNCTION _jm_f_6(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .'$validation'.enum
  RETURN JSONB_TYPEOF(val) = 'array';
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_12_map_exclusiveMaximum (.'$validation'.exclusiveMaximum)
CREATE OR REPLACE FUNCTION _jm_f_7(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .'$validation'.exclusiveMaximum
  RETURN JSONB_TYPEOF(val) = 'number';
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_12_map_exclusiveMinimum (.'$validation'.exclusiveMinimum)
CREATE OR REPLACE FUNCTION _jm_f_8(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .'$validation'.exclusiveMinimum
  RETURN JSONB_TYPEOF(val) = 'number';
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_12_map_maximum (.'$validation'.maximum)
CREATE OR REPLACE FUNCTION _jm_f_9(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .'$validation'.maximum
  RETURN JSONB_TYPEOF(val) = 'number';
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_12_map_minimum (.'$validation'.minimum)
CREATE OR REPLACE FUNCTION _jm_f_10(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .'$validation'.minimum
  RETURN JSONB_TYPEOF(val) = 'number';
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_12_map_multipleOf (.'$validation'.multipleOf)
CREATE OR REPLACE FUNCTION _jm_f_11(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .'$validation'.multipleOf
  RETURN JSONB_TYPEOF(val) = 'number' AND (val)::FLOAT8 > 0.0;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_12_map_pattern (.'$validation'.pattern)
CREATE OR REPLACE FUNCTION _jm_f_12(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .'$validation'.pattern
  RETURN JSONB_TYPEOF(val) = 'string' AND jm_is_valid_regex(JSON_VALUE(val, '$' RETURNING TEXT), NULL, NULL);
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_12_map_type (.'$validation'.type)
CREATE OR REPLACE FUNCTION _jm_f_13(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .'$validation'.type
  -- .'$validation'.type.'|'.0
  -- .'$validation'.type.'|'.1
  RETURN json_model_8(val, NULL, NULL) OR json_model_9(val, NULL, NULL);
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_12_map_uniqueItems (.'$validation'.uniqueItems)
CREATE OR REPLACE FUNCTION _jm_f_14(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .'$validation'.uniqueItems
  RETURN JSONB_TYPEOF(val) = 'boolean';
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION json_model_12_map(name TEXT)
RETURNS TEXT STRICT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  map JSONB := JSONB '{"const":"_jm_f_4","dependentRequired":"_jm_f_5","enum":"_jm_f_6","exclusiveMaximum":"_jm_f_7","exclusiveMinimum":"_jm_f_8","maxContains":"json_model_11","maxItems":"json_model_11","maxLength":"json_model_11","maxProperties":"json_model_11","maximum":"_jm_f_9","minContains":"json_model_11","minItems":"json_model_11","minLength":"json_model_11","minProperties":"json_model_11","minimum":"_jm_f_10","multipleOf":"_jm_f_11","pattern":"_jm_f_12","required":"json_model_10","type":"_jm_f_13","uniqueItems":"_jm_f_14"}';
BEGIN
  RETURN map->>name;
END;
$$ LANGUAGE plpgsql;

-- check $validation (.'$validation')
CREATE OR REPLACE FUNCTION json_model_12(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  pfun TEXT;
  prop TEXT;
  pval JSONB;
BEGIN
  -- .'$validation'
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF json_model_12_map(prop) IS NOT NULL THEN
      -- handle 20 may props
      pfun := json_model_12_map(prop);
      IF NOT jm_call(pfun, pval, NULL, NULL) THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check $schemaArray (.'$schemaArray')
CREATE OR REPLACE FUNCTION json_model_13(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  arr_2_idx INT8;
  arr_2_item JSONB;
  ival_1 int;
BEGIN
  -- .'$schemaArray'
  -- .'$schemaArray'.'@'
  res := JSONB_TYPEOF(val) = 'array';
  IF res THEN
    FOR arr_2_idx IN 0 .. JSONB_ARRAY_LENGTH(val) - 1 LOOP
      arr_2_item := val -> arr_2_idx;
      -- .'$schemaArray'.'@'.0
      res := json_model_16(arr_2_item, NULL, NULL);
      IF NOT res THEN
        EXIT;
      END IF;
    END LOOP;
  END IF;
  IF res THEN
    ival_1 := JSONB_ARRAY_LENGTH(val);
    res := ival_1 >= 1;
  END IF;
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_14_map_dependentSchemas (.'$applicator'.dependentSchemas)
CREATE OR REPLACE FUNCTION _jm_f_15(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
BEGIN
  -- .'$applicator'.dependentSchemas
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    -- handle other props
    -- .'$applicator'.dependentSchemas.''
    res := json_model_16(pval, NULL, NULL);
    IF NOT res THEN
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_14_map_patternProperties (.'$applicator'.patternProperties)
CREATE OR REPLACE FUNCTION _jm_f_16(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
BEGIN
  -- .'$applicator'.patternProperties
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF jm_is_valid_regex(prop, NULL, NULL) THEN
      -- handle 1 key props
      -- .'$applicator'.patternProperties.'$REGEX'
      res := json_model_16(pval, NULL, NULL);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_14_map_properties (.'$applicator'.properties)
CREATE OR REPLACE FUNCTION _jm_f_17(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
BEGIN
  -- .'$applicator'.properties
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    -- handle other props
    -- .'$applicator'.properties.''
    res := json_model_16(pval, NULL, NULL);
    IF NOT res THEN
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION json_model_14_map(name TEXT)
RETURNS TEXT STRICT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  map JSONB := JSONB '{"additionalProperties":"json_model_16","allOf":"json_model_13","anyOf":"json_model_13","contains":"json_model_16","dependentSchemas":"_jm_f_15","else":"json_model_16","if":"json_model_16","items":"json_model_16","not":"json_model_16","oneOf":"json_model_13","patternProperties":"_jm_f_16","prefixItems":"json_model_13","properties":"_jm_f_17","propertyNames":"json_model_16","then":"json_model_16"}';
BEGIN
  RETURN map->>name;
END;
$$ LANGUAGE plpgsql;

-- check $applicator (.'$applicator')
CREATE OR REPLACE FUNCTION json_model_14(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  pfun TEXT;
  prop TEXT;
  pval JSONB;
BEGIN
  -- .'$applicator'
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF json_model_14_map(prop) IS NOT NULL THEN
      -- handle 15 may props
      pfun := json_model_14_map(prop);
      IF NOT jm_call(pfun, pval, NULL, NULL) THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_15_map_$comment (.'$ObjectSchema'.'$comment')
CREATE OR REPLACE FUNCTION _jm_f_18(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .'$ObjectSchema'.'$comment'
  RETURN JSONB_TYPEOF(val) = 'string';
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_15_map_$defs (.'$ObjectSchema'.'$defs')
CREATE OR REPLACE FUNCTION _jm_f_19(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
BEGIN
  -- .'$ObjectSchema'.'$defs'
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    -- handle other props
    -- .'$ObjectSchema'.'$defs'.''
    res := json_model_16(pval, NULL, NULL);
    IF NOT res THEN
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_15_map_$schema (.'$ObjectSchema'.'$schema')
CREATE OR REPLACE FUNCTION _jm_f_20(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .'$ObjectSchema'.'$schema'
  RETURN JSONB_TYPEOF(val) = 'string' AND JSON_VALUE(val, '$' RETURNING TEXT) = 'https://json-schema.org/draft/2020-12/schema';
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_15_map_$vocabulary (.'$ObjectSchema'.'$vocabulary')
CREATE OR REPLACE FUNCTION _jm_f_21(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
BEGIN
  -- .'$ObjectSchema'.'$vocabulary'
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF jm_is_valid_url(prop, NULL, NULL) THEN
      -- handle 1 key props
      -- .'$ObjectSchema'.'$vocabulary'.'$URI'
      res := JSONB_TYPEOF(pval) = 'boolean';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_15_map_const (.'$ObjectSchema'.const)
CREATE OR REPLACE FUNCTION _jm_f_22(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .'$ObjectSchema'.const
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_15_map_contentEncoding (.'$ObjectSchema'.contentEncoding)
CREATE OR REPLACE FUNCTION _jm_f_23(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .'$ObjectSchema'.contentEncoding
  RETURN JSONB_TYPEOF(val) = 'string';
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_15_map_contentMediaType (.'$ObjectSchema'.contentMediaType)
CREATE OR REPLACE FUNCTION _jm_f_24(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .'$ObjectSchema'.contentMediaType
  RETURN JSONB_TYPEOF(val) = 'string';
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_15_map_default (.'$ObjectSchema'.default)
CREATE OR REPLACE FUNCTION _jm_f_25(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .'$ObjectSchema'.default
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_15_map_dependentRequired (.'$ObjectSchema'.dependentRequired)
CREATE OR REPLACE FUNCTION _jm_f_26(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
BEGIN
  -- .'$ObjectSchema'.dependentRequired
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    -- handle other props
    -- .'$ObjectSchema'.dependentRequired.''
    res := json_model_10(pval, NULL, NULL);
    IF NOT res THEN
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_15_map_dependentSchemas (.'$ObjectSchema'.dependentSchemas)
CREATE OR REPLACE FUNCTION _jm_f_27(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
BEGIN
  -- .'$ObjectSchema'.dependentSchemas
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    -- handle other props
    -- .'$ObjectSchema'.dependentSchemas.''
    res := json_model_16(pval, NULL, NULL);
    IF NOT res THEN
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_15_map_deprecated (.'$ObjectSchema'.deprecated)
CREATE OR REPLACE FUNCTION _jm_f_28(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .'$ObjectSchema'.deprecated
  RETURN JSONB_TYPEOF(val) = 'boolean';
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_15_map_description (.'$ObjectSchema'.description)
CREATE OR REPLACE FUNCTION _jm_f_29(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .'$ObjectSchema'.description
  RETURN JSONB_TYPEOF(val) = 'string';
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_15_map_enum (.'$ObjectSchema'.enum)
CREATE OR REPLACE FUNCTION _jm_f_30(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .'$ObjectSchema'.enum
  RETURN JSONB_TYPEOF(val) = 'array';
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_15_map_examples (.'$ObjectSchema'.examples)
CREATE OR REPLACE FUNCTION _jm_f_31(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .'$ObjectSchema'.examples
  RETURN JSONB_TYPEOF(val) = 'array';
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_15_map_exclusiveMaximum (.'$ObjectSchema'.exclusiveMaximum)
CREATE OR REPLACE FUNCTION _jm_f_32(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .'$ObjectSchema'.exclusiveMaximum
  RETURN JSONB_TYPEOF(val) = 'number';
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_15_map_exclusiveMinimum (.'$ObjectSchema'.exclusiveMinimum)
CREATE OR REPLACE FUNCTION _jm_f_33(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .'$ObjectSchema'.exclusiveMinimum
  RETURN JSONB_TYPEOF(val) = 'number';
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_15_map_format (.'$ObjectSchema'.format)
CREATE OR REPLACE FUNCTION _jm_f_34(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .'$ObjectSchema'.format
  RETURN JSONB_TYPEOF(val) = 'string';
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_15_map_maximum (.'$ObjectSchema'.maximum)
CREATE OR REPLACE FUNCTION _jm_f_35(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .'$ObjectSchema'.maximum
  RETURN JSONB_TYPEOF(val) = 'number';
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_15_map_minimum (.'$ObjectSchema'.minimum)
CREATE OR REPLACE FUNCTION _jm_f_36(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .'$ObjectSchema'.minimum
  RETURN JSONB_TYPEOF(val) = 'number';
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_15_map_multipleOf (.'$ObjectSchema'.multipleOf)
CREATE OR REPLACE FUNCTION _jm_f_37(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .'$ObjectSchema'.multipleOf
  RETURN JSONB_TYPEOF(val) = 'number' AND (val)::FLOAT8 > 0.0;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_15_map_pattern (.'$ObjectSchema'.pattern)
CREATE OR REPLACE FUNCTION _jm_f_38(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .'$ObjectSchema'.pattern
  RETURN JSONB_TYPEOF(val) = 'string' AND jm_is_valid_regex(JSON_VALUE(val, '$' RETURNING TEXT), NULL, NULL);
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_15_map_patternProperties (.'$ObjectSchema'.patternProperties)
CREATE OR REPLACE FUNCTION _jm_f_39(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
BEGIN
  -- .'$ObjectSchema'.patternProperties
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF jm_is_valid_regex(prop, NULL, NULL) THEN
      -- handle 1 key props
      -- .'$ObjectSchema'.patternProperties.'$REGEX'
      res := json_model_16(pval, NULL, NULL);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_15_map_properties (.'$ObjectSchema'.properties)
CREATE OR REPLACE FUNCTION _jm_f_40(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
BEGIN
  -- .'$ObjectSchema'.properties
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    -- handle other props
    -- .'$ObjectSchema'.properties.''
    res := json_model_16(pval, NULL, NULL);
    IF NOT res THEN
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_15_map_readOnly (.'$ObjectSchema'.readOnly)
CREATE OR REPLACE FUNCTION _jm_f_41(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .'$ObjectSchema'.readOnly
  RETURN JSONB_TYPEOF(val) = 'boolean';
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_15_map_title (.'$ObjectSchema'.title)
CREATE OR REPLACE FUNCTION _jm_f_42(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .'$ObjectSchema'.title
  RETURN JSONB_TYPEOF(val) = 'string';
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_15_map_type (.'$ObjectSchema'.type)
CREATE OR REPLACE FUNCTION _jm_f_43(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .'$ObjectSchema'.type
  -- .'$ObjectSchema'.type.'|'.0
  -- .'$ObjectSchema'.type.'|'.1
  RETURN json_model_8(val, NULL, NULL) OR json_model_9(val, NULL, NULL);
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_15_map_uniqueItems (.'$ObjectSchema'.uniqueItems)
CREATE OR REPLACE FUNCTION _jm_f_44(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .'$ObjectSchema'.uniqueItems
  RETURN JSONB_TYPEOF(val) = 'boolean';
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_15_map_writeOnly (.'$ObjectSchema'.writeOnly)
CREATE OR REPLACE FUNCTION _jm_f_45(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .'$ObjectSchema'.writeOnly
  RETURN JSONB_TYPEOF(val) = 'boolean';
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION json_model_15_map(name TEXT)
RETURNS TEXT STRICT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  map JSONB := JSONB '{"$anchor":"json_model_2","$comment":"_jm_f_18","$defs":"_jm_f_19","$dynamicAnchor":"json_model_2","$dynamicRef":"json_model_2","$id":"json_model_2","$ref":"json_model_2","$schema":"_jm_f_20","$vocabulary":"_jm_f_21","additionalProperties":"json_model_16","allOf":"json_model_13","anyOf":"json_model_13","const":"_jm_f_22","contains":"json_model_16","contentEncoding":"_jm_f_23","contentMediaType":"_jm_f_24","contentSchema":"json_model_16","default":"_jm_f_25","dependentRequired":"_jm_f_26","dependentSchemas":"_jm_f_27","deprecated":"_jm_f_28","description":"_jm_f_29","else":"json_model_16","enum":"_jm_f_30","examples":"_jm_f_31","exclusiveMaximum":"_jm_f_32","exclusiveMinimum":"_jm_f_33","format":"_jm_f_34","if":"json_model_16","items":"json_model_16","maxContains":"json_model_11","maxItems":"json_model_11","maxLength":"json_model_11","maxProperties":"json_model_11","maximum":"_jm_f_35","minContains":"json_model_11","minItems":"json_model_11","minLength":"json_model_11","minProperties":"json_model_11","minimum":"_jm_f_36","multipleOf":"_jm_f_37","not":"json_model_16","oneOf":"json_model_13","pattern":"_jm_f_38","patternProperties":"_jm_f_39","prefixItems":"json_model_13","properties":"_jm_f_40","propertyNames":"json_model_16","readOnly":"_jm_f_41","required":"json_model_10","then":"json_model_16","title":"_jm_f_42","type":"_jm_f_43","unevaluatedItems":"json_model_16","unevaluatedProperties":"json_model_16","uniqueItems":"_jm_f_44","writeOnly":"_jm_f_45"}';
BEGIN
  RETURN map->>name;
END;
$$ LANGUAGE plpgsql;

-- check $ObjectSchema (.'$ObjectSchema')
CREATE OR REPLACE FUNCTION json_model_15(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  pfun TEXT;
  prop TEXT;
  pval JSONB;
BEGIN
  -- .'$ObjectSchema'
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF json_model_15_map(prop) IS NOT NULL THEN
      -- handle 57 may props
      pfun := json_model_15_map(prop);
      IF NOT jm_call(pfun, pval, NULL, NULL) THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check $Schema (.'$Schema')
CREATE OR REPLACE FUNCTION json_model_16(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .'$Schema'
  -- .'$Schema'.'|'.0
  -- .'$Schema'.'|'.1
  RETURN JSONB_TYPEOF(val) = 'boolean' OR json_model_15(val, NULL, NULL);
END;
$$ LANGUAGE PLpgSQL;

-- check $ (.)
CREATE OR REPLACE FUNCTION json_model_1(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- JSON Model for JSON Schema 2020-12 [JSON_MODEL_LOOSE_NUMBER]
  -- .
  -- .'@'
  RETURN json_model_16(val, NULL, NULL);
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION check_model_map(name TEXT)
RETURNS TEXT STRICT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  map JSONB := JSONB '{"":"json_model_1","URI-REFERENCE":"json_model_2","core":"json_model_3","meta":"json_model_4","content":"json_model_5","unevaluated":"json_model_6","format":"json_model_7","simpleTypes":"json_model_8","simpleTypesArray":"json_model_9","stringArray":"json_model_10","nonNegativeInteger":"json_model_11","validation":"json_model_12","schemaArray":"json_model_13","applicator":"json_model_14","ObjectSchema":"json_model_15","Schema":"json_model_16"}';
BEGIN
  RETURN map->>name;
END;
$$ LANGUAGE plpgsql;

--
-- constant maps initialization
--
TRUNCATE jm_constant_maps;

--
-- JSON Model checking entry point
--
-- TODO INOUT rep?
CREATE OR REPLACE FUNCTION check_model(val JSONB, name TEXT, rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  fun TEXT;
BEGIN
  fun := check_model_map(name);
  IF fun IS NULL THEN
    RAISE EXCEPTION 'model for % not found', name;
  END IF;
  RETURN jm_call(fun, val, NULL, rep);
END;
$$ LANGUAGE plpgsql;
