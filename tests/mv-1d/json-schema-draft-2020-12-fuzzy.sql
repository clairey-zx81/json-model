--
-- Generated by JSON Model Compiler version 2
-- see https://github.com/clairey-zx81/json-model
--
-- JSON_MODEL_VERSION is 2
CREATE EXTENSION IF NOT EXISTS json_model;

-- check $URI-REFERENCE (.'$URI-REFERENCE')
CREATE OR REPLACE FUNCTION json_model_3(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .'$URI-REFERENCE'
  RETURN JSONB_TYPEOF(val) = 'string';
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_4_map_$comment (.'$core'.'$comment')
CREATE OR REPLACE FUNCTION _jm_f_0(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .'$core'.'$comment'
  RETURN JSONB_TYPEOF(val) = 'string';
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_4_map_$defs (.'$core'.'$defs')
CREATE OR REPLACE FUNCTION _jm_f_1(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
BEGIN
  -- .'$core'.'$defs'
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    -- handle other props
    -- .'$core'.'$defs'.''
    res := json_model_17(pval, NULL, NULL);
    IF NOT res THEN
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_4_map_$schema (.'$core'.'$schema')
CREATE OR REPLACE FUNCTION _jm_f_2(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .'$core'.'$schema'
  RETURN JSONB_TYPEOF(val) = 'string' AND jm_is_valid_url(JSON_VALUE(val, '$' RETURNING TEXT), NULL, NULL);
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_4_map_$vocabulary (.'$core'.'$vocabulary')
CREATE OR REPLACE FUNCTION _jm_f_3(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
BEGIN
  -- .'$core'.'$vocabulary'
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF jm_is_valid_url(prop, NULL, NULL) THEN
      -- handle 1 key props
      -- .'$core'.'$vocabulary'.'$URI'
      res := JSONB_TYPEOF(pval) = 'boolean';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION json_model_4_map(name TEXT)
RETURNS TEXT STRICT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  map JSONB := JSONB '{"$anchor":"json_model_3","$comment":"_jm_f_0","$defs":"_jm_f_1","$dynamicAnchor":"json_model_3","$dynamicRef":"json_model_3","$id":"json_model_3","$ref":"json_model_3","$schema":"_jm_f_2","$vocabulary":"_jm_f_3"}';
BEGIN
  RETURN map->>name;
END;
$$ LANGUAGE plpgsql;

-- check $core (.'$core')
CREATE OR REPLACE FUNCTION json_model_4(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  pfun TEXT;
  prop TEXT;
  pval JSONB;
BEGIN
  -- .'$core'
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF json_model_4_map(prop) IS NOT NULL THEN
      -- handle 9 may props
      pfun := json_model_4_map(prop);
      IF NOT jm_call(pfun, pval, NULL, NULL) THEN
        RETURN FALSE;
      END IF;
      CONTINUE;
    END IF;
    RETURN FALSE;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check $meta (.'$meta')
CREATE OR REPLACE FUNCTION json_model_5(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
BEGIN
  -- .'$meta'
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = 'title' THEN
      -- handle may title property
      -- .'$meta'.title
      res := JSONB_TYPEOF(pval) = 'string';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
      CONTINUE;
    ELSEIF prop = 'default' THEN
      -- handle may default property
      -- .'$meta'.default
      res := TRUE;
      CONTINUE;
    ELSEIF prop = 'examples' THEN
      -- handle may examples property
      -- .'$meta'.examples
      res := JSONB_TYPEOF(pval) = 'array';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
      CONTINUE;
    ELSEIF prop = 'readOnly' THEN
      -- handle may readOnly property
      -- .'$meta'.readOnly
      res := JSONB_TYPEOF(pval) = 'boolean';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
      CONTINUE;
    ELSEIF prop = 'writeOnly' THEN
      -- handle may writeOnly property
      -- .'$meta'.writeOnly
      res := JSONB_TYPEOF(pval) = 'boolean';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
      CONTINUE;
    ELSEIF prop = 'deprecated' THEN
      -- handle may deprecated property
      -- .'$meta'.deprecated
      res := JSONB_TYPEOF(pval) = 'boolean';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
      CONTINUE;
    ELSEIF prop = 'description' THEN
      -- handle may description property
      -- .'$meta'.description
      res := JSONB_TYPEOF(pval) = 'string';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
      CONTINUE;
    END IF;
    RETURN FALSE;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check $content (.'$content')
CREATE OR REPLACE FUNCTION json_model_6(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
BEGIN
  -- .'$content'
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = 'contentSchema' THEN
      -- handle may contentSchema property
      -- .'$content'.contentSchema
      res := json_model_17(pval, NULL, NULL);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
      CONTINUE;
    ELSEIF prop = 'contentEncoding' THEN
      -- handle may contentEncoding property
      -- .'$content'.contentEncoding
      res := JSONB_TYPEOF(pval) = 'string';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
      CONTINUE;
    ELSEIF prop = 'contentMediaType' THEN
      -- handle may contentMediaType property
      -- .'$content'.contentMediaType
      res := JSONB_TYPEOF(pval) = 'string';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
      CONTINUE;
    END IF;
    RETURN FALSE;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check $unevaluated (.'$unevaluated')
CREATE OR REPLACE FUNCTION json_model_7(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
BEGIN
  -- .'$unevaluated'
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = 'unevaluatedItems' THEN
      -- handle may unevaluatedItems property
      -- .'$unevaluated'.unevaluatedItems
      res := json_model_17(pval, NULL, NULL);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
      CONTINUE;
    ELSEIF prop = 'unevaluatedProperties' THEN
      -- handle may unevaluatedProperties property
      -- .'$unevaluated'.unevaluatedProperties
      res := json_model_17(pval, NULL, NULL);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
      CONTINUE;
    END IF;
    RETURN FALSE;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check $format (.'$format')
CREATE OR REPLACE FUNCTION json_model_8(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
BEGIN
  -- .'$format'
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = 'format' THEN
      -- handle may format property
      -- .'$format'.format
      res := JSONB_TYPEOF(pval) = 'string';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
      CONTINUE;
    END IF;
    RETURN FALSE;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION _jm_cst_0(value JSONB)
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  constants JSONB = JSONB '["array","boolean","integer","null","number","object","string"]';
BEGIN
  RETURN constants @> value;
END;
$$ LANGUAGE plpgsql;

-- check $simpleTypes (.'$simpleTypes')
CREATE OR REPLACE FUNCTION json_model_9(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .'$simpleTypes'
  RETURN JSONB_TYPEOF(val) IN ('null', 'boolean', 'number', 'string') AND _jm_cst_0(val);
END;
$$ LANGUAGE PLpgSQL;

-- check $simpleTypesArray (.'$simpleTypesArray')
CREATE OR REPLACE FUNCTION json_model_10(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  arr_0_idx INT8;
  arr_0_item JSONB;
  ival_0 int;
BEGIN
  -- .'$simpleTypesArray'
  -- .'$simpleTypesArray'.'@'
  res := JSONB_TYPEOF(val) = 'array';
  IF res THEN
    FOR arr_0_idx IN 0 .. JSONB_ARRAY_LENGTH(val) - 1 LOOP
      arr_0_item := val -> arr_0_idx;
      -- .'$simpleTypesArray'.'@'.0
      res := json_model_9(arr_0_item, NULL, NULL);
      IF NOT res THEN
        EXIT;
      END IF;
    END LOOP;
  END IF;
  IF res THEN
    ival_0 := JSONB_ARRAY_LENGTH(val);
    res := jm_array_is_unique(val, NULL, NULL) AND ival_0 >= 1;
  END IF;
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check $stringArray (.'$stringArray')
CREATE OR REPLACE FUNCTION json_model_11(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  arr_1_idx INT8;
  arr_1_item JSONB;
BEGIN
  -- .'$stringArray'
  -- .'$stringArray'.'@'
  res := JSONB_TYPEOF(val) = 'array';
  IF res THEN
    FOR arr_1_idx IN 0 .. JSONB_ARRAY_LENGTH(val) - 1 LOOP
      arr_1_item := val -> arr_1_idx;
      -- .'$stringArray'.'@'.0
      res := JSONB_TYPEOF(arr_1_item) = 'string';
      IF NOT res THEN
        EXIT;
      END IF;
    END LOOP;
  END IF;
  IF res THEN
    res := jm_array_is_unique(val, NULL, NULL);
  END IF;
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check $nonNegativeInteger (.'$nonNegativeInteger')
CREATE OR REPLACE FUNCTION json_model_12(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .'$nonNegativeInteger'
  RETURN JSONB_TYPEOF(val) = 'number' AND (val)::INT8 = (val)::FLOAT8 AND (val)::FLOAT8 >= 0;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_13_map_const (.'$validation'.const)
CREATE OR REPLACE FUNCTION _jm_f_4(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .'$validation'.const
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_13_map_dependentRequired (.'$validation'.dependentRequired)
CREATE OR REPLACE FUNCTION _jm_f_5(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
BEGIN
  -- .'$validation'.dependentRequired
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    -- handle other props
    -- .'$validation'.dependentRequired.''
    res := json_model_11(pval, NULL, NULL);
    IF NOT res THEN
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_13_map_enum (.'$validation'.enum)
CREATE OR REPLACE FUNCTION _jm_f_6(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .'$validation'.enum
  RETURN JSONB_TYPEOF(val) = 'array';
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_13_map_exclusiveMaximum (.'$validation'.exclusiveMaximum)
CREATE OR REPLACE FUNCTION _jm_f_7(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .'$validation'.exclusiveMaximum
  RETURN JSONB_TYPEOF(val) = 'number';
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_13_map_exclusiveMinimum (.'$validation'.exclusiveMinimum)
CREATE OR REPLACE FUNCTION _jm_f_8(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .'$validation'.exclusiveMinimum
  RETURN JSONB_TYPEOF(val) = 'number';
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_13_map_maximum (.'$validation'.maximum)
CREATE OR REPLACE FUNCTION _jm_f_9(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .'$validation'.maximum
  RETURN JSONB_TYPEOF(val) = 'number';
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_13_map_minimum (.'$validation'.minimum)
CREATE OR REPLACE FUNCTION _jm_f_10(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .'$validation'.minimum
  RETURN JSONB_TYPEOF(val) = 'number';
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_13_map_multipleOf (.'$validation'.multipleOf)
CREATE OR REPLACE FUNCTION _jm_f_11(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .'$validation'.multipleOf
  RETURN JSONB_TYPEOF(val) = 'number' AND (val)::FLOAT8 > 0.0;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_13_map_pattern (.'$validation'.pattern)
CREATE OR REPLACE FUNCTION _jm_f_12(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .'$validation'.pattern
  RETURN JSONB_TYPEOF(val) = 'string';
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_13_map_type (.'$validation'.type)
CREATE OR REPLACE FUNCTION _jm_f_13(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .'$validation'.type
  -- .'$validation'.type.'|'.0
  -- .'$validation'.type.'|'.1
  RETURN json_model_9(val, NULL, NULL) OR json_model_10(val, NULL, NULL);
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_13_map_uniqueItems (.'$validation'.uniqueItems)
CREATE OR REPLACE FUNCTION _jm_f_14(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .'$validation'.uniqueItems
  RETURN JSONB_TYPEOF(val) = 'boolean';
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION json_model_13_map(name TEXT)
RETURNS TEXT STRICT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  map JSONB := JSONB '{"const":"_jm_f_4","dependentRequired":"_jm_f_5","enum":"_jm_f_6","exclusiveMaximum":"_jm_f_7","exclusiveMinimum":"_jm_f_8","maxContains":"json_model_12","maxItems":"json_model_12","maxLength":"json_model_12","maxProperties":"json_model_12","maximum":"_jm_f_9","minContains":"json_model_12","minItems":"json_model_12","minLength":"json_model_12","minProperties":"json_model_12","minimum":"_jm_f_10","multipleOf":"_jm_f_11","pattern":"_jm_f_12","required":"json_model_11","type":"_jm_f_13","uniqueItems":"_jm_f_14"}';
BEGIN
  RETURN map->>name;
END;
$$ LANGUAGE plpgsql;

-- check $validation (.'$validation')
CREATE OR REPLACE FUNCTION json_model_13(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  pfun TEXT;
  prop TEXT;
  pval JSONB;
BEGIN
  -- .'$validation'
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF json_model_13_map(prop) IS NOT NULL THEN
      -- handle 20 may props
      pfun := json_model_13_map(prop);
      IF NOT jm_call(pfun, pval, NULL, NULL) THEN
        RETURN FALSE;
      END IF;
      CONTINUE;
    END IF;
    RETURN FALSE;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check $schemaArray (.'$schemaArray')
CREATE OR REPLACE FUNCTION json_model_14(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  arr_2_idx INT8;
  arr_2_item JSONB;
  ival_1 int;
BEGIN
  -- .'$schemaArray'
  -- .'$schemaArray'.'@'
  res := JSONB_TYPEOF(val) = 'array';
  IF res THEN
    FOR arr_2_idx IN 0 .. JSONB_ARRAY_LENGTH(val) - 1 LOOP
      arr_2_item := val -> arr_2_idx;
      -- .'$schemaArray'.'@'.0
      res := json_model_17(arr_2_item, NULL, NULL);
      IF NOT res THEN
        EXIT;
      END IF;
    END LOOP;
  END IF;
  IF res THEN
    ival_1 := JSONB_ARRAY_LENGTH(val);
    res := ival_1 >= 1;
  END IF;
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_15_map_dependentSchemas (.'$applicator'.dependentSchemas)
CREATE OR REPLACE FUNCTION _jm_f_15(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
BEGIN
  -- .'$applicator'.dependentSchemas
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    -- handle other props
    -- .'$applicator'.dependentSchemas.''
    res := json_model_17(pval, NULL, NULL);
    IF NOT res THEN
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_15_map_patternProperties (.'$applicator'.patternProperties)
CREATE OR REPLACE FUNCTION _jm_f_16(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
BEGIN
  -- .'$applicator'.patternProperties
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    -- handle other props
    -- .'$applicator'.patternProperties.''
    res := json_model_17(pval, NULL, NULL);
    IF NOT res THEN
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_15_map_properties (.'$applicator'.properties)
CREATE OR REPLACE FUNCTION _jm_f_17(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
BEGIN
  -- .'$applicator'.properties
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    -- handle other props
    -- .'$applicator'.properties.''
    res := json_model_17(pval, NULL, NULL);
    IF NOT res THEN
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION json_model_15_map(name TEXT)
RETURNS TEXT STRICT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  map JSONB := JSONB '{"additionalProperties":"json_model_17","allOf":"json_model_14","anyOf":"json_model_14","contains":"json_model_17","dependentSchemas":"_jm_f_15","else":"json_model_17","if":"json_model_17","items":"json_model_17","not":"json_model_17","oneOf":"json_model_14","patternProperties":"_jm_f_16","prefixItems":"json_model_14","properties":"_jm_f_17","propertyNames":"json_model_17","then":"json_model_17"}';
BEGIN
  RETURN map->>name;
END;
$$ LANGUAGE plpgsql;

-- check $applicator (.'$applicator')
CREATE OR REPLACE FUNCTION json_model_15(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  pfun TEXT;
  prop TEXT;
  pval JSONB;
BEGIN
  -- .'$applicator'
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF json_model_15_map(prop) IS NOT NULL THEN
      -- handle 15 may props
      pfun := json_model_15_map(prop);
      IF NOT jm_call(pfun, pval, NULL, NULL) THEN
        RETURN FALSE;
      END IF;
      CONTINUE;
    END IF;
    RETURN FALSE;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_16_map_$comment (.'$ObjectSchema'.'$comment')
CREATE OR REPLACE FUNCTION _jm_f_18(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .'$ObjectSchema'.'$comment'
  RETURN JSONB_TYPEOF(val) = 'string';
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_16_map_$defs (.'$ObjectSchema'.'$defs')
CREATE OR REPLACE FUNCTION _jm_f_19(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
BEGIN
  -- .'$ObjectSchema'.'$defs'
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    -- handle other props
    -- .'$ObjectSchema'.'$defs'.''
    res := json_model_17(pval, NULL, NULL);
    IF NOT res THEN
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_16_map_$recursiveAnchor (.'$ObjectSchema'.'$recursiveAnchor')
CREATE OR REPLACE FUNCTION _jm_f_20(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .'$ObjectSchema'.'$recursiveAnchor'
  RETURN JSONB_TYPEOF(val) = 'string';
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_16_map_$recursiveRef (.'$ObjectSchema'.'$recursiveRef')
CREATE OR REPLACE FUNCTION _jm_f_21(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .'$ObjectSchema'.'$recursiveRef'
  RETURN JSONB_TYPEOF(val) = 'string';
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_16_map_$schema (.'$ObjectSchema'.'$schema')
CREATE OR REPLACE FUNCTION _jm_f_22(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .'$ObjectSchema'.'$schema'
  RETURN JSONB_TYPEOF(val) = 'string' AND jm_is_valid_url(JSON_VALUE(val, '$' RETURNING TEXT), NULL, NULL);
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_16_map_$vocabulary (.'$ObjectSchema'.'$vocabulary')
CREATE OR REPLACE FUNCTION _jm_f_23(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
BEGIN
  -- .'$ObjectSchema'.'$vocabulary'
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF jm_is_valid_url(prop, NULL, NULL) THEN
      -- handle 1 key props
      -- .'$ObjectSchema'.'$vocabulary'.'$URI'
      res := JSONB_TYPEOF(pval) = 'boolean';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_16_map_const (.'$ObjectSchema'.const)
CREATE OR REPLACE FUNCTION _jm_f_24(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .'$ObjectSchema'.const
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_16_map_contentEncoding (.'$ObjectSchema'.contentEncoding)
CREATE OR REPLACE FUNCTION _jm_f_25(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .'$ObjectSchema'.contentEncoding
  RETURN JSONB_TYPEOF(val) = 'string';
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_16_map_contentMediaType (.'$ObjectSchema'.contentMediaType)
CREATE OR REPLACE FUNCTION _jm_f_26(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .'$ObjectSchema'.contentMediaType
  RETURN JSONB_TYPEOF(val) = 'string';
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_16_map_default (.'$ObjectSchema'.default)
CREATE OR REPLACE FUNCTION _jm_f_27(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .'$ObjectSchema'.default
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_16_map_definitions (.'$ObjectSchema'.definitions)
CREATE OR REPLACE FUNCTION _jm_f_28(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
BEGIN
  -- .'$ObjectSchema'.definitions
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    -- handle other props
    -- .'$ObjectSchema'.definitions.''
    res := json_model_17(pval, NULL, NULL);
    IF NOT res THEN
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_16_map_dependencies (.'$ObjectSchema'.dependencies)
CREATE OR REPLACE FUNCTION _jm_f_29(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
BEGIN
  -- .'$ObjectSchema'.dependencies
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    -- handle other props
    -- .'$ObjectSchema'.dependencies.''
    -- .'$ObjectSchema'.dependencies.''.'|'.0
    -- .'$ObjectSchema'.dependencies.''.'|'.1
    res := json_model_17(pval, NULL, NULL) OR json_model_11(pval, NULL, NULL);
    IF NOT res THEN
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_16_map_dependentRequired (.'$ObjectSchema'.dependentRequired)
CREATE OR REPLACE FUNCTION _jm_f_30(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
BEGIN
  -- .'$ObjectSchema'.dependentRequired
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    -- handle other props
    -- .'$ObjectSchema'.dependentRequired.''
    res := json_model_11(pval, NULL, NULL);
    IF NOT res THEN
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_16_map_dependentSchemas (.'$ObjectSchema'.dependentSchemas)
CREATE OR REPLACE FUNCTION _jm_f_31(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
BEGIN
  -- .'$ObjectSchema'.dependentSchemas
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    -- handle other props
    -- .'$ObjectSchema'.dependentSchemas.''
    res := json_model_17(pval, NULL, NULL);
    IF NOT res THEN
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_16_map_deprecated (.'$ObjectSchema'.deprecated)
CREATE OR REPLACE FUNCTION _jm_f_32(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .'$ObjectSchema'.deprecated
  RETURN JSONB_TYPEOF(val) = 'boolean';
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_16_map_description (.'$ObjectSchema'.description)
CREATE OR REPLACE FUNCTION _jm_f_33(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .'$ObjectSchema'.description
  RETURN JSONB_TYPEOF(val) = 'string';
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_16_map_enum (.'$ObjectSchema'.enum)
CREATE OR REPLACE FUNCTION _jm_f_34(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .'$ObjectSchema'.enum
  RETURN JSONB_TYPEOF(val) = 'array';
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_16_map_examples (.'$ObjectSchema'.examples)
CREATE OR REPLACE FUNCTION _jm_f_35(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .'$ObjectSchema'.examples
  RETURN JSONB_TYPEOF(val) = 'array';
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_16_map_exclusiveMaximum (.'$ObjectSchema'.exclusiveMaximum)
CREATE OR REPLACE FUNCTION _jm_f_36(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .'$ObjectSchema'.exclusiveMaximum
  RETURN JSONB_TYPEOF(val) = 'number';
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_16_map_exclusiveMinimum (.'$ObjectSchema'.exclusiveMinimum)
CREATE OR REPLACE FUNCTION _jm_f_37(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .'$ObjectSchema'.exclusiveMinimum
  RETURN JSONB_TYPEOF(val) = 'number';
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_16_map_format (.'$ObjectSchema'.format)
CREATE OR REPLACE FUNCTION _jm_f_38(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .'$ObjectSchema'.format
  RETURN JSONB_TYPEOF(val) = 'string';
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_16_map_maximum (.'$ObjectSchema'.maximum)
CREATE OR REPLACE FUNCTION _jm_f_39(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .'$ObjectSchema'.maximum
  RETURN JSONB_TYPEOF(val) = 'number';
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_16_map_minimum (.'$ObjectSchema'.minimum)
CREATE OR REPLACE FUNCTION _jm_f_40(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .'$ObjectSchema'.minimum
  RETURN JSONB_TYPEOF(val) = 'number';
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_16_map_multipleOf (.'$ObjectSchema'.multipleOf)
CREATE OR REPLACE FUNCTION _jm_f_41(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .'$ObjectSchema'.multipleOf
  RETURN JSONB_TYPEOF(val) = 'number' AND (val)::FLOAT8 > 0.0;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_16_map_pattern (.'$ObjectSchema'.pattern)
CREATE OR REPLACE FUNCTION _jm_f_42(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .'$ObjectSchema'.pattern
  RETURN JSONB_TYPEOF(val) = 'string';
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_16_map_patternProperties (.'$ObjectSchema'.patternProperties)
CREATE OR REPLACE FUNCTION _jm_f_43(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
BEGIN
  -- .'$ObjectSchema'.patternProperties
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    -- handle other props
    -- .'$ObjectSchema'.patternProperties.''
    res := json_model_17(pval, NULL, NULL);
    IF NOT res THEN
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_16_map_properties (.'$ObjectSchema'.properties)
CREATE OR REPLACE FUNCTION _jm_f_44(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
BEGIN
  -- .'$ObjectSchema'.properties
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    -- handle other props
    -- .'$ObjectSchema'.properties.''
    res := json_model_17(pval, NULL, NULL);
    IF NOT res THEN
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_16_map_readOnly (.'$ObjectSchema'.readOnly)
CREATE OR REPLACE FUNCTION _jm_f_45(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .'$ObjectSchema'.readOnly
  RETURN JSONB_TYPEOF(val) = 'boolean';
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_16_map_title (.'$ObjectSchema'.title)
CREATE OR REPLACE FUNCTION _jm_f_46(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .'$ObjectSchema'.title
  RETURN JSONB_TYPEOF(val) = 'string';
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_16_map_type (.'$ObjectSchema'.type)
CREATE OR REPLACE FUNCTION _jm_f_47(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .'$ObjectSchema'.type
  -- .'$ObjectSchema'.type.'|'.0
  -- .'$ObjectSchema'.type.'|'.1
  RETURN json_model_9(val, NULL, NULL) OR json_model_10(val, NULL, NULL);
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_16_map_uniqueItems (.'$ObjectSchema'.uniqueItems)
CREATE OR REPLACE FUNCTION _jm_f_48(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .'$ObjectSchema'.uniqueItems
  RETURN JSONB_TYPEOF(val) = 'boolean';
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_16_map_writeOnly (.'$ObjectSchema'.writeOnly)
CREATE OR REPLACE FUNCTION _jm_f_49(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .'$ObjectSchema'.writeOnly
  RETURN JSONB_TYPEOF(val) = 'boolean';
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION json_model_16_map(name TEXT)
RETURNS TEXT STRICT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  map JSONB := JSONB '{"$anchor":"json_model_3","$comment":"_jm_f_18","$defs":"_jm_f_19","$dynamicAnchor":"json_model_3","$dynamicRef":"json_model_3","$id":"json_model_3","$recursiveAnchor":"_jm_f_20","$recursiveRef":"_jm_f_21","$ref":"json_model_3","$schema":"_jm_f_22","$vocabulary":"_jm_f_23","additionalProperties":"json_model_17","allOf":"json_model_14","anyOf":"json_model_14","const":"_jm_f_24","contains":"json_model_17","contentEncoding":"_jm_f_25","contentMediaType":"_jm_f_26","contentSchema":"json_model_17","default":"_jm_f_27","definitions":"_jm_f_28","dependencies":"_jm_f_29","dependentRequired":"_jm_f_30","dependentSchemas":"_jm_f_31","deprecated":"_jm_f_32","description":"_jm_f_33","else":"json_model_17","enum":"_jm_f_34","examples":"_jm_f_35","exclusiveMaximum":"_jm_f_36","exclusiveMinimum":"_jm_f_37","format":"_jm_f_38","if":"json_model_17","items":"json_model_17","maxContains":"json_model_12","maxItems":"json_model_12","maxLength":"json_model_12","maxProperties":"json_model_12","maximum":"_jm_f_39","minContains":"json_model_12","minItems":"json_model_12","minLength":"json_model_12","minProperties":"json_model_12","minimum":"_jm_f_40","multipleOf":"_jm_f_41","not":"json_model_17","oneOf":"json_model_14","pattern":"_jm_f_42","patternProperties":"_jm_f_43","prefixItems":"json_model_14","properties":"_jm_f_44","propertyNames":"json_model_17","readOnly":"_jm_f_45","required":"json_model_11","then":"json_model_17","title":"_jm_f_46","type":"_jm_f_47","unevaluatedItems":"json_model_17","unevaluatedProperties":"json_model_17","uniqueItems":"_jm_f_48","writeOnly":"_jm_f_49"}';
BEGIN
  RETURN map->>name;
END;
$$ LANGUAGE plpgsql;

-- check $ObjectSchema (.'$ObjectSchema')
CREATE OR REPLACE FUNCTION json_model_16(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  pfun TEXT;
  prop TEXT;
  pval JSONB;
BEGIN
  -- .'$ObjectSchema'
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF json_model_16_map(prop) IS NOT NULL THEN
      -- handle 61 may props
      pfun := json_model_16_map(prop);
      IF NOT jm_call(pfun, pval, NULL, NULL) THEN
        RETURN FALSE;
      END IF;
      CONTINUE;
    END IF;
    -- accept any other props
    NULL;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check $Schema (.'$Schema')
CREATE OR REPLACE FUNCTION json_model_17(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .'$Schema'
  -- .'$Schema'.'|'.0
  -- .'$Schema'.'|'.1
  RETURN JSONB_TYPEOF(val) = 'boolean' OR json_model_16(val, NULL, NULL);
END;
$$ LANGUAGE PLpgSQL;

-- object .'$deprecated'.definitions
CREATE OR REPLACE FUNCTION _jm_obj_0(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    -- handle other props
    -- .'$deprecated'.definitions.''
    res := json_model_17(pval, NULL, NULL);
    IF NOT res THEN
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- object .'$deprecated'.dependencies
CREATE OR REPLACE FUNCTION _jm_obj_1(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    -- handle other props
    -- .'$deprecated'.dependencies.''
    -- .'$deprecated'.dependencies.''.'|'.0
    -- .'$deprecated'.dependencies.''.'|'.1
    res := json_model_17(pval, NULL, NULL) OR json_model_11(pval, NULL, NULL);
    IF NOT res THEN
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check $deprecated (.'$deprecated')
CREATE OR REPLACE FUNCTION json_model_18(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
BEGIN
  -- .'$deprecated'
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = 'definitions' THEN
      -- handle may definitions property
      -- .'$deprecated'.definitions
      res := _jm_obj_0(pval, NULL, NULL);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
      CONTINUE;
    ELSEIF prop = 'dependencies' THEN
      -- handle may dependencies property
      -- .'$deprecated'.dependencies
      res := _jm_obj_1(pval, NULL, NULL);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
      CONTINUE;
    ELSEIF prop = '$recursiveRef' THEN
      -- handle may $recursiveRef property
      -- .'$deprecated'.'$recursiveRef'
      res := JSONB_TYPEOF(pval) = 'string';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
      CONTINUE;
    ELSEIF prop = '$recursiveAnchor' THEN
      -- handle may $recursiveAnchor property
      -- .'$deprecated'.'$recursiveAnchor'
      res := JSONB_TYPEOF(pval) = 'string';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
      CONTINUE;
    END IF;
    RETURN FALSE;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check $fuzzy (.'$fuzzy')
CREATE OR REPLACE FUNCTION json_model_19(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .'$fuzzy'
  -- accept any object
  RETURN JSONB_TYPEOF(val) = 'object';
END;
$$ LANGUAGE PLpgSQL;

-- check $ (.)
CREATE OR REPLACE FUNCTION json_model_1(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .
  RETURN json_model_17(val, NULL, NULL);
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION check_model_map(name TEXT)
RETURNS TEXT STRICT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  map JSONB := JSONB '{"":"json_model_17","URI-REFERENCE":"json_model_3","core":"json_model_4","meta":"json_model_5","content":"json_model_6","unevaluated":"json_model_7","format":"json_model_8","simpleTypes":"json_model_9","simpleTypesArray":"json_model_10","stringArray":"json_model_11","nonNegativeInteger":"json_model_12","validation":"json_model_13","schemaArray":"json_model_14","applicator":"json_model_15","ObjectSchema":"json_model_16","Schema":"json_model_17","deprecated":"json_model_18","fuzzy":"json_model_19"}';
BEGIN
  RETURN map->>name;
END;
$$ LANGUAGE plpgsql;

--
-- constant maps initialization
--
TRUNCATE jm_constant_maps;

--
-- JSON Model checking entry point
--
-- TODO INOUT rep?
CREATE OR REPLACE FUNCTION check_model(val JSONB, name TEXT, rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  fun TEXT;
BEGIN
  fun := check_model_map(name);
  IF fun IS NULL THEN
    RAISE EXCEPTION 'model for % not found', name;
  END IF;
  RETURN jm_call(fun, val, NULL, rep);
END;
$$ LANGUAGE plpgsql;
