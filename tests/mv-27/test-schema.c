//
// Generated by JSON Model Compiler version 2
// see https://github.com/clairey-zx81/json-model
//

// regular expression engine
#include <stddef.h>
#include <cre2.h>

#include <json-model.h>
#define JSON_MODEL_VERSION "2"

static cre2_regexp_t *_jm_re_0_re2 = NULL;
static int _jm_re_0_nn = 0;
static bool _jm_re_0(const char *s, jm_path_t *path, jm_report_t *rep);
static bool json_model_2(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool json_model_3(const json_t *val, jm_path_t *path, jm_report_t *rep);
static cre2_regexp_t *_jm_re_1_re2 = NULL;
static int _jm_re_1_nn = 0;
static bool _jm_re_1(const char *s, jm_path_t *path, jm_report_t *rep);
static cre2_regexp_t *_jm_re_2_re2 = NULL;
static int _jm_re_2_nn = 0;
static bool _jm_re_2(const char *s, jm_path_t *path, jm_report_t *rep);
static bool _jm_obj_0(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool json_model_4(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool json_model_5(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool json_model_1(const json_t *val, jm_path_t *path, jm_report_t *rep);
jm_propmap_t check_model_map_tab[5];
const size_t check_model_map_size = 5;

static bool _jm_re_0(const char *s, jm_path_t *path, jm_report_t *rep)
{
    size_t slen = strlen(s);
    return cre2_match(_jm_re_0_re2, s, slen, 0, slen, CRE2_UNANCHORED, NULL, 0);
}

// check $Version (.'$Version')
static bool json_model_2(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    // .'$Version'
    // "/^[0-9a-zA-Z]+(\\.[0-9a-zA-Z]+)*$/"
    return json_is_string(val) && _jm_re_0(json_string_value(val), NULL, NULL);
}

// check $Test (.'$Test')
static bool json_model_3(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    // A single test
    // .'$Test'
    if (unlikely(! json_is_object(val)))
        return false;
    bool res;
    int64_t must_count = 0;
    const char *prop;
    json_t *pval;
    json_object_foreach((json_t *) val, prop, pval)
    {
        if (unlikely(jm_str_eq_8(prop, 0x7470697263736564LL) && jm_str_eq_4(prop + 8, 0x006e6f69)))
        {
            // handle must description property
            must_count += 1;
            // .'$Test'.description
            res = json_is_string(pval);
            if (unlikely(! res))
                return false;
        }
        else if (unlikely(jm_str_eq_5(prop, 0x0000000061746164LL)))
        {
            // handle must data property
            must_count += 1;
            // .'$Test'.data
            res = true;
        }
        else if (unlikely(jm_str_eq_6(prop, 0x00000064696c6176LL)))
        {
            // handle must valid property
            must_count += 1;
            // .'$Test'.valid
            res = json_is_boolean(pval);
            if (unlikely(! res))
                return false;
        }
        else if (unlikely(jm_str_eq_8(prop, 0x00746e656d6d6f63LL)))
        {
            // handle may comment property
            // .'$Test'.comment
            res = json_is_string(pval);
            if (unlikely(! res))
                return false;
        }
        else
            return false;
    }
    return must_count == 3;
}

static bool _jm_re_1(const char *s, jm_path_t *path, jm_report_t *rep)
{
    size_t slen = strlen(s);
    return cre2_match(_jm_re_1_re2, s, slen, 0, slen, CRE2_UNANCHORED, NULL, 0);
}

static bool _jm_re_2(const char *s, jm_path_t *path, jm_report_t *rep)
{
    size_t slen = strlen(s);
    return cre2_match(_jm_re_2_re2, s, slen, 0, slen, CRE2_UNANCHORED, NULL, 0);
}

// object .'$Specification'.'@'
static INLINE bool _jm_obj_0(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    if (unlikely(! json_is_object(val)))
        return false;
    bool res;
    const char *prop;
    json_t *pval;
    json_object_foreach((json_t *) val, prop, pval)
    {
        if (unlikely(jm_str_eq_5(prop, 0x0000000065726f63LL)))
        {
            // handle may core property
            // .'$Specification'.'@'.core
            res = json_model_2(pval, NULL, NULL);
            if (unlikely(! res))
                return false;
        }
        else if (unlikely(jm_str_eq_8(prop, 0x69746164696c6176LL) && jm_str_eq_3(prop + 8, 0x00006e6f)))
        {
            // handle may validation property
            // .'$Specification'.'@'.validation
            res = json_model_2(pval, NULL, NULL);
            if (unlikely(! res))
                return false;
        }
        else if (unlikely(jm_str_eq_8(prop, 0x00323632616d6365LL)))
        {
            // handle may ecma262 property
            // .'$Specification'.'@'.ecma262
            res = json_model_2(pval, NULL, NULL);
            if (unlikely(! res))
                return false;
        }
        else if (unlikely(jm_str_eq_6(prop, 0x000000356c726570LL)))
        {
            // handle may perl5 property
            // .'$Specification'.'@'.perl5
            res = json_is_string(pval);
            if (unlikely(! res))
                return false;
        }
        else if (unlikely(jm_str_eq_6(prop, 0x00000065746f7571LL)))
        {
            // handle may quote property
            // .'$Specification'.'@'.quote
            res = json_is_string(pval);
            if (unlikely(! res))
                return false;
        }
        else if (_jm_re_1(prop, NULL, NULL))
        {
            // handle 2 re props
            // .'$Specification'.'@'.'/^rfc\\d+$/'
            res = json_model_2(pval, NULL, NULL);
            if (! res)
                return false;
        }
        else if (likely(_jm_re_2(prop, NULL, NULL)))
        {
            // handle 2 re props
            // .'$Specification'.'@'.'/^iso\\d+$/'
            res = json_model_2(pval, NULL, NULL);
            if (! res)
                return false;
        }
        else
            return false;
    }
    return true;
}

// check $Specification (.'$Specification')
static bool json_model_4(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    // .'$Specification'
    // .'$Specification'.'@'
    bool res = _jm_obj_0(val, NULL, NULL);
    if (likely(res))
    {
        int64_t ival_0 = json_object_size(val);
        res = ival_0 >= 1;
    }
    return res;
}

// check $TestCase (.'$TestCase')
static bool json_model_5(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    // .'$TestCase'
    if (unlikely(! json_is_object(val)))
        return false;
    bool res;
    int64_t must_count = 0;
    const char *prop;
    json_t *pval;
    json_object_foreach((json_t *) val, prop, pval)
    {
        if (unlikely(jm_str_eq_8(prop, 0x7470697263736564LL) && jm_str_eq_4(prop + 8, 0x006e6f69)))
        {
            // handle must description property
            must_count += 1;
            // .'$TestCase'.description
            res = json_is_string(pval);
            if (unlikely(! res))
                return false;
        }
        else if (unlikely(jm_str_eq_7(prop, 0x0000616d65686373LL)))
        {
            // handle must schema property
            must_count += 1;
            // .'$TestCase'.schema
            res = true;
        }
        else if (unlikely(jm_str_eq_6(prop, 0x0000007374736574LL)))
        {
            // handle must tests property
            must_count += 1;
            // .'$TestCase'.tests
            // .'$TestCase'.tests.'@'
            res = json_is_array(pval);
            if (res)
            {
                size_t arr_0_idx;
                json_t *arr_0_item;
                json_array_foreach(pval, arr_0_idx, arr_0_item)
                {
                    // .'$TestCase'.tests.'@'.0
                    res = json_model_3(arr_0_item, NULL, NULL);
                    if (unlikely(! res))
                        break;
                }
            }
            if (likely(res))
            {
                int64_t ival_1 = json_array_size(pval);
                res = ival_1 >= 1;
            }
            if (unlikely(! res))
                return false;
        }
        else if (unlikely(jm_str_eq_8(prop, 0x00746e656d6d6f63LL)))
        {
            // handle may comment property
            // .'$TestCase'.comment
            res = json_is_string(pval);
            if (unlikely(! res))
                return false;
        }
        else if (unlikely(jm_str_eq_8(prop, 0x6369666963657073LL) && jm_str_eq_6(prop + 8, 0x0000006e6f697461LL)))
        {
            // handle may specification property
            // .'$TestCase'.specification
            // .'$TestCase'.specification.'@'
            res = json_is_array(pval);
            if (res)
            {
                size_t arr_1_idx;
                json_t *arr_1_item;
                json_array_foreach(pval, arr_1_idx, arr_1_item)
                {
                    // .'$TestCase'.specification.'@'.0
                    res = json_model_4(arr_1_item, NULL, NULL);
                    if (unlikely(! res))
                        break;
                }
            }
            if (likely(res))
            {
                int64_t ival_2 = json_array_size(pval);
                res = jm_array_is_unique(pval, NULL, NULL) && ival_2 >= 1;
            }
            if (unlikely(! res))
                return false;
        }
        else
            return false;
    }
    return must_count == 3;
}

// check $ (.)
static bool json_model_1(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    // Model for the JSON Schema Test Suite tests
    // .
    // .'@'
    bool res = json_is_array(val);
    if (res)
    {
        size_t arr_2_idx;
        json_t *arr_2_item;
        json_array_foreach(val, arr_2_idx, arr_2_item)
        {
            // .'@'.0
            res = json_model_5(arr_2_item, NULL, NULL);
            if (unlikely(! res))
                break;
        }
    }
    if (likely(res))
    {
        int64_t ival_3 = json_array_size(val);
        res = ival_3 >= 1;
    }
    return res;
}

jm_check_fun_t check_model_map(const char *pname)
{
    return jm_search_propmap(pname, check_model_map_tab, 5);
}

static bool initialized = false;

const char *check_model_init(void)
{
    if (!initialized)
    {
        initialized = true;
        jm_version_string = JSON_MODEL_VERSION;
        _jm_re_0_re2 = cre2_new("^[0-9a-zA-Z]+(\\.[0-9a-zA-Z]+)*$", strlen("^[0-9a-zA-Z]+(\\.[0-9a-zA-Z]+)*$"), NULL);
        if (cre2_error_code(_jm_re_0_re2))
            return cre2_error_string(_jm_re_0_re2);
        _jm_re_0_nn = cre2_num_capturing_groups(_jm_re_0_re2) + 1;
        _jm_re_1_re2 = cre2_new("^rfc\\d+$", strlen("^rfc\\d+$"), NULL);
        if (cre2_error_code(_jm_re_1_re2))
            return cre2_error_string(_jm_re_1_re2);
        _jm_re_1_nn = cre2_num_capturing_groups(_jm_re_1_re2) + 1;
        _jm_re_2_re2 = cre2_new("^iso\\d+$", strlen("^iso\\d+$"), NULL);
        if (cre2_error_code(_jm_re_2_re2))
            return cre2_error_string(_jm_re_2_re2);
        _jm_re_2_nn = cre2_num_capturing_groups(_jm_re_2_re2) + 1;
        check_model_map_tab[0] = (jm_propmap_t) { "", json_model_1 };
        check_model_map_tab[1] = (jm_propmap_t) { "Version", json_model_2 };
        check_model_map_tab[2] = (jm_propmap_t) { "Test", json_model_3 };
        check_model_map_tab[3] = (jm_propmap_t) { "Specification", json_model_4 };
        check_model_map_tab[4] = (jm_propmap_t) { "TestCase", json_model_5 };
        jm_sort_propmap(check_model_map_tab, 5);
    }
    return NULL;
}

void check_model_free(void)
{
    if (initialized)
    {
        initialized = false;

        // cleanup code
        cre2_delete(_jm_re_0_re2);
        _jm_re_0_re2 = NULL;
        _jm_re_0_nn = 0;
        cre2_delete(_jm_re_1_re2);
        _jm_re_1_re2 = NULL;
        _jm_re_1_nn = 0;
        cre2_delete(_jm_re_2_re2);
        _jm_re_2_re2 = NULL;
        _jm_re_2_nn = 0;
    }
}

/*
 * # API
 *
 * ```c
 * bool error;
 * char *message;
 *
 * bool valid = check(json_value, "model-name", &error, &message);
 *
 * if (message)
 *    free(message), message = NULL;
 * ```
 *
 * - `error` is set of there was an error during initialization or if the model does not exists.
 * - `message` is provided if a non NULL pointer is passed, and must be freed by the caller.
 */
bool
check_model(const json_t *val, const char *name, bool *error, char **reasons)
{
    return jm_generic_entry(check_model_init, check_model_map, val, name, error, reasons);
}
