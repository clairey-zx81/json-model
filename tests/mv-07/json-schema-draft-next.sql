--
-- Generated by JSON Model Compiler version 2
-- see https://github.com/clairey-zx81/json-model
--
-- JSON_MODEL_VERSION is 2
CREATE EXTENSION IF NOT EXISTS json_model;

-- check $URI-REFERENCE (.'$URI-REFERENCE')
CREATE OR REPLACE FUNCTION json_model_2(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$URI-REFERENCE'
  res := JSONB_TYPEOF(val) = 'string';
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_3_map_$anchor (.'$core'.'$anchor')
CREATE OR REPLACE FUNCTION _jm_f_0(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$core'.'$anchor'
  res := json_model_2(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_3_map_$comment (.'$core'.'$comment')
CREATE OR REPLACE FUNCTION _jm_f_1(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$core'.'$comment'
  res := JSONB_TYPEOF(val) = 'string';
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_3_map_$defs (.'$core'.'$defs')
CREATE OR REPLACE FUNCTION _jm_f_2(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
BEGIN
  -- .'$core'.'$defs'
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    -- handle other props
    -- .'$core'.'$defs'.''
    res := json_model_16(pval, NULL, rep);
    IF NOT res THEN
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_3_map_$dynamicAnchor (.'$core'.'$dynamicAnchor')
CREATE OR REPLACE FUNCTION _jm_f_3(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$core'.'$dynamicAnchor'
  res := json_model_2(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_3_map_$dynamicRef (.'$core'.'$dynamicRef')
CREATE OR REPLACE FUNCTION _jm_f_4(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$core'.'$dynamicRef'
  res := json_model_2(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_3_map_$id (.'$core'.'$id')
CREATE OR REPLACE FUNCTION _jm_f_5(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$core'.'$id'
  res := json_model_2(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_3_map_$ref (.'$core'.'$ref')
CREATE OR REPLACE FUNCTION _jm_f_6(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$core'.'$ref'
  res := json_model_2(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_3_map_$schema (.'$core'.'$schema')
CREATE OR REPLACE FUNCTION _jm_f_7(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$core'.'$schema'
  res := JSONB_TYPEOF(val) = 'string' AND jm_is_valid_url(JSON_VALUE(val, '$' RETURNING TEXT), path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_3_map_$vocabulary (.'$core'.'$vocabulary')
CREATE OR REPLACE FUNCTION _jm_f_8(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
BEGIN
  -- .'$core'.'$vocabulary'
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF jm_is_valid_url(prop, NULL, rep) THEN
      -- handle 1 key props
      -- .'$core'.'$vocabulary'.'$URI'
      res := JSONB_TYPEOF(pval) = 'boolean';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION json_model_3_map(name TEXT)
RETURNS TEXT STRICT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  map JSONB := JSONB '{"$anchor":"_jm_f_0","$comment":"_jm_f_1","$defs":"_jm_f_2","$dynamicAnchor":"_jm_f_3","$dynamicRef":"_jm_f_4","$id":"_jm_f_5","$ref":"_jm_f_6","$schema":"_jm_f_7","$vocabulary":"_jm_f_8"}';
BEGIN
  RETURN map->>name;
END;
$$ LANGUAGE plpgsql;

-- check $core (.'$core')
CREATE OR REPLACE FUNCTION json_model_3(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  pfun TEXT;
  prop TEXT;
  pval JSONB;
BEGIN
  -- .'$core'
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF json_model_3_map(prop) IS NOT NULL THEN
      -- handle 9 may props
      pfun := json_model_3_map(prop);
      IF NOT jm_call(pfun, pval, NULL, rep) THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_4_map_default (.'$meta'.default)
CREATE OR REPLACE FUNCTION _jm_f_9(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$meta'.default
  res := TRUE;
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_4_map_deprecated (.'$meta'.deprecated)
CREATE OR REPLACE FUNCTION _jm_f_10(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$meta'.deprecated
  res := JSONB_TYPEOF(val) = 'boolean';
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_4_map_description (.'$meta'.description)
CREATE OR REPLACE FUNCTION _jm_f_11(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$meta'.description
  res := JSONB_TYPEOF(val) = 'string';
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_4_map_examples (.'$meta'.examples)
CREATE OR REPLACE FUNCTION _jm_f_12(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$meta'.examples
  res := JSONB_TYPEOF(val) = 'array';
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_4_map_readOnly (.'$meta'.readOnly)
CREATE OR REPLACE FUNCTION _jm_f_13(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$meta'.readOnly
  res := JSONB_TYPEOF(val) = 'boolean';
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_4_map_title (.'$meta'.title)
CREATE OR REPLACE FUNCTION _jm_f_14(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$meta'.title
  res := JSONB_TYPEOF(val) = 'string';
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_4_map_writeOnly (.'$meta'.writeOnly)
CREATE OR REPLACE FUNCTION _jm_f_15(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$meta'.writeOnly
  res := JSONB_TYPEOF(val) = 'boolean';
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION json_model_4_map(name TEXT)
RETURNS TEXT STRICT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  map JSONB := JSONB '{"default":"_jm_f_9","deprecated":"_jm_f_10","description":"_jm_f_11","examples":"_jm_f_12","readOnly":"_jm_f_13","title":"_jm_f_14","writeOnly":"_jm_f_15"}';
BEGIN
  RETURN map->>name;
END;
$$ LANGUAGE plpgsql;

-- check $meta (.'$meta')
CREATE OR REPLACE FUNCTION json_model_4(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  pfun TEXT;
  prop TEXT;
  pval JSONB;
BEGIN
  -- .'$meta'
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF json_model_4_map(prop) IS NOT NULL THEN
      -- handle 7 may props
      pfun := json_model_4_map(prop);
      IF NOT jm_call(pfun, pval, NULL, rep) THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check $content (.'$content')
CREATE OR REPLACE FUNCTION json_model_5(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
BEGIN
  -- .'$content'
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = 'contentEncoding' THEN
      -- handle may contentEncoding property
      -- .'$content'.contentEncoding
      res := JSONB_TYPEOF(pval) = 'string';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'contentMediaType' THEN
      -- handle may contentMediaType property
      -- .'$content'.contentMediaType
      res := JSONB_TYPEOF(pval) = 'string';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'contentSchema' THEN
      -- handle may contentSchema property
      -- .'$content'.contentSchema
      res := json_model_16(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check $unevaluated (.'$unevaluated')
CREATE OR REPLACE FUNCTION json_model_6(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
BEGIN
  -- .'$unevaluated'
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = 'unevaluatedItems' THEN
      -- handle may unevaluatedItems property
      -- .'$unevaluated'.unevaluatedItems
      res := json_model_16(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'unevaluatedProperties' THEN
      -- handle may unevaluatedProperties property
      -- .'$unevaluated'.unevaluatedProperties
      res := json_model_16(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check $format (.'$format')
CREATE OR REPLACE FUNCTION json_model_7(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
BEGIN
  -- .'$format'
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = 'format' THEN
      -- handle may format property
      -- .'$format'.format
      res := JSONB_TYPEOF(pval) = 'string';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION _jm_cst_0(value JSONB)
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  constants JSONB = JSONB '["array","boolean","integer","null","number","object","string"]';
BEGIN
  RETURN constants @> value;
END;
$$ LANGUAGE plpgsql;

-- check $simpleTypes (.'$simpleTypes')
CREATE OR REPLACE FUNCTION json_model_8(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$simpleTypes'
  res := JSONB_TYPEOF(val) IN ('null', 'boolean', 'number', 'string') AND _jm_cst_0(val);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check $simpleTypesArray (.'$simpleTypesArray')
CREATE OR REPLACE FUNCTION json_model_9(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  arr_0_idx INT8;
  arr_0_item JSONB;
  ival_0 int;
BEGIN
  -- .'$simpleTypesArray'
  -- .'$simpleTypesArray'.'@'
  res := JSONB_TYPEOF(val) = 'array';
  IF res THEN
    FOR arr_0_idx IN 0 .. JSONB_ARRAY_LENGTH(val) - 1 LOOP
      arr_0_item := val -> arr_0_idx;
      -- .'$simpleTypesArray'.'@'.0
      res := json_model_8(arr_0_item, NULL, rep);
      IF NOT res THEN
        EXIT;
      END IF;
    END LOOP;
  END IF;
  IF res THEN
    ival_0 := JSONB_ARRAY_LENGTH(val);
    res := jm_array_is_unique(val, path, rep) AND ival_0 >= 1;
  END IF;
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check $stringArray (.'$stringArray')
CREATE OR REPLACE FUNCTION json_model_10(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  arr_1_idx INT8;
  arr_1_item JSONB;
BEGIN
  -- .'$stringArray'
  -- .'$stringArray'.'@'
  res := JSONB_TYPEOF(val) = 'array';
  IF res THEN
    FOR arr_1_idx IN 0 .. JSONB_ARRAY_LENGTH(val) - 1 LOOP
      arr_1_item := val -> arr_1_idx;
      -- .'$stringArray'.'@'.0
      res := JSONB_TYPEOF(arr_1_item) = 'string';
      IF NOT res THEN
        EXIT;
      END IF;
    END LOOP;
  END IF;
  IF res THEN
    res := jm_array_is_unique(val, path, rep);
  END IF;
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check $nonNegativeInteger (.'$nonNegativeInteger')
CREATE OR REPLACE FUNCTION json_model_11(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$nonNegativeInteger'
  res := JSONB_TYPEOF(val) = 'number' AND (val)::INT8 = (val)::FLOAT8 AND (val)::FLOAT8 >= 0;
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_12_map_const (.'$validation'.const)
CREATE OR REPLACE FUNCTION _jm_f_16(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$validation'.const
  res := TRUE;
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_12_map_dependentRequired (.'$validation'.dependentRequired)
CREATE OR REPLACE FUNCTION _jm_f_17(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
BEGIN
  -- .'$validation'.dependentRequired
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    -- handle other props
    -- .'$validation'.dependentRequired.''
    res := json_model_10(pval, NULL, rep);
    IF NOT res THEN
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_12_map_enum (.'$validation'.enum)
CREATE OR REPLACE FUNCTION _jm_f_18(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$validation'.enum
  res := JSONB_TYPEOF(val) = 'array';
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_12_map_exclusiveMaximum (.'$validation'.exclusiveMaximum)
CREATE OR REPLACE FUNCTION _jm_f_19(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$validation'.exclusiveMaximum
  res := JSONB_TYPEOF(val) = 'number';
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_12_map_exclusiveMinimum (.'$validation'.exclusiveMinimum)
CREATE OR REPLACE FUNCTION _jm_f_20(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$validation'.exclusiveMinimum
  res := JSONB_TYPEOF(val) = 'number';
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_12_map_maxContains (.'$validation'.maxContains)
CREATE OR REPLACE FUNCTION _jm_f_21(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$validation'.maxContains
  res := json_model_11(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_12_map_maxItems (.'$validation'.maxItems)
CREATE OR REPLACE FUNCTION _jm_f_22(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$validation'.maxItems
  res := json_model_11(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_12_map_maxLength (.'$validation'.maxLength)
CREATE OR REPLACE FUNCTION _jm_f_23(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$validation'.maxLength
  res := json_model_11(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_12_map_maxProperties (.'$validation'.maxProperties)
CREATE OR REPLACE FUNCTION _jm_f_24(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$validation'.maxProperties
  res := json_model_11(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_12_map_maximum (.'$validation'.maximum)
CREATE OR REPLACE FUNCTION _jm_f_25(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$validation'.maximum
  res := JSONB_TYPEOF(val) = 'number';
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_12_map_minContains (.'$validation'.minContains)
CREATE OR REPLACE FUNCTION _jm_f_26(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$validation'.minContains
  res := json_model_11(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_12_map_minItems (.'$validation'.minItems)
CREATE OR REPLACE FUNCTION _jm_f_27(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$validation'.minItems
  res := json_model_11(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_12_map_minLength (.'$validation'.minLength)
CREATE OR REPLACE FUNCTION _jm_f_28(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$validation'.minLength
  res := json_model_11(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_12_map_minProperties (.'$validation'.minProperties)
CREATE OR REPLACE FUNCTION _jm_f_29(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$validation'.minProperties
  res := json_model_11(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_12_map_minimum (.'$validation'.minimum)
CREATE OR REPLACE FUNCTION _jm_f_30(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$validation'.minimum
  res := JSONB_TYPEOF(val) = 'number';
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_12_map_multipleOf (.'$validation'.multipleOf)
CREATE OR REPLACE FUNCTION _jm_f_31(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$validation'.multipleOf
  res := JSONB_TYPEOF(val) = 'number' AND (val)::FLOAT8 > 0.0;
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_12_map_pattern (.'$validation'.pattern)
CREATE OR REPLACE FUNCTION _jm_f_32(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$validation'.pattern
  res := JSONB_TYPEOF(val) = 'string' AND jm_is_valid_regex(JSON_VALUE(val, '$' RETURNING TEXT), path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_12_map_required (.'$validation'.required)
CREATE OR REPLACE FUNCTION _jm_f_33(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$validation'.required
  res := json_model_10(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_12_map_type (.'$validation'.type)
CREATE OR REPLACE FUNCTION _jm_f_34(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$validation'.type
  -- .'$validation'.type.'|'.0
  res := json_model_8(val, path, rep);
  IF NOT res THEN
    -- .'$validation'.type.'|'.1
    res := json_model_9(val, path, rep);
  END IF;
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_12_map_uniqueItems (.'$validation'.uniqueItems)
CREATE OR REPLACE FUNCTION _jm_f_35(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$validation'.uniqueItems
  res := JSONB_TYPEOF(val) = 'boolean';
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION json_model_12_map(name TEXT)
RETURNS TEXT STRICT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  map JSONB := JSONB '{"const":"_jm_f_16","dependentRequired":"_jm_f_17","enum":"_jm_f_18","exclusiveMaximum":"_jm_f_19","exclusiveMinimum":"_jm_f_20","maxContains":"_jm_f_21","maxItems":"_jm_f_22","maxLength":"_jm_f_23","maxProperties":"_jm_f_24","maximum":"_jm_f_25","minContains":"_jm_f_26","minItems":"_jm_f_27","minLength":"_jm_f_28","minProperties":"_jm_f_29","minimum":"_jm_f_30","multipleOf":"_jm_f_31","pattern":"_jm_f_32","required":"_jm_f_33","type":"_jm_f_34","uniqueItems":"_jm_f_35"}';
BEGIN
  RETURN map->>name;
END;
$$ LANGUAGE plpgsql;

-- check $validation (.'$validation')
CREATE OR REPLACE FUNCTION json_model_12(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  pfun TEXT;
  prop TEXT;
  pval JSONB;
BEGIN
  -- .'$validation'
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF json_model_12_map(prop) IS NOT NULL THEN
      -- handle 20 may props
      pfun := json_model_12_map(prop);
      IF NOT jm_call(pfun, pval, NULL, rep) THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check $schemaArray (.'$schemaArray')
CREATE OR REPLACE FUNCTION json_model_13(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  arr_2_idx INT8;
  arr_2_item JSONB;
  ival_1 int;
BEGIN
  -- .'$schemaArray'
  -- .'$schemaArray'.'@'
  res := JSONB_TYPEOF(val) = 'array';
  IF res THEN
    FOR arr_2_idx IN 0 .. JSONB_ARRAY_LENGTH(val) - 1 LOOP
      arr_2_item := val -> arr_2_idx;
      -- .'$schemaArray'.'@'.0
      res := json_model_16(arr_2_item, NULL, rep);
      IF NOT res THEN
        EXIT;
      END IF;
    END LOOP;
  END IF;
  IF res THEN
    ival_1 := JSONB_ARRAY_LENGTH(val);
    res := ival_1 >= 1;
  END IF;
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_14_map_additionalProperties (.'$applicator'.additionalProperties)
CREATE OR REPLACE FUNCTION _jm_f_36(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$applicator'.additionalProperties
  res := json_model_16(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_14_map_allOf (.'$applicator'.allOf)
CREATE OR REPLACE FUNCTION _jm_f_37(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$applicator'.allOf
  res := json_model_13(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_14_map_anyOf (.'$applicator'.anyOf)
CREATE OR REPLACE FUNCTION _jm_f_38(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$applicator'.anyOf
  res := json_model_13(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_14_map_contains (.'$applicator'.contains)
CREATE OR REPLACE FUNCTION _jm_f_39(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$applicator'.contains
  res := json_model_16(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_14_map_dependentSchemas (.'$applicator'.dependentSchemas)
CREATE OR REPLACE FUNCTION _jm_f_40(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
BEGIN
  -- .'$applicator'.dependentSchemas
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    -- handle other props
    -- .'$applicator'.dependentSchemas.''
    res := json_model_16(pval, NULL, rep);
    IF NOT res THEN
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_14_map_else (.'$applicator'.else)
CREATE OR REPLACE FUNCTION _jm_f_41(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$applicator'.else
  res := json_model_16(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_14_map_if (.'$applicator'.if)
CREATE OR REPLACE FUNCTION _jm_f_42(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$applicator'.if
  res := json_model_16(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_14_map_items (.'$applicator'.items)
CREATE OR REPLACE FUNCTION _jm_f_43(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$applicator'.items
  res := json_model_16(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_14_map_not (.'$applicator'.not)
CREATE OR REPLACE FUNCTION _jm_f_44(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$applicator'.not
  res := json_model_16(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_14_map_oneOf (.'$applicator'.oneOf)
CREATE OR REPLACE FUNCTION _jm_f_45(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$applicator'.oneOf
  res := json_model_13(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_14_map_patternProperties (.'$applicator'.patternProperties)
CREATE OR REPLACE FUNCTION _jm_f_46(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
BEGIN
  -- .'$applicator'.patternProperties
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF jm_is_valid_regex(prop, NULL, rep) THEN
      -- handle 1 key props
      -- .'$applicator'.patternProperties.'$REGEX'
      res := json_model_16(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_14_map_prefixItems (.'$applicator'.prefixItems)
CREATE OR REPLACE FUNCTION _jm_f_47(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$applicator'.prefixItems
  res := json_model_13(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_14_map_properties (.'$applicator'.properties)
CREATE OR REPLACE FUNCTION _jm_f_48(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
BEGIN
  -- .'$applicator'.properties
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    -- handle other props
    -- .'$applicator'.properties.''
    res := json_model_16(pval, NULL, rep);
    IF NOT res THEN
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- object .'$applicator'.propertyDependencies.''
CREATE OR REPLACE FUNCTION _jm_obj_0(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    -- handle other props
    -- .'$applicator'.propertyDependencies.''.''
    res := json_model_16(pval, NULL, rep);
    IF NOT res THEN
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_14_map_propertyDependencies (.'$applicator'.propertyDependencies)
CREATE OR REPLACE FUNCTION _jm_f_49(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
BEGIN
  -- .'$applicator'.propertyDependencies
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    -- handle other props
    -- .'$applicator'.propertyDependencies.''
    res := _jm_obj_0(pval, NULL, rep);
    IF NOT res THEN
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_14_map_propertyNames (.'$applicator'.propertyNames)
CREATE OR REPLACE FUNCTION _jm_f_50(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$applicator'.propertyNames
  res := json_model_16(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_14_map_then (.'$applicator'.then)
CREATE OR REPLACE FUNCTION _jm_f_51(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$applicator'.then
  res := json_model_16(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION json_model_14_map(name TEXT)
RETURNS TEXT STRICT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  map JSONB := JSONB '{"additionalProperties":"_jm_f_36","allOf":"_jm_f_37","anyOf":"_jm_f_38","contains":"_jm_f_39","dependentSchemas":"_jm_f_40","else":"_jm_f_41","if":"_jm_f_42","items":"_jm_f_43","not":"_jm_f_44","oneOf":"_jm_f_45","patternProperties":"_jm_f_46","prefixItems":"_jm_f_47","properties":"_jm_f_48","propertyDependencies":"_jm_f_49","propertyNames":"_jm_f_50","then":"_jm_f_51"}';
BEGIN
  RETURN map->>name;
END;
$$ LANGUAGE plpgsql;

-- check $applicator (.'$applicator')
CREATE OR REPLACE FUNCTION json_model_14(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  pfun TEXT;
  prop TEXT;
  pval JSONB;
BEGIN
  -- .'$applicator'
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF json_model_14_map(prop) IS NOT NULL THEN
      -- handle 16 may props
      pfun := json_model_14_map(prop);
      IF NOT jm_call(pfun, pval, NULL, rep) THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_15_map_$anchor (.'$ObjectSchema'.'$anchor')
CREATE OR REPLACE FUNCTION _jm_f_52(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$ObjectSchema'.'$anchor'
  res := json_model_2(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_15_map_$comment (.'$ObjectSchema'.'$comment')
CREATE OR REPLACE FUNCTION _jm_f_53(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$ObjectSchema'.'$comment'
  res := JSONB_TYPEOF(val) = 'string';
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_15_map_$defs (.'$ObjectSchema'.'$defs')
CREATE OR REPLACE FUNCTION _jm_f_54(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
BEGIN
  -- .'$ObjectSchema'.'$defs'
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    -- handle other props
    -- .'$ObjectSchema'.'$defs'.''
    res := json_model_16(pval, NULL, rep);
    IF NOT res THEN
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_15_map_$dynamicAnchor (.'$ObjectSchema'.'$dynamicAnchor')
CREATE OR REPLACE FUNCTION _jm_f_55(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$ObjectSchema'.'$dynamicAnchor'
  res := json_model_2(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_15_map_$dynamicRef (.'$ObjectSchema'.'$dynamicRef')
CREATE OR REPLACE FUNCTION _jm_f_56(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$ObjectSchema'.'$dynamicRef'
  res := json_model_2(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_15_map_$id (.'$ObjectSchema'.'$id')
CREATE OR REPLACE FUNCTION _jm_f_57(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$ObjectSchema'.'$id'
  res := json_model_2(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_15_map_$ref (.'$ObjectSchema'.'$ref')
CREATE OR REPLACE FUNCTION _jm_f_58(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$ObjectSchema'.'$ref'
  res := json_model_2(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_15_map_$schema (.'$ObjectSchema'.'$schema')
CREATE OR REPLACE FUNCTION _jm_f_59(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$ObjectSchema'.'$schema'
  res := JSONB_TYPEOF(val) = 'string' AND jm_is_valid_url(JSON_VALUE(val, '$' RETURNING TEXT), path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_15_map_$vocabulary (.'$ObjectSchema'.'$vocabulary')
CREATE OR REPLACE FUNCTION _jm_f_60(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
BEGIN
  -- .'$ObjectSchema'.'$vocabulary'
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF jm_is_valid_url(prop, NULL, rep) THEN
      -- handle 1 key props
      -- .'$ObjectSchema'.'$vocabulary'.'$URI'
      res := JSONB_TYPEOF(pval) = 'boolean';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_15_map_additionalProperties (.'$ObjectSchema'.additionalProperties)
CREATE OR REPLACE FUNCTION _jm_f_61(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$ObjectSchema'.additionalProperties
  res := json_model_16(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_15_map_allOf (.'$ObjectSchema'.allOf)
CREATE OR REPLACE FUNCTION _jm_f_62(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$ObjectSchema'.allOf
  res := json_model_13(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_15_map_anyOf (.'$ObjectSchema'.anyOf)
CREATE OR REPLACE FUNCTION _jm_f_63(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$ObjectSchema'.anyOf
  res := json_model_13(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_15_map_const (.'$ObjectSchema'.const)
CREATE OR REPLACE FUNCTION _jm_f_64(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$ObjectSchema'.const
  res := TRUE;
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_15_map_contains (.'$ObjectSchema'.contains)
CREATE OR REPLACE FUNCTION _jm_f_65(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$ObjectSchema'.contains
  res := json_model_16(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_15_map_contentEncoding (.'$ObjectSchema'.contentEncoding)
CREATE OR REPLACE FUNCTION _jm_f_66(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$ObjectSchema'.contentEncoding
  res := JSONB_TYPEOF(val) = 'string';
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_15_map_contentMediaType (.'$ObjectSchema'.contentMediaType)
CREATE OR REPLACE FUNCTION _jm_f_67(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$ObjectSchema'.contentMediaType
  res := JSONB_TYPEOF(val) = 'string';
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_15_map_contentSchema (.'$ObjectSchema'.contentSchema)
CREATE OR REPLACE FUNCTION _jm_f_68(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$ObjectSchema'.contentSchema
  res := json_model_16(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_15_map_default (.'$ObjectSchema'.default)
CREATE OR REPLACE FUNCTION _jm_f_69(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$ObjectSchema'.default
  res := TRUE;
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_15_map_dependentRequired (.'$ObjectSchema'.dependentRequired)
CREATE OR REPLACE FUNCTION _jm_f_70(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
BEGIN
  -- .'$ObjectSchema'.dependentRequired
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    -- handle other props
    -- .'$ObjectSchema'.dependentRequired.''
    res := json_model_10(pval, NULL, rep);
    IF NOT res THEN
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_15_map_dependentSchemas (.'$ObjectSchema'.dependentSchemas)
CREATE OR REPLACE FUNCTION _jm_f_71(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
BEGIN
  -- .'$ObjectSchema'.dependentSchemas
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    -- handle other props
    -- .'$ObjectSchema'.dependentSchemas.''
    res := json_model_16(pval, NULL, rep);
    IF NOT res THEN
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_15_map_deprecated (.'$ObjectSchema'.deprecated)
CREATE OR REPLACE FUNCTION _jm_f_72(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$ObjectSchema'.deprecated
  res := JSONB_TYPEOF(val) = 'boolean';
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_15_map_description (.'$ObjectSchema'.description)
CREATE OR REPLACE FUNCTION _jm_f_73(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$ObjectSchema'.description
  res := JSONB_TYPEOF(val) = 'string';
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_15_map_else (.'$ObjectSchema'.else)
CREATE OR REPLACE FUNCTION _jm_f_74(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$ObjectSchema'.else
  res := json_model_16(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_15_map_enum (.'$ObjectSchema'.enum)
CREATE OR REPLACE FUNCTION _jm_f_75(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$ObjectSchema'.enum
  res := JSONB_TYPEOF(val) = 'array';
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_15_map_examples (.'$ObjectSchema'.examples)
CREATE OR REPLACE FUNCTION _jm_f_76(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$ObjectSchema'.examples
  res := JSONB_TYPEOF(val) = 'array';
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_15_map_exclusiveMaximum (.'$ObjectSchema'.exclusiveMaximum)
CREATE OR REPLACE FUNCTION _jm_f_77(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$ObjectSchema'.exclusiveMaximum
  res := JSONB_TYPEOF(val) = 'number';
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_15_map_exclusiveMinimum (.'$ObjectSchema'.exclusiveMinimum)
CREATE OR REPLACE FUNCTION _jm_f_78(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$ObjectSchema'.exclusiveMinimum
  res := JSONB_TYPEOF(val) = 'number';
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_15_map_format (.'$ObjectSchema'.format)
CREATE OR REPLACE FUNCTION _jm_f_79(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$ObjectSchema'.format
  res := JSONB_TYPEOF(val) = 'string';
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_15_map_if (.'$ObjectSchema'.if)
CREATE OR REPLACE FUNCTION _jm_f_80(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$ObjectSchema'.if
  res := json_model_16(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_15_map_items (.'$ObjectSchema'.items)
CREATE OR REPLACE FUNCTION _jm_f_81(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$ObjectSchema'.items
  res := json_model_16(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_15_map_maxContains (.'$ObjectSchema'.maxContains)
CREATE OR REPLACE FUNCTION _jm_f_82(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$ObjectSchema'.maxContains
  res := json_model_11(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_15_map_maxItems (.'$ObjectSchema'.maxItems)
CREATE OR REPLACE FUNCTION _jm_f_83(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$ObjectSchema'.maxItems
  res := json_model_11(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_15_map_maxLength (.'$ObjectSchema'.maxLength)
CREATE OR REPLACE FUNCTION _jm_f_84(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$ObjectSchema'.maxLength
  res := json_model_11(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_15_map_maxProperties (.'$ObjectSchema'.maxProperties)
CREATE OR REPLACE FUNCTION _jm_f_85(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$ObjectSchema'.maxProperties
  res := json_model_11(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_15_map_maximum (.'$ObjectSchema'.maximum)
CREATE OR REPLACE FUNCTION _jm_f_86(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$ObjectSchema'.maximum
  res := JSONB_TYPEOF(val) = 'number';
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_15_map_minContains (.'$ObjectSchema'.minContains)
CREATE OR REPLACE FUNCTION _jm_f_87(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$ObjectSchema'.minContains
  res := json_model_11(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_15_map_minItems (.'$ObjectSchema'.minItems)
CREATE OR REPLACE FUNCTION _jm_f_88(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$ObjectSchema'.minItems
  res := json_model_11(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_15_map_minLength (.'$ObjectSchema'.minLength)
CREATE OR REPLACE FUNCTION _jm_f_89(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$ObjectSchema'.minLength
  res := json_model_11(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_15_map_minProperties (.'$ObjectSchema'.minProperties)
CREATE OR REPLACE FUNCTION _jm_f_90(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$ObjectSchema'.minProperties
  res := json_model_11(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_15_map_minimum (.'$ObjectSchema'.minimum)
CREATE OR REPLACE FUNCTION _jm_f_91(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$ObjectSchema'.minimum
  res := JSONB_TYPEOF(val) = 'number';
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_15_map_multipleOf (.'$ObjectSchema'.multipleOf)
CREATE OR REPLACE FUNCTION _jm_f_92(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$ObjectSchema'.multipleOf
  res := JSONB_TYPEOF(val) = 'number' AND (val)::FLOAT8 > 0.0;
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_15_map_not (.'$ObjectSchema'.not)
CREATE OR REPLACE FUNCTION _jm_f_93(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$ObjectSchema'.not
  res := json_model_16(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_15_map_oneOf (.'$ObjectSchema'.oneOf)
CREATE OR REPLACE FUNCTION _jm_f_94(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$ObjectSchema'.oneOf
  res := json_model_13(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_15_map_pattern (.'$ObjectSchema'.pattern)
CREATE OR REPLACE FUNCTION _jm_f_95(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$ObjectSchema'.pattern
  res := JSONB_TYPEOF(val) = 'string' AND jm_is_valid_regex(JSON_VALUE(val, '$' RETURNING TEXT), path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_15_map_patternProperties (.'$ObjectSchema'.patternProperties)
CREATE OR REPLACE FUNCTION _jm_f_96(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
BEGIN
  -- .'$ObjectSchema'.patternProperties
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF jm_is_valid_regex(prop, NULL, rep) THEN
      -- handle 1 key props
      -- .'$ObjectSchema'.patternProperties.'$REGEX'
      res := json_model_16(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_15_map_prefixItems (.'$ObjectSchema'.prefixItems)
CREATE OR REPLACE FUNCTION _jm_f_97(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$ObjectSchema'.prefixItems
  res := json_model_13(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_15_map_properties (.'$ObjectSchema'.properties)
CREATE OR REPLACE FUNCTION _jm_f_98(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
BEGIN
  -- .'$ObjectSchema'.properties
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    -- handle other props
    -- .'$ObjectSchema'.properties.''
    res := json_model_16(pval, NULL, rep);
    IF NOT res THEN
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- object .'$ObjectSchema'.propertyDependencies.''
CREATE OR REPLACE FUNCTION _jm_obj_1(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    -- handle other props
    -- .'$ObjectSchema'.propertyDependencies.''.''
    res := json_model_16(pval, NULL, rep);
    IF NOT res THEN
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_15_map_propertyDependencies (.'$ObjectSchema'.propertyDependencies)
CREATE OR REPLACE FUNCTION _jm_f_99(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
BEGIN
  -- .'$ObjectSchema'.propertyDependencies
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    -- handle other props
    -- .'$ObjectSchema'.propertyDependencies.''
    res := _jm_obj_1(pval, NULL, rep);
    IF NOT res THEN
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_15_map_propertyNames (.'$ObjectSchema'.propertyNames)
CREATE OR REPLACE FUNCTION _jm_f_100(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$ObjectSchema'.propertyNames
  res := json_model_16(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_15_map_readOnly (.'$ObjectSchema'.readOnly)
CREATE OR REPLACE FUNCTION _jm_f_101(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$ObjectSchema'.readOnly
  res := JSONB_TYPEOF(val) = 'boolean';
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_15_map_required (.'$ObjectSchema'.required)
CREATE OR REPLACE FUNCTION _jm_f_102(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$ObjectSchema'.required
  res := json_model_10(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_15_map_then (.'$ObjectSchema'.then)
CREATE OR REPLACE FUNCTION _jm_f_103(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$ObjectSchema'.then
  res := json_model_16(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_15_map_title (.'$ObjectSchema'.title)
CREATE OR REPLACE FUNCTION _jm_f_104(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$ObjectSchema'.title
  res := JSONB_TYPEOF(val) = 'string';
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_15_map_type (.'$ObjectSchema'.type)
CREATE OR REPLACE FUNCTION _jm_f_105(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$ObjectSchema'.type
  -- .'$ObjectSchema'.type.'|'.0
  res := json_model_8(val, path, rep);
  IF NOT res THEN
    -- .'$ObjectSchema'.type.'|'.1
    res := json_model_9(val, path, rep);
  END IF;
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_15_map_unevaluatedItems (.'$ObjectSchema'.unevaluatedItems)
CREATE OR REPLACE FUNCTION _jm_f_106(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$ObjectSchema'.unevaluatedItems
  res := json_model_16(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_15_map_unevaluatedProperties (.'$ObjectSchema'.unevaluatedProperties)
CREATE OR REPLACE FUNCTION _jm_f_107(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$ObjectSchema'.unevaluatedProperties
  res := json_model_16(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_15_map_uniqueItems (.'$ObjectSchema'.uniqueItems)
CREATE OR REPLACE FUNCTION _jm_f_108(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$ObjectSchema'.uniqueItems
  res := JSONB_TYPEOF(val) = 'boolean';
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_15_map_writeOnly (.'$ObjectSchema'.writeOnly)
CREATE OR REPLACE FUNCTION _jm_f_109(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$ObjectSchema'.writeOnly
  res := JSONB_TYPEOF(val) = 'boolean';
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION json_model_15_map(name TEXT)
RETURNS TEXT STRICT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  map JSONB := JSONB '{"$anchor":"_jm_f_52","$comment":"_jm_f_53","$defs":"_jm_f_54","$dynamicAnchor":"_jm_f_55","$dynamicRef":"_jm_f_56","$id":"_jm_f_57","$ref":"_jm_f_58","$schema":"_jm_f_59","$vocabulary":"_jm_f_60","additionalProperties":"_jm_f_61","allOf":"_jm_f_62","anyOf":"_jm_f_63","const":"_jm_f_64","contains":"_jm_f_65","contentEncoding":"_jm_f_66","contentMediaType":"_jm_f_67","contentSchema":"_jm_f_68","default":"_jm_f_69","dependentRequired":"_jm_f_70","dependentSchemas":"_jm_f_71","deprecated":"_jm_f_72","description":"_jm_f_73","else":"_jm_f_74","enum":"_jm_f_75","examples":"_jm_f_76","exclusiveMaximum":"_jm_f_77","exclusiveMinimum":"_jm_f_78","format":"_jm_f_79","if":"_jm_f_80","items":"_jm_f_81","maxContains":"_jm_f_82","maxItems":"_jm_f_83","maxLength":"_jm_f_84","maxProperties":"_jm_f_85","maximum":"_jm_f_86","minContains":"_jm_f_87","minItems":"_jm_f_88","minLength":"_jm_f_89","minProperties":"_jm_f_90","minimum":"_jm_f_91","multipleOf":"_jm_f_92","not":"_jm_f_93","oneOf":"_jm_f_94","pattern":"_jm_f_95","patternProperties":"_jm_f_96","prefixItems":"_jm_f_97","properties":"_jm_f_98","propertyDependencies":"_jm_f_99","propertyNames":"_jm_f_100","readOnly":"_jm_f_101","required":"_jm_f_102","then":"_jm_f_103","title":"_jm_f_104","type":"_jm_f_105","unevaluatedItems":"_jm_f_106","unevaluatedProperties":"_jm_f_107","uniqueItems":"_jm_f_108","writeOnly":"_jm_f_109"}';
BEGIN
  RETURN map->>name;
END;
$$ LANGUAGE plpgsql;

-- check $ObjectSchema (.'$ObjectSchema')
CREATE OR REPLACE FUNCTION json_model_15(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  pfun TEXT;
  prop TEXT;
  pval JSONB;
BEGIN
  -- .'$ObjectSchema'
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF json_model_15_map(prop) IS NOT NULL THEN
      -- handle 58 may props
      pfun := json_model_15_map(prop);
      IF NOT jm_call(pfun, pval, NULL, rep) THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check $Schema (.'$Schema')
CREATE OR REPLACE FUNCTION json_model_16(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$Schema'
  -- .'$Schema'.'|'.0
  res := JSONB_TYPEOF(val) = 'boolean';
  IF NOT res THEN
    -- .'$Schema'.'|'.1
    res := json_model_15(val, path, rep);
  END IF;
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check $ (.)
CREATE OR REPLACE FUNCTION json_model_1(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- JSON Schema Draft Next as of 2023 [JSON_MODEL_LOOSE_INT, JSON_MODEL_LOOSE_FLOAT]
  -- .
  -- .'@'
  res := json_model_16(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION check_model_map(name TEXT)
RETURNS TEXT STRICT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  map JSONB := JSONB '{"":"json_model_1","URI-REFERENCE":"json_model_2","core":"json_model_3","meta":"json_model_4","content":"json_model_5","unevaluated":"json_model_6","format":"json_model_7","simpleTypes":"json_model_8","simpleTypesArray":"json_model_9","stringArray":"json_model_10","nonNegativeInteger":"json_model_11","validation":"json_model_12","schemaArray":"json_model_13","applicator":"json_model_14","ObjectSchema":"json_model_15","Schema":"json_model_16"}';
BEGIN
  RETURN map->>name;
END;
$$ LANGUAGE plpgsql;

--
-- constant maps initialization
--
TRUNCATE jm_constant_maps;

--
-- JSON Model checking entry point
--
-- TODO INOUT rep?
CREATE OR REPLACE FUNCTION check_model(val JSONB, name TEXT, rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  fun TEXT;
BEGIN
  fun := check_model_map(name);
  IF fun IS NULL THEN
    RAISE EXCEPTION 'model for % not found', name;
  END IF;
  RETURN jm_call(fun, val, NULL, rep);
END;
$$ LANGUAGE plpgsql;
