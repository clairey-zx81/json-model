//
// Generated by JSON Model Compiler version 2.0a0
// see https://github.com/clairey-zx81/json-model
//
#include <json-model.h>
#define JSON_MODEL_VERSION "2.0a0"

static bool json_model_2(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool json_model_3(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool json_model_4(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool json_model_5(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool json_model_6(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool json_model_7(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool json_model_8(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool json_model_9(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool json_model_10(const json_t *val, jm_path_t *path, jm_report_t *rep);
static jm_constmap_t _jm_map_0_tab[6];
static bool json_model_11(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool json_model_12(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool json_model_13(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool json_model_14(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool json_model_1(const json_t *val, jm_path_t *path, jm_report_t *rep);
jm_propmap_t check_model_map_tab[14];
const size_t check_model_map_size = 14;

// check $position (.'$position')
static bool json_model_2(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .'$position'
    // .'$position'.'@'
    res = json_is_array(val);
    if (res)
    {
        size_t arr_0_idx;
        json_t *arr_0_item;
        json_array_foreach(val, arr_0_idx, arr_0_item)
        {
            jm_path_t arr_0_lpath = (jm_path_t) { NULL, arr_0_idx, path, NULL };
            // .'$position'.'@'.0
            res = json_is_number(arr_0_item);
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "not a -1.0 loose float [.'$position'.'@'.0]", (path ? &arr_0_lpath : NULL));
            }
            if (! res)
            {
                break;
            }
        }
    }
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "not array or unexpected array [.'$position'.'@']", path);
    }
    if (res)
    {
        int64_t ival_0 = json_array_size(val);
        res = ival_0 <= 3 && ival_0 >= 2;
    }
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "constraints failed [.'$position']", path);
    }
    return res;
}

// check $coord_array (.'$coord_array')
static bool json_model_3(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .'$coord_array'
    // .'$coord_array'.'@'
    res = json_is_array(val);
    if (res)
    {
        size_t arr_1_idx;
        json_t *arr_1_item;
        json_array_foreach(val, arr_1_idx, arr_1_item)
        {
            jm_path_t arr_1_lpath = (jm_path_t) { NULL, arr_1_idx, path, NULL };
            // .'$coord_array'.'@'.0
            res = json_model_2(arr_1_item, (path ? &arr_1_lpath : NULL), rep);
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "unexpected $position [.'$coord_array'.'@'.0]", (path ? &arr_1_lpath : NULL));
            }
            if (! res)
            {
                break;
            }
        }
    }
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "not array or unexpected array [.'$coord_array'.'@']", path);
    }
    if (res)
    {
        int64_t ival_1 = json_array_size(val);
        res = ival_1 >= 2;
    }
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "constraints failed [.'$coord_array']", path);
    }
    return res;
}

// check $linear_ring (.'$linear_ring')
static bool json_model_4(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .'$linear_ring'
    // .'$linear_ring'.'@'
    res = json_is_array(val);
    if (res)
    {
        size_t arr_2_idx;
        json_t *arr_2_item;
        json_array_foreach(val, arr_2_idx, arr_2_item)
        {
            jm_path_t arr_2_lpath = (jm_path_t) { NULL, arr_2_idx, path, NULL };
            // .'$linear_ring'.'@'.0
            res = json_model_2(arr_2_item, (path ? &arr_2_lpath : NULL), rep);
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "unexpected $position [.'$linear_ring'.'@'.0]", (path ? &arr_2_lpath : NULL));
            }
            if (! res)
            {
                break;
            }
        }
    }
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "not array or unexpected array [.'$linear_ring'.'@']", path);
    }
    if (res)
    {
        int64_t ival_2 = json_array_size(val);
        res = ival_2 >= 4;
    }
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "constraints failed [.'$linear_ring']", path);
    }
    return res;
}

// object .'$Point'
static bool _jm_obj_0(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    if (! json_is_object(val))
    {
        if (rep) jm_report_add_entry(rep, "not an object [.'$Point']", path);
        return false;
    }
    bool res;
    int64_t must_count = 0;
    const char *prop;
    json_t *pval;
    json_object_foreach((json_t *) val, prop, pval)
    {
        jm_path_t lpath_0 = (jm_path_t) { prop, 0, path, NULL };
        if (strcmp(prop, "type") == 0)
        {
            // handle must type property
            must_count += 1;
            // .'$Point'.type
            res = json_is_string(pval) && strcmp(json_string_value(pval), "Point") == 0;
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "unexpected Point [.'$Point'.type]", (path ? &lpath_0 : NULL));
            }
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "invalid mandatory prop value [.'$Point'.type]", (path ? &lpath_0 : NULL));
                return false;
            }
        }
        else if (strcmp(prop, "coordinates") == 0)
        {
            // handle must coordinates property
            must_count += 1;
            // .'$Point'.coordinates
            res = json_model_2(pval, (path ? &lpath_0 : NULL), rep);
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "unexpected $position [.'$Point'.coordinates]", (path ? &lpath_0 : NULL));
            }
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "invalid mandatory prop value [.'$Point'.coordinates]", (path ? &lpath_0 : NULL));
                return false;
            }
        }
        else if (strcmp(prop, "bbox") == 0)
        {
            // handle may bbox property
            // .'$Point'.bbox
            res = json_is_array(pval);
            if (res)
            {
                size_t arr_3_idx;
                json_t *arr_3_item;
                json_array_foreach(pval, arr_3_idx, arr_3_item)
                {
                    jm_path_t arr_3_lpath = (jm_path_t) { NULL, arr_3_idx, (path ? &lpath_0 : NULL), NULL };
                    // .'$Point'.bbox.0
                    res = json_is_number(arr_3_item);
                    if (! res)
                    {
                        if (rep) jm_report_add_entry(rep, "not a -1.0 loose float [.'$Point'.bbox.0]", ((path ? &lpath_0 : NULL) ? &arr_3_lpath : NULL));
                    }
                    if (! res)
                    {
                        break;
                    }
                }
            }
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "not array or unexpected array [.'$Point'.bbox]", (path ? &lpath_0 : NULL));
            }
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "invalid optional prop value [.'$Point'.bbox]", (path ? &lpath_0 : NULL));
                return false;
            }
        }
        else
        {
            if (rep) jm_report_add_entry(rep, "unexpected prop [.'$Point']", (path ? &lpath_0 : NULL));
            return false;
        }
    }
    if (must_count != 2)
    {
        if (rep != NULL)
        {
            if (! (json_object_get(val, "coordinates") != NULL))
            {
                if (rep) jm_report_add_entry(rep, "missing mandatory prop <coordinates> [.'$Point']", path);
            }
            if (! (json_object_get(val, "type") != NULL))
            {
                if (rep) jm_report_add_entry(rep, "missing mandatory prop <type> [.'$Point']", path);
            }
        }
        return false;
    }
    return true;
}

// check $Point (.'$Point')
static bool json_model_5(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .'$Point'
    res = _jm_obj_0(val, path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "not an expected object [.'$Point']", path);
    }
    return res;
}

// object .'$MultiPoint'
static bool _jm_obj_1(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    if (! json_is_object(val))
    {
        if (rep) jm_report_add_entry(rep, "not an object [.'$MultiPoint']", path);
        return false;
    }
    bool res;
    int64_t must_count = 0;
    const char *prop;
    json_t *pval;
    json_object_foreach((json_t *) val, prop, pval)
    {
        jm_path_t lpath_1 = (jm_path_t) { prop, 0, path, NULL };
        if (strcmp(prop, "type") == 0)
        {
            // handle must type property
            must_count += 1;
            // .'$MultiPoint'.type
            res = json_is_string(pval) && strcmp(json_string_value(pval), "MultiPoint") == 0;
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "unexpected MultiPoint [.'$MultiPoint'.type]", (path ? &lpath_1 : NULL));
            }
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "invalid mandatory prop value [.'$MultiPoint'.type]", (path ? &lpath_1 : NULL));
                return false;
            }
        }
        else if (strcmp(prop, "coordinates") == 0)
        {
            // handle must coordinates property
            must_count += 1;
            // .'$MultiPoint'.coordinates
            res = json_is_array(pval);
            if (res)
            {
                size_t arr_4_idx;
                json_t *arr_4_item;
                json_array_foreach(pval, arr_4_idx, arr_4_item)
                {
                    jm_path_t arr_4_lpath = (jm_path_t) { NULL, arr_4_idx, (path ? &lpath_1 : NULL), NULL };
                    // .'$MultiPoint'.coordinates.0
                    res = json_model_2(arr_4_item, ((path ? &lpath_1 : NULL) ? &arr_4_lpath : NULL), rep);
                    if (! res)
                    {
                        if (rep) jm_report_add_entry(rep, "unexpected $position [.'$MultiPoint'.coordinates.0]", ((path ? &lpath_1 : NULL) ? &arr_4_lpath : NULL));
                    }
                    if (! res)
                    {
                        break;
                    }
                }
            }
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "not array or unexpected array [.'$MultiPoint'.coordinates]", (path ? &lpath_1 : NULL));
            }
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "invalid mandatory prop value [.'$MultiPoint'.coordinates]", (path ? &lpath_1 : NULL));
                return false;
            }
        }
        else if (strcmp(prop, "bbox") == 0)
        {
            // handle may bbox property
            // .'$MultiPoint'.bbox
            res = json_is_array(pval);
            if (res)
            {
                size_t arr_5_idx;
                json_t *arr_5_item;
                json_array_foreach(pval, arr_5_idx, arr_5_item)
                {
                    jm_path_t arr_5_lpath = (jm_path_t) { NULL, arr_5_idx, (path ? &lpath_1 : NULL), NULL };
                    // .'$MultiPoint'.bbox.0
                    res = json_is_number(arr_5_item);
                    if (! res)
                    {
                        if (rep) jm_report_add_entry(rep, "not a -1.0 loose float [.'$MultiPoint'.bbox.0]", ((path ? &lpath_1 : NULL) ? &arr_5_lpath : NULL));
                    }
                    if (! res)
                    {
                        break;
                    }
                }
            }
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "not array or unexpected array [.'$MultiPoint'.bbox]", (path ? &lpath_1 : NULL));
            }
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "invalid optional prop value [.'$MultiPoint'.bbox]", (path ? &lpath_1 : NULL));
                return false;
            }
        }
        else
        {
            if (rep) jm_report_add_entry(rep, "unexpected prop [.'$MultiPoint']", (path ? &lpath_1 : NULL));
            return false;
        }
    }
    if (must_count != 2)
    {
        if (rep != NULL)
        {
            if (! (json_object_get(val, "coordinates") != NULL))
            {
                if (rep) jm_report_add_entry(rep, "missing mandatory prop <coordinates> [.'$MultiPoint']", path);
            }
            if (! (json_object_get(val, "type") != NULL))
            {
                if (rep) jm_report_add_entry(rep, "missing mandatory prop <type> [.'$MultiPoint']", path);
            }
        }
        return false;
    }
    return true;
}

// check $MultiPoint (.'$MultiPoint')
static bool json_model_6(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .'$MultiPoint'
    res = _jm_obj_1(val, path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "not an expected object [.'$MultiPoint']", path);
    }
    return res;
}

// object .'$LineString'
static bool _jm_obj_2(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    if (! json_is_object(val))
    {
        if (rep) jm_report_add_entry(rep, "not an object [.'$LineString']", path);
        return false;
    }
    bool res;
    int64_t must_count = 0;
    const char *prop;
    json_t *pval;
    json_object_foreach((json_t *) val, prop, pval)
    {
        jm_path_t lpath_2 = (jm_path_t) { prop, 0, path, NULL };
        if (strcmp(prop, "type") == 0)
        {
            // handle must type property
            must_count += 1;
            // .'$LineString'.type
            res = json_is_string(pval) && strcmp(json_string_value(pval), "LineString") == 0;
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "unexpected LineString [.'$LineString'.type]", (path ? &lpath_2 : NULL));
            }
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "invalid mandatory prop value [.'$LineString'.type]", (path ? &lpath_2 : NULL));
                return false;
            }
        }
        else if (strcmp(prop, "coordinates") == 0)
        {
            // handle must coordinates property
            must_count += 1;
            // .'$LineString'.coordinates
            res = json_model_3(pval, (path ? &lpath_2 : NULL), rep);
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "unexpected $coord_array [.'$LineString'.coordinates]", (path ? &lpath_2 : NULL));
            }
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "invalid mandatory prop value [.'$LineString'.coordinates]", (path ? &lpath_2 : NULL));
                return false;
            }
        }
        else if (strcmp(prop, "bbox") == 0)
        {
            // handle may bbox property
            // .'$LineString'.bbox
            res = json_is_array(pval);
            if (res)
            {
                size_t arr_6_idx;
                json_t *arr_6_item;
                json_array_foreach(pval, arr_6_idx, arr_6_item)
                {
                    jm_path_t arr_6_lpath = (jm_path_t) { NULL, arr_6_idx, (path ? &lpath_2 : NULL), NULL };
                    // .'$LineString'.bbox.0
                    res = json_is_number(arr_6_item);
                    if (! res)
                    {
                        if (rep) jm_report_add_entry(rep, "not a -1.0 loose float [.'$LineString'.bbox.0]", ((path ? &lpath_2 : NULL) ? &arr_6_lpath : NULL));
                    }
                    if (! res)
                    {
                        break;
                    }
                }
            }
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "not array or unexpected array [.'$LineString'.bbox]", (path ? &lpath_2 : NULL));
            }
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "invalid optional prop value [.'$LineString'.bbox]", (path ? &lpath_2 : NULL));
                return false;
            }
        }
        else
        {
            if (rep) jm_report_add_entry(rep, "unexpected prop [.'$LineString']", (path ? &lpath_2 : NULL));
            return false;
        }
    }
    if (must_count != 2)
    {
        if (rep != NULL)
        {
            if (! (json_object_get(val, "coordinates") != NULL))
            {
                if (rep) jm_report_add_entry(rep, "missing mandatory prop <coordinates> [.'$LineString']", path);
            }
            if (! (json_object_get(val, "type") != NULL))
            {
                if (rep) jm_report_add_entry(rep, "missing mandatory prop <type> [.'$LineString']", path);
            }
        }
        return false;
    }
    return true;
}

// check $LineString (.'$LineString')
static bool json_model_7(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .'$LineString'
    res = _jm_obj_2(val, path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "not an expected object [.'$LineString']", path);
    }
    return res;
}

// object .'$MultiLineString'
static bool _jm_obj_3(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    if (! json_is_object(val))
    {
        if (rep) jm_report_add_entry(rep, "not an object [.'$MultiLineString']", path);
        return false;
    }
    bool res;
    int64_t must_count = 0;
    const char *prop;
    json_t *pval;
    json_object_foreach((json_t *) val, prop, pval)
    {
        jm_path_t lpath_3 = (jm_path_t) { prop, 0, path, NULL };
        if (strcmp(prop, "type") == 0)
        {
            // handle must type property
            must_count += 1;
            // .'$MultiLineString'.type
            res = json_is_string(pval) && strcmp(json_string_value(pval), "MultiLineString") == 0;
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "unexpected MultiLineString [.'$MultiLineString'.type]", (path ? &lpath_3 : NULL));
            }
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "invalid mandatory prop value [.'$MultiLineString'.type]", (path ? &lpath_3 : NULL));
                return false;
            }
        }
        else if (strcmp(prop, "coordinates") == 0)
        {
            // handle must coordinates property
            must_count += 1;
            // .'$MultiLineString'.coordinates
            res = json_is_array(pval);
            if (res)
            {
                size_t arr_7_idx;
                json_t *arr_7_item;
                json_array_foreach(pval, arr_7_idx, arr_7_item)
                {
                    jm_path_t arr_7_lpath = (jm_path_t) { NULL, arr_7_idx, (path ? &lpath_3 : NULL), NULL };
                    // .'$MultiLineString'.coordinates.0
                    res = json_model_3(arr_7_item, ((path ? &lpath_3 : NULL) ? &arr_7_lpath : NULL), rep);
                    if (! res)
                    {
                        if (rep) jm_report_add_entry(rep, "unexpected $coord_array [.'$MultiLineString'.coordinates.0]", ((path ? &lpath_3 : NULL) ? &arr_7_lpath : NULL));
                    }
                    if (! res)
                    {
                        break;
                    }
                }
            }
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "not array or unexpected array [.'$MultiLineString'.coordinates]", (path ? &lpath_3 : NULL));
            }
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "invalid mandatory prop value [.'$MultiLineString'.coordinates]", (path ? &lpath_3 : NULL));
                return false;
            }
        }
        else if (strcmp(prop, "bbox") == 0)
        {
            // handle may bbox property
            // .'$MultiLineString'.bbox
            res = json_is_array(pval);
            if (res)
            {
                size_t arr_8_idx;
                json_t *arr_8_item;
                json_array_foreach(pval, arr_8_idx, arr_8_item)
                {
                    jm_path_t arr_8_lpath = (jm_path_t) { NULL, arr_8_idx, (path ? &lpath_3 : NULL), NULL };
                    // .'$MultiLineString'.bbox.0
                    res = json_is_number(arr_8_item);
                    if (! res)
                    {
                        if (rep) jm_report_add_entry(rep, "not a -1.0 loose float [.'$MultiLineString'.bbox.0]", ((path ? &lpath_3 : NULL) ? &arr_8_lpath : NULL));
                    }
                    if (! res)
                    {
                        break;
                    }
                }
            }
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "not array or unexpected array [.'$MultiLineString'.bbox]", (path ? &lpath_3 : NULL));
            }
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "invalid optional prop value [.'$MultiLineString'.bbox]", (path ? &lpath_3 : NULL));
                return false;
            }
        }
        else
        {
            if (rep) jm_report_add_entry(rep, "unexpected prop [.'$MultiLineString']", (path ? &lpath_3 : NULL));
            return false;
        }
    }
    if (must_count != 2)
    {
        if (rep != NULL)
        {
            if (! (json_object_get(val, "coordinates") != NULL))
            {
                if (rep) jm_report_add_entry(rep, "missing mandatory prop <coordinates> [.'$MultiLineString']", path);
            }
            if (! (json_object_get(val, "type") != NULL))
            {
                if (rep) jm_report_add_entry(rep, "missing mandatory prop <type> [.'$MultiLineString']", path);
            }
        }
        return false;
    }
    return true;
}

// check $MultiLineString (.'$MultiLineString')
static bool json_model_8(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .'$MultiLineString'
    res = _jm_obj_3(val, path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "not an expected object [.'$MultiLineString']", path);
    }
    return res;
}

// object .'$Polygon'
static bool _jm_obj_4(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    if (! json_is_object(val))
    {
        if (rep) jm_report_add_entry(rep, "not an object [.'$Polygon']", path);
        return false;
    }
    bool res;
    int64_t must_count = 0;
    const char *prop;
    json_t *pval;
    json_object_foreach((json_t *) val, prop, pval)
    {
        jm_path_t lpath_4 = (jm_path_t) { prop, 0, path, NULL };
        if (strcmp(prop, "type") == 0)
        {
            // handle must type property
            must_count += 1;
            // .'$Polygon'.type
            res = json_is_string(pval) && strcmp(json_string_value(pval), "Polygon") == 0;
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "unexpected Polygon [.'$Polygon'.type]", (path ? &lpath_4 : NULL));
            }
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "invalid mandatory prop value [.'$Polygon'.type]", (path ? &lpath_4 : NULL));
                return false;
            }
        }
        else if (strcmp(prop, "coordinates") == 0)
        {
            // handle must coordinates property
            must_count += 1;
            // .'$Polygon'.coordinates
            res = json_is_array(pval);
            if (res)
            {
                size_t arr_9_idx;
                json_t *arr_9_item;
                json_array_foreach(pval, arr_9_idx, arr_9_item)
                {
                    jm_path_t arr_9_lpath = (jm_path_t) { NULL, arr_9_idx, (path ? &lpath_4 : NULL), NULL };
                    // .'$Polygon'.coordinates.0
                    res = json_model_4(arr_9_item, ((path ? &lpath_4 : NULL) ? &arr_9_lpath : NULL), rep);
                    if (! res)
                    {
                        if (rep) jm_report_add_entry(rep, "unexpected $linear_ring [.'$Polygon'.coordinates.0]", ((path ? &lpath_4 : NULL) ? &arr_9_lpath : NULL));
                    }
                    if (! res)
                    {
                        break;
                    }
                }
            }
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "not array or unexpected array [.'$Polygon'.coordinates]", (path ? &lpath_4 : NULL));
            }
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "invalid mandatory prop value [.'$Polygon'.coordinates]", (path ? &lpath_4 : NULL));
                return false;
            }
        }
        else if (strcmp(prop, "bbox") == 0)
        {
            // handle may bbox property
            // .'$Polygon'.bbox
            res = json_is_array(pval);
            if (res)
            {
                size_t arr_10_idx;
                json_t *arr_10_item;
                json_array_foreach(pval, arr_10_idx, arr_10_item)
                {
                    jm_path_t arr_10_lpath = (jm_path_t) { NULL, arr_10_idx, (path ? &lpath_4 : NULL), NULL };
                    // .'$Polygon'.bbox.0
                    res = json_is_number(arr_10_item);
                    if (! res)
                    {
                        if (rep) jm_report_add_entry(rep, "not a -1.0 loose float [.'$Polygon'.bbox.0]", ((path ? &lpath_4 : NULL) ? &arr_10_lpath : NULL));
                    }
                    if (! res)
                    {
                        break;
                    }
                }
            }
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "not array or unexpected array [.'$Polygon'.bbox]", (path ? &lpath_4 : NULL));
            }
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "invalid optional prop value [.'$Polygon'.bbox]", (path ? &lpath_4 : NULL));
                return false;
            }
        }
        else
        {
            if (rep) jm_report_add_entry(rep, "unexpected prop [.'$Polygon']", (path ? &lpath_4 : NULL));
            return false;
        }
    }
    if (must_count != 2)
    {
        if (rep != NULL)
        {
            if (! (json_object_get(val, "coordinates") != NULL))
            {
                if (rep) jm_report_add_entry(rep, "missing mandatory prop <coordinates> [.'$Polygon']", path);
            }
            if (! (json_object_get(val, "type") != NULL))
            {
                if (rep) jm_report_add_entry(rep, "missing mandatory prop <type> [.'$Polygon']", path);
            }
        }
        return false;
    }
    return true;
}

// check $Polygon (.'$Polygon')
static bool json_model_9(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .'$Polygon'
    res = _jm_obj_4(val, path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "not an expected object [.'$Polygon']", path);
    }
    return res;
}

// object .'$MultiPolygon'
static bool _jm_obj_5(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    if (! json_is_object(val))
    {
        if (rep) jm_report_add_entry(rep, "not an object [.'$MultiPolygon']", path);
        return false;
    }
    bool res;
    int64_t must_count = 0;
    const char *prop;
    json_t *pval;
    json_object_foreach((json_t *) val, prop, pval)
    {
        jm_path_t lpath_5 = (jm_path_t) { prop, 0, path, NULL };
        if (strcmp(prop, "type") == 0)
        {
            // handle must type property
            must_count += 1;
            // .'$MultiPolygon'.type
            res = json_is_string(pval) && strcmp(json_string_value(pval), "MultiPolygon") == 0;
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "unexpected MultiPolygon [.'$MultiPolygon'.type]", (path ? &lpath_5 : NULL));
            }
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "invalid mandatory prop value [.'$MultiPolygon'.type]", (path ? &lpath_5 : NULL));
                return false;
            }
        }
        else if (strcmp(prop, "coordinates") == 0)
        {
            // handle must coordinates property
            must_count += 1;
            // .'$MultiPolygon'.coordinates
            res = json_is_array(pval);
            if (res)
            {
                size_t arr_11_idx;
                json_t *arr_11_item;
                json_array_foreach(pval, arr_11_idx, arr_11_item)
                {
                    jm_path_t arr_11_lpath = (jm_path_t) { NULL, arr_11_idx, (path ? &lpath_5 : NULL), NULL };
                    // .'$MultiPolygon'.coordinates.0
                    res = json_is_array(arr_11_item);
                    if (res)
                    {
                        size_t arr_12_idx;
                        json_t *arr_12_item;
                        json_array_foreach(arr_11_item, arr_12_idx, arr_12_item)
                        {
                            jm_path_t arr_12_lpath = (jm_path_t) { NULL, arr_12_idx, ((path ? &lpath_5 : NULL) ? &arr_11_lpath : NULL), NULL };
                            // .'$MultiPolygon'.coordinates.0.0
                            res = json_model_4(arr_12_item, (((path ? &lpath_5 : NULL) ? &arr_11_lpath : NULL) ? &arr_12_lpath : NULL), rep);
                            if (! res)
                            {
                                if (rep) jm_report_add_entry(rep, "unexpected $linear_ring [.'$MultiPolygon'.coordinates.0.0]", (((path ? &lpath_5 : NULL) ? &arr_11_lpath : NULL) ? &arr_12_lpath : NULL));
                            }
                            if (! res)
                            {
                                break;
                            }
                        }
                    }
                    if (! res)
                    {
                        if (rep) jm_report_add_entry(rep, "not array or unexpected array [.'$MultiPolygon'.coordinates.0]", ((path ? &lpath_5 : NULL) ? &arr_11_lpath : NULL));
                    }
                    if (! res)
                    {
                        break;
                    }
                }
            }
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "not array or unexpected array [.'$MultiPolygon'.coordinates]", (path ? &lpath_5 : NULL));
            }
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "invalid mandatory prop value [.'$MultiPolygon'.coordinates]", (path ? &lpath_5 : NULL));
                return false;
            }
        }
        else if (strcmp(prop, "bbox") == 0)
        {
            // handle may bbox property
            // .'$MultiPolygon'.bbox
            res = json_is_array(pval);
            if (res)
            {
                size_t arr_13_idx;
                json_t *arr_13_item;
                json_array_foreach(pval, arr_13_idx, arr_13_item)
                {
                    jm_path_t arr_13_lpath = (jm_path_t) { NULL, arr_13_idx, (path ? &lpath_5 : NULL), NULL };
                    // .'$MultiPolygon'.bbox.0
                    res = json_is_number(arr_13_item);
                    if (! res)
                    {
                        if (rep) jm_report_add_entry(rep, "not a -1.0 loose float [.'$MultiPolygon'.bbox.0]", ((path ? &lpath_5 : NULL) ? &arr_13_lpath : NULL));
                    }
                    if (! res)
                    {
                        break;
                    }
                }
            }
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "not array or unexpected array [.'$MultiPolygon'.bbox]", (path ? &lpath_5 : NULL));
            }
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "invalid optional prop value [.'$MultiPolygon'.bbox]", (path ? &lpath_5 : NULL));
                return false;
            }
        }
        else
        {
            if (rep) jm_report_add_entry(rep, "unexpected prop [.'$MultiPolygon']", (path ? &lpath_5 : NULL));
            return false;
        }
    }
    if (must_count != 2)
    {
        if (rep != NULL)
        {
            if (! (json_object_get(val, "coordinates") != NULL))
            {
                if (rep) jm_report_add_entry(rep, "missing mandatory prop <coordinates> [.'$MultiPolygon']", path);
            }
            if (! (json_object_get(val, "type") != NULL))
            {
                if (rep) jm_report_add_entry(rep, "missing mandatory prop <type> [.'$MultiPolygon']", path);
            }
        }
        return false;
    }
    return true;
}

// check $MultiPolygon (.'$MultiPolygon')
static bool json_model_10(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .'$MultiPolygon'
    res = _jm_obj_5(val, path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "not an expected object [.'$MultiPolygon']", path);
    }
    return res;
}

static jm_check_fun_t _jm_map_0(json_t *val)
{
    jm_constant_t cst;
    jm_set_cst(&cst, val);
    return jm_search_constmap(&cst, _jm_map_0_tab, 6);
}

// check $geometry (.'$geometry')
static bool json_model_11(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .'$geometry'
    res = json_is_object(val);
    if (res)
    {
        json_t * tag_0 = json_object_get(val, "type");
        if (tag_0 != NULL)
        {
            jm_check_fun_t fun_0 = _jm_map_0(tag_0);
            if (fun_0 != NULL)
            {
                res = fun_0(val, path, rep);
            }
            else
            {
                res = false;
                if (rep) jm_report_add_entry(rep, "tag <type> value not found [.'$geometry'.'|']", path);
            }
        }
        else
        {
            res = false;
            if (rep) jm_report_add_entry(rep, "tag prop <type> is missing [.'$geometry'.'|']", path);
        }
    }
    else
    {
        if (rep) jm_report_add_entry(rep, "value is not an object [.'$geometry'.'|']", path);
    }
    return res;
}

// object .'$GeometryCollection'
static bool _jm_obj_6(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    if (! json_is_object(val))
    {
        if (rep) jm_report_add_entry(rep, "not an object [.'$GeometryCollection']", path);
        return false;
    }
    bool res;
    int64_t must_count = 0;
    const char *prop;
    json_t *pval;
    json_object_foreach((json_t *) val, prop, pval)
    {
        jm_path_t lpath_6 = (jm_path_t) { prop, 0, path, NULL };
        if (strcmp(prop, "type") == 0)
        {
            // handle must type property
            must_count += 1;
            // .'$GeometryCollection'.type
            res = json_is_string(pval) && strcmp(json_string_value(pval), "GeometryCollection") == 0;
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "unexpected GeometryCollection [.'$GeometryCollection'.type]", (path ? &lpath_6 : NULL));
            }
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "invalid mandatory prop value [.'$GeometryCollection'.type]", (path ? &lpath_6 : NULL));
                return false;
            }
        }
        else if (strcmp(prop, "geometries") == 0)
        {
            // handle must geometries property
            must_count += 1;
            // .'$GeometryCollection'.geometries
            res = json_is_array(pval);
            if (res)
            {
                size_t arr_14_idx;
                json_t *arr_14_item;
                json_array_foreach(pval, arr_14_idx, arr_14_item)
                {
                    jm_path_t arr_14_lpath = (jm_path_t) { NULL, arr_14_idx, (path ? &lpath_6 : NULL), NULL };
                    // .'$GeometryCollection'.geometries.0
                    res = json_model_11(arr_14_item, ((path ? &lpath_6 : NULL) ? &arr_14_lpath : NULL), rep);
                    if (! res)
                    {
                        if (rep) jm_report_add_entry(rep, "unexpected $geometry [.'$GeometryCollection'.geometries.0]", ((path ? &lpath_6 : NULL) ? &arr_14_lpath : NULL));
                    }
                    if (! res)
                    {
                        break;
                    }
                }
            }
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "not array or unexpected array [.'$GeometryCollection'.geometries]", (path ? &lpath_6 : NULL));
            }
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "invalid mandatory prop value [.'$GeometryCollection'.geometries]", (path ? &lpath_6 : NULL));
                return false;
            }
        }
        else if (strcmp(prop, "bbox") == 0)
        {
            // handle may bbox property
            // .'$GeometryCollection'.bbox
            res = json_is_array(pval);
            if (res)
            {
                size_t arr_15_idx;
                json_t *arr_15_item;
                json_array_foreach(pval, arr_15_idx, arr_15_item)
                {
                    jm_path_t arr_15_lpath = (jm_path_t) { NULL, arr_15_idx, (path ? &lpath_6 : NULL), NULL };
                    // .'$GeometryCollection'.bbox.0
                    res = json_is_number(arr_15_item);
                    if (! res)
                    {
                        if (rep) jm_report_add_entry(rep, "not a -1.0 loose float [.'$GeometryCollection'.bbox.0]", ((path ? &lpath_6 : NULL) ? &arr_15_lpath : NULL));
                    }
                    if (! res)
                    {
                        break;
                    }
                }
            }
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "not array or unexpected array [.'$GeometryCollection'.bbox]", (path ? &lpath_6 : NULL));
            }
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "invalid optional prop value [.'$GeometryCollection'.bbox]", (path ? &lpath_6 : NULL));
                return false;
            }
        }
        else
        {
            if (rep) jm_report_add_entry(rep, "unexpected prop [.'$GeometryCollection']", (path ? &lpath_6 : NULL));
            return false;
        }
    }
    if (must_count != 2)
    {
        if (rep != NULL)
        {
            if (! (json_object_get(val, "geometries") != NULL))
            {
                if (rep) jm_report_add_entry(rep, "missing mandatory prop <geometries> [.'$GeometryCollection']", path);
            }
            if (! (json_object_get(val, "type") != NULL))
            {
                if (rep) jm_report_add_entry(rep, "missing mandatory prop <type> [.'$GeometryCollection']", path);
            }
        }
        return false;
    }
    return true;
}

// check $GeometryCollection (.'$GeometryCollection')
static bool json_model_12(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .'$GeometryCollection'
    res = _jm_obj_6(val, path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "not an expected object [.'$GeometryCollection']", path);
    }
    return res;
}

// object .'$Feature'.properties.'|'.1
static bool _jm_obj_8(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    if (! json_is_object(val))
    {
        if (rep) jm_report_add_entry(rep, "not an object [.'$Feature'.properties.'|'.1]", path);
        return false;
    }
    // accept any object
    return true;
}

// object .'$Feature'
static bool _jm_obj_7(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    if (! json_is_object(val))
    {
        if (rep) jm_report_add_entry(rep, "not an object [.'$Feature']", path);
        return false;
    }
    bool res;
    int64_t must_count = 0;
    const char *prop;
    json_t *pval;
    json_object_foreach((json_t *) val, prop, pval)
    {
        jm_path_t lpath_7 = (jm_path_t) { prop, 0, path, NULL };
        if (strcmp(prop, "type") == 0)
        {
            // handle must type property
            must_count += 1;
            // .'$Feature'.type
            res = json_is_string(pval) && strcmp(json_string_value(pval), "Feature") == 0;
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "unexpected Feature [.'$Feature'.type]", (path ? &lpath_7 : NULL));
            }
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "invalid mandatory prop value [.'$Feature'.type]", (path ? &lpath_7 : NULL));
                return false;
            }
        }
        else if (strcmp(prop, "geometry") == 0)
        {
            // handle must geometry property
            must_count += 1;
            // .'$Feature'.geometry
            // .'$Feature'.geometry.'|'.0
            res = json_is_null(pval);
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "not null [.'$Feature'.geometry.'|'.0]", (path ? &lpath_7 : NULL));
            }
            if (! res)
            {
                // .'$Feature'.geometry.'|'.1
                res = json_model_11(pval, (path ? &lpath_7 : NULL), rep);
                if (! res)
                {
                    if (rep) jm_report_add_entry(rep, "unexpected $geometry [.'$Feature'.geometry.'|'.1]", (path ? &lpath_7 : NULL));
                }
                if (! res)
                {
                    // .'$Feature'.geometry.'|'.2
                    res = json_model_12(pval, (path ? &lpath_7 : NULL), rep);
                    if (! res)
                    {
                        if (rep) jm_report_add_entry(rep, "unexpected $GeometryCollection [.'$Feature'.geometry.'|'.2]", (path ? &lpath_7 : NULL));
                    }
                }
            }
            if (res)
            {
                if (rep) jm_report_free_entries(rep);
            }
            else
            {
                if (rep) jm_report_add_entry(rep, "no model matched [.'$Feature'.geometry.'|']", (path ? &lpath_7 : NULL));
            }
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "invalid mandatory prop value [.'$Feature'.geometry]", (path ? &lpath_7 : NULL));
                return false;
            }
        }
        else if (strcmp(prop, "properties") == 0)
        {
            // handle must properties property
            must_count += 1;
            // .'$Feature'.properties
            // .'$Feature'.properties.'|'.0
            res = json_is_null(pval);
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "not null [.'$Feature'.properties.'|'.0]", (path ? &lpath_7 : NULL));
            }
            if (! res)
            {
                // .'$Feature'.properties.'|'.1
                res = _jm_obj_8(pval, (path ? &lpath_7 : NULL), rep);
                if (! res)
                {
                    if (rep) jm_report_add_entry(rep, "not an expected object [.'$Feature'.properties.'|'.1]", (path ? &lpath_7 : NULL));
                }
            }
            if (res)
            {
                if (rep) jm_report_free_entries(rep);
            }
            else
            {
                if (rep) jm_report_add_entry(rep, "no model matched [.'$Feature'.properties.'|']", (path ? &lpath_7 : NULL));
            }
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "invalid mandatory prop value [.'$Feature'.properties]", (path ? &lpath_7 : NULL));
                return false;
            }
        }
        else if (strcmp(prop, "id") == 0)
        {
            // handle may id property
            // .'$Feature'.id
            // .'$Feature'.id.'|'.0
            res = json_is_string(pval);
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "unexpected string [.'$Feature'.id.'|'.0]", (path ? &lpath_7 : NULL));
            }
            if (! res)
            {
                // .'$Feature'.id.'|'.1
                res = json_is_number(pval);
                if (! res)
                {
                    if (rep) jm_report_add_entry(rep, "not a -1.0 loose float [.'$Feature'.id.'|'.1]", (path ? &lpath_7 : NULL));
                }
            }
            if (res)
            {
                if (rep) jm_report_free_entries(rep);
            }
            else
            {
                if (rep) jm_report_add_entry(rep, "no model matched [.'$Feature'.id.'|']", (path ? &lpath_7 : NULL));
            }
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "invalid optional prop value [.'$Feature'.id]", (path ? &lpath_7 : NULL));
                return false;
            }
        }
        else if (strcmp(prop, "bbox") == 0)
        {
            // handle may bbox property
            // .'$Feature'.bbox
            res = json_is_array(pval);
            if (res)
            {
                size_t arr_16_idx;
                json_t *arr_16_item;
                json_array_foreach(pval, arr_16_idx, arr_16_item)
                {
                    jm_path_t arr_16_lpath = (jm_path_t) { NULL, arr_16_idx, (path ? &lpath_7 : NULL), NULL };
                    // .'$Feature'.bbox.0
                    res = json_is_number(arr_16_item);
                    if (! res)
                    {
                        if (rep) jm_report_add_entry(rep, "not a -1.0 loose float [.'$Feature'.bbox.0]", ((path ? &lpath_7 : NULL) ? &arr_16_lpath : NULL));
                    }
                    if (! res)
                    {
                        break;
                    }
                }
            }
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "not array or unexpected array [.'$Feature'.bbox]", (path ? &lpath_7 : NULL));
            }
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "invalid optional prop value [.'$Feature'.bbox]", (path ? &lpath_7 : NULL));
                return false;
            }
        }
        else
        {
            if (rep) jm_report_add_entry(rep, "unexpected prop [.'$Feature']", (path ? &lpath_7 : NULL));
            return false;
        }
    }
    if (must_count != 3)
    {
        if (rep != NULL)
        {
            if (! (json_object_get(val, "geometry") != NULL))
            {
                if (rep) jm_report_add_entry(rep, "missing mandatory prop <geometry> [.'$Feature']", path);
            }
            if (! (json_object_get(val, "properties") != NULL))
            {
                if (rep) jm_report_add_entry(rep, "missing mandatory prop <properties> [.'$Feature']", path);
            }
            if (! (json_object_get(val, "type") != NULL))
            {
                if (rep) jm_report_add_entry(rep, "missing mandatory prop <type> [.'$Feature']", path);
            }
        }
        return false;
    }
    return true;
}

// check $Feature (.'$Feature')
static bool json_model_13(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .'$Feature'
    res = _jm_obj_7(val, path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "not an expected object [.'$Feature']", path);
    }
    return res;
}

// object .'$FeatureCollection'
static bool _jm_obj_9(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    if (! json_is_object(val))
    {
        if (rep) jm_report_add_entry(rep, "not an object [.'$FeatureCollection']", path);
        return false;
    }
    bool res;
    int64_t must_count = 0;
    const char *prop;
    json_t *pval;
    json_object_foreach((json_t *) val, prop, pval)
    {
        jm_path_t lpath_8 = (jm_path_t) { prop, 0, path, NULL };
        if (strcmp(prop, "type") == 0)
        {
            // handle must type property
            must_count += 1;
            // .'$FeatureCollection'.type
            res = json_is_string(pval) && strcmp(json_string_value(pval), "FeatureCollection") == 0;
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "unexpected FeatureCollection [.'$FeatureCollection'.type]", (path ? &lpath_8 : NULL));
            }
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "invalid mandatory prop value [.'$FeatureCollection'.type]", (path ? &lpath_8 : NULL));
                return false;
            }
        }
        else if (strcmp(prop, "features") == 0)
        {
            // handle must features property
            must_count += 1;
            // .'$FeatureCollection'.features
            res = json_is_array(pval);
            if (res)
            {
                size_t arr_17_idx;
                json_t *arr_17_item;
                json_array_foreach(pval, arr_17_idx, arr_17_item)
                {
                    jm_path_t arr_17_lpath = (jm_path_t) { NULL, arr_17_idx, (path ? &lpath_8 : NULL), NULL };
                    // .'$FeatureCollection'.features.0
                    res = json_model_13(arr_17_item, ((path ? &lpath_8 : NULL) ? &arr_17_lpath : NULL), rep);
                    if (! res)
                    {
                        if (rep) jm_report_add_entry(rep, "unexpected $Feature [.'$FeatureCollection'.features.0]", ((path ? &lpath_8 : NULL) ? &arr_17_lpath : NULL));
                    }
                    if (! res)
                    {
                        break;
                    }
                }
            }
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "not array or unexpected array [.'$FeatureCollection'.features]", (path ? &lpath_8 : NULL));
            }
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "invalid mandatory prop value [.'$FeatureCollection'.features]", (path ? &lpath_8 : NULL));
                return false;
            }
        }
        else if (strcmp(prop, "bbox") == 0)
        {
            // handle may bbox property
            // .'$FeatureCollection'.bbox
            res = json_is_array(pval);
            if (res)
            {
                size_t arr_18_idx;
                json_t *arr_18_item;
                json_array_foreach(pval, arr_18_idx, arr_18_item)
                {
                    jm_path_t arr_18_lpath = (jm_path_t) { NULL, arr_18_idx, (path ? &lpath_8 : NULL), NULL };
                    // .'$FeatureCollection'.bbox.0
                    res = json_is_number(arr_18_item);
                    if (! res)
                    {
                        if (rep) jm_report_add_entry(rep, "not a -1.0 loose float [.'$FeatureCollection'.bbox.0]", ((path ? &lpath_8 : NULL) ? &arr_18_lpath : NULL));
                    }
                    if (! res)
                    {
                        break;
                    }
                }
            }
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "not array or unexpected array [.'$FeatureCollection'.bbox]", (path ? &lpath_8 : NULL));
            }
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "invalid optional prop value [.'$FeatureCollection'.bbox]", (path ? &lpath_8 : NULL));
                return false;
            }
        }
        else
        {
            if (rep) jm_report_add_entry(rep, "unexpected prop [.'$FeatureCollection']", (path ? &lpath_8 : NULL));
            return false;
        }
    }
    if (must_count != 2)
    {
        if (rep != NULL)
        {
            if (! (json_object_get(val, "features") != NULL))
            {
                if (rep) jm_report_add_entry(rep, "missing mandatory prop <features> [.'$FeatureCollection']", path);
            }
            if (! (json_object_get(val, "type") != NULL))
            {
                if (rep) jm_report_add_entry(rep, "missing mandatory prop <type> [.'$FeatureCollection']", path);
            }
        }
        return false;
    }
    return true;
}

// check $FeatureCollection (.'$FeatureCollection')
static bool json_model_14(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .'$FeatureCollection'
    res = _jm_obj_9(val, path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "not an expected object [.'$FeatureCollection']", path);
    }
    return res;
}

// check $ (.)
static bool json_model_1(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .
    // generic xor list
    int64_t xc_0 = 0;
    bool xr_0;
    // .'^'.0
    xr_0 = json_model_11(val, path, rep);
    if (! xr_0)
    {
        if (rep) jm_report_add_entry(rep, "unexpected $geometry [.'^'.0]", path);
    }
    if (xr_0)
    {
        xc_0 += 1;
    }
    // .'^'.1
    xr_0 = json_model_12(val, path, rep);
    if (! xr_0)
    {
        if (rep) jm_report_add_entry(rep, "unexpected $GeometryCollection [.'^'.1]", path);
    }
    if (xr_0)
    {
        xc_0 += 1;
    }
    if (xc_0 <= 1)
    {
        // .'^'.2
        xr_0 = json_model_13(val, path, rep);
        if (! xr_0)
        {
            if (rep) jm_report_add_entry(rep, "unexpected $Feature [.'^'.2]", path);
        }
        if (xr_0)
        {
            xc_0 += 1;
        }
    }
    if (xc_0 <= 1)
    {
        // .'^'.3
        xr_0 = json_model_14(val, path, rep);
        if (! xr_0)
        {
            if (rep) jm_report_add_entry(rep, "unexpected $FeatureCollection [.'^'.3]", path);
        }
        if (xr_0)
        {
            xc_0 += 1;
        }
    }
    res = xc_0 == 1;
    if (res)
    {
        if (rep) jm_report_free_entries(rep);
    }
    else
    {
        if (rep) jm_report_add_entry(rep, "not one model match [.'^']", path);
    }
    return res;
}

jm_check_fun_t check_model_map(const char *pname)
{
    return jm_search_propmap(pname, check_model_map_tab, 14);
}

static bool initialized = false;

char *CHECK_init(void)
{
    if (!initialized)
    {
        initialized = true;
        jm_version_string = JSON_MODEL_VERSION;
        _jm_map_0_tab[0] = (jm_constmap_t) { (jm_constant_t) { cst_is_string, { .s = "Point" } }, json_model_5 };
        _jm_map_0_tab[1] = (jm_constmap_t) { (jm_constant_t) { cst_is_string, { .s = "MultiPoint" } }, json_model_6 };
        _jm_map_0_tab[2] = (jm_constmap_t) { (jm_constant_t) { cst_is_string, { .s = "LineString" } }, json_model_7 };
        _jm_map_0_tab[3] = (jm_constmap_t) { (jm_constant_t) { cst_is_string, { .s = "MultiLineString" } }, json_model_8 };
        _jm_map_0_tab[4] = (jm_constmap_t) { (jm_constant_t) { cst_is_string, { .s = "Polygon" } }, json_model_9 };
        _jm_map_0_tab[5] = (jm_constmap_t) { (jm_constant_t) { cst_is_string, { .s = "MultiPolygon" } }, json_model_10 };
        jm_sort_constmap(_jm_map_0_tab, 6);
        check_model_map_tab[0] = (jm_propmap_t) { "", json_model_1 };
        check_model_map_tab[1] = (jm_propmap_t) { "position", json_model_2 };
        check_model_map_tab[2] = (jm_propmap_t) { "coord_array", json_model_3 };
        check_model_map_tab[3] = (jm_propmap_t) { "linear_ring", json_model_4 };
        check_model_map_tab[4] = (jm_propmap_t) { "Point", json_model_5 };
        check_model_map_tab[5] = (jm_propmap_t) { "MultiPoint", json_model_6 };
        check_model_map_tab[6] = (jm_propmap_t) { "LineString", json_model_7 };
        check_model_map_tab[7] = (jm_propmap_t) { "MultiLineString", json_model_8 };
        check_model_map_tab[8] = (jm_propmap_t) { "Polygon", json_model_9 };
        check_model_map_tab[9] = (jm_propmap_t) { "MultiPolygon", json_model_10 };
        check_model_map_tab[10] = (jm_propmap_t) { "geometry", json_model_11 };
        check_model_map_tab[11] = (jm_propmap_t) { "GeometryCollection", json_model_12 };
        check_model_map_tab[12] = (jm_propmap_t) { "Feature", json_model_13 };
        check_model_map_tab[13] = (jm_propmap_t) { "FeatureCollection", json_model_14 };
        jm_sort_propmap(check_model_map_tab, 14);
    }
    return NULL;
}

void CHECK_free(void)
{
    if (initialized)
    {
        initialized = false;

        // cleanup code
    }
}


/*
 * # API
 *
 * ```c
 * bool error;
 * char *message;
 *
 * bool valid = check(json_value, "model-name", &error, &message);
 *
 * if (message)
 *    free(message), message = NULL;
 * ```
 *
 * - `error` is set of there was an error during initialization or if the model does not exists.
 * - `message` is provided if a non NULL pointer is passed, and must be freed by the caller.
 */
bool
CHECK(const json_t *val, const char *name, bool *error, char **reasons)
{
    return jm_generic_entry(CHECK_init, CHECK_fun, val, name, error, reasons);
}
