//
// Generated by JSON Model Compiler version 2
// see https://github.com/clairey-zx81/json-model
//

// regular expression engine
#include <stddef.h>
#include <cre2.h>

#include <json-model.h>
#define JSON_MODEL_VERSION "2"

static bool json_model_2(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool json_model_3(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool json_model_4(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool json_model_5(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool json_model_6(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool json_model_7(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool json_model_8(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool json_model_9(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool json_model_10(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_obj_0(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_obj_1(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_obj_2(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_obj_3(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_obj_4(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_obj_5(const json_t *val, jm_path_t *path, jm_report_t *rep);
static jm_constmap_t _jm_map_0_tab[6];
static bool json_model_11(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool json_model_12(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_obj_6(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool json_model_13(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool json_model_14(const json_t *val, jm_path_t *path, jm_report_t *rep);
static jm_constmap_t _jm_map_1_tab[3];
static bool json_model_1(const json_t *val, jm_path_t *path, jm_report_t *rep);
jm_propmap_t check_model_map_tab[14];
const size_t check_model_map_size = 14;

// check $position (.'$position')
static bool json_model_2(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    // .'$position'
    // .'$position'.'@'
    bool res = json_is_array(val);
    if (res)
    {
        size_t arr_0_idx;
        json_t *arr_0_item;
        json_array_foreach(val, arr_0_idx, arr_0_item)
        {
            jm_path_t arr_0_lpath = (jm_path_t) { NULL, arr_0_idx, path, NULL };
            // .'$position'.'@'.0
            res = json_is_number(arr_0_item);
            if (unlikely(! res))
            {
                if (rep) jm_report_add_entry(rep, "not a -1.0 loose float [.'$position'.'@'.0]", (path ? &arr_0_lpath : NULL));
                break;
            }
        }
    }
    if (unlikely(! res))
    {
        if (rep) jm_report_add_entry(rep, "not array or unexpected array [.'$position'.'@']", path);
    }
    if (likely(res))
    {
        int64_t ival_0 = json_array_size(val);
        res = ival_0 <= 3 && ival_0 >= 2;
        if (unlikely(! res))
        {
            if (rep) jm_report_add_entry(rep, "constraints failed [.'$position']", path);
        }
    }
    return res;
}

// check $coord_array (.'$coord_array')
static bool json_model_3(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    // .'$coord_array'
    // .'$coord_array'.'@'
    bool res = json_is_array(val);
    if (res)
    {
        size_t arr_1_idx;
        json_t *arr_1_item;
        json_array_foreach(val, arr_1_idx, arr_1_item)
        {
            jm_path_t arr_1_lpath = (jm_path_t) { NULL, arr_1_idx, path, NULL };
            // .'$coord_array'.'@'.0
            res = json_model_2(arr_1_item, (path ? &arr_1_lpath : NULL), rep);
            if (unlikely(! res))
            {
                if (rep) jm_report_add_entry(rep, "unexpected $position [.'$coord_array'.'@'.0]", (path ? &arr_1_lpath : NULL));
                break;
            }
        }
    }
    if (unlikely(! res))
    {
        if (rep) jm_report_add_entry(rep, "not array or unexpected array [.'$coord_array'.'@']", path);
    }
    if (likely(res))
    {
        int64_t ival_1 = json_array_size(val);
        res = ival_1 >= 2;
        if (unlikely(! res))
        {
            if (rep) jm_report_add_entry(rep, "constraints failed [.'$coord_array']", path);
        }
    }
    return res;
}

// check $linear_ring (.'$linear_ring')
static bool json_model_4(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    // .'$linear_ring'
    // .'$linear_ring'.'@'
    bool res = json_is_array(val);
    if (res)
    {
        size_t arr_2_idx;
        json_t *arr_2_item;
        json_array_foreach(val, arr_2_idx, arr_2_item)
        {
            jm_path_t arr_2_lpath = (jm_path_t) { NULL, arr_2_idx, path, NULL };
            // .'$linear_ring'.'@'.0
            res = json_model_2(arr_2_item, (path ? &arr_2_lpath : NULL), rep);
            if (unlikely(! res))
            {
                if (rep) jm_report_add_entry(rep, "unexpected $position [.'$linear_ring'.'@'.0]", (path ? &arr_2_lpath : NULL));
                break;
            }
        }
    }
    if (unlikely(! res))
    {
        if (rep) jm_report_add_entry(rep, "not array or unexpected array [.'$linear_ring'.'@']", path);
    }
    if (likely(res))
    {
        int64_t ival_2 = json_array_size(val);
        res = ival_2 >= 4;
        if (unlikely(! res))
        {
            if (rep) jm_report_add_entry(rep, "constraints failed [.'$linear_ring']", path);
        }
    }
    return res;
}

// check $Point (.'$Point')
static bool json_model_5(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    // .'$Point'
    if (unlikely(! json_is_object(val)))
    {
        if (rep) jm_report_add_entry(rep, "not an object [.'$Point']", path);
        return false;
    }
    bool res;
    int64_t must_count = 0;
    const char *prop;
    json_t *pval;
    json_object_foreach((json_t *) val, prop, pval)
    {
        jm_path_t lpath_0 = (jm_path_t) { prop, 0, path, NULL };
        if (unlikely(jm_str_eq_5(prop, 0x0000000065707974LL)))
        {
            // handle must type property
            must_count += 1;
            // .'$Point'.type
            res = json_is_string(pval) && jm_str_eq_6(json_string_value(pval), 0x000000746e696f50LL);
            if (unlikely(! res))
            {
                if (rep) jm_report_add_entry(rep, "unexpected Point [.'$Point'.type]", (path ? &lpath_0 : NULL));
                if (rep) jm_report_add_entry(rep, "invalid mandatory prop value [.'$Point'.type]", (path ? &lpath_0 : NULL));
                return false;
            }
        }
        else if (likely(jm_str_eq_8(prop, 0x616e6964726f6f63LL) && jm_str_eq_4(prop + 8, 0x00736574)))
        {
            // handle must coordinates property
            must_count += 1;
            // .'$Point'.coordinates
            res = json_model_2(pval, (path ? &lpath_0 : NULL), rep);
            if (unlikely(! res))
            {
                if (rep) jm_report_add_entry(rep, "unexpected $position [.'$Point'.coordinates]", (path ? &lpath_0 : NULL));
                if (rep) jm_report_add_entry(rep, "invalid mandatory prop value [.'$Point'.coordinates]", (path ? &lpath_0 : NULL));
                return false;
            }
        }
        else if (likely(jm_str_eq_5(prop, 0x00000000786f6262LL)))
        {
            // handle may bbox property
            // .'$Point'.bbox
            res = json_is_array(pval);
            if (res)
            {
                size_t arr_3_idx;
                json_t *arr_3_item;
                json_array_foreach(pval, arr_3_idx, arr_3_item)
                {
                    jm_path_t arr_3_lpath = (jm_path_t) { NULL, arr_3_idx, (path ? &lpath_0 : NULL), NULL };
                    // .'$Point'.bbox.0
                    res = json_is_number(arr_3_item);
                    if (unlikely(! res))
                    {
                        if (rep) jm_report_add_entry(rep, "not a -1.0 loose float [.'$Point'.bbox.0]", ((path ? &lpath_0 : NULL) ? &arr_3_lpath : NULL));
                        break;
                    }
                }
            }
            if (unlikely(! res))
            {
                if (rep) jm_report_add_entry(rep, "not array or unexpected array [.'$Point'.bbox]", (path ? &lpath_0 : NULL));
                if (rep) jm_report_add_entry(rep, "invalid optional prop value [.'$Point'.bbox]", (path ? &lpath_0 : NULL));
                return false;
            }
        }
        else
        {
            if (rep) jm_report_add_entry(rep, "unexpected prop [.'$Point']", (path ? &lpath_0 : NULL));
            return false;
        }
    }
    if (unlikely(must_count != 2))
    {
        if (likely(rep != NULL))
        {
            if (! (json_object_get(val, "coordinates") != NULL))
            {
                if (rep) jm_report_add_entry(rep, "missing mandatory prop <coordinates> [.'$Point']", path);
            }
            if (! (json_object_get(val, "type") != NULL))
            {
                if (rep) jm_report_add_entry(rep, "missing mandatory prop <type> [.'$Point']", path);
            }
        }
        return false;
    }
    return true;
}

// check $MultiPoint (.'$MultiPoint')
static bool json_model_6(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    // .'$MultiPoint'
    if (unlikely(! json_is_object(val)))
    {
        if (rep) jm_report_add_entry(rep, "not an object [.'$MultiPoint']", path);
        return false;
    }
    bool res;
    int64_t must_count = 0;
    const char *prop;
    json_t *pval;
    json_object_foreach((json_t *) val, prop, pval)
    {
        jm_path_t lpath_1 = (jm_path_t) { prop, 0, path, NULL };
        if (unlikely(jm_str_eq_5(prop, 0x0000000065707974LL)))
        {
            // handle must type property
            must_count += 1;
            // .'$MultiPoint'.type
            res = json_is_string(pval) && jm_str_eq(json_string_value(pval), "MultiPoint");
            if (unlikely(! res))
            {
                if (rep) jm_report_add_entry(rep, "unexpected MultiPoint [.'$MultiPoint'.type]", (path ? &lpath_1 : NULL));
                if (rep) jm_report_add_entry(rep, "invalid mandatory prop value [.'$MultiPoint'.type]", (path ? &lpath_1 : NULL));
                return false;
            }
        }
        else if (likely(jm_str_eq_8(prop, 0x616e6964726f6f63LL) && jm_str_eq_4(prop + 8, 0x00736574)))
        {
            // handle must coordinates property
            must_count += 1;
            // .'$MultiPoint'.coordinates
            res = json_is_array(pval);
            if (res)
            {
                size_t arr_4_idx;
                json_t *arr_4_item;
                json_array_foreach(pval, arr_4_idx, arr_4_item)
                {
                    jm_path_t arr_4_lpath = (jm_path_t) { NULL, arr_4_idx, (path ? &lpath_1 : NULL), NULL };
                    // .'$MultiPoint'.coordinates.0
                    res = json_model_2(arr_4_item, ((path ? &lpath_1 : NULL) ? &arr_4_lpath : NULL), rep);
                    if (unlikely(! res))
                    {
                        if (rep) jm_report_add_entry(rep, "unexpected $position [.'$MultiPoint'.coordinates.0]", ((path ? &lpath_1 : NULL) ? &arr_4_lpath : NULL));
                        break;
                    }
                }
            }
            if (unlikely(! res))
            {
                if (rep) jm_report_add_entry(rep, "not array or unexpected array [.'$MultiPoint'.coordinates]", (path ? &lpath_1 : NULL));
                if (rep) jm_report_add_entry(rep, "invalid mandatory prop value [.'$MultiPoint'.coordinates]", (path ? &lpath_1 : NULL));
                return false;
            }
        }
        else if (likely(jm_str_eq_5(prop, 0x00000000786f6262LL)))
        {
            // handle may bbox property
            // .'$MultiPoint'.bbox
            res = json_is_array(pval);
            if (res)
            {
                size_t arr_5_idx;
                json_t *arr_5_item;
                json_array_foreach(pval, arr_5_idx, arr_5_item)
                {
                    jm_path_t arr_5_lpath = (jm_path_t) { NULL, arr_5_idx, (path ? &lpath_1 : NULL), NULL };
                    // .'$MultiPoint'.bbox.0
                    res = json_is_number(arr_5_item);
                    if (unlikely(! res))
                    {
                        if (rep) jm_report_add_entry(rep, "not a -1.0 loose float [.'$MultiPoint'.bbox.0]", ((path ? &lpath_1 : NULL) ? &arr_5_lpath : NULL));
                        break;
                    }
                }
            }
            if (unlikely(! res))
            {
                if (rep) jm_report_add_entry(rep, "not array or unexpected array [.'$MultiPoint'.bbox]", (path ? &lpath_1 : NULL));
                if (rep) jm_report_add_entry(rep, "invalid optional prop value [.'$MultiPoint'.bbox]", (path ? &lpath_1 : NULL));
                return false;
            }
        }
        else
        {
            if (rep) jm_report_add_entry(rep, "unexpected prop [.'$MultiPoint']", (path ? &lpath_1 : NULL));
            return false;
        }
    }
    if (unlikely(must_count != 2))
    {
        if (likely(rep != NULL))
        {
            if (! (json_object_get(val, "coordinates") != NULL))
            {
                if (rep) jm_report_add_entry(rep, "missing mandatory prop <coordinates> [.'$MultiPoint']", path);
            }
            if (! (json_object_get(val, "type") != NULL))
            {
                if (rep) jm_report_add_entry(rep, "missing mandatory prop <type> [.'$MultiPoint']", path);
            }
        }
        return false;
    }
    return true;
}

// check $LineString (.'$LineString')
static bool json_model_7(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    // .'$LineString'
    if (unlikely(! json_is_object(val)))
    {
        if (rep) jm_report_add_entry(rep, "not an object [.'$LineString']", path);
        return false;
    }
    bool res;
    int64_t must_count = 0;
    const char *prop;
    json_t *pval;
    json_object_foreach((json_t *) val, prop, pval)
    {
        jm_path_t lpath_2 = (jm_path_t) { prop, 0, path, NULL };
        if (unlikely(jm_str_eq_5(prop, 0x0000000065707974LL)))
        {
            // handle must type property
            must_count += 1;
            // .'$LineString'.type
            res = json_is_string(pval) && jm_str_eq(json_string_value(pval), "LineString");
            if (unlikely(! res))
            {
                if (rep) jm_report_add_entry(rep, "unexpected LineString [.'$LineString'.type]", (path ? &lpath_2 : NULL));
                if (rep) jm_report_add_entry(rep, "invalid mandatory prop value [.'$LineString'.type]", (path ? &lpath_2 : NULL));
                return false;
            }
        }
        else if (likely(jm_str_eq_8(prop, 0x616e6964726f6f63LL) && jm_str_eq_4(prop + 8, 0x00736574)))
        {
            // handle must coordinates property
            must_count += 1;
            // .'$LineString'.coordinates
            res = json_model_3(pval, (path ? &lpath_2 : NULL), rep);
            if (unlikely(! res))
            {
                if (rep) jm_report_add_entry(rep, "unexpected $coord_array [.'$LineString'.coordinates]", (path ? &lpath_2 : NULL));
                if (rep) jm_report_add_entry(rep, "invalid mandatory prop value [.'$LineString'.coordinates]", (path ? &lpath_2 : NULL));
                return false;
            }
        }
        else if (likely(jm_str_eq_5(prop, 0x00000000786f6262LL)))
        {
            // handle may bbox property
            // .'$LineString'.bbox
            res = json_is_array(pval);
            if (res)
            {
                size_t arr_6_idx;
                json_t *arr_6_item;
                json_array_foreach(pval, arr_6_idx, arr_6_item)
                {
                    jm_path_t arr_6_lpath = (jm_path_t) { NULL, arr_6_idx, (path ? &lpath_2 : NULL), NULL };
                    // .'$LineString'.bbox.0
                    res = json_is_number(arr_6_item);
                    if (unlikely(! res))
                    {
                        if (rep) jm_report_add_entry(rep, "not a -1.0 loose float [.'$LineString'.bbox.0]", ((path ? &lpath_2 : NULL) ? &arr_6_lpath : NULL));
                        break;
                    }
                }
            }
            if (unlikely(! res))
            {
                if (rep) jm_report_add_entry(rep, "not array or unexpected array [.'$LineString'.bbox]", (path ? &lpath_2 : NULL));
                if (rep) jm_report_add_entry(rep, "invalid optional prop value [.'$LineString'.bbox]", (path ? &lpath_2 : NULL));
                return false;
            }
        }
        else
        {
            if (rep) jm_report_add_entry(rep, "unexpected prop [.'$LineString']", (path ? &lpath_2 : NULL));
            return false;
        }
    }
    if (unlikely(must_count != 2))
    {
        if (likely(rep != NULL))
        {
            if (! (json_object_get(val, "coordinates") != NULL))
            {
                if (rep) jm_report_add_entry(rep, "missing mandatory prop <coordinates> [.'$LineString']", path);
            }
            if (! (json_object_get(val, "type") != NULL))
            {
                if (rep) jm_report_add_entry(rep, "missing mandatory prop <type> [.'$LineString']", path);
            }
        }
        return false;
    }
    return true;
}

// check $MultiLineString (.'$MultiLineString')
static bool json_model_8(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    // .'$MultiLineString'
    if (unlikely(! json_is_object(val)))
    {
        if (rep) jm_report_add_entry(rep, "not an object [.'$MultiLineString']", path);
        return false;
    }
    bool res;
    int64_t must_count = 0;
    const char *prop;
    json_t *pval;
    json_object_foreach((json_t *) val, prop, pval)
    {
        jm_path_t lpath_3 = (jm_path_t) { prop, 0, path, NULL };
        if (unlikely(jm_str_eq_5(prop, 0x0000000065707974LL)))
        {
            // handle must type property
            must_count += 1;
            // .'$MultiLineString'.type
            res = json_is_string(pval) && jm_str_eq(json_string_value(pval), "MultiLineString");
            if (unlikely(! res))
            {
                if (rep) jm_report_add_entry(rep, "unexpected MultiLineString [.'$MultiLineString'.type]", (path ? &lpath_3 : NULL));
                if (rep) jm_report_add_entry(rep, "invalid mandatory prop value [.'$MultiLineString'.type]", (path ? &lpath_3 : NULL));
                return false;
            }
        }
        else if (likely(jm_str_eq_8(prop, 0x616e6964726f6f63LL) && jm_str_eq_4(prop + 8, 0x00736574)))
        {
            // handle must coordinates property
            must_count += 1;
            // .'$MultiLineString'.coordinates
            res = json_is_array(pval);
            if (res)
            {
                size_t arr_7_idx;
                json_t *arr_7_item;
                json_array_foreach(pval, arr_7_idx, arr_7_item)
                {
                    jm_path_t arr_7_lpath = (jm_path_t) { NULL, arr_7_idx, (path ? &lpath_3 : NULL), NULL };
                    // .'$MultiLineString'.coordinates.0
                    res = json_model_3(arr_7_item, ((path ? &lpath_3 : NULL) ? &arr_7_lpath : NULL), rep);
                    if (unlikely(! res))
                    {
                        if (rep) jm_report_add_entry(rep, "unexpected $coord_array [.'$MultiLineString'.coordinates.0]", ((path ? &lpath_3 : NULL) ? &arr_7_lpath : NULL));
                        break;
                    }
                }
            }
            if (unlikely(! res))
            {
                if (rep) jm_report_add_entry(rep, "not array or unexpected array [.'$MultiLineString'.coordinates]", (path ? &lpath_3 : NULL));
                if (rep) jm_report_add_entry(rep, "invalid mandatory prop value [.'$MultiLineString'.coordinates]", (path ? &lpath_3 : NULL));
                return false;
            }
        }
        else if (likely(jm_str_eq_5(prop, 0x00000000786f6262LL)))
        {
            // handle may bbox property
            // .'$MultiLineString'.bbox
            res = json_is_array(pval);
            if (res)
            {
                size_t arr_8_idx;
                json_t *arr_8_item;
                json_array_foreach(pval, arr_8_idx, arr_8_item)
                {
                    jm_path_t arr_8_lpath = (jm_path_t) { NULL, arr_8_idx, (path ? &lpath_3 : NULL), NULL };
                    // .'$MultiLineString'.bbox.0
                    res = json_is_number(arr_8_item);
                    if (unlikely(! res))
                    {
                        if (rep) jm_report_add_entry(rep, "not a -1.0 loose float [.'$MultiLineString'.bbox.0]", ((path ? &lpath_3 : NULL) ? &arr_8_lpath : NULL));
                        break;
                    }
                }
            }
            if (unlikely(! res))
            {
                if (rep) jm_report_add_entry(rep, "not array or unexpected array [.'$MultiLineString'.bbox]", (path ? &lpath_3 : NULL));
                if (rep) jm_report_add_entry(rep, "invalid optional prop value [.'$MultiLineString'.bbox]", (path ? &lpath_3 : NULL));
                return false;
            }
        }
        else
        {
            if (rep) jm_report_add_entry(rep, "unexpected prop [.'$MultiLineString']", (path ? &lpath_3 : NULL));
            return false;
        }
    }
    if (unlikely(must_count != 2))
    {
        if (likely(rep != NULL))
        {
            if (! (json_object_get(val, "coordinates") != NULL))
            {
                if (rep) jm_report_add_entry(rep, "missing mandatory prop <coordinates> [.'$MultiLineString']", path);
            }
            if (! (json_object_get(val, "type") != NULL))
            {
                if (rep) jm_report_add_entry(rep, "missing mandatory prop <type> [.'$MultiLineString']", path);
            }
        }
        return false;
    }
    return true;
}

// check $Polygon (.'$Polygon')
static bool json_model_9(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    // .'$Polygon'
    if (unlikely(! json_is_object(val)))
    {
        if (rep) jm_report_add_entry(rep, "not an object [.'$Polygon']", path);
        return false;
    }
    bool res;
    int64_t must_count = 0;
    const char *prop;
    json_t *pval;
    json_object_foreach((json_t *) val, prop, pval)
    {
        jm_path_t lpath_4 = (jm_path_t) { prop, 0, path, NULL };
        if (unlikely(jm_str_eq_5(prop, 0x0000000065707974LL)))
        {
            // handle must type property
            must_count += 1;
            // .'$Polygon'.type
            res = json_is_string(pval) && jm_str_eq_8(json_string_value(pval), 0x006e6f67796c6f50LL);
            if (unlikely(! res))
            {
                if (rep) jm_report_add_entry(rep, "unexpected Polygon [.'$Polygon'.type]", (path ? &lpath_4 : NULL));
                if (rep) jm_report_add_entry(rep, "invalid mandatory prop value [.'$Polygon'.type]", (path ? &lpath_4 : NULL));
                return false;
            }
        }
        else if (likely(jm_str_eq_8(prop, 0x616e6964726f6f63LL) && jm_str_eq_4(prop + 8, 0x00736574)))
        {
            // handle must coordinates property
            must_count += 1;
            // .'$Polygon'.coordinates
            res = json_is_array(pval);
            if (res)
            {
                size_t arr_9_idx;
                json_t *arr_9_item;
                json_array_foreach(pval, arr_9_idx, arr_9_item)
                {
                    jm_path_t arr_9_lpath = (jm_path_t) { NULL, arr_9_idx, (path ? &lpath_4 : NULL), NULL };
                    // .'$Polygon'.coordinates.0
                    res = json_model_4(arr_9_item, ((path ? &lpath_4 : NULL) ? &arr_9_lpath : NULL), rep);
                    if (unlikely(! res))
                    {
                        if (rep) jm_report_add_entry(rep, "unexpected $linear_ring [.'$Polygon'.coordinates.0]", ((path ? &lpath_4 : NULL) ? &arr_9_lpath : NULL));
                        break;
                    }
                }
            }
            if (unlikely(! res))
            {
                if (rep) jm_report_add_entry(rep, "not array or unexpected array [.'$Polygon'.coordinates]", (path ? &lpath_4 : NULL));
                if (rep) jm_report_add_entry(rep, "invalid mandatory prop value [.'$Polygon'.coordinates]", (path ? &lpath_4 : NULL));
                return false;
            }
        }
        else if (likely(jm_str_eq_5(prop, 0x00000000786f6262LL)))
        {
            // handle may bbox property
            // .'$Polygon'.bbox
            res = json_is_array(pval);
            if (res)
            {
                size_t arr_10_idx;
                json_t *arr_10_item;
                json_array_foreach(pval, arr_10_idx, arr_10_item)
                {
                    jm_path_t arr_10_lpath = (jm_path_t) { NULL, arr_10_idx, (path ? &lpath_4 : NULL), NULL };
                    // .'$Polygon'.bbox.0
                    res = json_is_number(arr_10_item);
                    if (unlikely(! res))
                    {
                        if (rep) jm_report_add_entry(rep, "not a -1.0 loose float [.'$Polygon'.bbox.0]", ((path ? &lpath_4 : NULL) ? &arr_10_lpath : NULL));
                        break;
                    }
                }
            }
            if (unlikely(! res))
            {
                if (rep) jm_report_add_entry(rep, "not array or unexpected array [.'$Polygon'.bbox]", (path ? &lpath_4 : NULL));
                if (rep) jm_report_add_entry(rep, "invalid optional prop value [.'$Polygon'.bbox]", (path ? &lpath_4 : NULL));
                return false;
            }
        }
        else
        {
            if (rep) jm_report_add_entry(rep, "unexpected prop [.'$Polygon']", (path ? &lpath_4 : NULL));
            return false;
        }
    }
    if (unlikely(must_count != 2))
    {
        if (likely(rep != NULL))
        {
            if (! (json_object_get(val, "coordinates") != NULL))
            {
                if (rep) jm_report_add_entry(rep, "missing mandatory prop <coordinates> [.'$Polygon']", path);
            }
            if (! (json_object_get(val, "type") != NULL))
            {
                if (rep) jm_report_add_entry(rep, "missing mandatory prop <type> [.'$Polygon']", path);
            }
        }
        return false;
    }
    return true;
}

// check $MultiPolygon (.'$MultiPolygon')
static bool json_model_10(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    // .'$MultiPolygon'
    if (unlikely(! json_is_object(val)))
    {
        if (rep) jm_report_add_entry(rep, "not an object [.'$MultiPolygon']", path);
        return false;
    }
    bool res;
    int64_t must_count = 0;
    const char *prop;
    json_t *pval;
    json_object_foreach((json_t *) val, prop, pval)
    {
        jm_path_t lpath_5 = (jm_path_t) { prop, 0, path, NULL };
        if (unlikely(jm_str_eq_5(prop, 0x0000000065707974LL)))
        {
            // handle must type property
            must_count += 1;
            // .'$MultiPolygon'.type
            res = json_is_string(pval) && jm_str_eq(json_string_value(pval), "MultiPolygon");
            if (unlikely(! res))
            {
                if (rep) jm_report_add_entry(rep, "unexpected MultiPolygon [.'$MultiPolygon'.type]", (path ? &lpath_5 : NULL));
                if (rep) jm_report_add_entry(rep, "invalid mandatory prop value [.'$MultiPolygon'.type]", (path ? &lpath_5 : NULL));
                return false;
            }
        }
        else if (likely(jm_str_eq_8(prop, 0x616e6964726f6f63LL) && jm_str_eq_4(prop + 8, 0x00736574)))
        {
            // handle must coordinates property
            must_count += 1;
            // .'$MultiPolygon'.coordinates
            res = json_is_array(pval);
            if (res)
            {
                size_t arr_11_idx;
                json_t *arr_11_item;
                json_array_foreach(pval, arr_11_idx, arr_11_item)
                {
                    jm_path_t arr_11_lpath = (jm_path_t) { NULL, arr_11_idx, (path ? &lpath_5 : NULL), NULL };
                    // .'$MultiPolygon'.coordinates.0
                    res = json_is_array(arr_11_item);
                    if (res)
                    {
                        size_t arr_12_idx;
                        json_t *arr_12_item;
                        json_array_foreach(arr_11_item, arr_12_idx, arr_12_item)
                        {
                            jm_path_t arr_12_lpath = (jm_path_t) { NULL, arr_12_idx, ((path ? &lpath_5 : NULL) ? &arr_11_lpath : NULL), NULL };
                            // .'$MultiPolygon'.coordinates.0.0
                            res = json_model_4(arr_12_item, (((path ? &lpath_5 : NULL) ? &arr_11_lpath : NULL) ? &arr_12_lpath : NULL), rep);
                            if (unlikely(! res))
                            {
                                if (rep) jm_report_add_entry(rep, "unexpected $linear_ring [.'$MultiPolygon'.coordinates.0.0]", (((path ? &lpath_5 : NULL) ? &arr_11_lpath : NULL) ? &arr_12_lpath : NULL));
                                break;
                            }
                        }
                    }
                    if (unlikely(! res))
                    {
                        if (rep) jm_report_add_entry(rep, "not array or unexpected array [.'$MultiPolygon'.coordinates.0]", ((path ? &lpath_5 : NULL) ? &arr_11_lpath : NULL));
                        break;
                    }
                }
            }
            if (unlikely(! res))
            {
                if (rep) jm_report_add_entry(rep, "not array or unexpected array [.'$MultiPolygon'.coordinates]", (path ? &lpath_5 : NULL));
                if (rep) jm_report_add_entry(rep, "invalid mandatory prop value [.'$MultiPolygon'.coordinates]", (path ? &lpath_5 : NULL));
                return false;
            }
        }
        else if (likely(jm_str_eq_5(prop, 0x00000000786f6262LL)))
        {
            // handle may bbox property
            // .'$MultiPolygon'.bbox
            res = json_is_array(pval);
            if (res)
            {
                size_t arr_13_idx;
                json_t *arr_13_item;
                json_array_foreach(pval, arr_13_idx, arr_13_item)
                {
                    jm_path_t arr_13_lpath = (jm_path_t) { NULL, arr_13_idx, (path ? &lpath_5 : NULL), NULL };
                    // .'$MultiPolygon'.bbox.0
                    res = json_is_number(arr_13_item);
                    if (unlikely(! res))
                    {
                        if (rep) jm_report_add_entry(rep, "not a -1.0 loose float [.'$MultiPolygon'.bbox.0]", ((path ? &lpath_5 : NULL) ? &arr_13_lpath : NULL));
                        break;
                    }
                }
            }
            if (unlikely(! res))
            {
                if (rep) jm_report_add_entry(rep, "not array or unexpected array [.'$MultiPolygon'.bbox]", (path ? &lpath_5 : NULL));
                if (rep) jm_report_add_entry(rep, "invalid optional prop value [.'$MultiPolygon'.bbox]", (path ? &lpath_5 : NULL));
                return false;
            }
        }
        else
        {
            if (rep) jm_report_add_entry(rep, "unexpected prop [.'$MultiPolygon']", (path ? &lpath_5 : NULL));
            return false;
        }
    }
    if (unlikely(must_count != 2))
    {
        if (likely(rep != NULL))
        {
            if (! (json_object_get(val, "coordinates") != NULL))
            {
                if (rep) jm_report_add_entry(rep, "missing mandatory prop <coordinates> [.'$MultiPolygon']", path);
            }
            if (! (json_object_get(val, "type") != NULL))
            {
                if (rep) jm_report_add_entry(rep, "missing mandatory prop <type> [.'$MultiPolygon']", path);
            }
        }
        return false;
    }
    return true;
}

// object .'$geometry'.'|'.0
static INLINE bool _jm_obj_0(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    if (unlikely(! json_is_object(val)))
    {
        if (rep) jm_report_add_entry(rep, "not an object [.'$geometry'.'|'.0]", path);
        return false;
    }
    bool res;
    int64_t must_count = 0;
    const char *prop;
    json_t *pval;
    json_object_foreach((json_t *) val, prop, pval)
    {
        jm_path_t lpath_6 = (jm_path_t) { prop, 0, path, NULL };
        if (unlikely(jm_str_eq_5(prop, 0x0000000065707974LL)))
        {
            // handle must type property
            must_count += 1;
            // .'$geometry'.'|'.0.type
            res = json_is_string(pval) && jm_str_eq_6(json_string_value(pval), 0x000000746e696f50LL);
            if (unlikely(! res))
            {
                if (rep) jm_report_add_entry(rep, "unexpected Point [.'$geometry'.'|'.0.type]", (path ? &lpath_6 : NULL));
                if (rep) jm_report_add_entry(rep, "invalid mandatory prop value [.'$geometry'.'|'.0.type]", (path ? &lpath_6 : NULL));
                return false;
            }
        }
        else if (unlikely(jm_str_eq_8(prop, 0x616e6964726f6f63LL) && jm_str_eq_4(prop + 8, 0x00736574)))
        {
            // handle must coordinates property
            must_count += 1;
            // .'$geometry'.'|'.0.coordinates
            res = json_model_2(pval, (path ? &lpath_6 : NULL), rep);
            if (unlikely(! res))
            {
                if (rep) jm_report_add_entry(rep, "unexpected $position [.'$geometry'.'|'.0.coordinates]", (path ? &lpath_6 : NULL));
                if (rep) jm_report_add_entry(rep, "invalid mandatory prop value [.'$geometry'.'|'.0.coordinates]", (path ? &lpath_6 : NULL));
                return false;
            }
        }
        else if (unlikely(jm_str_eq_5(prop, 0x00000000786f6262LL)))
        {
            // handle may bbox property
            // .'$geometry'.'|'.0.bbox
            res = json_is_array(pval);
            if (res)
            {
                size_t arr_14_idx;
                json_t *arr_14_item;
                json_array_foreach(pval, arr_14_idx, arr_14_item)
                {
                    jm_path_t arr_14_lpath = (jm_path_t) { NULL, arr_14_idx, (path ? &lpath_6 : NULL), NULL };
                    // .'$geometry'.'|'.0.bbox.0
                    res = json_is_number(arr_14_item);
                    if (unlikely(! res))
                    {
                        if (rep) jm_report_add_entry(rep, "not a -1.0 loose float [.'$geometry'.'|'.0.bbox.0]", ((path ? &lpath_6 : NULL) ? &arr_14_lpath : NULL));
                        break;
                    }
                }
            }
            if (unlikely(! res))
            {
                if (rep) jm_report_add_entry(rep, "not array or unexpected array [.'$geometry'.'|'.0.bbox]", (path ? &lpath_6 : NULL));
                if (rep) jm_report_add_entry(rep, "invalid optional prop value [.'$geometry'.'|'.0.bbox]", (path ? &lpath_6 : NULL));
                return false;
            }
        }
        else
        {
            // accept any other props
        }
    }
    if (unlikely(must_count != 2))
    {
        if (likely(rep != NULL))
        {
            if (! (json_object_get(val, "coordinates") != NULL))
            {
                if (rep) jm_report_add_entry(rep, "missing mandatory prop <coordinates> [.'$geometry'.'|'.0.'']", path);
            }
            if (! (json_object_get(val, "type") != NULL))
            {
                if (rep) jm_report_add_entry(rep, "missing mandatory prop <type> [.'$geometry'.'|'.0.'']", path);
            }
        }
        return false;
    }
    return true;
}

// object .'$geometry'.'|'.1
static INLINE bool _jm_obj_1(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    if (unlikely(! json_is_object(val)))
    {
        if (rep) jm_report_add_entry(rep, "not an object [.'$geometry'.'|'.1]", path);
        return false;
    }
    bool res;
    int64_t must_count = 0;
    const char *prop;
    json_t *pval;
    json_object_foreach((json_t *) val, prop, pval)
    {
        jm_path_t lpath_7 = (jm_path_t) { prop, 0, path, NULL };
        if (unlikely(jm_str_eq_5(prop, 0x0000000065707974LL)))
        {
            // handle must type property
            must_count += 1;
            // .'$geometry'.'|'.1.type
            res = json_is_string(pval) && jm_str_eq(json_string_value(pval), "MultiPoint");
            if (unlikely(! res))
            {
                if (rep) jm_report_add_entry(rep, "unexpected MultiPoint [.'$geometry'.'|'.1.type]", (path ? &lpath_7 : NULL));
                if (rep) jm_report_add_entry(rep, "invalid mandatory prop value [.'$geometry'.'|'.1.type]", (path ? &lpath_7 : NULL));
                return false;
            }
        }
        else if (unlikely(jm_str_eq_8(prop, 0x616e6964726f6f63LL) && jm_str_eq_4(prop + 8, 0x00736574)))
        {
            // handle must coordinates property
            must_count += 1;
            // .'$geometry'.'|'.1.coordinates
            res = json_is_array(pval);
            if (res)
            {
                size_t arr_15_idx;
                json_t *arr_15_item;
                json_array_foreach(pval, arr_15_idx, arr_15_item)
                {
                    jm_path_t arr_15_lpath = (jm_path_t) { NULL, arr_15_idx, (path ? &lpath_7 : NULL), NULL };
                    // .'$geometry'.'|'.1.coordinates.0
                    res = json_model_2(arr_15_item, ((path ? &lpath_7 : NULL) ? &arr_15_lpath : NULL), rep);
                    if (unlikely(! res))
                    {
                        if (rep) jm_report_add_entry(rep, "unexpected $position [.'$geometry'.'|'.1.coordinates.0]", ((path ? &lpath_7 : NULL) ? &arr_15_lpath : NULL));
                        break;
                    }
                }
            }
            if (unlikely(! res))
            {
                if (rep) jm_report_add_entry(rep, "not array or unexpected array [.'$geometry'.'|'.1.coordinates]", (path ? &lpath_7 : NULL));
                if (rep) jm_report_add_entry(rep, "invalid mandatory prop value [.'$geometry'.'|'.1.coordinates]", (path ? &lpath_7 : NULL));
                return false;
            }
        }
        else if (unlikely(jm_str_eq_5(prop, 0x00000000786f6262LL)))
        {
            // handle may bbox property
            // .'$geometry'.'|'.1.bbox
            res = json_is_array(pval);
            if (res)
            {
                size_t arr_16_idx;
                json_t *arr_16_item;
                json_array_foreach(pval, arr_16_idx, arr_16_item)
                {
                    jm_path_t arr_16_lpath = (jm_path_t) { NULL, arr_16_idx, (path ? &lpath_7 : NULL), NULL };
                    // .'$geometry'.'|'.1.bbox.0
                    res = json_is_number(arr_16_item);
                    if (unlikely(! res))
                    {
                        if (rep) jm_report_add_entry(rep, "not a -1.0 loose float [.'$geometry'.'|'.1.bbox.0]", ((path ? &lpath_7 : NULL) ? &arr_16_lpath : NULL));
                        break;
                    }
                }
            }
            if (unlikely(! res))
            {
                if (rep) jm_report_add_entry(rep, "not array or unexpected array [.'$geometry'.'|'.1.bbox]", (path ? &lpath_7 : NULL));
                if (rep) jm_report_add_entry(rep, "invalid optional prop value [.'$geometry'.'|'.1.bbox]", (path ? &lpath_7 : NULL));
                return false;
            }
        }
        else
        {
            // accept any other props
        }
    }
    if (unlikely(must_count != 2))
    {
        if (likely(rep != NULL))
        {
            if (! (json_object_get(val, "coordinates") != NULL))
            {
                if (rep) jm_report_add_entry(rep, "missing mandatory prop <coordinates> [.'$geometry'.'|'.1.'']", path);
            }
            if (! (json_object_get(val, "type") != NULL))
            {
                if (rep) jm_report_add_entry(rep, "missing mandatory prop <type> [.'$geometry'.'|'.1.'']", path);
            }
        }
        return false;
    }
    return true;
}

// object .'$geometry'.'|'.2
static INLINE bool _jm_obj_2(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    if (unlikely(! json_is_object(val)))
    {
        if (rep) jm_report_add_entry(rep, "not an object [.'$geometry'.'|'.2]", path);
        return false;
    }
    bool res;
    int64_t must_count = 0;
    const char *prop;
    json_t *pval;
    json_object_foreach((json_t *) val, prop, pval)
    {
        jm_path_t lpath_8 = (jm_path_t) { prop, 0, path, NULL };
        if (unlikely(jm_str_eq_5(prop, 0x0000000065707974LL)))
        {
            // handle must type property
            must_count += 1;
            // .'$geometry'.'|'.2.type
            res = json_is_string(pval) && jm_str_eq(json_string_value(pval), "LineString");
            if (unlikely(! res))
            {
                if (rep) jm_report_add_entry(rep, "unexpected LineString [.'$geometry'.'|'.2.type]", (path ? &lpath_8 : NULL));
                if (rep) jm_report_add_entry(rep, "invalid mandatory prop value [.'$geometry'.'|'.2.type]", (path ? &lpath_8 : NULL));
                return false;
            }
        }
        else if (unlikely(jm_str_eq_8(prop, 0x616e6964726f6f63LL) && jm_str_eq_4(prop + 8, 0x00736574)))
        {
            // handle must coordinates property
            must_count += 1;
            // .'$geometry'.'|'.2.coordinates
            res = json_model_3(pval, (path ? &lpath_8 : NULL), rep);
            if (unlikely(! res))
            {
                if (rep) jm_report_add_entry(rep, "unexpected $coord_array [.'$geometry'.'|'.2.coordinates]", (path ? &lpath_8 : NULL));
                if (rep) jm_report_add_entry(rep, "invalid mandatory prop value [.'$geometry'.'|'.2.coordinates]", (path ? &lpath_8 : NULL));
                return false;
            }
        }
        else if (unlikely(jm_str_eq_5(prop, 0x00000000786f6262LL)))
        {
            // handle may bbox property
            // .'$geometry'.'|'.2.bbox
            res = json_is_array(pval);
            if (res)
            {
                size_t arr_17_idx;
                json_t *arr_17_item;
                json_array_foreach(pval, arr_17_idx, arr_17_item)
                {
                    jm_path_t arr_17_lpath = (jm_path_t) { NULL, arr_17_idx, (path ? &lpath_8 : NULL), NULL };
                    // .'$geometry'.'|'.2.bbox.0
                    res = json_is_number(arr_17_item);
                    if (unlikely(! res))
                    {
                        if (rep) jm_report_add_entry(rep, "not a -1.0 loose float [.'$geometry'.'|'.2.bbox.0]", ((path ? &lpath_8 : NULL) ? &arr_17_lpath : NULL));
                        break;
                    }
                }
            }
            if (unlikely(! res))
            {
                if (rep) jm_report_add_entry(rep, "not array or unexpected array [.'$geometry'.'|'.2.bbox]", (path ? &lpath_8 : NULL));
                if (rep) jm_report_add_entry(rep, "invalid optional prop value [.'$geometry'.'|'.2.bbox]", (path ? &lpath_8 : NULL));
                return false;
            }
        }
        else
        {
            // accept any other props
        }
    }
    if (unlikely(must_count != 2))
    {
        if (likely(rep != NULL))
        {
            if (! (json_object_get(val, "coordinates") != NULL))
            {
                if (rep) jm_report_add_entry(rep, "missing mandatory prop <coordinates> [.'$geometry'.'|'.2.'']", path);
            }
            if (! (json_object_get(val, "type") != NULL))
            {
                if (rep) jm_report_add_entry(rep, "missing mandatory prop <type> [.'$geometry'.'|'.2.'']", path);
            }
        }
        return false;
    }
    return true;
}

// object .'$geometry'.'|'.3
static INLINE bool _jm_obj_3(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    if (unlikely(! json_is_object(val)))
    {
        if (rep) jm_report_add_entry(rep, "not an object [.'$geometry'.'|'.3]", path);
        return false;
    }
    bool res;
    int64_t must_count = 0;
    const char *prop;
    json_t *pval;
    json_object_foreach((json_t *) val, prop, pval)
    {
        jm_path_t lpath_9 = (jm_path_t) { prop, 0, path, NULL };
        if (unlikely(jm_str_eq_5(prop, 0x0000000065707974LL)))
        {
            // handle must type property
            must_count += 1;
            // .'$geometry'.'|'.3.type
            res = json_is_string(pval) && jm_str_eq(json_string_value(pval), "MultiLineString");
            if (unlikely(! res))
            {
                if (rep) jm_report_add_entry(rep, "unexpected MultiLineString [.'$geometry'.'|'.3.type]", (path ? &lpath_9 : NULL));
                if (rep) jm_report_add_entry(rep, "invalid mandatory prop value [.'$geometry'.'|'.3.type]", (path ? &lpath_9 : NULL));
                return false;
            }
        }
        else if (unlikely(jm_str_eq_8(prop, 0x616e6964726f6f63LL) && jm_str_eq_4(prop + 8, 0x00736574)))
        {
            // handle must coordinates property
            must_count += 1;
            // .'$geometry'.'|'.3.coordinates
            res = json_is_array(pval);
            if (res)
            {
                size_t arr_18_idx;
                json_t *arr_18_item;
                json_array_foreach(pval, arr_18_idx, arr_18_item)
                {
                    jm_path_t arr_18_lpath = (jm_path_t) { NULL, arr_18_idx, (path ? &lpath_9 : NULL), NULL };
                    // .'$geometry'.'|'.3.coordinates.0
                    res = json_model_3(arr_18_item, ((path ? &lpath_9 : NULL) ? &arr_18_lpath : NULL), rep);
                    if (unlikely(! res))
                    {
                        if (rep) jm_report_add_entry(rep, "unexpected $coord_array [.'$geometry'.'|'.3.coordinates.0]", ((path ? &lpath_9 : NULL) ? &arr_18_lpath : NULL));
                        break;
                    }
                }
            }
            if (unlikely(! res))
            {
                if (rep) jm_report_add_entry(rep, "not array or unexpected array [.'$geometry'.'|'.3.coordinates]", (path ? &lpath_9 : NULL));
                if (rep) jm_report_add_entry(rep, "invalid mandatory prop value [.'$geometry'.'|'.3.coordinates]", (path ? &lpath_9 : NULL));
                return false;
            }
        }
        else if (unlikely(jm_str_eq_5(prop, 0x00000000786f6262LL)))
        {
            // handle may bbox property
            // .'$geometry'.'|'.3.bbox
            res = json_is_array(pval);
            if (res)
            {
                size_t arr_19_idx;
                json_t *arr_19_item;
                json_array_foreach(pval, arr_19_idx, arr_19_item)
                {
                    jm_path_t arr_19_lpath = (jm_path_t) { NULL, arr_19_idx, (path ? &lpath_9 : NULL), NULL };
                    // .'$geometry'.'|'.3.bbox.0
                    res = json_is_number(arr_19_item);
                    if (unlikely(! res))
                    {
                        if (rep) jm_report_add_entry(rep, "not a -1.0 loose float [.'$geometry'.'|'.3.bbox.0]", ((path ? &lpath_9 : NULL) ? &arr_19_lpath : NULL));
                        break;
                    }
                }
            }
            if (unlikely(! res))
            {
                if (rep) jm_report_add_entry(rep, "not array or unexpected array [.'$geometry'.'|'.3.bbox]", (path ? &lpath_9 : NULL));
                if (rep) jm_report_add_entry(rep, "invalid optional prop value [.'$geometry'.'|'.3.bbox]", (path ? &lpath_9 : NULL));
                return false;
            }
        }
        else
        {
            // accept any other props
        }
    }
    if (unlikely(must_count != 2))
    {
        if (likely(rep != NULL))
        {
            if (! (json_object_get(val, "coordinates") != NULL))
            {
                if (rep) jm_report_add_entry(rep, "missing mandatory prop <coordinates> [.'$geometry'.'|'.3.'']", path);
            }
            if (! (json_object_get(val, "type") != NULL))
            {
                if (rep) jm_report_add_entry(rep, "missing mandatory prop <type> [.'$geometry'.'|'.3.'']", path);
            }
        }
        return false;
    }
    return true;
}

// object .'$geometry'.'|'.4
static INLINE bool _jm_obj_4(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    if (unlikely(! json_is_object(val)))
    {
        if (rep) jm_report_add_entry(rep, "not an object [.'$geometry'.'|'.4]", path);
        return false;
    }
    bool res;
    int64_t must_count = 0;
    const char *prop;
    json_t *pval;
    json_object_foreach((json_t *) val, prop, pval)
    {
        jm_path_t lpath_10 = (jm_path_t) { prop, 0, path, NULL };
        if (unlikely(jm_str_eq_5(prop, 0x0000000065707974LL)))
        {
            // handle must type property
            must_count += 1;
            // .'$geometry'.'|'.4.type
            res = json_is_string(pval) && jm_str_eq_8(json_string_value(pval), 0x006e6f67796c6f50LL);
            if (unlikely(! res))
            {
                if (rep) jm_report_add_entry(rep, "unexpected Polygon [.'$geometry'.'|'.4.type]", (path ? &lpath_10 : NULL));
                if (rep) jm_report_add_entry(rep, "invalid mandatory prop value [.'$geometry'.'|'.4.type]", (path ? &lpath_10 : NULL));
                return false;
            }
        }
        else if (unlikely(jm_str_eq_8(prop, 0x616e6964726f6f63LL) && jm_str_eq_4(prop + 8, 0x00736574)))
        {
            // handle must coordinates property
            must_count += 1;
            // .'$geometry'.'|'.4.coordinates
            res = json_is_array(pval);
            if (res)
            {
                size_t arr_20_idx;
                json_t *arr_20_item;
                json_array_foreach(pval, arr_20_idx, arr_20_item)
                {
                    jm_path_t arr_20_lpath = (jm_path_t) { NULL, arr_20_idx, (path ? &lpath_10 : NULL), NULL };
                    // .'$geometry'.'|'.4.coordinates.0
                    res = json_model_4(arr_20_item, ((path ? &lpath_10 : NULL) ? &arr_20_lpath : NULL), rep);
                    if (unlikely(! res))
                    {
                        if (rep) jm_report_add_entry(rep, "unexpected $linear_ring [.'$geometry'.'|'.4.coordinates.0]", ((path ? &lpath_10 : NULL) ? &arr_20_lpath : NULL));
                        break;
                    }
                }
            }
            if (unlikely(! res))
            {
                if (rep) jm_report_add_entry(rep, "not array or unexpected array [.'$geometry'.'|'.4.coordinates]", (path ? &lpath_10 : NULL));
                if (rep) jm_report_add_entry(rep, "invalid mandatory prop value [.'$geometry'.'|'.4.coordinates]", (path ? &lpath_10 : NULL));
                return false;
            }
        }
        else if (unlikely(jm_str_eq_5(prop, 0x00000000786f6262LL)))
        {
            // handle may bbox property
            // .'$geometry'.'|'.4.bbox
            res = json_is_array(pval);
            if (res)
            {
                size_t arr_21_idx;
                json_t *arr_21_item;
                json_array_foreach(pval, arr_21_idx, arr_21_item)
                {
                    jm_path_t arr_21_lpath = (jm_path_t) { NULL, arr_21_idx, (path ? &lpath_10 : NULL), NULL };
                    // .'$geometry'.'|'.4.bbox.0
                    res = json_is_number(arr_21_item);
                    if (unlikely(! res))
                    {
                        if (rep) jm_report_add_entry(rep, "not a -1.0 loose float [.'$geometry'.'|'.4.bbox.0]", ((path ? &lpath_10 : NULL) ? &arr_21_lpath : NULL));
                        break;
                    }
                }
            }
            if (unlikely(! res))
            {
                if (rep) jm_report_add_entry(rep, "not array or unexpected array [.'$geometry'.'|'.4.bbox]", (path ? &lpath_10 : NULL));
                if (rep) jm_report_add_entry(rep, "invalid optional prop value [.'$geometry'.'|'.4.bbox]", (path ? &lpath_10 : NULL));
                return false;
            }
        }
        else
        {
            // accept any other props
        }
    }
    if (unlikely(must_count != 2))
    {
        if (likely(rep != NULL))
        {
            if (! (json_object_get(val, "coordinates") != NULL))
            {
                if (rep) jm_report_add_entry(rep, "missing mandatory prop <coordinates> [.'$geometry'.'|'.4.'']", path);
            }
            if (! (json_object_get(val, "type") != NULL))
            {
                if (rep) jm_report_add_entry(rep, "missing mandatory prop <type> [.'$geometry'.'|'.4.'']", path);
            }
        }
        return false;
    }
    return true;
}

// object .'$geometry'.'|'.5
static INLINE bool _jm_obj_5(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    if (unlikely(! json_is_object(val)))
    {
        if (rep) jm_report_add_entry(rep, "not an object [.'$geometry'.'|'.5]", path);
        return false;
    }
    bool res;
    int64_t must_count = 0;
    const char *prop;
    json_t *pval;
    json_object_foreach((json_t *) val, prop, pval)
    {
        jm_path_t lpath_11 = (jm_path_t) { prop, 0, path, NULL };
        if (unlikely(jm_str_eq_5(prop, 0x0000000065707974LL)))
        {
            // handle must type property
            must_count += 1;
            // .'$geometry'.'|'.5.type
            res = json_is_string(pval) && jm_str_eq(json_string_value(pval), "MultiPolygon");
            if (unlikely(! res))
            {
                if (rep) jm_report_add_entry(rep, "unexpected MultiPolygon [.'$geometry'.'|'.5.type]", (path ? &lpath_11 : NULL));
                if (rep) jm_report_add_entry(rep, "invalid mandatory prop value [.'$geometry'.'|'.5.type]", (path ? &lpath_11 : NULL));
                return false;
            }
        }
        else if (unlikely(jm_str_eq_8(prop, 0x616e6964726f6f63LL) && jm_str_eq_4(prop + 8, 0x00736574)))
        {
            // handle must coordinates property
            must_count += 1;
            // .'$geometry'.'|'.5.coordinates
            res = json_is_array(pval);
            if (res)
            {
                size_t arr_22_idx;
                json_t *arr_22_item;
                json_array_foreach(pval, arr_22_idx, arr_22_item)
                {
                    jm_path_t arr_22_lpath = (jm_path_t) { NULL, arr_22_idx, (path ? &lpath_11 : NULL), NULL };
                    // .'$geometry'.'|'.5.coordinates.0
                    res = json_is_array(arr_22_item);
                    if (res)
                    {
                        size_t arr_23_idx;
                        json_t *arr_23_item;
                        json_array_foreach(arr_22_item, arr_23_idx, arr_23_item)
                        {
                            jm_path_t arr_23_lpath = (jm_path_t) { NULL, arr_23_idx, ((path ? &lpath_11 : NULL) ? &arr_22_lpath : NULL), NULL };
                            // .'$geometry'.'|'.5.coordinates.0.0
                            res = json_model_4(arr_23_item, (((path ? &lpath_11 : NULL) ? &arr_22_lpath : NULL) ? &arr_23_lpath : NULL), rep);
                            if (unlikely(! res))
                            {
                                if (rep) jm_report_add_entry(rep, "unexpected $linear_ring [.'$geometry'.'|'.5.coordinates.0.0]", (((path ? &lpath_11 : NULL) ? &arr_22_lpath : NULL) ? &arr_23_lpath : NULL));
                                break;
                            }
                        }
                    }
                    if (unlikely(! res))
                    {
                        if (rep) jm_report_add_entry(rep, "not array or unexpected array [.'$geometry'.'|'.5.coordinates.0]", ((path ? &lpath_11 : NULL) ? &arr_22_lpath : NULL));
                        break;
                    }
                }
            }
            if (unlikely(! res))
            {
                if (rep) jm_report_add_entry(rep, "not array or unexpected array [.'$geometry'.'|'.5.coordinates]", (path ? &lpath_11 : NULL));
                if (rep) jm_report_add_entry(rep, "invalid mandatory prop value [.'$geometry'.'|'.5.coordinates]", (path ? &lpath_11 : NULL));
                return false;
            }
        }
        else if (unlikely(jm_str_eq_5(prop, 0x00000000786f6262LL)))
        {
            // handle may bbox property
            // .'$geometry'.'|'.5.bbox
            res = json_is_array(pval);
            if (res)
            {
                size_t arr_24_idx;
                json_t *arr_24_item;
                json_array_foreach(pval, arr_24_idx, arr_24_item)
                {
                    jm_path_t arr_24_lpath = (jm_path_t) { NULL, arr_24_idx, (path ? &lpath_11 : NULL), NULL };
                    // .'$geometry'.'|'.5.bbox.0
                    res = json_is_number(arr_24_item);
                    if (unlikely(! res))
                    {
                        if (rep) jm_report_add_entry(rep, "not a -1.0 loose float [.'$geometry'.'|'.5.bbox.0]", ((path ? &lpath_11 : NULL) ? &arr_24_lpath : NULL));
                        break;
                    }
                }
            }
            if (unlikely(! res))
            {
                if (rep) jm_report_add_entry(rep, "not array or unexpected array [.'$geometry'.'|'.5.bbox]", (path ? &lpath_11 : NULL));
                if (rep) jm_report_add_entry(rep, "invalid optional prop value [.'$geometry'.'|'.5.bbox]", (path ? &lpath_11 : NULL));
                return false;
            }
        }
        else
        {
            // accept any other props
        }
    }
    if (unlikely(must_count != 2))
    {
        if (likely(rep != NULL))
        {
            if (! (json_object_get(val, "coordinates") != NULL))
            {
                if (rep) jm_report_add_entry(rep, "missing mandatory prop <coordinates> [.'$geometry'.'|'.5.'']", path);
            }
            if (! (json_object_get(val, "type") != NULL))
            {
                if (rep) jm_report_add_entry(rep, "missing mandatory prop <type> [.'$geometry'.'|'.5.'']", path);
            }
        }
        return false;
    }
    return true;
}

static INLINE jm_check_fun_t _jm_map_0(json_t *val)
{
    jm_constant_t cst;
    jm_set_cst(&cst, val);
    return jm_search_constmap(&cst, _jm_map_0_tab, 6);
}

// check $geometry (.'$geometry')
static bool json_model_11(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .'$geometry'
    bool iso_0 = json_is_object(val);
    res = iso_0;
    if (likely(res))
    {
        if (likely(json_object_get(val, "type") != NULL))
        {
            json_t * tag_0 = json_object_get(val, "type");
            jm_check_fun_t fun_0 = _jm_map_0(tag_0);
            if (likely(fun_0 != NULL))
                res = fun_0(val, path, rep);
            else
            {
                res = false;
                if (rep) jm_report_add_entry(rep, "tag <type> value not found [.'$geometry'.'|']", path);
            }
        }
        else
        {
            res = false;
            if (rep) jm_report_add_entry(rep, "tag prop <type> is missing [.'$geometry'.'|']", path);
        }
    }
    else
    {
        if (rep) jm_report_add_entry(rep, "value is not an object [.'$geometry'.'|']", path);
    }
    return res;
}

// check $GeometryCollection (.'$GeometryCollection')
static bool json_model_12(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    // .'$GeometryCollection'
    if (unlikely(! json_is_object(val)))
    {
        if (rep) jm_report_add_entry(rep, "not an object [.'$GeometryCollection']", path);
        return false;
    }
    bool res;
    int64_t must_count = 0;
    const char *prop;
    json_t *pval;
    json_object_foreach((json_t *) val, prop, pval)
    {
        jm_path_t lpath_12 = (jm_path_t) { prop, 0, path, NULL };
        if (unlikely(jm_str_eq_5(prop, 0x0000000065707974LL)))
        {
            // handle must type property
            must_count += 1;
            // .'$GeometryCollection'.type
            res = json_is_string(pval) && jm_str_eq(json_string_value(pval), "GeometryCollection");
            if (unlikely(! res))
            {
                if (rep) jm_report_add_entry(rep, "unexpected GeometryCollection [.'$GeometryCollection'.type]", (path ? &lpath_12 : NULL));
                if (rep) jm_report_add_entry(rep, "invalid mandatory prop value [.'$GeometryCollection'.type]", (path ? &lpath_12 : NULL));
                return false;
            }
        }
        else if (unlikely(jm_str_eq_8(prop, 0x697274656d6f6567LL) && jm_str_eq_3(prop + 8, 0x00007365)))
        {
            // handle must geometries property
            must_count += 1;
            // .'$GeometryCollection'.geometries
            res = json_is_array(pval);
            if (res)
            {
                size_t arr_25_idx;
                json_t *arr_25_item;
                json_array_foreach(pval, arr_25_idx, arr_25_item)
                {
                    jm_path_t arr_25_lpath = (jm_path_t) { NULL, arr_25_idx, (path ? &lpath_12 : NULL), NULL };
                    // .'$GeometryCollection'.geometries.0
                    res = json_model_11(arr_25_item, ((path ? &lpath_12 : NULL) ? &arr_25_lpath : NULL), rep);
                    if (unlikely(! res))
                    {
                        if (rep) jm_report_add_entry(rep, "unexpected $geometry [.'$GeometryCollection'.geometries.0]", ((path ? &lpath_12 : NULL) ? &arr_25_lpath : NULL));
                        break;
                    }
                }
            }
            if (unlikely(! res))
            {
                if (rep) jm_report_add_entry(rep, "not array or unexpected array [.'$GeometryCollection'.geometries]", (path ? &lpath_12 : NULL));
                if (rep) jm_report_add_entry(rep, "invalid mandatory prop value [.'$GeometryCollection'.geometries]", (path ? &lpath_12 : NULL));
                return false;
            }
        }
        else if (unlikely(jm_str_eq_5(prop, 0x00000000786f6262LL)))
        {
            // handle may bbox property
            // .'$GeometryCollection'.bbox
            res = json_is_array(pval);
            if (res)
            {
                size_t arr_26_idx;
                json_t *arr_26_item;
                json_array_foreach(pval, arr_26_idx, arr_26_item)
                {
                    jm_path_t arr_26_lpath = (jm_path_t) { NULL, arr_26_idx, (path ? &lpath_12 : NULL), NULL };
                    // .'$GeometryCollection'.bbox.0
                    res = json_is_number(arr_26_item);
                    if (unlikely(! res))
                    {
                        if (rep) jm_report_add_entry(rep, "not a -1.0 loose float [.'$GeometryCollection'.bbox.0]", ((path ? &lpath_12 : NULL) ? &arr_26_lpath : NULL));
                        break;
                    }
                }
            }
            if (unlikely(! res))
            {
                if (rep) jm_report_add_entry(rep, "not array or unexpected array [.'$GeometryCollection'.bbox]", (path ? &lpath_12 : NULL));
                if (rep) jm_report_add_entry(rep, "invalid optional prop value [.'$GeometryCollection'.bbox]", (path ? &lpath_12 : NULL));
                return false;
            }
        }
        else
        {
            // accept any other props
        }
    }
    if (unlikely(must_count != 2))
    {
        if (likely(rep != NULL))
        {
            if (! (json_object_get(val, "geometries") != NULL))
            {
                if (rep) jm_report_add_entry(rep, "missing mandatory prop <geometries> [.'$GeometryCollection'.'']", path);
            }
            if (! (json_object_get(val, "type") != NULL))
            {
                if (rep) jm_report_add_entry(rep, "missing mandatory prop <type> [.'$GeometryCollection'.'']", path);
            }
        }
        return false;
    }
    return true;
}

// object .'$Feature'.properties.'|'.1
static INLINE bool _jm_obj_6(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    if (unlikely(! json_is_object(val)))
    {
        if (rep) jm_report_add_entry(rep, "not an object [.'$Feature'.properties.'|'.1]", path);
        return false;
    }
    // accept any object
    return true;
}

// check $Feature (.'$Feature')
static bool json_model_13(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    // .'$Feature'
    if (unlikely(! json_is_object(val)))
    {
        if (rep) jm_report_add_entry(rep, "not an object [.'$Feature']", path);
        return false;
    }
    bool res;
    int64_t must_count = 0;
    const char *prop;
    json_t *pval;
    json_object_foreach((json_t *) val, prop, pval)
    {
        jm_path_t lpath_13 = (jm_path_t) { prop, 0, path, NULL };
        if (unlikely(jm_str_eq_5(prop, 0x0000000065707974LL)))
        {
            // handle must type property
            must_count += 1;
            // .'$Feature'.type
            res = json_is_string(pval) && jm_str_eq_8(json_string_value(pval), 0x0065727574616546LL);
            if (unlikely(! res))
            {
                if (rep) jm_report_add_entry(rep, "unexpected Feature [.'$Feature'.type]", (path ? &lpath_13 : NULL));
                if (rep) jm_report_add_entry(rep, "invalid mandatory prop value [.'$Feature'.type]", (path ? &lpath_13 : NULL));
                return false;
            }
        }
        else if (unlikely(jm_str_eq_8(prop, 0x797274656d6f6567LL) && jm_str_eq_0(prop + 8)))
        {
            // handle must geometry property
            must_count += 1;
            // .'$Feature'.geometry
            // .'$Feature'.geometry.'|'.0
            res = json_is_null(pval);
            if (unlikely(! res))
            {
                if (rep) jm_report_add_entry(rep, "not null [.'$Feature'.geometry.'|'.0]", (path ? &lpath_13 : NULL));
            }
            if (! res)
            {
                // .'$Feature'.geometry.'|'.1
                res = json_model_11(pval, (path ? &lpath_13 : NULL), rep);
                if (unlikely(! res))
                {
                    if (rep) jm_report_add_entry(rep, "unexpected $geometry [.'$Feature'.geometry.'|'.1]", (path ? &lpath_13 : NULL));
                }
                if (! res)
                {
                    // .'$Feature'.geometry.'|'.2
                    res = json_model_12(pval, (path ? &lpath_13 : NULL), rep);
                    if (unlikely(! res))
                    {
                        if (rep) jm_report_add_entry(rep, "unexpected $GeometryCollection [.'$Feature'.geometry.'|'.2]", (path ? &lpath_13 : NULL));
                    }
                }
            }
            if (likely(res))
            {
                if (rep) jm_report_free_entries(rep);
            }
            else
            {
                if (rep) jm_report_add_entry(rep, "no model matched [.'$Feature'.geometry.'|']", (path ? &lpath_13 : NULL));
                if (rep) jm_report_add_entry(rep, "invalid mandatory prop value [.'$Feature'.geometry]", (path ? &lpath_13 : NULL));
                return false;
            }
        }
        else if (unlikely(jm_str_eq_8(prop, 0x69747265706f7270LL) && jm_str_eq_3(prop + 8, 0x00007365)))
        {
            // handle must properties property
            must_count += 1;
            // .'$Feature'.properties
            // .'$Feature'.properties.'|'.0
            res = json_is_null(pval);
            if (unlikely(! res))
            {
                if (rep) jm_report_add_entry(rep, "not null [.'$Feature'.properties.'|'.0]", (path ? &lpath_13 : NULL));
            }
            if (! res)
            {
                // .'$Feature'.properties.'|'.1
                res = _jm_obj_6(pval, (path ? &lpath_13 : NULL), rep);
                if (unlikely(! res))
                {
                    if (rep) jm_report_add_entry(rep, "unexpected element [.'$Feature'.properties.'|'.1]", (path ? &lpath_13 : NULL));
                }
            }
            if (likely(res))
            {
                if (rep) jm_report_free_entries(rep);
            }
            else
            {
                if (rep) jm_report_add_entry(rep, "no model matched [.'$Feature'.properties.'|']", (path ? &lpath_13 : NULL));
                if (rep) jm_report_add_entry(rep, "invalid mandatory prop value [.'$Feature'.properties]", (path ? &lpath_13 : NULL));
                return false;
            }
        }
        else if (unlikely(jm_str_eq_3(prop, 0x00006469)))
        {
            // handle may id property
            // .'$Feature'.id
            // .'$Feature'.id.'|'.0
            res = json_is_string(pval);
            if (unlikely(! res))
            {
                if (rep) jm_report_add_entry(rep, "unexpected string [.'$Feature'.id.'|'.0]", (path ? &lpath_13 : NULL));
            }
            if (! res)
            {
                // .'$Feature'.id.'|'.1
                res = json_is_number(pval);
                if (unlikely(! res))
                {
                    if (rep) jm_report_add_entry(rep, "not a -1.0 loose float [.'$Feature'.id.'|'.1]", (path ? &lpath_13 : NULL));
                }
            }
            if (likely(res))
            {
                if (rep) jm_report_free_entries(rep);
            }
            else
            {
                if (rep) jm_report_add_entry(rep, "no model matched [.'$Feature'.id.'|']", (path ? &lpath_13 : NULL));
                if (rep) jm_report_add_entry(rep, "invalid optional prop value [.'$Feature'.id]", (path ? &lpath_13 : NULL));
                return false;
            }
        }
        else if (unlikely(jm_str_eq_5(prop, 0x00000000786f6262LL)))
        {
            // handle may bbox property
            // .'$Feature'.bbox
            res = json_is_array(pval);
            if (res)
            {
                size_t arr_27_idx;
                json_t *arr_27_item;
                json_array_foreach(pval, arr_27_idx, arr_27_item)
                {
                    jm_path_t arr_27_lpath = (jm_path_t) { NULL, arr_27_idx, (path ? &lpath_13 : NULL), NULL };
                    // .'$Feature'.bbox.0
                    res = json_is_number(arr_27_item);
                    if (unlikely(! res))
                    {
                        if (rep) jm_report_add_entry(rep, "not a -1.0 loose float [.'$Feature'.bbox.0]", ((path ? &lpath_13 : NULL) ? &arr_27_lpath : NULL));
                        break;
                    }
                }
            }
            if (unlikely(! res))
            {
                if (rep) jm_report_add_entry(rep, "not array or unexpected array [.'$Feature'.bbox]", (path ? &lpath_13 : NULL));
                if (rep) jm_report_add_entry(rep, "invalid optional prop value [.'$Feature'.bbox]", (path ? &lpath_13 : NULL));
                return false;
            }
        }
        else
        {
            // accept any other props
        }
    }
    if (unlikely(must_count != 3))
    {
        if (likely(rep != NULL))
        {
            if (! (json_object_get(val, "geometry") != NULL))
            {
                if (rep) jm_report_add_entry(rep, "missing mandatory prop <geometry> [.'$Feature'.'']", path);
            }
            if (! (json_object_get(val, "properties") != NULL))
            {
                if (rep) jm_report_add_entry(rep, "missing mandatory prop <properties> [.'$Feature'.'']", path);
            }
            if (! (json_object_get(val, "type") != NULL))
            {
                if (rep) jm_report_add_entry(rep, "missing mandatory prop <type> [.'$Feature'.'']", path);
            }
        }
        return false;
    }
    return true;
}

// check $FeatureCollection (.'$FeatureCollection')
static bool json_model_14(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    // .'$FeatureCollection'
    if (unlikely(! json_is_object(val)))
    {
        if (rep) jm_report_add_entry(rep, "not an object [.'$FeatureCollection']", path);
        return false;
    }
    bool res;
    int64_t must_count = 0;
    const char *prop;
    json_t *pval;
    json_object_foreach((json_t *) val, prop, pval)
    {
        jm_path_t lpath_14 = (jm_path_t) { prop, 0, path, NULL };
        if (unlikely(jm_str_eq_5(prop, 0x0000000065707974LL)))
        {
            // handle must type property
            must_count += 1;
            // .'$FeatureCollection'.type
            res = json_is_string(pval) && jm_str_eq(json_string_value(pval), "FeatureCollection");
            if (unlikely(! res))
            {
                if (rep) jm_report_add_entry(rep, "unexpected FeatureCollection [.'$FeatureCollection'.type]", (path ? &lpath_14 : NULL));
                if (rep) jm_report_add_entry(rep, "invalid mandatory prop value [.'$FeatureCollection'.type]", (path ? &lpath_14 : NULL));
                return false;
            }
        }
        else if (unlikely(jm_str_eq_8(prop, 0x7365727574616566LL) && jm_str_eq_0(prop + 8)))
        {
            // handle must features property
            must_count += 1;
            // .'$FeatureCollection'.features
            res = json_is_array(pval);
            if (res)
            {
                size_t arr_28_idx;
                json_t *arr_28_item;
                json_array_foreach(pval, arr_28_idx, arr_28_item)
                {
                    jm_path_t arr_28_lpath = (jm_path_t) { NULL, arr_28_idx, (path ? &lpath_14 : NULL), NULL };
                    // .'$FeatureCollection'.features.0
                    res = json_model_13(arr_28_item, ((path ? &lpath_14 : NULL) ? &arr_28_lpath : NULL), rep);
                    if (unlikely(! res))
                    {
                        if (rep) jm_report_add_entry(rep, "unexpected $Feature [.'$FeatureCollection'.features.0]", ((path ? &lpath_14 : NULL) ? &arr_28_lpath : NULL));
                        break;
                    }
                }
            }
            if (unlikely(! res))
            {
                if (rep) jm_report_add_entry(rep, "not array or unexpected array [.'$FeatureCollection'.features]", (path ? &lpath_14 : NULL));
                if (rep) jm_report_add_entry(rep, "invalid mandatory prop value [.'$FeatureCollection'.features]", (path ? &lpath_14 : NULL));
                return false;
            }
        }
        else if (unlikely(jm_str_eq_5(prop, 0x00000000786f6262LL)))
        {
            // handle may bbox property
            // .'$FeatureCollection'.bbox
            res = json_is_array(pval);
            if (res)
            {
                size_t arr_29_idx;
                json_t *arr_29_item;
                json_array_foreach(pval, arr_29_idx, arr_29_item)
                {
                    jm_path_t arr_29_lpath = (jm_path_t) { NULL, arr_29_idx, (path ? &lpath_14 : NULL), NULL };
                    // .'$FeatureCollection'.bbox.0
                    res = json_is_number(arr_29_item);
                    if (unlikely(! res))
                    {
                        if (rep) jm_report_add_entry(rep, "not a -1.0 loose float [.'$FeatureCollection'.bbox.0]", ((path ? &lpath_14 : NULL) ? &arr_29_lpath : NULL));
                        break;
                    }
                }
            }
            if (unlikely(! res))
            {
                if (rep) jm_report_add_entry(rep, "not array or unexpected array [.'$FeatureCollection'.bbox]", (path ? &lpath_14 : NULL));
                if (rep) jm_report_add_entry(rep, "invalid optional prop value [.'$FeatureCollection'.bbox]", (path ? &lpath_14 : NULL));
                return false;
            }
        }
        else
        {
            // accept any other props
        }
    }
    if (unlikely(must_count != 2))
    {
        if (likely(rep != NULL))
        {
            if (! (json_object_get(val, "features") != NULL))
            {
                if (rep) jm_report_add_entry(rep, "missing mandatory prop <features> [.'$FeatureCollection'.'']", path);
            }
            if (! (json_object_get(val, "type") != NULL))
            {
                if (rep) jm_report_add_entry(rep, "missing mandatory prop <type> [.'$FeatureCollection'.'']", path);
            }
        }
        return false;
    }
    return true;
}

static INLINE jm_check_fun_t _jm_map_1(json_t *val)
{
    jm_constant_t cst;
    jm_set_cst(&cst, val);
    return jm_search_constmap(&cst, _jm_map_1_tab, 3);
}

// check $ (.)
static bool json_model_1(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // Geo JSON Model JSON_MODEL_LOOSE_FLOAT
    // .
    bool iso_1 = json_is_object(val);
    res = iso_1;
    if (likely(res))
    {
        if (likely(json_object_get(val, "type") != NULL))
        {
            json_t * tag_1 = json_object_get(val, "type");
            jm_check_fun_t fun_1 = _jm_map_1(tag_1);
            if (likely(fun_1 != NULL))
                res = fun_1(val, path, rep);
            else
            {
                res = false;
                if (rep) jm_report_add_entry(rep, "tag <type> value not found [.'|']", path);
            }
        }
        else
        {
            res = false;
            if (rep) jm_report_add_entry(rep, "tag prop <type> is missing [.'|']", path);
        }
    }
    else
    {
        if (rep) jm_report_add_entry(rep, "value is not an object [.'|']", path);
    }
    return res || json_model_11(val, path, rep);
}

jm_check_fun_t check_model_map(const char *pname)
{
    return jm_search_propmap(pname, check_model_map_tab, 14);
}

static bool initialized = false;

const char *check_model_init(void)
{
    if (!initialized)
    {
        initialized = true;
        jm_version_string = JSON_MODEL_VERSION;
        _jm_map_0_tab[0] = (jm_constmap_t) { (jm_constant_t) { cst_is_string, { .s = "Point" } }, _jm_obj_0 };
        _jm_map_0_tab[1] = (jm_constmap_t) { (jm_constant_t) { cst_is_string, { .s = "MultiPoint" } }, _jm_obj_1 };
        _jm_map_0_tab[2] = (jm_constmap_t) { (jm_constant_t) { cst_is_string, { .s = "LineString" } }, _jm_obj_2 };
        _jm_map_0_tab[3] = (jm_constmap_t) { (jm_constant_t) { cst_is_string, { .s = "MultiLineString" } }, _jm_obj_3 };
        _jm_map_0_tab[4] = (jm_constmap_t) { (jm_constant_t) { cst_is_string, { .s = "Polygon" } }, _jm_obj_4 };
        _jm_map_0_tab[5] = (jm_constmap_t) { (jm_constant_t) { cst_is_string, { .s = "MultiPolygon" } }, _jm_obj_5 };
        jm_sort_constmap(_jm_map_0_tab, 6);
        _jm_map_1_tab[0] = (jm_constmap_t) { (jm_constant_t) { cst_is_string, { .s = "GeometryCollection" } }, json_model_12 };
        _jm_map_1_tab[1] = (jm_constmap_t) { (jm_constant_t) { cst_is_string, { .s = "Feature" } }, json_model_13 };
        _jm_map_1_tab[2] = (jm_constmap_t) { (jm_constant_t) { cst_is_string, { .s = "FeatureCollection" } }, json_model_14 };
        jm_sort_constmap(_jm_map_1_tab, 3);
        check_model_map_tab[0] = (jm_propmap_t) { "", json_model_1 };
        check_model_map_tab[1] = (jm_propmap_t) { "position", json_model_2 };
        check_model_map_tab[2] = (jm_propmap_t) { "coord_array", json_model_3 };
        check_model_map_tab[3] = (jm_propmap_t) { "linear_ring", json_model_4 };
        check_model_map_tab[4] = (jm_propmap_t) { "Point", json_model_5 };
        check_model_map_tab[5] = (jm_propmap_t) { "MultiPoint", json_model_6 };
        check_model_map_tab[6] = (jm_propmap_t) { "LineString", json_model_7 };
        check_model_map_tab[7] = (jm_propmap_t) { "MultiLineString", json_model_8 };
        check_model_map_tab[8] = (jm_propmap_t) { "Polygon", json_model_9 };
        check_model_map_tab[9] = (jm_propmap_t) { "MultiPolygon", json_model_10 };
        check_model_map_tab[10] = (jm_propmap_t) { "geometry", json_model_11 };
        check_model_map_tab[11] = (jm_propmap_t) { "GeometryCollection", json_model_12 };
        check_model_map_tab[12] = (jm_propmap_t) { "Feature", json_model_13 };
        check_model_map_tab[13] = (jm_propmap_t) { "FeatureCollection", json_model_14 };
        jm_sort_propmap(check_model_map_tab, 14);
    }
    return NULL;
}

void check_model_free(void)
{
    if (initialized)
        initialized = false;

        // cleanup code
}

/*
 * # API
 *
 * ```c
 * bool error;
 * char *message;
 *
 * bool valid = check(json_value, "model-name", &error, &message);
 *
 * if (message)
 *    free(message), message = NULL;
 * ```
 *
 * - `error` is set of there was an error during initialization or if the model does not exists.
 * - `message` is provided if a non NULL pointer is passed, and must be freed by the caller.
 */
bool
check_model(const json_t *val, const char *name, bool *error, char **reasons)
{
    return jm_generic_entry(check_model_init, check_model_map, val, name, error, reasons);
}
