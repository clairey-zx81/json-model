#! /usr/bin/perl
#
# Generated by JSON Model Compiler version 2
# see https://github.com/clairey-zx81/json-model
#
use strict;
use warnings;
no warnings "uninitialized";
use re::engine::RE2;
use JSON::JsonModel;
use constant JMC_VERSION => '2';


sub json_model_2($$$);
sub json_model_3($$$);
sub json_model_4($$$);
sub _jm_obj_0($$$);
sub json_model_5($$$);
sub _jm_obj_1($$$);
sub json_model_6($$$);
sub _jm_obj_2($$$);
sub json_model_7($$$);
sub _jm_obj_3($$$);
sub json_model_8($$$);
sub _jm_obj_4($$$);
sub json_model_9($$$);
sub _jm_obj_5($$$);
sub json_model_10($$$);
sub _jm_obj_6($$$);
sub _jm_obj_7($$$);
sub _jm_obj_8($$$);
sub _jm_obj_9($$$);
sub _jm_obj_10($$$);
sub _jm_obj_11($$$);
my %_jm_map_0;
sub json_model_11($$$);
sub _jm_obj_12($$$);
sub json_model_12($$$);
sub _jm_obj_14($$$);
sub _jm_obj_13($$$);
sub json_model_13($$$);
sub _jm_obj_15($$$);
sub json_model_14($$$);
sub json_model_1($$$);
my %check_model_map;

# check $position (.'$position')
sub json_model_2($$$)
{
    my ($val, $path, $rep) = @_;
    my $res;
    # .'$position'
    # .'$position'.'@'
    $res = jm_is_array($val);
    if ($res)
    {
        for my $arr_0_idx (0 .. $#$val)
        {
            my $arr_0_item = $$val[$arr_0_idx];
            # .'$position'.'@'.0
            $res = jm_is_numeric($arr_0_item);
            if (! $res)
            {
                last;
            }
        }
    }
    if ($res)
    {
        my $ival_0 = scalar @$val;
        $res = $ival_0 <= 3 && $ival_0 >= 2;
    }
    return $res;
}

# check $coord_array (.'$coord_array')
sub json_model_3($$$)
{
    my ($val, $path, $rep) = @_;
    my $res;
    # .'$coord_array'
    # .'$coord_array'.'@'
    $res = jm_is_array($val);
    if ($res)
    {
        for my $arr_1_idx (0 .. $#$val)
        {
            my $arr_1_item = $$val[$arr_1_idx];
            # .'$coord_array'.'@'.0
            $res = json_model_2($arr_1_item, undef, $rep);
            if (! $res)
            {
                last;
            }
        }
    }
    if ($res)
    {
        my $ival_1 = scalar @$val;
        $res = $ival_1 >= 2;
    }
    return $res;
}

# check $linear_ring (.'$linear_ring')
sub json_model_4($$$)
{
    my ($val, $path, $rep) = @_;
    my $res;
    # .'$linear_ring'
    # .'$linear_ring'.'@'
    $res = jm_is_array($val);
    if ($res)
    {
        for my $arr_2_idx (0 .. $#$val)
        {
            my $arr_2_item = $$val[$arr_2_idx];
            # .'$linear_ring'.'@'.0
            $res = json_model_2($arr_2_item, undef, $rep);
            if (! $res)
            {
                last;
            }
        }
    }
    if ($res)
    {
        my $ival_2 = scalar @$val;
        $res = $ival_2 >= 4;
    }
    return $res;
}

# object .'$Point'
sub _jm_obj_0($$$)
{
    my ($val, $path, $rep) = @_;
    if (! jm_is_object($val))
    {
        return 0;
    }
    my $res;
    my $must_count = 0;
    scalar keys %$val;
    while (my ($prop, $pval) = each %$val)
    {
        if ($prop eq 'type')
        {
            # handle must type property
            $must_count++;
            # .'$Point'.type
            $res = jm_is_string($pval) && $pval eq 'Point';
            if (! $res)
            {
                return 0;
            }
        }
        elsif ($prop eq 'coordinates')
        {
            # handle must coordinates property
            $must_count++;
            # .'$Point'.coordinates
            $res = json_model_2($pval, undef, $rep);
            if (! $res)
            {
                return 0;
            }
        }
        elsif ($prop eq 'bbox')
        {
            # handle may bbox property
            # .'$Point'.bbox
            $res = jm_is_array($pval);
            if ($res)
            {
                for my $arr_3_idx (0 .. $#$pval)
                {
                    my $arr_3_item = $$pval[$arr_3_idx];
                    # .'$Point'.bbox.0
                    $res = jm_is_numeric($arr_3_item);
                    if (! $res)
                    {
                        last;
                    }
                }
            }
            if (! $res)
            {
                return 0;
            }
        }
        else
        {
            return 0;
        }
    }
    if ($must_count != 2)
    {
        return 0;
    }
    return 1;
}

# check $Point (.'$Point')
sub json_model_5($$$)
{
    my ($val, $path, $rep) = @_;
    my $res;
    # .'$Point'
    $res = _jm_obj_0($val, $path, $rep);
    return $res;
}

# object .'$MultiPoint'
sub _jm_obj_1($$$)
{
    my ($val, $path, $rep) = @_;
    if (! jm_is_object($val))
    {
        return 0;
    }
    my $res;
    my $must_count = 0;
    scalar keys %$val;
    while (my ($prop, $pval) = each %$val)
    {
        if ($prop eq 'type')
        {
            # handle must type property
            $must_count++;
            # .'$MultiPoint'.type
            $res = jm_is_string($pval) && $pval eq 'MultiPoint';
            if (! $res)
            {
                return 0;
            }
        }
        elsif ($prop eq 'coordinates')
        {
            # handle must coordinates property
            $must_count++;
            # .'$MultiPoint'.coordinates
            $res = jm_is_array($pval);
            if ($res)
            {
                for my $arr_4_idx (0 .. $#$pval)
                {
                    my $arr_4_item = $$pval[$arr_4_idx];
                    # .'$MultiPoint'.coordinates.0
                    $res = json_model_2($arr_4_item, undef, $rep);
                    if (! $res)
                    {
                        last;
                    }
                }
            }
            if (! $res)
            {
                return 0;
            }
        }
        elsif ($prop eq 'bbox')
        {
            # handle may bbox property
            # .'$MultiPoint'.bbox
            $res = jm_is_array($pval);
            if ($res)
            {
                for my $arr_5_idx (0 .. $#$pval)
                {
                    my $arr_5_item = $$pval[$arr_5_idx];
                    # .'$MultiPoint'.bbox.0
                    $res = jm_is_numeric($arr_5_item);
                    if (! $res)
                    {
                        last;
                    }
                }
            }
            if (! $res)
            {
                return 0;
            }
        }
        else
        {
            return 0;
        }
    }
    if ($must_count != 2)
    {
        return 0;
    }
    return 1;
}

# check $MultiPoint (.'$MultiPoint')
sub json_model_6($$$)
{
    my ($val, $path, $rep) = @_;
    my $res;
    # .'$MultiPoint'
    $res = _jm_obj_1($val, $path, $rep);
    return $res;
}

# object .'$LineString'
sub _jm_obj_2($$$)
{
    my ($val, $path, $rep) = @_;
    if (! jm_is_object($val))
    {
        return 0;
    }
    my $res;
    my $must_count = 0;
    scalar keys %$val;
    while (my ($prop, $pval) = each %$val)
    {
        if ($prop eq 'type')
        {
            # handle must type property
            $must_count++;
            # .'$LineString'.type
            $res = jm_is_string($pval) && $pval eq 'LineString';
            if (! $res)
            {
                return 0;
            }
        }
        elsif ($prop eq 'coordinates')
        {
            # handle must coordinates property
            $must_count++;
            # .'$LineString'.coordinates
            $res = json_model_3($pval, undef, $rep);
            if (! $res)
            {
                return 0;
            }
        }
        elsif ($prop eq 'bbox')
        {
            # handle may bbox property
            # .'$LineString'.bbox
            $res = jm_is_array($pval);
            if ($res)
            {
                for my $arr_6_idx (0 .. $#$pval)
                {
                    my $arr_6_item = $$pval[$arr_6_idx];
                    # .'$LineString'.bbox.0
                    $res = jm_is_numeric($arr_6_item);
                    if (! $res)
                    {
                        last;
                    }
                }
            }
            if (! $res)
            {
                return 0;
            }
        }
        else
        {
            return 0;
        }
    }
    if ($must_count != 2)
    {
        return 0;
    }
    return 1;
}

# check $LineString (.'$LineString')
sub json_model_7($$$)
{
    my ($val, $path, $rep) = @_;
    my $res;
    # .'$LineString'
    $res = _jm_obj_2($val, $path, $rep);
    return $res;
}

# object .'$MultiLineString'
sub _jm_obj_3($$$)
{
    my ($val, $path, $rep) = @_;
    if (! jm_is_object($val))
    {
        return 0;
    }
    my $res;
    my $must_count = 0;
    scalar keys %$val;
    while (my ($prop, $pval) = each %$val)
    {
        if ($prop eq 'type')
        {
            # handle must type property
            $must_count++;
            # .'$MultiLineString'.type
            $res = jm_is_string($pval) && $pval eq 'MultiLineString';
            if (! $res)
            {
                return 0;
            }
        }
        elsif ($prop eq 'coordinates')
        {
            # handle must coordinates property
            $must_count++;
            # .'$MultiLineString'.coordinates
            $res = jm_is_array($pval);
            if ($res)
            {
                for my $arr_7_idx (0 .. $#$pval)
                {
                    my $arr_7_item = $$pval[$arr_7_idx];
                    # .'$MultiLineString'.coordinates.0
                    $res = json_model_3($arr_7_item, undef, $rep);
                    if (! $res)
                    {
                        last;
                    }
                }
            }
            if (! $res)
            {
                return 0;
            }
        }
        elsif ($prop eq 'bbox')
        {
            # handle may bbox property
            # .'$MultiLineString'.bbox
            $res = jm_is_array($pval);
            if ($res)
            {
                for my $arr_8_idx (0 .. $#$pval)
                {
                    my $arr_8_item = $$pval[$arr_8_idx];
                    # .'$MultiLineString'.bbox.0
                    $res = jm_is_numeric($arr_8_item);
                    if (! $res)
                    {
                        last;
                    }
                }
            }
            if (! $res)
            {
                return 0;
            }
        }
        else
        {
            return 0;
        }
    }
    if ($must_count != 2)
    {
        return 0;
    }
    return 1;
}

# check $MultiLineString (.'$MultiLineString')
sub json_model_8($$$)
{
    my ($val, $path, $rep) = @_;
    my $res;
    # .'$MultiLineString'
    $res = _jm_obj_3($val, $path, $rep);
    return $res;
}

# object .'$Polygon'
sub _jm_obj_4($$$)
{
    my ($val, $path, $rep) = @_;
    if (! jm_is_object($val))
    {
        return 0;
    }
    my $res;
    my $must_count = 0;
    scalar keys %$val;
    while (my ($prop, $pval) = each %$val)
    {
        if ($prop eq 'type')
        {
            # handle must type property
            $must_count++;
            # .'$Polygon'.type
            $res = jm_is_string($pval) && $pval eq 'Polygon';
            if (! $res)
            {
                return 0;
            }
        }
        elsif ($prop eq 'coordinates')
        {
            # handle must coordinates property
            $must_count++;
            # .'$Polygon'.coordinates
            $res = jm_is_array($pval);
            if ($res)
            {
                for my $arr_9_idx (0 .. $#$pval)
                {
                    my $arr_9_item = $$pval[$arr_9_idx];
                    # .'$Polygon'.coordinates.0
                    $res = json_model_4($arr_9_item, undef, $rep);
                    if (! $res)
                    {
                        last;
                    }
                }
            }
            if (! $res)
            {
                return 0;
            }
        }
        elsif ($prop eq 'bbox')
        {
            # handle may bbox property
            # .'$Polygon'.bbox
            $res = jm_is_array($pval);
            if ($res)
            {
                for my $arr_10_idx (0 .. $#$pval)
                {
                    my $arr_10_item = $$pval[$arr_10_idx];
                    # .'$Polygon'.bbox.0
                    $res = jm_is_numeric($arr_10_item);
                    if (! $res)
                    {
                        last;
                    }
                }
            }
            if (! $res)
            {
                return 0;
            }
        }
        else
        {
            return 0;
        }
    }
    if ($must_count != 2)
    {
        return 0;
    }
    return 1;
}

# check $Polygon (.'$Polygon')
sub json_model_9($$$)
{
    my ($val, $path, $rep) = @_;
    my $res;
    # .'$Polygon'
    $res = _jm_obj_4($val, $path, $rep);
    return $res;
}

# object .'$MultiPolygon'
sub _jm_obj_5($$$)
{
    my ($val, $path, $rep) = @_;
    if (! jm_is_object($val))
    {
        return 0;
    }
    my $res;
    my $must_count = 0;
    scalar keys %$val;
    while (my ($prop, $pval) = each %$val)
    {
        if ($prop eq 'type')
        {
            # handle must type property
            $must_count++;
            # .'$MultiPolygon'.type
            $res = jm_is_string($pval) && $pval eq 'MultiPolygon';
            if (! $res)
            {
                return 0;
            }
        }
        elsif ($prop eq 'coordinates')
        {
            # handle must coordinates property
            $must_count++;
            # .'$MultiPolygon'.coordinates
            $res = jm_is_array($pval);
            if ($res)
            {
                for my $arr_11_idx (0 .. $#$pval)
                {
                    my $arr_11_item = $$pval[$arr_11_idx];
                    # .'$MultiPolygon'.coordinates.0
                    $res = jm_is_array($arr_11_item);
                    if ($res)
                    {
                        for my $arr_12_idx (0 .. $#$arr_11_item)
                        {
                            my $arr_12_item = $$arr_11_item[$arr_12_idx];
                            # .'$MultiPolygon'.coordinates.0.0
                            $res = json_model_4($arr_12_item, undef, $rep);
                            if (! $res)
                            {
                                last;
                            }
                        }
                    }
                    if (! $res)
                    {
                        last;
                    }
                }
            }
            if (! $res)
            {
                return 0;
            }
        }
        elsif ($prop eq 'bbox')
        {
            # handle may bbox property
            # .'$MultiPolygon'.bbox
            $res = jm_is_array($pval);
            if ($res)
            {
                for my $arr_13_idx (0 .. $#$pval)
                {
                    my $arr_13_item = $$pval[$arr_13_idx];
                    # .'$MultiPolygon'.bbox.0
                    $res = jm_is_numeric($arr_13_item);
                    if (! $res)
                    {
                        last;
                    }
                }
            }
            if (! $res)
            {
                return 0;
            }
        }
        else
        {
            return 0;
        }
    }
    if ($must_count != 2)
    {
        return 0;
    }
    return 1;
}

# check $MultiPolygon (.'$MultiPolygon')
sub json_model_10($$$)
{
    my ($val, $path, $rep) = @_;
    my $res;
    # .'$MultiPolygon'
    $res = _jm_obj_5($val, $path, $rep);
    return $res;
}

# object .'$geometry'.'|'.0
sub _jm_obj_6($$$)
{
    my ($val, $path, $rep) = @_;
    # check open must/may only props
    if (! jm_is_object($val))
    {
        return 0;
    }
    my $pval;
    my $res;
    if (! exists $$val{'type'})
    {
        return 0;
    }
    $pval = $$val{'type'};
    # .'$geometry'.'|'.0.type
    $res = jm_is_string($pval) && $pval eq 'Point';
    if (! $res)
    {
        return 0;
    }
    if (! exists $$val{'coordinates'})
    {
        return 0;
    }
    $pval = $$val{'coordinates'};
    # .'$geometry'.'|'.0.coordinates
    $res = json_model_2($pval, undef, $rep);
    if (! $res)
    {
        return 0;
    }
    if (exists $$val{'bbox'})
    {
        $pval = $$val{'bbox'};
        # .'$geometry'.'|'.0.bbox
        $res = jm_is_array($pval);
        if ($res)
        {
            for my $arr_14_idx (0 .. $#$pval)
            {
                my $arr_14_item = $$pval[$arr_14_idx];
                # .'$geometry'.'|'.0.bbox.0
                $res = jm_is_numeric($arr_14_item);
                if (! $res)
                {
                    last;
                }
            }
        }
        if (! $res)
        {
            return 0;
        }
    }
    return 1;
}

# object .'$geometry'.'|'.1
sub _jm_obj_7($$$)
{
    my ($val, $path, $rep) = @_;
    # check open must/may only props
    if (! jm_is_object($val))
    {
        return 0;
    }
    my $pval;
    my $res;
    if (! exists $$val{'type'})
    {
        return 0;
    }
    $pval = $$val{'type'};
    # .'$geometry'.'|'.1.type
    $res = jm_is_string($pval) && $pval eq 'MultiPoint';
    if (! $res)
    {
        return 0;
    }
    if (! exists $$val{'coordinates'})
    {
        return 0;
    }
    $pval = $$val{'coordinates'};
    # .'$geometry'.'|'.1.coordinates
    $res = jm_is_array($pval);
    if ($res)
    {
        for my $arr_15_idx (0 .. $#$pval)
        {
            my $arr_15_item = $$pval[$arr_15_idx];
            # .'$geometry'.'|'.1.coordinates.0
            $res = json_model_2($arr_15_item, undef, $rep);
            if (! $res)
            {
                last;
            }
        }
    }
    if (! $res)
    {
        return 0;
    }
    if (exists $$val{'bbox'})
    {
        $pval = $$val{'bbox'};
        # .'$geometry'.'|'.1.bbox
        $res = jm_is_array($pval);
        if ($res)
        {
            for my $arr_16_idx (0 .. $#$pval)
            {
                my $arr_16_item = $$pval[$arr_16_idx];
                # .'$geometry'.'|'.1.bbox.0
                $res = jm_is_numeric($arr_16_item);
                if (! $res)
                {
                    last;
                }
            }
        }
        if (! $res)
        {
            return 0;
        }
    }
    return 1;
}

# object .'$geometry'.'|'.2
sub _jm_obj_8($$$)
{
    my ($val, $path, $rep) = @_;
    # check open must/may only props
    if (! jm_is_object($val))
    {
        return 0;
    }
    my $pval;
    my $res;
    if (! exists $$val{'type'})
    {
        return 0;
    }
    $pval = $$val{'type'};
    # .'$geometry'.'|'.2.type
    $res = jm_is_string($pval) && $pval eq 'LineString';
    if (! $res)
    {
        return 0;
    }
    if (! exists $$val{'coordinates'})
    {
        return 0;
    }
    $pval = $$val{'coordinates'};
    # .'$geometry'.'|'.2.coordinates
    $res = json_model_3($pval, undef, $rep);
    if (! $res)
    {
        return 0;
    }
    if (exists $$val{'bbox'})
    {
        $pval = $$val{'bbox'};
        # .'$geometry'.'|'.2.bbox
        $res = jm_is_array($pval);
        if ($res)
        {
            for my $arr_17_idx (0 .. $#$pval)
            {
                my $arr_17_item = $$pval[$arr_17_idx];
                # .'$geometry'.'|'.2.bbox.0
                $res = jm_is_numeric($arr_17_item);
                if (! $res)
                {
                    last;
                }
            }
        }
        if (! $res)
        {
            return 0;
        }
    }
    return 1;
}

# object .'$geometry'.'|'.3
sub _jm_obj_9($$$)
{
    my ($val, $path, $rep) = @_;
    # check open must/may only props
    if (! jm_is_object($val))
    {
        return 0;
    }
    my $pval;
    my $res;
    if (! exists $$val{'type'})
    {
        return 0;
    }
    $pval = $$val{'type'};
    # .'$geometry'.'|'.3.type
    $res = jm_is_string($pval) && $pval eq 'MultiLineString';
    if (! $res)
    {
        return 0;
    }
    if (! exists $$val{'coordinates'})
    {
        return 0;
    }
    $pval = $$val{'coordinates'};
    # .'$geometry'.'|'.3.coordinates
    $res = jm_is_array($pval);
    if ($res)
    {
        for my $arr_18_idx (0 .. $#$pval)
        {
            my $arr_18_item = $$pval[$arr_18_idx];
            # .'$geometry'.'|'.3.coordinates.0
            $res = json_model_3($arr_18_item, undef, $rep);
            if (! $res)
            {
                last;
            }
        }
    }
    if (! $res)
    {
        return 0;
    }
    if (exists $$val{'bbox'})
    {
        $pval = $$val{'bbox'};
        # .'$geometry'.'|'.3.bbox
        $res = jm_is_array($pval);
        if ($res)
        {
            for my $arr_19_idx (0 .. $#$pval)
            {
                my $arr_19_item = $$pval[$arr_19_idx];
                # .'$geometry'.'|'.3.bbox.0
                $res = jm_is_numeric($arr_19_item);
                if (! $res)
                {
                    last;
                }
            }
        }
        if (! $res)
        {
            return 0;
        }
    }
    return 1;
}

# object .'$geometry'.'|'.4
sub _jm_obj_10($$$)
{
    my ($val, $path, $rep) = @_;
    # check open must/may only props
    if (! jm_is_object($val))
    {
        return 0;
    }
    my $pval;
    my $res;
    if (! exists $$val{'type'})
    {
        return 0;
    }
    $pval = $$val{'type'};
    # .'$geometry'.'|'.4.type
    $res = jm_is_string($pval) && $pval eq 'Polygon';
    if (! $res)
    {
        return 0;
    }
    if (! exists $$val{'coordinates'})
    {
        return 0;
    }
    $pval = $$val{'coordinates'};
    # .'$geometry'.'|'.4.coordinates
    $res = jm_is_array($pval);
    if ($res)
    {
        for my $arr_20_idx (0 .. $#$pval)
        {
            my $arr_20_item = $$pval[$arr_20_idx];
            # .'$geometry'.'|'.4.coordinates.0
            $res = json_model_4($arr_20_item, undef, $rep);
            if (! $res)
            {
                last;
            }
        }
    }
    if (! $res)
    {
        return 0;
    }
    if (exists $$val{'bbox'})
    {
        $pval = $$val{'bbox'};
        # .'$geometry'.'|'.4.bbox
        $res = jm_is_array($pval);
        if ($res)
        {
            for my $arr_21_idx (0 .. $#$pval)
            {
                my $arr_21_item = $$pval[$arr_21_idx];
                # .'$geometry'.'|'.4.bbox.0
                $res = jm_is_numeric($arr_21_item);
                if (! $res)
                {
                    last;
                }
            }
        }
        if (! $res)
        {
            return 0;
        }
    }
    return 1;
}

# object .'$geometry'.'|'.5
sub _jm_obj_11($$$)
{
    my ($val, $path, $rep) = @_;
    # check open must/may only props
    if (! jm_is_object($val))
    {
        return 0;
    }
    my $pval;
    my $res;
    if (! exists $$val{'type'})
    {
        return 0;
    }
    $pval = $$val{'type'};
    # .'$geometry'.'|'.5.type
    $res = jm_is_string($pval) && $pval eq 'MultiPolygon';
    if (! $res)
    {
        return 0;
    }
    if (! exists $$val{'coordinates'})
    {
        return 0;
    }
    $pval = $$val{'coordinates'};
    # .'$geometry'.'|'.5.coordinates
    $res = jm_is_array($pval);
    if ($res)
    {
        for my $arr_22_idx (0 .. $#$pval)
        {
            my $arr_22_item = $$pval[$arr_22_idx];
            # .'$geometry'.'|'.5.coordinates.0
            $res = jm_is_array($arr_22_item);
            if ($res)
            {
                for my $arr_23_idx (0 .. $#$arr_22_item)
                {
                    my $arr_23_item = $$arr_22_item[$arr_23_idx];
                    # .'$geometry'.'|'.5.coordinates.0.0
                    $res = json_model_4($arr_23_item, undef, $rep);
                    if (! $res)
                    {
                        last;
                    }
                }
            }
            if (! $res)
            {
                last;
            }
        }
    }
    if (! $res)
    {
        return 0;
    }
    if (exists $$val{'bbox'})
    {
        $pval = $$val{'bbox'};
        # .'$geometry'.'|'.5.bbox
        $res = jm_is_array($pval);
        if ($res)
        {
            for my $arr_24_idx (0 .. $#$pval)
            {
                my $arr_24_item = $$pval[$arr_24_idx];
                # .'$geometry'.'|'.5.bbox.0
                $res = jm_is_numeric($arr_24_item);
                if (! $res)
                {
                    last;
                }
            }
        }
        if (! $res)
        {
            return 0;
        }
    }
    return 1;
}


# check $geometry (.'$geometry')
sub json_model_11($$$)
{
    my ($val, $path, $rep) = @_;
    my $res;
    # .'$geometry'
    my $iso_0 = jm_is_object($val);
    $res = $iso_0;
    if ($res)
    {
        if (exists $$val{'type'})
        {
            my $tag_0 = $$val{'type'};
            my $fun_0 = $_jm_map_0{$tag_0};
            if (defined($fun_0))
            {
                $res = &$fun_0($val, $path, $rep);
            }
            else
            {
                $res = 0;
            }
        }
        else
        {
            $res = 0;
        }
    }
    return $res;
}

# object .'$GeometryCollection'
sub _jm_obj_12($$$)
{
    my ($val, $path, $rep) = @_;
    # check open must/may only props
    if (! jm_is_object($val))
    {
        return 0;
    }
    my $pval;
    my $res;
    if (! exists $$val{'type'})
    {
        return 0;
    }
    $pval = $$val{'type'};
    # .'$GeometryCollection'.type
    $res = jm_is_string($pval) && $pval eq 'GeometryCollection';
    if (! $res)
    {
        return 0;
    }
    if (! exists $$val{'geometries'})
    {
        return 0;
    }
    $pval = $$val{'geometries'};
    # .'$GeometryCollection'.geometries
    $res = jm_is_array($pval);
    if ($res)
    {
        for my $arr_25_idx (0 .. $#$pval)
        {
            my $arr_25_item = $$pval[$arr_25_idx];
            # .'$GeometryCollection'.geometries.0
            $res = json_model_11($arr_25_item, undef, $rep);
            if (! $res)
            {
                last;
            }
        }
    }
    if (! $res)
    {
        return 0;
    }
    if (exists $$val{'bbox'})
    {
        $pval = $$val{'bbox'};
        # .'$GeometryCollection'.bbox
        $res = jm_is_array($pval);
        if ($res)
        {
            for my $arr_26_idx (0 .. $#$pval)
            {
                my $arr_26_item = $$pval[$arr_26_idx];
                # .'$GeometryCollection'.bbox.0
                $res = jm_is_numeric($arr_26_item);
                if (! $res)
                {
                    last;
                }
            }
        }
        if (! $res)
        {
            return 0;
        }
    }
    return 1;
}

# check $GeometryCollection (.'$GeometryCollection')
sub json_model_12($$$)
{
    my ($val, $path, $rep) = @_;
    my $res;
    # .'$GeometryCollection'
    $res = _jm_obj_12($val, $path, $rep);
    return $res;
}

# object .'$Feature'.properties.'|'.1
sub _jm_obj_14($$$)
{
    my ($val, $path, $rep) = @_;
    if (! jm_is_object($val))
    {
        return 0;
    }
    # accept any object
    return 1;
}

# object .'$Feature'
sub _jm_obj_13($$$)
{
    my ($val, $path, $rep) = @_;
    # check open must/may only props
    if (! jm_is_object($val))
    {
        return 0;
    }
    my $pval;
    my $res;
    if (! exists $$val{'type'})
    {
        return 0;
    }
    $pval = $$val{'type'};
    # .'$Feature'.type
    $res = jm_is_string($pval) && $pval eq 'Feature';
    if (! $res)
    {
        return 0;
    }
    if (! exists $$val{'geometry'})
    {
        return 0;
    }
    $pval = $$val{'geometry'};
    # .'$Feature'.geometry
    # .'$Feature'.geometry.'|'.0
    $res = !defined($pval);
    if (! $res)
    {
        # .'$Feature'.geometry.'|'.1
        $res = json_model_11($pval, undef, $rep);
        if (! $res)
        {
            # .'$Feature'.geometry.'|'.2
            $res = _jm_obj_12($pval, undef, $rep);
        }
    }
    if (! $res)
    {
        return 0;
    }
    if (! exists $$val{'properties'})
    {
        return 0;
    }
    $pval = $$val{'properties'};
    # .'$Feature'.properties
    # .'$Feature'.properties.'|'.0
    $res = !defined($pval);
    if (! $res)
    {
        # .'$Feature'.properties.'|'.1
        $res = _jm_obj_14($pval, undef, $rep);
    }
    if (! $res)
    {
        return 0;
    }
    if (exists $$val{'id'})
    {
        $pval = $$val{'id'};
        # .'$Feature'.id
        # .'$Feature'.id.'|'.0
        $res = jm_is_string($pval);
        if (! $res)
        {
            # .'$Feature'.id.'|'.1
            $res = jm_is_numeric($pval);
        }
        if (! $res)
        {
            return 0;
        }
    }
    if (exists $$val{'bbox'})
    {
        $pval = $$val{'bbox'};
        # .'$Feature'.bbox
        $res = jm_is_array($pval);
        if ($res)
        {
            for my $arr_27_idx (0 .. $#$pval)
            {
                my $arr_27_item = $$pval[$arr_27_idx];
                # .'$Feature'.bbox.0
                $res = jm_is_numeric($arr_27_item);
                if (! $res)
                {
                    last;
                }
            }
        }
        if (! $res)
        {
            return 0;
        }
    }
    return 1;
}

# check $Feature (.'$Feature')
sub json_model_13($$$)
{
    my ($val, $path, $rep) = @_;
    my $res;
    # .'$Feature'
    $res = _jm_obj_13($val, $path, $rep);
    return $res;
}

# object .'$FeatureCollection'
sub _jm_obj_15($$$)
{
    my ($val, $path, $rep) = @_;
    # check open must/may only props
    if (! jm_is_object($val))
    {
        return 0;
    }
    my $pval;
    my $res;
    if (! exists $$val{'type'})
    {
        return 0;
    }
    $pval = $$val{'type'};
    # .'$FeatureCollection'.type
    $res = jm_is_string($pval) && $pval eq 'FeatureCollection';
    if (! $res)
    {
        return 0;
    }
    if (! exists $$val{'features'})
    {
        return 0;
    }
    $pval = $$val{'features'};
    # .'$FeatureCollection'.features
    $res = jm_is_array($pval);
    if ($res)
    {
        for my $arr_28_idx (0 .. $#$pval)
        {
            my $arr_28_item = $$pval[$arr_28_idx];
            # .'$FeatureCollection'.features.0
            $res = _jm_obj_13($arr_28_item, undef, $rep);
            if (! $res)
            {
                last;
            }
        }
    }
    if (! $res)
    {
        return 0;
    }
    if (exists $$val{'bbox'})
    {
        $pval = $$val{'bbox'};
        # .'$FeatureCollection'.bbox
        $res = jm_is_array($pval);
        if ($res)
        {
            for my $arr_29_idx (0 .. $#$pval)
            {
                my $arr_29_item = $$pval[$arr_29_idx];
                # .'$FeatureCollection'.bbox.0
                $res = jm_is_numeric($arr_29_item);
                if (! $res)
                {
                    last;
                }
            }
        }
        if (! $res)
        {
            return 0;
        }
    }
    return 1;
}

# check $FeatureCollection (.'$FeatureCollection')
sub json_model_14($$$)
{
    my ($val, $path, $rep) = @_;
    my $res;
    # .'$FeatureCollection'
    $res = _jm_obj_15($val, $path, $rep);
    return $res;
}

# check $ (.)
sub json_model_1($$$)
{
    my ($val, $path, $rep) = @_;
    my $res;
    # Geo JSON Model JSON_MODEL_LOOSE_FLOAT
    # .
    # generic xor list
    my $xc_0 = 0;
    my $xr_0;
    # .'^'.0
    $xr_0 = json_model_11($val, $path, $rep);
    if ($xr_0)
    {
        $xc_0++;
    }
    # .'^'.1
    $xr_0 = _jm_obj_12($val, $path, $rep);
    if ($xr_0)
    {
        $xc_0++;
    }
    if ($xc_0 <= 1)
    {
        # .'^'.2
        $xr_0 = _jm_obj_13($val, $path, $rep);
        if ($xr_0)
        {
            $xc_0++;
        }
    }
    if ($xc_0 <= 1)
    {
        # .'^'.3
        $xr_0 = _jm_obj_15($val, $path, $rep);
        if ($xr_0)
        {
            $xc_0++;
        }
    }
    $res = $xc_0 == 1;
    return $res;
}


# initialization of global variables

our $initialized = 0;

sub check_model_init()
{
    if (!$initialized)
    {
        $initialized = 1;
        %_jm_map_0 = (
            'Point' => \&_jm_obj_6,
            'MultiPoint' => \&_jm_obj_7,
            'LineString' => \&_jm_obj_8,
            'MultiLineString' => \&_jm_obj_9,
            'Polygon' => \&_jm_obj_10,
            'MultiPolygon' => \&_jm_obj_11,
        );
        %check_model_map = (
            '' => \&json_model_1,
            'position' => \&json_model_2,
            'coord_array' => \&json_model_3,
            'linear_ring' => \&json_model_4,
            'Point' => \&_jm_obj_0,
            'MultiPoint' => \&_jm_obj_1,
            'LineString' => \&_jm_obj_2,
            'MultiLineString' => \&_jm_obj_3,
            'Polygon' => \&_jm_obj_4,
            'MultiPolygon' => \&_jm_obj_5,
            'geometry' => \&json_model_11,
            'GeometryCollection' => \&_jm_obj_12,
            'Feature' => \&_jm_obj_13,
            'FeatureCollection' => \&_jm_obj_15,
        );
    }
}

sub check_model_free()
{
    if ($initialized)
    {
        $initialized = 0;
        %_jm_map_0 = ();
        %check_model_map = ();
    }
}

sub check_model($$$)
{
    my ($json, $name, $rep) = @_;
    die "unexpected model name \"$name\"" unless exists $check_model_map{$name};
    my $path = defined $rep ? [] : undef;
    return $check_model_map{$name}($json, $path, $rep);
}

#
# SCRIPT EXECUTION
#
check_model_init();
jm_main(\&check_model, \%check_model_map, JMC_VERSION);
check_model_free();
