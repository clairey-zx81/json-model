//
// Generated by JSON Model Compiler version 2
// see https://github.com/clairey-zx81/json-model
//

// regular expression engine
#include <stddef.h>
#include <cre2.h>

#include <json-model.h>
#define JSON_MODEL_VERSION "2"

static bool _jm_obj_0(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool json_model_2(const json_t *val, jm_path_t *path, jm_report_t *rep);
static jm_constmap_t _jm_map_0_tab[4];
static bool json_model_3(const json_t *val, jm_path_t *path, jm_report_t *rep);
static INLINE bool _jm_cst_0_str_test(const char *);
static bool json_model_4(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool json_model_5(const json_t *val, jm_path_t *path, jm_report_t *rep);
static INLINE bool _jm_cst_1_str_test(const char *);
static bool json_model_6(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool json_model_7(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool json_model_8(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool json_model_9(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool json_model_10(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool json_model_11(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool json_model_1(const json_t *val, jm_path_t *path, jm_report_t *rep);
jm_propmap_t check_model_map_tab[11];
const size_t check_model_map_size = 11;

// object .'$Schema'.metadata
static INLINE bool _jm_obj_0(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    if (unlikely(! json_is_object(val)))
    {
        if (rep) jm_report_add_entry(rep, "not an object [.'$Schema'.metadata]", path);
        return false;
    }
    bool res;
    const char *prop;
    json_t *pval;
    json_object_foreach((json_t *) val, prop, pval)
    {
        jm_path_t lpath_1 = (jm_path_t) { prop, 0, path, NULL };
        if (unlikely(jm_str_eq_5(prop, 0x0000000065746164LL)))
        {
            // handle may date property
            // .'$Schema'.metadata.date
            res = json_is_string(pval);
            if (unlikely(! res))
            {
                if (rep) jm_report_add_entry(rep, "unexpected string [.'$Schema'.metadata.date]", (path ? &lpath_1 : NULL));
                if (rep) jm_report_add_entry(rep, "invalid optional prop value [.'$Schema'.metadata.date]", (path ? &lpath_1 : NULL));
                return false;
            }
            continue;
        }
        else if (unlikely(jm_str_eq_5(prop, 0x00000000656d616eLL)))
        {
            // handle may name property
            // .'$Schema'.metadata.name
            res = json_is_string(pval);
            if (unlikely(! res))
            {
                if (rep) jm_report_add_entry(rep, "unexpected string [.'$Schema'.metadata.name]", (path ? &lpath_1 : NULL));
                if (rep) jm_report_add_entry(rep, "invalid optional prop value [.'$Schema'.metadata.name]", (path ? &lpath_1 : NULL));
                return false;
            }
            continue;
        }
        else if (jm_str_eq_8(prop, 0x0073726f68747561LL))
        {
            // handle may authors property
            // .'$Schema'.metadata.authors
            res = json_is_array(pval);
            if (likely(res))
            {
                size_t arr_1_idx;
                json_t *arr_1_item;
                json_array_foreach(pval, arr_1_idx, arr_1_item)
                {
                    jm_path_t arr_1_lpath = (jm_path_t) { NULL, arr_1_idx, (path ? &lpath_1 : NULL), NULL };
                    // .'$Schema'.metadata.authors.0
                    res = json_is_string(arr_1_item);
                    if (unlikely(! res))
                    {
                        if (rep) jm_report_add_entry(rep, "unexpected string [.'$Schema'.metadata.authors.0]", ((path ? &lpath_1 : NULL) ? &arr_1_lpath : NULL));
                        break;
                    }
                }
            }
            if (unlikely(! res))
            {
                if (rep) jm_report_add_entry(rep, "not array or unexpected array [.'$Schema'.metadata.authors]", (path ? &lpath_1 : NULL));
                if (rep) jm_report_add_entry(rep, "invalid optional prop value [.'$Schema'.metadata.authors]", (path ? &lpath_1 : NULL));
                return false;
            }
            continue;
        }
        else if (likely(jm_str_eq_8(prop, 0x73756f6976657270LL) && jm_str_eq_0(prop + 8)))
        {
            // handle may previous property
            // .'$Schema'.metadata.previous
            res = json_is_string(pval);
            if (unlikely(! res))
            {
                if (rep) jm_report_add_entry(rep, "unexpected string [.'$Schema'.metadata.previous]", (path ? &lpath_1 : NULL));
                if (rep) jm_report_add_entry(rep, "invalid optional prop value [.'$Schema'.metadata.previous]", (path ? &lpath_1 : NULL));
                return false;
            }
            continue;
        }
        if (rep) jm_report_add_entry(rep, "unexpected prop [.'$Schema'.metadata]", (path ? &lpath_1 : NULL));
        return false;
    }
    return true;
}

// check $Schema (.'$Schema')
static bool json_model_2(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    // .'$Schema'
    if (unlikely(! json_is_object(val)))
    {
        if (rep) jm_report_add_entry(rep, "not an object [.'$Schema']", path);
        return false;
    }
    bool res;
    int64_t must_count = 0;
    const char *prop;
    json_t *pval;
    json_object_foreach((json_t *) val, prop, pval)
    {
        jm_path_t lpath_0 = (jm_path_t) { prop, 0, path, NULL };
        if (likely(jm_str_eq_6(prop, 0x0000007365707974LL)))
        {
            // handle must types property
            must_count += 1;
            // .'$Schema'.types
            res = json_is_array(pval);
            if (likely(res))
            {
                size_t arr_0_idx;
                json_t *arr_0_item;
                json_array_foreach(pval, arr_0_idx, arr_0_item)
                {
                    jm_path_t arr_0_lpath = (jm_path_t) { NULL, arr_0_idx, (path ? &lpath_0 : NULL), NULL };
                    // .'$Schema'.types.0
                    res = json_model_3(arr_0_item, ((path ? &lpath_0 : NULL) ? &arr_0_lpath : NULL), rep);
                    if (unlikely(! res))
                    {
                        if (rep) jm_report_add_entry(rep, "unexpected $Type [.'$Schema'.types.0]", ((path ? &lpath_0 : NULL) ? &arr_0_lpath : NULL));
                        break;
                    }
                }
            }
            if (unlikely(! res))
            {
                if (rep) jm_report_add_entry(rep, "not array or unexpected array [.'$Schema'.types]", (path ? &lpath_0 : NULL));
                if (rep) jm_report_add_entry(rep, "invalid mandatory prop value [.'$Schema'.types]", (path ? &lpath_0 : NULL));
                return false;
            }
            continue;
        }
        if (likely(jm_str_eq_8(prop, 0x617461646174656dLL) && jm_str_eq_0(prop + 8)))
        {
            // handle may metadata property
            // .'$Schema'.metadata
            res = _jm_obj_0(pval, (path ? &lpath_0 : NULL), rep);
            if (unlikely(! res))
            {
                if (rep) jm_report_add_entry(rep, "unexpected element [.'$Schema'.metadata]", (path ? &lpath_0 : NULL));
                if (rep) jm_report_add_entry(rep, "invalid optional prop value [.'$Schema'.metadata]", (path ? &lpath_0 : NULL));
                return false;
            }
            continue;
        }
        if (rep) jm_report_add_entry(rep, "unexpected prop [.'$Schema']", (path ? &lpath_0 : NULL));
        return false;
    }
    if (unlikely(must_count != 1))
    {
        if (likely(rep != NULL))
        {
            if (! (json_object_get(val, "types") != NULL))
            {
                if (rep) jm_report_add_entry(rep, "missing mandatory prop <types> [.'$Schema']", path);
            }
        }
        return false;
    }
    return true;
}

static INLINE jm_check_fun_t _jm_map_0(json_t *val)
{
    jm_constant_t cst;
    jm_set_cst(&cst, val);
    return jm_search_constmap(&cst, _jm_map_0_tab, 4);
}

// check $Type (.'$Type')
static bool json_model_3(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .'$Type'
    bool iso_0 = json_is_object(val);
    res = iso_0;
    if (likely(res))
    {
        if (likely(json_object_get(val, "kind") != NULL))
        {
            json_t * tag_0 = json_object_get(val, "kind");
            jm_check_fun_t fun_0 = _jm_map_0(tag_0);
            if (likely(fun_0 != NULL))
                res = fun_0(val, path, rep);
            else
            {
                res = false;
                if (rep) jm_report_add_entry(rep, "tag <kind> value not found [.'$Type'.'|']", path);
            }
        }
        else
        {
            res = false;
            if (rep) jm_report_add_entry(rep, "tag prop <kind> is missing [.'$Type'.'|']", path);
        }
    }
    else
    {
        if (rep) jm_report_add_entry(rep, "value is not an object [.'$Type'.'|']", path);
    }
    return res;
}

static INLINE bool _jm_cst_0_str_test(const char *s)
{
    return
           jm_str_eq_5(s, 0x0000000065746164LL)  // "date"
        || jm_str_eq_5(s, 0x000000006c6c756eLL)  // "null"
        || jm_str_eq_5(s, 0x00000000656d6974LL)  // "time"
        || jm_str_eq_7(s, 0x0000495255796e61LL)  // "anyURI"
        || jm_str_eq_7(s, 0x0000656c62756f64LL)  // "double"
        || jm_str_eq_7(s, 0x0000676e69727473LL)  // "string"
        || jm_str_eq_8(s, 0x006e61656c6f6f62LL)  // "boolean"
        || jm_str_eq_8(s, 0x006c616d69636564LL)  // "decimal"
        || jm_str_eq_8(s, 0x0072656765746e69LL)  // "integer"
        || jm_str_eq_8(s, 0x656d695465746164LL) && jm_str_eq_0(s + 8)  // "dateTime"
        || jm_str_eq_8(s, 0x6e6f697461727564LL) && jm_str_eq_0(s + 8)  // "duration"
        || jm_str_eq_8(s, 0x72616e6942786568LL) && jm_str_eq_2(s + 8, 0x00000079)  // "hexBinary"
        || jm_str_eq_8(s, 0x6942343665736162LL) && jm_str_eq_5(s + 8, 0x000000007972616eLL)  // "base64Binary"
        || jm_str_eq_8(s, 0x656d695465746164LL) && jm_str_eq_6(s + 8, 0x000000706d617453LL)  // "dateTimeStamp"

    ;
}

// check $atomic-types (.'$atomic-types')
static bool json_model_4(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    // .'$atomic-types'
    bool res = json_is_string(val) && _jm_cst_0_str_test(json_string_value(val));
    if (unlikely(! res))
    {
        if (rep) jm_report_add_entry(rep, "value not in enum [.'$atomic-types'.'|']", path);
    }
    return res;
}

// check $atomic (.'$atomic')
static bool json_model_5(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    // .'$atomic'
    // .'$atomic'.'|'.0
    bool res = json_is_null(val);
    if (unlikely(! res))
    {
        if (rep) jm_report_add_entry(rep, "not null [.'$atomic'.'|'.0]", path);
    }
    if (! res)
    {
        // .'$atomic'.'|'.1
        res = json_is_boolean(val);
        if (unlikely(! res))
        {
            if (rep) jm_report_add_entry(rep, "not a bool [.'$atomic'.'|'.1]", path);
        }
        if (! res)
        {
            // .'$atomic'.'|'.2
            res = json_is_integer(val);
            if (unlikely(! res))
            {
                if (rep) jm_report_add_entry(rep, "not a -1 strict int [.'$atomic'.'|'.2]", path);
            }
            if (! res)
            {
                // .'$atomic'.'|'.3
                res = json_is_real(val);
                if (unlikely(! res))
                {
                    if (rep) jm_report_add_entry(rep, "not a -1.0 strict float [.'$atomic'.'|'.3]", path);
                }
                if (! res)
                {
                    // .'$atomic'.'|'.4
                    res = json_is_string(val);
                    if (unlikely(! res))
                    {
                        if (rep) jm_report_add_entry(rep, "unexpected string [.'$atomic'.'|'.4]", path);
                    }
                }
            }
        }
    }
    if (likely(res))
    {
        if (rep) jm_report_free_entries(rep);
    }
    else
    {
        if (rep) jm_report_add_entry(rep, "no model matched [.'$atomic'.'|']", path);
    }
    return res;
}

static INLINE bool _jm_cst_1_str_test(const char *s)
{
    return
           jm_str_eq_8(s, 0x6c616e6f6974706fLL) && jm_str_eq_0(s + 8)  // "optional"
        || jm_str_eq_8(s, 0x6465726975716572LL) && jm_str_eq_0(s + 8)  // "required"
        || jm_str_eq_8(s, 0x74696269686f7270LL) && jm_str_eq_3(s + 8, 0x00006465)  // "prohibited"

    ;
}

// check $Atomic (.'$Atomic')
static bool json_model_6(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    // could there be derived atomics as well?
    // .'$Atomic'
    if (unlikely(! json_is_object(val)))
    {
        if (rep) jm_report_add_entry(rep, "not an object [.'$Atomic']", path);
        return false;
    }
    bool res;
    int64_t must_count = 0;
    const char *prop;
    json_t *pval;
    json_object_foreach((json_t *) val, prop, pval)
    {
        jm_path_t lpath_2 = (jm_path_t) { prop, 0, path, NULL };
        if (unlikely(jm_str_eq_5(prop, 0x00000000646e696bLL)))
        {
            // handle must kind property
            must_count += 1;
            // .'$Atomic'.kind
            res = json_is_string(pval) && jm_str_eq_7(json_string_value(pval), 0x000063696d6f7461LL);
            if (unlikely(! res))
            {
                if (rep) jm_report_add_entry(rep, "unexpected atomic [.'$Atomic'.kind]", (path ? &lpath_2 : NULL));
                if (rep) jm_report_add_entry(rep, "invalid mandatory prop value [.'$Atomic'.kind]", (path ? &lpath_2 : NULL));
                return false;
            }
            continue;
        }
        else if (unlikely(jm_str_eq_8(prop, 0x6570795465736162LL) && jm_str_eq_0(prop + 8)))
        {
            // handle must baseType property
            must_count += 1;
            // .'$Atomic'.baseType
            res = json_model_4(pval, (path ? &lpath_2 : NULL), rep);
            if (unlikely(! res))
            {
                if (rep) jm_report_add_entry(rep, "unexpected $atomic-types [.'$Atomic'.baseType]", (path ? &lpath_2 : NULL));
                if (rep) jm_report_add_entry(rep, "invalid mandatory prop value [.'$Atomic'.baseType]", (path ? &lpath_2 : NULL));
                return false;
            }
            continue;
        }
        uint32_t hash_0 = *((uint32_t *) (prop));
        if (hash_0 <= 0x4c78616d)
        {
            if (jm_str_eq_8(prop, 0x74676e654c78616dLL) && jm_str_eq_2(prop + 8, 0x00000068))
            {
                // handle may maxLength property
                // .'$Atomic'.maxLength
                res = json_is_integer(pval) && json_integer_value(pval) >= 0;
                if (unlikely(! res))
                {
                    if (rep) jm_report_add_entry(rep, "not a 0 strict int [.'$Atomic'.maxLength]", (path ? &lpath_2 : NULL));
                    if (rep) jm_report_add_entry(rep, "invalid optional prop value [.'$Atomic'.maxLength]", (path ? &lpath_2 : NULL));
                    return false;
                }
                continue;
            }
            else if (jm_str_eq_8(prop, 0x74676e654c6e696dLL) && jm_str_eq_2(prop + 8, 0x00000068))
            {
                // handle may minLength property
                // .'$Atomic'.minLength
                res = json_is_integer(pval) && json_integer_value(pval) >= 0;
                if (unlikely(! res))
                {
                    if (rep) jm_report_add_entry(rep, "not a 0 strict int [.'$Atomic'.minLength]", (path ? &lpath_2 : NULL));
                    if (rep) jm_report_add_entry(rep, "invalid optional prop value [.'$Atomic'.minLength]", (path ? &lpath_2 : NULL));
                    return false;
                }
                continue;
            }
            else if (jm_str_eq_8(prop, 0x756c63784578616dLL) && jm_str_eq_5(prop + 8, 0x0000000065766973LL))
            {
                // handle may maxExclusive property
                // .'$Atomic'.maxExclusive
                res = json_model_5(pval, (path ? &lpath_2 : NULL), rep);
                if (unlikely(! res))
                {
                    if (rep) jm_report_add_entry(rep, "unexpected $atomic [.'$Atomic'.maxExclusive]", (path ? &lpath_2 : NULL));
                    if (rep) jm_report_add_entry(rep, "invalid optional prop value [.'$Atomic'.maxExclusive]", (path ? &lpath_2 : NULL));
                    return false;
                }
                continue;
            }
            else if (jm_str_eq_8(prop, 0x756c636e4978616dLL) && jm_str_eq_5(prop + 8, 0x0000000065766973LL))
            {
                // handle may maxInclusive property
                // .'$Atomic'.maxInclusive
                res = json_model_5(pval, (path ? &lpath_2 : NULL), rep);
                if (unlikely(! res))
                {
                    if (rep) jm_report_add_entry(rep, "unexpected $atomic [.'$Atomic'.maxInclusive]", (path ? &lpath_2 : NULL));
                    if (rep) jm_report_add_entry(rep, "invalid optional prop value [.'$Atomic'.maxInclusive]", (path ? &lpath_2 : NULL));
                    return false;
                }
                continue;
            }
            else if (jm_str_eq_8(prop, 0x756c6378456e696dLL) && jm_str_eq_5(prop + 8, 0x0000000065766973LL))
            {
                // handle may minExclusive property
                // .'$Atomic'.minExclusive
                res = json_model_5(pval, (path ? &lpath_2 : NULL), rep);
                if (unlikely(! res))
                {
                    if (rep) jm_report_add_entry(rep, "unexpected $atomic [.'$Atomic'.minExclusive]", (path ? &lpath_2 : NULL));
                    if (rep) jm_report_add_entry(rep, "invalid optional prop value [.'$Atomic'.minExclusive]", (path ? &lpath_2 : NULL));
                    return false;
                }
                continue;
            }
            else if (jm_str_eq_8(prop, 0x756c636e496e696dLL) && jm_str_eq_5(prop + 8, 0x0000000065766973LL))
            {
                // handle may minInclusive property
                // .'$Atomic'.minInclusive
                res = json_model_5(pval, (path ? &lpath_2 : NULL), rep);
                if (unlikely(! res))
                {
                    if (rep) jm_report_add_entry(rep, "unexpected $atomic [.'$Atomic'.minInclusive]", (path ? &lpath_2 : NULL));
                    if (rep) jm_report_add_entry(rep, "invalid optional prop value [.'$Atomic'.minInclusive]", (path ? &lpath_2 : NULL));
                    return false;
                }
                continue;
            }
        }
        else
        {
            if (jm_str_eq_5(prop, 0x00000000656d616eLL))
            {
                // handle may name property
                // .'$Atomic'.name
                res = json_is_string(pval);
                if (unlikely(! res))
                {
                    if (rep) jm_report_add_entry(rep, "unexpected string [.'$Atomic'.name]", (path ? &lpath_2 : NULL));
                    if (rep) jm_report_add_entry(rep, "invalid optional prop value [.'$Atomic'.name]", (path ? &lpath_2 : NULL));
                    return false;
                }
                continue;
            }
            else if (jm_str_eq_7(prop, 0x00006874676e656cLL))
            {
                // handle may length property
                // .'$Atomic'.length
                res = json_is_integer(pval) && json_integer_value(pval) >= 0;
                if (unlikely(! res))
                {
                    if (rep) jm_report_add_entry(rep, "not a 0 strict int [.'$Atomic'.length]", (path ? &lpath_2 : NULL));
                    if (rep) jm_report_add_entry(rep, "invalid optional prop value [.'$Atomic'.length]", (path ? &lpath_2 : NULL));
                    return false;
                }
                continue;
            }
            else if (jm_str_eq_8(prop, 0x006e726574746170LL))
            {
                // handle may pattern property
                // .'$Atomic'.pattern
                res = json_is_string(pval);
                if (unlikely(! res))
                {
                    if (rep) jm_report_add_entry(rep, "unexpected string [.'$Atomic'.pattern]", (path ? &lpath_2 : NULL));
                    if (rep) jm_report_add_entry(rep, "invalid optional prop value [.'$Atomic'.pattern]", (path ? &lpath_2 : NULL));
                    return false;
                }
                continue;
            }
            else if (jm_str_eq_8(prop, 0x746172656d756e65LL) && jm_str_eq_4(prop + 8, 0x006e6f69))
            {
                // handle may enumeration property
                // .'$Atomic'.enumeration
                res = json_is_array(pval);
                if (likely(res))
                {
                    size_t arr_2_idx;
                    json_t *arr_2_item;
                    json_array_foreach(pval, arr_2_idx, arr_2_item)
                    {
                        jm_path_t arr_2_lpath = (jm_path_t) { NULL, arr_2_idx, (path ? &lpath_2 : NULL), NULL };
                        // .'$Atomic'.enumeration.0
                        res = json_model_5(arr_2_item, ((path ? &lpath_2 : NULL) ? &arr_2_lpath : NULL), rep);
                        if (unlikely(! res))
                        {
                            if (rep) jm_report_add_entry(rep, "unexpected $atomic [.'$Atomic'.enumeration.0]", ((path ? &lpath_2 : NULL) ? &arr_2_lpath : NULL));
                            break;
                        }
                    }
                }
                if (unlikely(! res))
                {
                    if (rep) jm_report_add_entry(rep, "not array or unexpected array [.'$Atomic'.enumeration]", (path ? &lpath_2 : NULL));
                    if (rep) jm_report_add_entry(rep, "invalid optional prop value [.'$Atomic'.enumeration]", (path ? &lpath_2 : NULL));
                    return false;
                }
                continue;
            }
            else if (jm_str_eq_8(prop, 0x6769446c61746f74LL) && jm_str_eq_4(prop + 8, 0x00737469))
            {
                // handle may totalDigits property
                // .'$Atomic'.totalDigits
                res = json_is_integer(pval) && json_integer_value(pval) >= 0;
                if (unlikely(! res))
                {
                    if (rep) jm_report_add_entry(rep, "not a 0 strict int [.'$Atomic'.totalDigits]", (path ? &lpath_2 : NULL));
                    if (rep) jm_report_add_entry(rep, "invalid optional prop value [.'$Atomic'.totalDigits]", (path ? &lpath_2 : NULL));
                    return false;
                }
                continue;
            }
            else if (jm_str_eq_8(prop, 0x6e6f697463617266LL) && jm_str_eq_7(prop + 8, 0x0000737469676944LL))
            {
                // handle may fractionDigits property
                // .'$Atomic'.fractionDigits
                res = json_is_integer(pval) && json_integer_value(pval) >= 0;
                if (unlikely(! res))
                {
                    if (rep) jm_report_add_entry(rep, "not a 0 strict int [.'$Atomic'.fractionDigits]", (path ? &lpath_2 : NULL));
                    if (rep) jm_report_add_entry(rep, "invalid optional prop value [.'$Atomic'.fractionDigits]", (path ? &lpath_2 : NULL));
                    return false;
                }
                continue;
            }
            else if (jm_str_eq_8(prop, 0x746963696c707865LL) && jm_str_eq_8(prop + 8, 0x656e6f5a65707954LL) && jm_str_eq_0(prop + 16))
            {
                // handle may explicitTypeZone property
                // .'$Atomic'.explicitTypeZone
                res = json_is_string(pval) && _jm_cst_1_str_test(json_string_value(pval));
                if (unlikely(! res))
                {
                    if (rep) jm_report_add_entry(rep, "value not in enum [.'$Atomic'.explicitTypeZone.'|']", (path ? &lpath_2 : NULL));
                    if (rep) jm_report_add_entry(rep, "invalid optional prop value [.'$Atomic'.explicitTypeZone]", (path ? &lpath_2 : NULL));
                    return false;
                }
                continue;
            }
        }
        if (rep) jm_report_add_entry(rep, "unexpected prop [.'$Atomic']", (path ? &lpath_2 : NULL));
        return false;
    }
    if (unlikely(must_count != 2))
    {
        if (likely(rep != NULL))
        {
            if (! (json_object_get(val, "baseType") != NULL))
            {
                if (rep) jm_report_add_entry(rep, "missing mandatory prop <baseType> [.'$Atomic']", path);
            }
            if (! (json_object_get(val, "kind") != NULL))
            {
                if (rep) jm_report_add_entry(rep, "missing mandatory prop <kind> [.'$Atomic']", path);
            }
        }
        return false;
    }
    return true;
}

// check $Object (.'$Object')
static bool json_model_7(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    // .'$Object'
    if (unlikely(! json_is_object(val)))
    {
        if (rep) jm_report_add_entry(rep, "not an object [.'$Object']", path);
        return false;
    }
    bool res;
    int64_t must_count = 0;
    const char *prop;
    json_t *pval;
    json_object_foreach((json_t *) val, prop, pval)
    {
        jm_path_t lpath_3 = (jm_path_t) { prop, 0, path, NULL };
        if (unlikely(jm_str_eq_5(prop, 0x00000000646e696bLL)))
        {
            // handle must kind property
            must_count += 1;
            // .'$Object'.kind
            res = json_is_string(pval) && jm_str_eq_7(json_string_value(pval), 0x00007463656a626fLL);
            if (unlikely(! res))
            {
                if (rep) jm_report_add_entry(rep, "unexpected object [.'$Object'.kind]", (path ? &lpath_3 : NULL));
                if (rep) jm_report_add_entry(rep, "invalid mandatory prop value [.'$Object'.kind]", (path ? &lpath_3 : NULL));
                return false;
            }
            continue;
        }
        if (unlikely(jm_str_eq_5(prop, 0x00000000656d616eLL)))
        {
            // handle may name property
            // .'$Object'.name
            res = json_is_string(pval);
            if (unlikely(! res))
            {
                if (rep) jm_report_add_entry(rep, "unexpected string [.'$Object'.name]", (path ? &lpath_3 : NULL));
                if (rep) jm_report_add_entry(rep, "invalid optional prop value [.'$Object'.name]", (path ? &lpath_3 : NULL));
                return false;
            }
            continue;
        }
        else if (unlikely(jm_str_eq_7(prop, 0x00006465736f6c63LL)))
        {
            // handle may closed property
            // .'$Object'.closed
            res = json_is_boolean(pval);
            if (unlikely(! res))
            {
                if (rep) jm_report_add_entry(rep, "not a bool [.'$Object'.closed]", (path ? &lpath_3 : NULL));
                if (rep) jm_report_add_entry(rep, "invalid optional prop value [.'$Object'.closed]", (path ? &lpath_3 : NULL));
                return false;
            }
            continue;
        }
        else if (jm_str_eq_8(prop, 0x00746e65746e6f63LL))
        {
            // handle may content property
            // .'$Object'.content
            res = json_is_array(pval);
            if (likely(res))
            {
                size_t arr_3_idx;
                json_t *arr_3_item;
                json_array_foreach(pval, arr_3_idx, arr_3_item)
                {
                    jm_path_t arr_3_lpath = (jm_path_t) { NULL, arr_3_idx, (path ? &lpath_3 : NULL), NULL };
                    // .'$Object'.content.0
                    res = json_model_8(arr_3_item, ((path ? &lpath_3 : NULL) ? &arr_3_lpath : NULL), rep);
                    if (unlikely(! res))
                    {
                        if (rep) jm_report_add_entry(rep, "unexpected $Fields [.'$Object'.content.0]", ((path ? &lpath_3 : NULL) ? &arr_3_lpath : NULL));
                        break;
                    }
                }
            }
            if (unlikely(! res))
            {
                if (rep) jm_report_add_entry(rep, "not array or unexpected array [.'$Object'.content]", (path ? &lpath_3 : NULL));
                if (rep) jm_report_add_entry(rep, "invalid optional prop value [.'$Object'.content]", (path ? &lpath_3 : NULL));
                return false;
            }
            continue;
        }
        else if (likely(jm_str_eq_8(prop, 0x6570795465736162LL) && jm_str_eq_0(prop + 8)))
        {
            // handle may baseType property
            // .'$Object'.baseType
            res = json_is_string(pval);
            if (unlikely(! res))
            {
                if (rep) jm_report_add_entry(rep, "unexpected string [.'$Object'.baseType]", (path ? &lpath_3 : NULL));
                if (rep) jm_report_add_entry(rep, "invalid optional prop value [.'$Object'.baseType]", (path ? &lpath_3 : NULL));
                return false;
            }
            continue;
        }
        if (rep) jm_report_add_entry(rep, "unexpected prop [.'$Object']", (path ? &lpath_3 : NULL));
        return false;
    }
    if (unlikely(must_count != 1))
    {
        if (likely(rep != NULL))
        {
            if (! (json_object_get(val, "kind") != NULL))
            {
                if (rep) jm_report_add_entry(rep, "missing mandatory prop <kind> [.'$Object']", path);
            }
        }
        return false;
    }
    return true;
}

// check $Fields (.'$Fields')
static bool json_model_8(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    // .'$Fields'
    if (unlikely(! json_is_object(val)))
    {
        if (rep) jm_report_add_entry(rep, "not an object [.'$Fields']", path);
        return false;
    }
    bool res;
    int64_t must_count = 0;
    const char *prop;
    json_t *pval;
    json_object_foreach((json_t *) val, prop, pval)
    {
        jm_path_t lpath_4 = (jm_path_t) { prop, 0, path, NULL };
        if (unlikely(jm_str_eq_5(prop, 0x00000000656d616eLL)))
        {
            // handle must name property
            must_count += 1;
            // .'$Fields'.name
            res = json_is_string(pval);
            if (unlikely(! res))
            {
                if (rep) jm_report_add_entry(rep, "unexpected string [.'$Fields'.name]", (path ? &lpath_4 : NULL));
                if (rep) jm_report_add_entry(rep, "invalid mandatory prop value [.'$Fields'.name]", (path ? &lpath_4 : NULL));
                return false;
            }
            continue;
        }
        else if (unlikely(jm_str_eq_5(prop, 0x0000000065707974LL)))
        {
            // handle must type property
            must_count += 1;
            // .'$Fields'.type
            res = json_model_11(pval, (path ? &lpath_4 : NULL), rep);
            if (unlikely(! res))
            {
                if (rep) jm_report_add_entry(rep, "unexpected $type-or-ref [.'$Fields'.type]", (path ? &lpath_4 : NULL));
                if (rep) jm_report_add_entry(rep, "invalid mandatory prop value [.'$Fields'.type]", (path ? &lpath_4 : NULL));
                return false;
            }
            continue;
        }
        if (unlikely(jm_str_eq_7(prop, 0x0000657571696e75LL)))
        {
            // handle may unique property
            // .'$Fields'.unique
            res = json_is_boolean(pval);
            if (unlikely(! res))
            {
                if (rep) jm_report_add_entry(rep, "not a bool [.'$Fields'.unique]", (path ? &lpath_4 : NULL));
                if (rep) jm_report_add_entry(rep, "invalid optional prop value [.'$Fields'.unique]", (path ? &lpath_4 : NULL));
                return false;
            }
            continue;
        }
        else if (jm_str_eq_8(prop, 0x00746c7561666564LL))
        {
            // handle may default property
            // .'$Fields'.default
            res = true;
            continue;
        }
        else if (likely(jm_str_eq_8(prop, 0x6465726975716572LL) && jm_str_eq_0(prop + 8)))
        {
            // handle may required property
            // .'$Fields'.required
            res = json_is_boolean(pval);
            if (unlikely(! res))
            {
                if (rep) jm_report_add_entry(rep, "not a bool [.'$Fields'.required]", (path ? &lpath_4 : NULL));
                if (rep) jm_report_add_entry(rep, "invalid optional prop value [.'$Fields'.required]", (path ? &lpath_4 : NULL));
                return false;
            }
            continue;
        }
        if (rep) jm_report_add_entry(rep, "unexpected prop [.'$Fields']", (path ? &lpath_4 : NULL));
        return false;
    }
    if (unlikely(must_count != 2))
    {
        if (likely(rep != NULL))
        {
            if (! (json_object_get(val, "name") != NULL))
            {
                if (rep) jm_report_add_entry(rep, "missing mandatory prop <name> [.'$Fields']", path);
            }
            if (! (json_object_get(val, "type") != NULL))
            {
                if (rep) jm_report_add_entry(rep, "missing mandatory prop <type> [.'$Fields']", path);
            }
        }
        return false;
    }
    return true;
}

// check $Array (.'$Array')
static bool json_model_9(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    // WTF about 'content'?
    // .'$Array'
    if (unlikely(! json_is_object(val)))
    {
        if (rep) jm_report_add_entry(rep, "not an object [.'$Array']", path);
        return false;
    }
    bool res;
    int64_t must_count = 0;
    const char *prop;
    json_t *pval;
    json_object_foreach((json_t *) val, prop, pval)
    {
        jm_path_t lpath_5 = (jm_path_t) { prop, 0, path, NULL };
        if (unlikely(jm_str_eq_5(prop, 0x00000000646e696bLL)))
        {
            // handle must kind property
            must_count += 1;
            // .'$Array'.kind
            res = json_is_string(pval) && jm_str_eq_6(json_string_value(pval), 0x0000007961727261LL);
            if (unlikely(! res))
            {
                if (rep) jm_report_add_entry(rep, "unexpected array [.'$Array'.kind]", (path ? &lpath_5 : NULL));
                if (rep) jm_report_add_entry(rep, "invalid mandatory prop value [.'$Array'.kind]", (path ? &lpath_5 : NULL));
                return false;
            }
            continue;
        }
        if (unlikely(jm_str_eq_5(prop, 0x00000000656d616eLL)))
        {
            // handle may name property
            // .'$Array'.name
            res = json_is_string(pval);
            if (unlikely(! res))
            {
                if (rep) jm_report_add_entry(rep, "unexpected string [.'$Array'.name]", (path ? &lpath_5 : NULL));
                if (rep) jm_report_add_entry(rep, "invalid optional prop value [.'$Array'.name]", (path ? &lpath_5 : NULL));
                return false;
            }
            continue;
        }
        else if (unlikely(jm_str_eq_8(prop, 0x00746e65746e6f63LL)))
        {
            // handle may content property
            // .'$Array'.content
            res = json_model_11(pval, (path ? &lpath_5 : NULL), rep);
            if (unlikely(! res))
            {
                if (rep) jm_report_add_entry(rep, "unexpected $type-or-ref [.'$Array'.content]", (path ? &lpath_5 : NULL));
                if (rep) jm_report_add_entry(rep, "invalid optional prop value [.'$Array'.content]", (path ? &lpath_5 : NULL));
                return false;
            }
            continue;
        }
        else if (unlikely(jm_str_eq_8(prop, 0x6570795465736162LL) && jm_str_eq_0(prop + 8)))
        {
            // handle may baseType property
            // .'$Array'.baseType
            res = json_is_string(pval);
            if (unlikely(! res))
            {
                if (rep) jm_report_add_entry(rep, "unexpected string [.'$Array'.baseType]", (path ? &lpath_5 : NULL));
                if (rep) jm_report_add_entry(rep, "invalid optional prop value [.'$Array'.baseType]", (path ? &lpath_5 : NULL));
                return false;
            }
            continue;
        }
        else if (jm_str_eq_8(prop, 0x74676e654c78616dLL) && jm_str_eq_2(prop + 8, 0x00000068))
        {
            // handle may maxLength property
            // .'$Array'.maxLength
            res = json_is_integer(pval) && json_integer_value(pval) >= 0;
            if (unlikely(! res))
            {
                if (rep) jm_report_add_entry(rep, "not a 0 strict int [.'$Array'.maxLength]", (path ? &lpath_5 : NULL));
                if (rep) jm_report_add_entry(rep, "invalid optional prop value [.'$Array'.maxLength]", (path ? &lpath_5 : NULL));
                return false;
            }
            continue;
        }
        else if (likely(jm_str_eq_8(prop, 0x74676e654c6e696dLL) && jm_str_eq_2(prop + 8, 0x00000068)))
        {
            // handle may minLength property
            // .'$Array'.minLength
            res = json_is_integer(pval) && json_integer_value(pval) >= 0;
            if (unlikely(! res))
            {
                if (rep) jm_report_add_entry(rep, "not a 0 strict int [.'$Array'.minLength]", (path ? &lpath_5 : NULL));
                if (rep) jm_report_add_entry(rep, "invalid optional prop value [.'$Array'.minLength]", (path ? &lpath_5 : NULL));
                return false;
            }
            continue;
        }
        if (rep) jm_report_add_entry(rep, "unexpected prop [.'$Array']", (path ? &lpath_5 : NULL));
        return false;
    }
    if (unlikely(must_count != 1))
    {
        if (likely(rep != NULL))
        {
            if (! (json_object_get(val, "kind") != NULL))
            {
                if (rep) jm_report_add_entry(rep, "missing mandatory prop <kind> [.'$Array']", path);
            }
        }
        return false;
    }
    return true;
}

// check $Union (.'$Union')
static bool json_model_10(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    // jsound.jsound.json does not say that it is a typeâ€¦
    // .'$Union'
    if (unlikely(! json_is_object(val)))
    {
        if (rep) jm_report_add_entry(rep, "not an object [.'$Union']", path);
        return false;
    }
    bool res;
    int64_t must_count = 0;
    const char *prop;
    json_t *pval;
    json_object_foreach((json_t *) val, prop, pval)
    {
        jm_path_t lpath_6 = (jm_path_t) { prop, 0, path, NULL };
        if (unlikely(jm_str_eq_5(prop, 0x00000000646e696bLL)))
        {
            // handle must kind property
            must_count += 1;
            // .'$Union'.kind
            res = json_is_string(pval) && jm_str_eq_6(json_string_value(pval), 0x0000006e6f696e75LL);
            if (unlikely(! res))
            {
                if (rep) jm_report_add_entry(rep, "unexpected union [.'$Union'.kind]", (path ? &lpath_6 : NULL));
                if (rep) jm_report_add_entry(rep, "invalid mandatory prop value [.'$Union'.kind]", (path ? &lpath_6 : NULL));
                return false;
            }
            continue;
        }
        else if (unlikely(jm_str_eq_5(prop, 0x00000000656d616eLL)))
        {
            // handle must name property
            must_count += 1;
            // .'$Union'.name
            res = json_is_string(pval);
            if (unlikely(! res))
            {
                if (rep) jm_report_add_entry(rep, "unexpected string [.'$Union'.name]", (path ? &lpath_6 : NULL));
                if (rep) jm_report_add_entry(rep, "invalid mandatory prop value [.'$Union'.name]", (path ? &lpath_6 : NULL));
                return false;
            }
            continue;
        }
        else if (likely(jm_str_eq_8(prop, 0x00746e65746e6f63LL)))
        {
            // handle must content property
            must_count += 1;
            // .'$Union'.content
            res = json_is_array(pval);
            if (likely(res))
            {
                size_t arr_4_idx;
                json_t *arr_4_item;
                json_array_foreach(pval, arr_4_idx, arr_4_item)
                {
                    jm_path_t arr_4_lpath = (jm_path_t) { NULL, arr_4_idx, (path ? &lpath_6 : NULL), NULL };
                    // .'$Union'.content.0
                    res = json_model_11(arr_4_item, ((path ? &lpath_6 : NULL) ? &arr_4_lpath : NULL), rep);
                    if (unlikely(! res))
                    {
                        if (rep) jm_report_add_entry(rep, "unexpected $type-or-ref [.'$Union'.content.0]", ((path ? &lpath_6 : NULL) ? &arr_4_lpath : NULL));
                        break;
                    }
                }
            }
            if (unlikely(! res))
            {
                if (rep) jm_report_add_entry(rep, "not array or unexpected array [.'$Union'.content]", (path ? &lpath_6 : NULL));
                if (rep) jm_report_add_entry(rep, "invalid mandatory prop value [.'$Union'.content]", (path ? &lpath_6 : NULL));
                return false;
            }
            continue;
        }
        if (likely(jm_str_eq_8(prop, 0x6570795465736162LL) && jm_str_eq_0(prop + 8)))
        {
            // handle may baseType property
            // .'$Union'.baseType
            res = json_is_string(pval);
            if (unlikely(! res))
            {
                if (rep) jm_report_add_entry(rep, "unexpected string [.'$Union'.baseType]", (path ? &lpath_6 : NULL));
                if (rep) jm_report_add_entry(rep, "invalid optional prop value [.'$Union'.baseType]", (path ? &lpath_6 : NULL));
                return false;
            }
            continue;
        }
        if (rep) jm_report_add_entry(rep, "unexpected prop [.'$Union']", (path ? &lpath_6 : NULL));
        return false;
    }
    if (unlikely(must_count != 3))
    {
        if (likely(rep != NULL))
        {
            if (! (json_object_get(val, "content") != NULL))
            {
                if (rep) jm_report_add_entry(rep, "missing mandatory prop <content> [.'$Union']", path);
            }
            if (! (json_object_get(val, "kind") != NULL))
            {
                if (rep) jm_report_add_entry(rep, "missing mandatory prop <kind> [.'$Union']", path);
            }
            if (! (json_object_get(val, "name") != NULL))
            {
                if (rep) jm_report_add_entry(rep, "missing mandatory prop <name> [.'$Union']", path);
            }
        }
        return false;
    }
    return true;
}

// check $type-or-ref (.'$type-or-ref')
static bool json_model_11(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    // .'$type-or-ref'
    // .'$type-or-ref'.'|'.0
    bool res = json_is_string(val);
    if (unlikely(! res))
    {
        if (rep) jm_report_add_entry(rep, "unexpected string [.'$type-or-ref'.'|'.0]", path);
    }
    if (! res)
    {
        // .'$type-or-ref'.'|'.1
        res = json_model_3(val, path, rep);
        if (unlikely(! res))
        {
            if (rep) jm_report_add_entry(rep, "unexpected $Type [.'$type-or-ref'.'|'.1]", path);
        }
    }
    if (likely(res))
    {
        if (rep) jm_report_free_entries(rep);
    }
    else
    {
        if (rep) jm_report_add_entry(rep, "no model matched [.'$type-or-ref'.'|']", path);
    }
    return res;
}

// check $ (.)
static bool json_model_1(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    // .
    bool res = json_model_2(val, path, rep);
    if (unlikely(! res))
    {
        if (rep) jm_report_add_entry(rep, "unexpected $Schema [.]", path);
    }
    return res;
}

jm_check_fun_t check_model_map(const char *pname)
{
    return jm_search_propmap(pname, check_model_map_tab, 11);
}

static bool initialized = false;

const char *check_model_init(void)
{
    if (!initialized)
    {
        initialized = true;
        jm_version_string = JSON_MODEL_VERSION;
        _jm_map_0_tab[0] = (jm_constmap_t) { (jm_constant_t) { 7, { .s = "atomic" } }, json_model_6 };
        _jm_map_0_tab[1] = (jm_constmap_t) { (jm_constant_t) { 7, { .s = "object" } }, json_model_7 };
        _jm_map_0_tab[2] = (jm_constmap_t) { (jm_constant_t) { 6, { .s = "array" } }, json_model_9 };
        _jm_map_0_tab[3] = (jm_constmap_t) { (jm_constant_t) { 6, { .s = "union" } }, json_model_10 };
        jm_sort_constmap(_jm_map_0_tab, 4);
        check_model_map_tab[0] = (jm_propmap_t) { "", json_model_2 };
        check_model_map_tab[1] = (jm_propmap_t) { "Schema", json_model_2 };
        check_model_map_tab[2] = (jm_propmap_t) { "Type", json_model_3 };
        check_model_map_tab[3] = (jm_propmap_t) { "atomic-types", json_model_4 };
        check_model_map_tab[4] = (jm_propmap_t) { "atomic", json_model_5 };
        check_model_map_tab[5] = (jm_propmap_t) { "Atomic", json_model_6 };
        check_model_map_tab[6] = (jm_propmap_t) { "Object", json_model_7 };
        check_model_map_tab[7] = (jm_propmap_t) { "Fields", json_model_8 };
        check_model_map_tab[8] = (jm_propmap_t) { "Array", json_model_9 };
        check_model_map_tab[9] = (jm_propmap_t) { "Union", json_model_10 };
        check_model_map_tab[10] = (jm_propmap_t) { "type-or-ref", json_model_11 };
        jm_sort_propmap(check_model_map_tab, 11);
    }
    return NULL;
}

void check_model_free(void)
{
    if (initialized)
        initialized = false;

        // cleanup code
}

/*
 * # API
 *
 * ```c
 * bool error;
 * char *message;
 *
 * bool valid = check(json_value, "model-name", &error, &message);
 *
 * if (message)
 *    free(message), message = NULL;
 * ```
 *
 * - `error` is set of there was an error during initialization or if the model does not exists.
 * - `message` is provided if a non NULL pointer is passed, and must be freed by the caller.
 */
bool
check_model(const json_t *val, const char *name, bool *error, char **reasons)
{
    return jm_generic_entry(check_model_init, check_model_map, val, name, error, reasons);
}
