#! /bin/env python
#
# Generated by JSON Model Compiler version 2.0a0
# see https://github.com/clairey-zx81/json-model
#
from typing import Callable
import re2 as re
from json_model.runtime import *
__version__ = "2.0a0"

def check_model_fun(name: str) -> CheckFun:
    """Return check function for JSON model name."""
    return check_model_map[name]

# entry point for generated checkers
def check_model(val: Jsonable, name: str = "", rep: Report = None) -> bool:
    """Check val validity agains JSON Model name."""
    if name not in check_model_map:
        raise Exception(f"unexpected model name: {name}")
    checker = check_model_map[name]
    return checker(val, [], rep)

_jm_obj_1_may: PropMap
_jm_cst_0: set[str]
_jm_obj_2_must: PropMap
_jm_cst_1: set[str]
_jm_obj_2_may: PropMap
_jm_obj_3_may: PropMap
_jm_obj_4_must: PropMap
_jm_obj_4_may: PropMap
_jm_obj_5_may: PropMap
_jm_obj_6_must: PropMap
check_model_map: PropMap

# check _jm_obj_1_may_authors ($.'$Schema'.metadata.authors)
def _jm_f_0(val: Jsonable, path: Path, rep: Report) -> bool:
    res: bool
    # $.'$Schema'.metadata.authors
    res = isinstance(val, list)
    if res:
        for arr_1_idx, arr_1_item in enumerate(val):
            arr_1_lpath: Path = (path + [ arr_1_idx ]) if path is not None else None
            # $.'$Schema'.metadata.authors.0
            res = isinstance(arr_1_item, str)
            if not res:
                rep is None or rep.append(("unexpected string [$.'$Schema'.metadata.authors.0]", arr_1_lpath if path is not None else None))
            if not res:
                break
    if not res:
        rep is None or rep.append(("not array or unexpected array [$.'$Schema'.metadata.authors]", path))
    return res

# check _jm_obj_1_may_date ($.'$Schema'.metadata.date)
def _jm_f_1(val: Jsonable, path: Path, rep: Report) -> bool:
    res: bool
    # $.'$Schema'.metadata.date
    res = isinstance(val, str)
    if not res:
        rep is None or rep.append(("unexpected string [$.'$Schema'.metadata.date]", path))
    return res

# check _jm_obj_1_may_name ($.'$Schema'.metadata.name)
def _jm_f_2(val: Jsonable, path: Path, rep: Report) -> bool:
    res: bool
    # $.'$Schema'.metadata.name
    res = isinstance(val, str)
    if not res:
        rep is None or rep.append(("unexpected string [$.'$Schema'.metadata.name]", path))
    return res

# check _jm_obj_1_may_previous ($.'$Schema'.metadata.previous)
def _jm_f_3(val: Jsonable, path: Path, rep: Report) -> bool:
    res: bool
    # $.'$Schema'.metadata.previous
    res = isinstance(val, str)
    if not res:
        rep is None or rep.append(("unexpected string [$.'$Schema'.metadata.previous]", path))
    return res


# object $.'$Schema'.metadata
def _jm_obj_1(val: Jsonable, path: Path, rep: Report) -> bool:
    if not isinstance(val, dict):
        rep is None or rep.append(("not an object [$.'$Schema'.metadata]", path))
        return False
    pfun: CheckFun
    for prop, pval in val.items():
        assert isinstance(prop, str)
        lpath_1: Path = (path + [ prop ]) if path is not None else None
        if pfun := _jm_obj_1_may.get(prop):
            # handle {len(may)} may props
            if pfun != UNDEFINED and not pfun(pval, lpath_1 if path is not None else None, rep):
                rep is None or rep.append(("invalid may property value [$.'$Schema'.metadata]", lpath_1 if path is not None else None))
                return False
        else:
            rep is None or rep.append(("no other prop expected [$.'$Schema'.metadata]", lpath_1 if path is not None else None))
            return False
    return True

# object $.'$Schema'
def _jm_obj_0(val: Jsonable, path: Path, rep: Report) -> bool:
    if not isinstance(val, dict):
        rep is None or rep.append(("not an object [$.'$Schema']", path))
        return False
    res: bool
    must_count: int = 0
    for prop, pval in val.items():
        assert isinstance(prop, str)
        lpath_0: Path = (path + [ prop ]) if path is not None else None
        if prop == "types":
            # handle one must property
            must_count += 1
            # $.'$Schema'.types
            res = isinstance(pval, list)
            if res:
                for arr_0_idx, arr_0_item in enumerate(pval):
                    arr_0_lpath: Path = ((lpath_0 if path is not None else None) + [ arr_0_idx ]) if (lpath_0 if path is not None else None) is not None else None
                    # $.'$Schema'.types.0
                    res = json_model_3(arr_0_item, path, rep)
                    if not res:
                        rep is None or rep.append(("unexpected $Type [$.'$Schema'.types.0]", arr_0_lpath if (lpath_0 if path is not None else None) is not None else None))
                    if not res:
                        break
            if not res:
                rep is None or rep.append(("not array or unexpected array [$.'$Schema'.types]", lpath_0 if path is not None else None))
            if not res:
                rep is None or rep.append(("invalid must property value [$.'$Schema'.types]", lpath_0 if path is not None else None))
                return False
        elif prop == "metadata":
            # handle one may property
            # $.'$Schema'.metadata
            res = _jm_obj_1(pval, lpath_0 if path is not None else None, rep)
            if not res:
                rep is None or rep.append(("not an expected object at [$.'$Schema'.metadata]", lpath_0 if path is not None else None))
            if not res:
                rep is None or rep.append(("invalid may property value [$.'$Schema'.metadata]", lpath_0 if path is not None else None))
                return False
        else:
            rep is None or rep.append(("no other prop expected [$.'$Schema']", lpath_0 if path is not None else None))
            return False
    if must_count != 1:
        rep is None or rep.append(("missing must prop [$.'$Schema']", path))
        return False
    return True

# check $Schema ($.'$Schema')
def json_model_2(val: Jsonable, path: Path, rep: Report) -> bool:
    res: bool
    # $.'$Schema'
    res = _jm_obj_0(val, path, rep)
    if not res:
        rep is None or rep.append(("not an expected object at [$.'$Schema']", path))
    return res

# check $Type ($.'$Type')
def json_model_3(val: Jsonable, path: Path, rep: Report) -> bool:
    res: bool
    # $.'$Type'
    # $.'$Type'.'|'.0
    res = json_model_6(val, path, rep)
    if not res:
        rep is None or rep.append(("unexpected $Atomic [$.'$Type'.'|'.0]", path))
    if not res:
        # $.'$Type'.'|'.1
        res = json_model_7(val, path, rep)
        if not res:
            rep is None or rep.append(("unexpected $Object [$.'$Type'.'|'.1]", path))
        if not res:
            # $.'$Type'.'|'.2
            res = json_model_9(val, path, rep)
            if not res:
                rep is None or rep.append(("unexpected $Array [$.'$Type'.'|'.2]", path))
            if not res:
                # $.'$Type'.'|'.3
                res = json_model_10(val, path, rep)
                if not res:
                    rep is None or rep.append(("unexpected $Union [$.'$Type'.'|'.3]", path))
    if not res:
        rep is None or rep.append(("no model matched [$.'$Type'.'|']", path))
    return res


# check $atomic-types ($.'$atomic-types')
def json_model_4(val: Jsonable, path: Path, rep: Report) -> bool:
    res: bool
    # $.'$atomic-types'
    res = (val is None or isinstance(val, (bool, int, float, str))) and val in _jm_cst_0
    if not res:
        rep is None or rep.append(("value not in enum [$.'$atomic-types'.'|']", path))
    return res

# check $atomic ($.'$atomic')
def json_model_5(val: Jsonable, path: Path, rep: Report) -> bool:
    res: bool
    # $.'$atomic'
    # $.'$atomic'.'|'.0
    res = val is None
    if not res:
        rep is None or rep.append(("not null [$.'$atomic'.'|'.0]", path))
    if not res:
        # $.'$atomic'.'|'.1
        res = isinstance(val, bool)
        if not res:
            rep is None or rep.append(("not a bool [$.'$atomic'.'|'.1]", path))
        if not res:
            # $.'$atomic'.'|'.2
            res = isinstance(val, int) and not isinstance(val, bool)
            if not res:
                rep is None or rep.append(("not a -1 strict int [$.'$atomic'.'|'.2]", path))
            if not res:
                # $.'$atomic'.'|'.3
                res = isinstance(val, float)
                if not res:
                    rep is None or rep.append(("not a -1.0 strict float [$.'$atomic'.'|'.3]", path))
                if not res:
                    # $.'$atomic'.'|'.4
                    res = isinstance(val, str)
                    if not res:
                        rep is None or rep.append(("unexpected string [$.'$atomic'.'|'.4]", path))
    if not res:
        rep is None or rep.append(("no model matched [$.'$atomic'.'|']", path))
    return res

# check _jm_obj_2_must_baseType ($.'$Atomic'.baseType)
def _jm_f_4(val: Jsonable, path: Path, rep: Report) -> bool:
    res: bool
    # $.'$Atomic'.baseType
    res = json_model_4(val, path, rep)
    if not res:
        rep is None or rep.append(("unexpected $atomic-types [$.'$Atomic'.baseType]", path))
    return res

# check _jm_obj_2_must_kind ($.'$Atomic'.kind)
def _jm_f_5(val: Jsonable, path: Path, rep: Report) -> bool:
    res: bool
    # $.'$Atomic'.kind
    res = isinstance(val, str) and val == "atomic"
    if not res:
        rep is None or rep.append(("unexpected atomic [$.'$Atomic'.kind]", path))
    return res


# check _jm_obj_2_may_enumeration ($.'$Atomic'.enumeration)
def _jm_f_6(val: Jsonable, path: Path, rep: Report) -> bool:
    res: bool
    # $.'$Atomic'.enumeration
    res = isinstance(val, list)
    if res:
        for arr_2_idx, arr_2_item in enumerate(val):
            arr_2_lpath: Path = (path + [ arr_2_idx ]) if path is not None else None
            # $.'$Atomic'.enumeration.0
            res = json_model_5(arr_2_item, path, rep)
            if not res:
                rep is None or rep.append(("unexpected $atomic [$.'$Atomic'.enumeration.0]", arr_2_lpath if path is not None else None))
            if not res:
                break
    if not res:
        rep is None or rep.append(("not array or unexpected array [$.'$Atomic'.enumeration]", path))
    return res


# check _jm_obj_2_may_explicitTypeZone ($.'$Atomic'.explicitTypeZone)
def _jm_f_7(val: Jsonable, path: Path, rep: Report) -> bool:
    res: bool
    # $.'$Atomic'.explicitTypeZone
    res = (val is None or isinstance(val, (bool, int, float, str))) and val in _jm_cst_1
    if not res:
        rep is None or rep.append(("value not in enum [$.'$Atomic'.explicitTypeZone.'|']", path))
    return res

# check _jm_obj_2_may_fractionDigits ($.'$Atomic'.fractionDigits)
def _jm_f_8(val: Jsonable, path: Path, rep: Report) -> bool:
    res: bool
    # $.'$Atomic'.fractionDigits
    res = isinstance(val, int) and not isinstance(val, bool) and val >= 0
    if not res:
        rep is None or rep.append(("not a 0 strict int [$.'$Atomic'.fractionDigits]", path))
    return res

# check _jm_obj_2_may_length ($.'$Atomic'.length)
def _jm_f_9(val: Jsonable, path: Path, rep: Report) -> bool:
    res: bool
    # $.'$Atomic'.length
    res = isinstance(val, int) and not isinstance(val, bool) and val >= 0
    if not res:
        rep is None or rep.append(("not a 0 strict int [$.'$Atomic'.length]", path))
    return res

# check _jm_obj_2_may_maxExclusive ($.'$Atomic'.maxExclusive)
def _jm_f_10(val: Jsonable, path: Path, rep: Report) -> bool:
    res: bool
    # $.'$Atomic'.maxExclusive
    res = json_model_5(val, path, rep)
    if not res:
        rep is None or rep.append(("unexpected $atomic [$.'$Atomic'.maxExclusive]", path))
    return res

# check _jm_obj_2_may_maxInclusive ($.'$Atomic'.maxInclusive)
def _jm_f_11(val: Jsonable, path: Path, rep: Report) -> bool:
    res: bool
    # $.'$Atomic'.maxInclusive
    res = json_model_5(val, path, rep)
    if not res:
        rep is None or rep.append(("unexpected $atomic [$.'$Atomic'.maxInclusive]", path))
    return res

# check _jm_obj_2_may_maxLength ($.'$Atomic'.maxLength)
def _jm_f_12(val: Jsonable, path: Path, rep: Report) -> bool:
    res: bool
    # $.'$Atomic'.maxLength
    res = isinstance(val, int) and not isinstance(val, bool) and val >= 0
    if not res:
        rep is None or rep.append(("not a 0 strict int [$.'$Atomic'.maxLength]", path))
    return res

# check _jm_obj_2_may_minExclusive ($.'$Atomic'.minExclusive)
def _jm_f_13(val: Jsonable, path: Path, rep: Report) -> bool:
    res: bool
    # $.'$Atomic'.minExclusive
    res = json_model_5(val, path, rep)
    if not res:
        rep is None or rep.append(("unexpected $atomic [$.'$Atomic'.minExclusive]", path))
    return res

# check _jm_obj_2_may_minInclusive ($.'$Atomic'.minInclusive)
def _jm_f_14(val: Jsonable, path: Path, rep: Report) -> bool:
    res: bool
    # $.'$Atomic'.minInclusive
    res = json_model_5(val, path, rep)
    if not res:
        rep is None or rep.append(("unexpected $atomic [$.'$Atomic'.minInclusive]", path))
    return res

# check _jm_obj_2_may_minLength ($.'$Atomic'.minLength)
def _jm_f_15(val: Jsonable, path: Path, rep: Report) -> bool:
    res: bool
    # $.'$Atomic'.minLength
    res = isinstance(val, int) and not isinstance(val, bool) and val >= 0
    if not res:
        rep is None or rep.append(("not a 0 strict int [$.'$Atomic'.minLength]", path))
    return res

# check _jm_obj_2_may_name ($.'$Atomic'.name)
def _jm_f_16(val: Jsonable, path: Path, rep: Report) -> bool:
    res: bool
    # $.'$Atomic'.name
    res = isinstance(val, str)
    if not res:
        rep is None or rep.append(("unexpected string [$.'$Atomic'.name]", path))
    return res

# check _jm_obj_2_may_pattern ($.'$Atomic'.pattern)
def _jm_f_17(val: Jsonable, path: Path, rep: Report) -> bool:
    res: bool
    # $.'$Atomic'.pattern
    res = isinstance(val, str)
    if not res:
        rep is None or rep.append(("unexpected string [$.'$Atomic'.pattern]", path))
    return res

# check _jm_obj_2_may_totalDigits ($.'$Atomic'.totalDigits)
def _jm_f_18(val: Jsonable, path: Path, rep: Report) -> bool:
    res: bool
    # $.'$Atomic'.totalDigits
    res = isinstance(val, int) and not isinstance(val, bool) and val >= 0
    if not res:
        rep is None or rep.append(("not a 0 strict int [$.'$Atomic'.totalDigits]", path))
    return res


# object $.'$Atomic'
def _jm_obj_2(val: Jsonable, path: Path, rep: Report) -> bool:
    if not isinstance(val, dict):
        rep is None or rep.append(("not an object [$.'$Atomic']", path))
        return False
    pfun: CheckFun
    must_count: int = 0
    for prop, pval in val.items():
        assert isinstance(prop, str)
        lpath_2: Path = (path + [ prop ]) if path is not None else None
        if pfun := _jm_obj_2_must.get(prop):
            # handle 2 must props
            if pfun != UNDEFINED:
                must_count += 1
                if not pfun(pval, lpath_2 if path is not None else None, rep):
                    rep is None or rep.append(("invalid must property value [$.'$Atomic']", lpath_2 if path is not None else None))
                    return False
        elif pfun := _jm_obj_2_may.get(prop):
            # handle {len(may)} may props
            if pfun != UNDEFINED and not pfun(pval, lpath_2 if path is not None else None, rep):
                rep is None or rep.append(("invalid may property value [$.'$Atomic']", lpath_2 if path is not None else None))
                return False
        else:
            rep is None or rep.append(("no other prop expected [$.'$Atomic']", lpath_2 if path is not None else None))
            return False
    if must_count != 2:
        rep is None or rep.append(("missing must prop [$.'$Atomic']", path))
        return False
    return True

# check $Atomic ($.'$Atomic')
def json_model_6(val: Jsonable, path: Path, rep: Report) -> bool:
    res: bool
    # $.'$Atomic'
    res = _jm_obj_2(val, path, rep)
    if not res:
        rep is None or rep.append(("not an expected object at [$.'$Atomic']", path))
    return res

# check _jm_obj_3_may_baseType ($.'$Object'.baseType)
def _jm_f_19(val: Jsonable, path: Path, rep: Report) -> bool:
    res: bool
    # $.'$Object'.baseType
    res = isinstance(val, str)
    if not res:
        rep is None or rep.append(("unexpected string [$.'$Object'.baseType]", path))
    return res

# check _jm_obj_3_may_closed ($.'$Object'.closed)
def _jm_f_20(val: Jsonable, path: Path, rep: Report) -> bool:
    res: bool
    # $.'$Object'.closed
    res = isinstance(val, bool)
    if not res:
        rep is None or rep.append(("not a bool [$.'$Object'.closed]", path))
    return res

# check _jm_obj_3_may_content ($.'$Object'.content)
def _jm_f_21(val: Jsonable, path: Path, rep: Report) -> bool:
    res: bool
    # $.'$Object'.content
    res = isinstance(val, list)
    if res:
        for arr_3_idx, arr_3_item in enumerate(val):
            arr_3_lpath: Path = (path + [ arr_3_idx ]) if path is not None else None
            # $.'$Object'.content.0
            res = json_model_8(arr_3_item, path, rep)
            if not res:
                rep is None or rep.append(("unexpected $Fields [$.'$Object'.content.0]", arr_3_lpath if path is not None else None))
            if not res:
                break
    if not res:
        rep is None or rep.append(("not array or unexpected array [$.'$Object'.content]", path))
    return res

# check _jm_obj_3_may_name ($.'$Object'.name)
def _jm_f_22(val: Jsonable, path: Path, rep: Report) -> bool:
    res: bool
    # $.'$Object'.name
    res = isinstance(val, str)
    if not res:
        rep is None or rep.append(("unexpected string [$.'$Object'.name]", path))
    return res


# object $.'$Object'
def _jm_obj_3(val: Jsonable, path: Path, rep: Report) -> bool:
    if not isinstance(val, dict):
        rep is None or rep.append(("not an object [$.'$Object']", path))
        return False
    res: bool
    pfun: CheckFun
    must_count: int = 0
    for prop, pval in val.items():
        assert isinstance(prop, str)
        lpath_3: Path = (path + [ prop ]) if path is not None else None
        if prop == "kind":
            # handle one must property
            must_count += 1
            # $.'$Object'.kind
            res = isinstance(pval, str) and pval == "object"
            if not res:
                rep is None or rep.append(("unexpected object [$.'$Object'.kind]", lpath_3 if path is not None else None))
            if not res:
                rep is None or rep.append(("invalid must property value [$.'$Object'.kind]", lpath_3 if path is not None else None))
                return False
        elif pfun := _jm_obj_3_may.get(prop):
            # handle {len(may)} may props
            if pfun != UNDEFINED and not pfun(pval, lpath_3 if path is not None else None, rep):
                rep is None or rep.append(("invalid may property value [$.'$Object']", lpath_3 if path is not None else None))
                return False
        else:
            rep is None or rep.append(("no other prop expected [$.'$Object']", lpath_3 if path is not None else None))
            return False
    if must_count != 1:
        rep is None or rep.append(("missing must prop [$.'$Object']", path))
        return False
    return True

# check $Object ($.'$Object')
def json_model_7(val: Jsonable, path: Path, rep: Report) -> bool:
    res: bool
    # $.'$Object'
    res = _jm_obj_3(val, path, rep)
    if not res:
        rep is None or rep.append(("not an expected object at [$.'$Object']", path))
    return res

# check _jm_obj_4_must_name ($.'$Fields'.name)
def _jm_f_23(val: Jsonable, path: Path, rep: Report) -> bool:
    res: bool
    # $.'$Fields'.name
    res = isinstance(val, str)
    if not res:
        rep is None or rep.append(("unexpected string [$.'$Fields'.name]", path))
    return res

# check _jm_obj_4_must_type ($.'$Fields'.type)
def _jm_f_24(val: Jsonable, path: Path, rep: Report) -> bool:
    res: bool
    # $.'$Fields'.type
    res = json_model_11(val, path, rep)
    if not res:
        rep is None or rep.append(("unexpected $type-or-ref [$.'$Fields'.type]", path))
    return res


# check _jm_obj_4_may_default ($.'$Fields'.default)
def _jm_f_25(val: Jsonable, path: Path, rep: Report) -> bool:
    res: bool
    # $.'$Fields'.default
    res = True
    if not res:
        rep is None or rep.append(("unexpected $ANY [$.'$Fields'.default]", path))
    return res

# check _jm_obj_4_may_required ($.'$Fields'.required)
def _jm_f_26(val: Jsonable, path: Path, rep: Report) -> bool:
    res: bool
    # $.'$Fields'.required
    res = isinstance(val, bool)
    if not res:
        rep is None or rep.append(("not a bool [$.'$Fields'.required]", path))
    return res

# check _jm_obj_4_may_unique ($.'$Fields'.unique)
def _jm_f_27(val: Jsonable, path: Path, rep: Report) -> bool:
    res: bool
    # $.'$Fields'.unique
    res = isinstance(val, bool)
    if not res:
        rep is None or rep.append(("not a bool [$.'$Fields'.unique]", path))
    return res


# object $.'$Fields'
def _jm_obj_4(val: Jsonable, path: Path, rep: Report) -> bool:
    if not isinstance(val, dict):
        rep is None or rep.append(("not an object [$.'$Fields']", path))
        return False
    pfun: CheckFun
    must_count: int = 0
    for prop, pval in val.items():
        assert isinstance(prop, str)
        lpath_4: Path = (path + [ prop ]) if path is not None else None
        if pfun := _jm_obj_4_must.get(prop):
            # handle 2 must props
            if pfun != UNDEFINED:
                must_count += 1
                if not pfun(pval, lpath_4 if path is not None else None, rep):
                    rep is None or rep.append(("invalid must property value [$.'$Fields']", lpath_4 if path is not None else None))
                    return False
        elif pfun := _jm_obj_4_may.get(prop):
            # handle {len(may)} may props
            if pfun != UNDEFINED and not pfun(pval, lpath_4 if path is not None else None, rep):
                rep is None or rep.append(("invalid may property value [$.'$Fields']", lpath_4 if path is not None else None))
                return False
        else:
            rep is None or rep.append(("no other prop expected [$.'$Fields']", lpath_4 if path is not None else None))
            return False
    if must_count != 2:
        rep is None or rep.append(("missing must prop [$.'$Fields']", path))
        return False
    return True

# check $Fields ($.'$Fields')
def json_model_8(val: Jsonable, path: Path, rep: Report) -> bool:
    res: bool
    # $.'$Fields'
    res = _jm_obj_4(val, path, rep)
    if not res:
        rep is None or rep.append(("not an expected object at [$.'$Fields']", path))
    return res

# check _jm_obj_5_may_baseType ($.'$Array'.baseType)
def _jm_f_28(val: Jsonable, path: Path, rep: Report) -> bool:
    res: bool
    # $.'$Array'.baseType
    res = isinstance(val, str)
    if not res:
        rep is None or rep.append(("unexpected string [$.'$Array'.baseType]", path))
    return res

# check _jm_obj_5_may_content ($.'$Array'.content)
def _jm_f_29(val: Jsonable, path: Path, rep: Report) -> bool:
    res: bool
    # $.'$Array'.content
    res = json_model_11(val, path, rep)
    if not res:
        rep is None or rep.append(("unexpected $type-or-ref [$.'$Array'.content]", path))
    return res

# check _jm_obj_5_may_maxLength ($.'$Array'.maxLength)
def _jm_f_30(val: Jsonable, path: Path, rep: Report) -> bool:
    res: bool
    # $.'$Array'.maxLength
    res = isinstance(val, int) and not isinstance(val, bool) and val >= 0
    if not res:
        rep is None or rep.append(("not a 0 strict int [$.'$Array'.maxLength]", path))
    return res

# check _jm_obj_5_may_minLength ($.'$Array'.minLength)
def _jm_f_31(val: Jsonable, path: Path, rep: Report) -> bool:
    res: bool
    # $.'$Array'.minLength
    res = isinstance(val, int) and not isinstance(val, bool) and val >= 0
    if not res:
        rep is None or rep.append(("not a 0 strict int [$.'$Array'.minLength]", path))
    return res

# check _jm_obj_5_may_name ($.'$Array'.name)
def _jm_f_32(val: Jsonable, path: Path, rep: Report) -> bool:
    res: bool
    # $.'$Array'.name
    res = isinstance(val, str)
    if not res:
        rep is None or rep.append(("unexpected string [$.'$Array'.name]", path))
    return res


# object $.'$Array'
def _jm_obj_5(val: Jsonable, path: Path, rep: Report) -> bool:
    if not isinstance(val, dict):
        rep is None or rep.append(("not an object [$.'$Array']", path))
        return False
    res: bool
    pfun: CheckFun
    must_count: int = 0
    for prop, pval in val.items():
        assert isinstance(prop, str)
        lpath_5: Path = (path + [ prop ]) if path is not None else None
        if prop == "kind":
            # handle one must property
            must_count += 1
            # $.'$Array'.kind
            res = isinstance(pval, str) and pval == "array"
            if not res:
                rep is None or rep.append(("unexpected array [$.'$Array'.kind]", lpath_5 if path is not None else None))
            if not res:
                rep is None or rep.append(("invalid must property value [$.'$Array'.kind]", lpath_5 if path is not None else None))
                return False
        elif pfun := _jm_obj_5_may.get(prop):
            # handle {len(may)} may props
            if pfun != UNDEFINED and not pfun(pval, lpath_5 if path is not None else None, rep):
                rep is None or rep.append(("invalid may property value [$.'$Array']", lpath_5 if path is not None else None))
                return False
        else:
            rep is None or rep.append(("no other prop expected [$.'$Array']", lpath_5 if path is not None else None))
            return False
    if must_count != 1:
        rep is None or rep.append(("missing must prop [$.'$Array']", path))
        return False
    return True

# check $Array ($.'$Array')
def json_model_9(val: Jsonable, path: Path, rep: Report) -> bool:
    res: bool
    # $.'$Array'
    res = _jm_obj_5(val, path, rep)
    if not res:
        rep is None or rep.append(("not an expected object at [$.'$Array']", path))
    return res

# check _jm_obj_6_must_content ($.'$Union'.content)
def _jm_f_33(val: Jsonable, path: Path, rep: Report) -> bool:
    res: bool
    # $.'$Union'.content
    res = isinstance(val, list)
    if res:
        for arr_4_idx, arr_4_item in enumerate(val):
            arr_4_lpath: Path = (path + [ arr_4_idx ]) if path is not None else None
            # $.'$Union'.content.0
            res = json_model_11(arr_4_item, path, rep)
            if not res:
                rep is None or rep.append(("unexpected $type-or-ref [$.'$Union'.content.0]", arr_4_lpath if path is not None else None))
            if not res:
                break
    if not res:
        rep is None or rep.append(("not array or unexpected array [$.'$Union'.content]", path))
    return res

# check _jm_obj_6_must_kind ($.'$Union'.kind)
def _jm_f_34(val: Jsonable, path: Path, rep: Report) -> bool:
    res: bool
    # $.'$Union'.kind
    res = isinstance(val, str) and val == "union"
    if not res:
        rep is None or rep.append(("unexpected union [$.'$Union'.kind]", path))
    return res

# check _jm_obj_6_must_name ($.'$Union'.name)
def _jm_f_35(val: Jsonable, path: Path, rep: Report) -> bool:
    res: bool
    # $.'$Union'.name
    res = isinstance(val, str)
    if not res:
        rep is None or rep.append(("unexpected string [$.'$Union'.name]", path))
    return res


# object $.'$Union'
def _jm_obj_6(val: Jsonable, path: Path, rep: Report) -> bool:
    if not isinstance(val, dict):
        rep is None or rep.append(("not an object [$.'$Union']", path))
        return False
    res: bool
    pfun: CheckFun
    must_count: int = 0
    for prop, pval in val.items():
        assert isinstance(prop, str)
        lpath_6: Path = (path + [ prop ]) if path is not None else None
        if pfun := _jm_obj_6_must.get(prop):
            # handle 3 must props
            if pfun != UNDEFINED:
                must_count += 1
                if not pfun(pval, lpath_6 if path is not None else None, rep):
                    rep is None or rep.append(("invalid must property value [$.'$Union']", lpath_6 if path is not None else None))
                    return False
        elif prop == "baseType":
            # handle one may property
            # $.'$Union'.baseType
            res = isinstance(pval, str)
            if not res:
                rep is None or rep.append(("unexpected string [$.'$Union'.baseType]", lpath_6 if path is not None else None))
            if not res:
                rep is None or rep.append(("invalid may property value [$.'$Union'.baseType]", lpath_6 if path is not None else None))
                return False
        else:
            rep is None or rep.append(("no other prop expected [$.'$Union']", lpath_6 if path is not None else None))
            return False
    if must_count != 3:
        rep is None or rep.append(("missing must prop [$.'$Union']", path))
        return False
    return True

# check $Union ($.'$Union')
def json_model_10(val: Jsonable, path: Path, rep: Report) -> bool:
    res: bool
    # $.'$Union'
    res = _jm_obj_6(val, path, rep)
    if not res:
        rep is None or rep.append(("not an expected object at [$.'$Union']", path))
    return res

# check $type-or-ref ($.'$type-or-ref')
def json_model_11(val: Jsonable, path: Path, rep: Report) -> bool:
    res: bool
    # $.'$type-or-ref'
    # $.'$type-or-ref'.'|'.0
    res = isinstance(val, str)
    if not res:
        rep is None or rep.append(("unexpected string [$.'$type-or-ref'.'|'.0]", path))
    if not res:
        # $.'$type-or-ref'.'|'.1
        res = json_model_3(val, path, rep)
        if not res:
            rep is None or rep.append(("unexpected $Type [$.'$type-or-ref'.'|'.1]", path))
    if not res:
        rep is None or rep.append(("no model matched [$.'$type-or-ref'.'|']", path))
    return res

# check $ ($)
def json_model_1(val: Jsonable, path: Path, rep: Report) -> bool:
    res: bool
    # $
    res = json_model_2(val, path, rep)
    if not res:
        rep is None or rep.append(("unexpected $Schema [$]", path))
    return res


# initialization guard
initialized: bool = False

# differed module initializations
def check_model_init():
    global initialized
    if not initialized:
        initialized = True
        global _jm_obj_1_may
        _jm_obj_1_may = {
            "authors": _jm_f_0,
            "date": _jm_f_1,
            "name": _jm_f_2,
            "previous": _jm_f_3,
        }
        global _jm_cst_0
        _jm_cst_0 = {'anyURI', 'base64Binary', 'boolean', 'date', 'dateTime', 'dateTimeStamp', 'decimal', 'double', 'duration', 'hexBinary', 'integer', 'null', 'string', 'time'}
        global _jm_obj_2_must
        _jm_obj_2_must = {
            "baseType": _jm_f_4,
            "kind": _jm_f_5,
        }
        global _jm_cst_1
        _jm_cst_1 = {'optional', 'prohibited', 'required'}
        global _jm_obj_2_may
        _jm_obj_2_may = {
            "enumeration": _jm_f_6,
            "explicitTypeZone": _jm_f_7,
            "fractionDigits": _jm_f_8,
            "length": _jm_f_9,
            "maxExclusive": _jm_f_10,
            "maxInclusive": _jm_f_11,
            "maxLength": _jm_f_12,
            "minExclusive": _jm_f_13,
            "minInclusive": _jm_f_14,
            "minLength": _jm_f_15,
            "name": _jm_f_16,
            "pattern": _jm_f_17,
            "totalDigits": _jm_f_18,
        }
        global _jm_obj_3_may
        _jm_obj_3_may = {
            "baseType": _jm_f_19,
            "closed": _jm_f_20,
            "content": _jm_f_21,
            "name": _jm_f_22,
        }
        global _jm_obj_4_must
        _jm_obj_4_must = {
            "name": _jm_f_23,
            "type": _jm_f_24,
        }
        global _jm_obj_4_may
        _jm_obj_4_may = {
            "default": _jm_f_25,
            "required": _jm_f_26,
            "unique": _jm_f_27,
        }
        global _jm_obj_5_may
        _jm_obj_5_may = {
            "baseType": _jm_f_28,
            "content": _jm_f_29,
            "maxLength": _jm_f_30,
            "minLength": _jm_f_31,
            "name": _jm_f_32,
        }
        global _jm_obj_6_must
        _jm_obj_6_must = {
            "content": _jm_f_33,
            "kind": _jm_f_34,
            "name": _jm_f_35,
        }
        global check_model_map
        check_model_map = {
            "": json_model_1,
            "Schema": json_model_2,
            "Type": json_model_3,
            "atomic-types": json_model_4,
            "atomic": json_model_5,
            "Atomic": json_model_6,
            "Object": json_model_7,
            "Fields": json_model_8,
            "Array": json_model_9,
            "Union": json_model_10,
            "type-or-ref": json_model_11,
        }

# differed module cleanup
def check_model_free():
    global initialized
    if initialized:
        initialized = False


if __name__ == "__main__":
    check_model_init()
    main(check_model_fun, check_model_map, __version__)
    check_model_free()
