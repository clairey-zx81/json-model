#! /usr/bin/perl
#
# Generated by JSON Model Compiler version 2
# see https://github.com/clairey-zx81/json-model
#
use strict;
use warnings;
no warnings "uninitialized";
use re::engine::RE2;
use JSON::JsonModel;
use constant JMC_VERSION => '2';


sub _jm_obj_0($$$);
sub json_model_2($$$);
my %_jm_map_0;
sub json_model_3($$$);
my %_jm_cst_0;
sub json_model_4($$$);
sub json_model_5($$$);
sub _jm_f_0($$$);
my %_jm_cst_1;
sub _jm_f_1($$$);
sub _jm_f_2($$$);
sub _jm_f_3($$$);
sub _jm_f_4($$$);
sub _jm_f_5($$$);
sub _jm_f_6($$$);
sub _jm_f_7($$$);
sub _jm_f_8($$$);
my %json_model_6_map;
sub json_model_6($$$);
sub json_model_7($$$);
sub json_model_8($$$);
sub json_model_9($$$);
sub json_model_10($$$);
sub json_model_11($$$);
sub json_model_1($$$);
my %check_model_map;

# object .'$Schema'.metadata
sub _jm_obj_0($$$)
{
    my ($val, $path, $rep) = @_;
    if (! jm_is_object($val))
    {
        return 0;
    }
    my $res;
    scalar keys %$val;
    while (my ($prop, $pval) = each %$val)
    {
        if ($prop eq 'name')
        {
            # handle may name property
            # .'$Schema'.metadata.name
            $res = jm_is_string($pval);
            if (! $res)
            {
                return 0;
            }
        }
        elsif ($prop eq 'previous')
        {
            # handle may previous property
            # .'$Schema'.metadata.previous
            $res = jm_is_string($pval);
            if (! $res)
            {
                return 0;
            }
        }
        elsif ($prop eq 'date')
        {
            # handle may date property
            # .'$Schema'.metadata.date
            $res = jm_is_string($pval);
            if (! $res)
            {
                return 0;
            }
        }
        elsif ($prop eq 'authors')
        {
            # handle may authors property
            # .'$Schema'.metadata.authors
            $res = jm_is_array($pval);
            if ($res)
            {
                for my $arr_1_idx (0 .. $#$pval)
                {
                    my $arr_1_item = $$pval[$arr_1_idx];
                    # .'$Schema'.metadata.authors.0
                    $res = jm_is_string($arr_1_item);
                    if (! $res)
                    {
                        last;
                    }
                }
            }
            if (! $res)
            {
                return 0;
            }
        }
        else
        {
            return 0;
        }
    }
    return 1;
}

# check $Schema (.'$Schema')
sub json_model_2($$$)
{
    my ($val, $path, $rep) = @_;
    # .'$Schema'
    if (! jm_is_object($val))
    {
        return 0;
    }
    my $res;
    my $must_count = 0;
    scalar keys %$val;
    while (my ($prop, $pval) = each %$val)
    {
        if ($prop eq 'types')
        {
            # handle must types property
            $must_count++;
            # .'$Schema'.types
            $res = jm_is_array($pval);
            if ($res)
            {
                for my $arr_0_idx (0 .. $#$pval)
                {
                    my $arr_0_item = $$pval[$arr_0_idx];
                    # .'$Schema'.types.0
                    $res = json_model_3($arr_0_item, undef, $rep);
                    if (! $res)
                    {
                        last;
                    }
                }
            }
            if (! $res)
            {
                return 0;
            }
        }
        elsif ($prop eq 'metadata')
        {
            # handle may metadata property
            # .'$Schema'.metadata
            $res = _jm_obj_0($pval, undef, $rep);
            if (! $res)
            {
                return 0;
            }
        }
        else
        {
            return 0;
        }
    }
    return $must_count == 1;
}


# check $Type (.'$Type')
sub json_model_3($$$)
{
    my ($val, $path, $rep) = @_;
    my $res;
    # .'$Type'
    my $iso_0 = jm_is_object($val);
    $res = $iso_0;
    if ($res)
    {
        if (exists $$val{'kind'})
        {
            my $tag_0 = $$val{'kind'};
            my $fun_0 = $_jm_map_0{$tag_0};
            if (defined($fun_0))
            {
                $res = &$fun_0($val, $path, $rep);
            }
            else
            {
                $res = 0;
            }
        }
        else
        {
            $res = 0;
        }
    }
    return $res;
}


# check $atomic-types (.'$atomic-types')
sub json_model_4($$$)
{
    my ($val, $path, $rep) = @_;
    my $res;
    # .'$atomic-types'
    $res = jm_is_scalar($val) && jm_is_string($val) && exists $_jm_cst_0{$val};
    return $res;
}

# check $atomic (.'$atomic')
sub json_model_5($$$)
{
    my ($val, $path, $rep) = @_;
    my $res;
    # .'$atomic'
    # .'$atomic'.'|'.0
    $res = !defined($val);
    if (! $res)
    {
        # .'$atomic'.'|'.1
        $res = jm_is_boolean($val);
        if (! $res)
        {
            # .'$atomic'.'|'.2
            $res = jm_is_integer($val);
            if (! $res)
            {
                # .'$atomic'.'|'.3
                $res = jm_is_numeric($val);
                if (! $res)
                {
                    # .'$atomic'.'|'.4
                    $res = jm_is_string($val);
                }
            }
        }
    }
    return $res;
}

# check json_model_6_map_enumeration (.'$Atomic'.enumeration)
sub _jm_f_0($$$)
{
    my ($val, $path, $rep) = @_;
    my $res;
    # .'$Atomic'.enumeration
    $res = jm_is_array($val);
    if ($res)
    {
        for my $arr_2_idx (0 .. $#$val)
        {
            my $arr_2_item = $$val[$arr_2_idx];
            # .'$Atomic'.enumeration.0
            $res = json_model_5($arr_2_item, undef, $rep);
            if (! $res)
            {
                last;
            }
        }
    }
    return $res;
}


# check json_model_6_map_explicitTypeZone (.'$Atomic'.explicitTypeZone)
sub _jm_f_1($$$)
{
    my ($val, $path, $rep) = @_;
    my $res;
    # .'$Atomic'.explicitTypeZone
    $res = jm_is_scalar($val) && jm_is_string($val) && exists $_jm_cst_1{$val};
    return $res;
}

# check json_model_6_map_fractionDigits (.'$Atomic'.fractionDigits)
sub _jm_f_2($$$)
{
    my ($val, $path, $rep) = @_;
    my $res;
    # .'$Atomic'.fractionDigits
    $res = jm_is_integer($val) && $val >= 0;
    return $res;
}

# check json_model_6_map_length (.'$Atomic'.length)
sub _jm_f_3($$$)
{
    my ($val, $path, $rep) = @_;
    my $res;
    # .'$Atomic'.length
    $res = jm_is_integer($val) && $val >= 0;
    return $res;
}

# check json_model_6_map_maxLength (.'$Atomic'.maxLength)
sub _jm_f_4($$$)
{
    my ($val, $path, $rep) = @_;
    my $res;
    # .'$Atomic'.maxLength
    $res = jm_is_integer($val) && $val >= 0;
    return $res;
}

# check json_model_6_map_minLength (.'$Atomic'.minLength)
sub _jm_f_5($$$)
{
    my ($val, $path, $rep) = @_;
    my $res;
    # .'$Atomic'.minLength
    $res = jm_is_integer($val) && $val >= 0;
    return $res;
}

# check json_model_6_map_name (.'$Atomic'.name)
sub _jm_f_6($$$)
{
    my ($val, $path, $rep) = @_;
    my $res;
    # .'$Atomic'.name
    $res = jm_is_string($val);
    return $res;
}

# check json_model_6_map_pattern (.'$Atomic'.pattern)
sub _jm_f_7($$$)
{
    my ($val, $path, $rep) = @_;
    my $res;
    # .'$Atomic'.pattern
    $res = jm_is_string($val);
    return $res;
}

# check json_model_6_map_totalDigits (.'$Atomic'.totalDigits)
sub _jm_f_8($$$)
{
    my ($val, $path, $rep) = @_;
    my $res;
    # .'$Atomic'.totalDigits
    $res = jm_is_integer($val) && $val >= 0;
    return $res;
}


# check $Atomic (.'$Atomic')
sub json_model_6($$$)
{
    my ($val, $path, $rep) = @_;
    # could there be derived atomics as well?
    # .'$Atomic'
    if (! jm_is_object($val))
    {
        return 0;
    }
    my $res;
    my $pfun;
    my $must_count = 0;
    scalar keys %$val;
    while (my ($prop, $pval) = each %$val)
    {
        if ($prop eq 'kind')
        {
            # handle must kind property
            $must_count++;
            # .'$Atomic'.kind
            $res = jm_is_string($pval) && $pval eq 'atomic';
            if (! $res)
            {
                return 0;
            }
        }
        elsif ($prop eq 'baseType')
        {
            # handle must baseType property
            $must_count++;
            # .'$Atomic'.baseType
            $res = json_model_4($pval, undef, $rep);
            if (! $res)
            {
                return 0;
            }
        }
        elsif (($pfun = $json_model_6_map{$prop}))
        {
            # handle 13 may props
            if (defined($pfun) && ! &$pfun($pval, undef, $rep))
            {
                return 0;
            }
        }
        else
        {
            return 0;
        }
    }
    return $must_count == 2;
}

# check $Object (.'$Object')
sub json_model_7($$$)
{
    my ($val, $path, $rep) = @_;
    # .'$Object'
    if (! jm_is_object($val))
    {
        return 0;
    }
    my $res;
    my $must_count = 0;
    scalar keys %$val;
    while (my ($prop, $pval) = each %$val)
    {
        if ($prop eq 'kind')
        {
            # handle must kind property
            $must_count++;
            # .'$Object'.kind
            $res = jm_is_string($pval) && $pval eq 'object';
            if (! $res)
            {
                return 0;
            }
        }
        elsif ($prop eq 'name')
        {
            # handle may name property
            # .'$Object'.name
            $res = jm_is_string($pval);
            if (! $res)
            {
                return 0;
            }
        }
        elsif ($prop eq 'baseType')
        {
            # handle may baseType property
            # .'$Object'.baseType
            $res = jm_is_string($pval);
            if (! $res)
            {
                return 0;
            }
        }
        elsif ($prop eq 'content')
        {
            # handle may content property
            # .'$Object'.content
            $res = jm_is_array($pval);
            if ($res)
            {
                for my $arr_3_idx (0 .. $#$pval)
                {
                    my $arr_3_item = $$pval[$arr_3_idx];
                    # .'$Object'.content.0
                    $res = json_model_8($arr_3_item, undef, $rep);
                    if (! $res)
                    {
                        last;
                    }
                }
            }
            if (! $res)
            {
                return 0;
            }
        }
        elsif ($prop eq 'closed')
        {
            # handle may closed property
            # .'$Object'.closed
            $res = jm_is_boolean($pval);
            if (! $res)
            {
                return 0;
            }
        }
        else
        {
            return 0;
        }
    }
    return $must_count == 1;
}

# check $Fields (.'$Fields')
sub json_model_8($$$)
{
    my ($val, $path, $rep) = @_;
    # .'$Fields'
    if (! jm_is_object($val))
    {
        return 0;
    }
    my $res;
    my $must_count = 0;
    scalar keys %$val;
    while (my ($prop, $pval) = each %$val)
    {
        if ($prop eq 'name')
        {
            # handle must name property
            $must_count++;
            # .'$Fields'.name
            $res = jm_is_string($pval);
            if (! $res)
            {
                return 0;
            }
        }
        elsif ($prop eq 'type')
        {
            # handle must type property
            $must_count++;
            # .'$Fields'.type
            $res = json_model_11($pval, undef, $rep);
            if (! $res)
            {
                return 0;
            }
        }
        elsif ($prop eq 'required')
        {
            # handle may required property
            # .'$Fields'.required
            $res = jm_is_boolean($pval);
            if (! $res)
            {
                return 0;
            }
        }
        elsif ($prop eq 'default')
        {
            # handle may default property
            # .'$Fields'.default
            $res = 1;
        }
        elsif ($prop eq 'unique')
        {
            # handle may unique property
            # .'$Fields'.unique
            $res = jm_is_boolean($pval);
            if (! $res)
            {
                return 0;
            }
        }
        else
        {
            return 0;
        }
    }
    return $must_count == 2;
}

# check $Array (.'$Array')
sub json_model_9($$$)
{
    my ($val, $path, $rep) = @_;
    # WTF about 'content'?
    # .'$Array'
    if (! jm_is_object($val))
    {
        return 0;
    }
    my $res;
    my $must_count = 0;
    scalar keys %$val;
    while (my ($prop, $pval) = each %$val)
    {
        if ($prop eq 'kind')
        {
            # handle must kind property
            $must_count++;
            # .'$Array'.kind
            $res = jm_is_string($pval) && $pval eq 'array';
            if (! $res)
            {
                return 0;
            }
        }
        elsif ($prop eq 'name')
        {
            # handle may name property
            # .'$Array'.name
            $res = jm_is_string($pval);
            if (! $res)
            {
                return 0;
            }
        }
        elsif ($prop eq 'baseType')
        {
            # handle may baseType property
            # .'$Array'.baseType
            $res = jm_is_string($pval);
            if (! $res)
            {
                return 0;
            }
        }
        elsif ($prop eq 'content')
        {
            # handle may content property
            # .'$Array'.content
            $res = json_model_11($pval, undef, $rep);
            if (! $res)
            {
                return 0;
            }
        }
        elsif ($prop eq 'minLength')
        {
            # handle may minLength property
            # .'$Array'.minLength
            $res = jm_is_integer($pval) && $pval >= 0;
            if (! $res)
            {
                return 0;
            }
        }
        elsif ($prop eq 'maxLength')
        {
            # handle may maxLength property
            # .'$Array'.maxLength
            $res = jm_is_integer($pval) && $pval >= 0;
            if (! $res)
            {
                return 0;
            }
        }
        else
        {
            return 0;
        }
    }
    return $must_count == 1;
}

# check $Union (.'$Union')
sub json_model_10($$$)
{
    my ($val, $path, $rep) = @_;
    # jsound.jsound.json does not say that it is a typeâ€¦
    # .'$Union'
    if (! jm_is_object($val))
    {
        return 0;
    }
    my $res;
    my $must_count = 0;
    scalar keys %$val;
    while (my ($prop, $pval) = each %$val)
    {
        if ($prop eq 'name')
        {
            # handle must name property
            $must_count++;
            # .'$Union'.name
            $res = jm_is_string($pval);
            if (! $res)
            {
                return 0;
            }
        }
        elsif ($prop eq 'kind')
        {
            # handle must kind property
            $must_count++;
            # .'$Union'.kind
            $res = jm_is_string($pval) && $pval eq 'union';
            if (! $res)
            {
                return 0;
            }
        }
        elsif ($prop eq 'content')
        {
            # handle must content property
            $must_count++;
            # .'$Union'.content
            $res = jm_is_array($pval);
            if ($res)
            {
                for my $arr_4_idx (0 .. $#$pval)
                {
                    my $arr_4_item = $$pval[$arr_4_idx];
                    # .'$Union'.content.0
                    $res = json_model_11($arr_4_item, undef, $rep);
                    if (! $res)
                    {
                        last;
                    }
                }
            }
            if (! $res)
            {
                return 0;
            }
        }
        elsif ($prop eq 'baseType')
        {
            # handle may baseType property
            # .'$Union'.baseType
            $res = jm_is_string($pval);
            if (! $res)
            {
                return 0;
            }
        }
        else
        {
            return 0;
        }
    }
    return $must_count == 3;
}

# check $type-or-ref (.'$type-or-ref')
sub json_model_11($$$)
{
    my ($val, $path, $rep) = @_;
    my $res;
    # .'$type-or-ref'
    # .'$type-or-ref'.'|'.0
    $res = jm_is_string($val);
    if (! $res)
    {
        # .'$type-or-ref'.'|'.1
        $res = json_model_3($val, $path, $rep);
    }
    return $res;
}

# check $ (.)
sub json_model_1($$$)
{
    my ($val, $path, $rep) = @_;
    my $res;
    # .
    $res = json_model_2($val, $path, $rep);
    return $res;
}


# initialization of global variables

our $initialized = 0;

sub check_model_init()
{
    if (!$initialized)
    {
        $initialized = 1;
        %_jm_map_0 = (
            'atomic' => \&json_model_6,
            'object' => \&json_model_7,
            'array' => \&json_model_9,
            'union' => \&json_model_10,
        );
        %_jm_cst_0 = (
            'string' => 1,
            'decimal' => 1,
            'integer' => 1,
            'double' => 1,
            'boolean' => 1,
            'anyURI' => 1,
            'base64Binary' => 1,
            'hexBinary' => 1,
            'date' => 1,
            'dateTime' => 1,
            'time' => 1,
            'dateTimeStamp' => 1,
            'duration' => 1,
            'null' => 1,
        );
        %_jm_cst_1 = (
            'required' => 1,
            'prohibited' => 1,
            'optional' => 1,
        );
        %json_model_6_map = (
            'enumeration' => \&_jm_f_0,
            'explicitTypeZone' => \&_jm_f_1,
            'fractionDigits' => \&_jm_f_2,
            'length' => \&_jm_f_3,
            'maxExclusive' => \&json_model_5,
            'maxInclusive' => \&json_model_5,
            'maxLength' => \&_jm_f_4,
            'minExclusive' => \&json_model_5,
            'minInclusive' => \&json_model_5,
            'minLength' => \&_jm_f_5,
            'name' => \&_jm_f_6,
            'pattern' => \&_jm_f_7,
            'totalDigits' => \&_jm_f_8,
        );
        %check_model_map = (
            '' => \&json_model_2,
            'Schema' => \&json_model_2,
            'Type' => \&json_model_3,
            'atomic-types' => \&json_model_4,
            'atomic' => \&json_model_5,
            'Atomic' => \&json_model_6,
            'Object' => \&json_model_7,
            'Fields' => \&json_model_8,
            'Array' => \&json_model_9,
            'Union' => \&json_model_10,
            'type-or-ref' => \&json_model_11,
        );
    }
}

sub check_model_free()
{
    if ($initialized)
    {
        $initialized = 0;
        %_jm_map_0 = ();
        %_jm_cst_0 = ();
        %_jm_cst_1 = ();
        %json_model_6_map = ();
        %check_model_map = ();
    }
}

sub check_model($$$)
{
    my ($json, $name, $rep) = @_;
    die "unexpected model name \"$name\"" unless exists $check_model_map{$name};
    my $path = defined $rep ? [] : undef;
    return $check_model_map{$name}($json, $path, $rep);
}

#
# SCRIPT EXECUTION
#
check_model_init();
jm_main(\&check_model, \%check_model_map, JMC_VERSION);
check_model_free();
