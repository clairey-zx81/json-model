--
-- Generated by JSON Model Compiler version 2
-- see https://github.com/clairey-zx81/json-model
--
-- JSON_MODEL_VERSION is 2
CREATE EXTENSION IF NOT EXISTS json_model;

-- check $a (.'$a')
CREATE OR REPLACE FUNCTION json_model_2(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .'$a'
  RETURN JSONB_TYPEOF(val) = 'string' AND JSON_VALUE(val, '$' RETURNING TEXT) = 'A';
END;
$$ LANGUAGE PLpgSQL;

-- check $b (.'$b')
CREATE OR REPLACE FUNCTION json_model_3(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .'$b'
  RETURN JSONB_TYPEOF(val) = 'string' AND JSON_VALUE(val, '$' RETURNING TEXT) = 'A';
END;
$$ LANGUAGE PLpgSQL;

-- check $ab (.'$ab')
CREATE OR REPLACE FUNCTION json_model_4(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  must_count int;
  prop TEXT;
  pval JSONB;
BEGIN
  -- .'$ab'
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  must_count := 0;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = 'a' THEN
      -- handle must a property
      must_count := must_count + 1;
      -- .'$ab'.a
      res := JSONB_TYPEOF(pval) = 'number' AND (pval)::INT8 = (pval)::FLOAT8 AND (pval)::INT8 >= 0;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'b' THEN
      -- handle must b property
      must_count := must_count + 1;
      -- .'$ab'.b
      res := JSONB_TYPEOF(pval) = 'number' AND (pval)::INT8 = (pval)::FLOAT8 AND (pval)::INT8 >= 0;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN must_count = 2;
END;
$$ LANGUAGE PLpgSQL;

-- check $cd (.'$cd')
CREATE OR REPLACE FUNCTION json_model_5(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  must_count int;
  prop TEXT;
  pval JSONB;
BEGIN
  -- .'$cd'
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  must_count := 0;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = 'c' THEN
      -- handle must c property
      must_count := must_count + 1;
      -- .'$cd'.c
      res := JSONB_TYPEOF(pval) = 'number' AND (pval)::INT8 = (pval)::FLOAT8 AND (pval)::INT8 >= 0;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'd' THEN
      -- handle must d property
      must_count := must_count + 1;
      -- .'$cd'.d
      res := JSONB_TYPEOF(pval) = 'number' AND (pval)::INT8 = (pval)::FLOAT8 AND (pval)::INT8 >= 0;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN must_count = 2;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_1_map_and (.and)
CREATE OR REPLACE FUNCTION _jm_f_0(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
BEGIN
  -- conjunction, all must match
  -- .and
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = 'a0' THEN
      -- handle may a0 property
      -- .and.a0
      -- .and.a0.'&'.0
      -- .and.a0.'&'.1
      -- "/^2020-/"
      res := JSONB_TYPEOF(pval) = 'string' AND jm_is_valid_date(JSON_VALUE(pval, '$' RETURNING TEXT), NULL, NULL) AND JSONB_TYPEOF(pval) = 'string' AND STARTS_WITH(JSON_VALUE(pval, '$' RETURNING TEXT), '2020-');
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_1_map_array (.array)
CREATE OR REPLACE FUNCTION _jm_f_1(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
  arr_0_idx INT8;
  arr_0_item JSONB;
  arr_1_idx INT8;
  arr_1_item JSONB;
  arr_2_idx INT8;
  arr_2_item JSONB;
  arr_3_idx INT8;
  arr_3_item JSONB;
BEGIN
  -- example arrays
  -- .array
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = 'a0' THEN
      -- handle may a0 property
      -- .array.a0
      res := JSONB_TYPEOF(pval) = 'array';
      IF res THEN
        FOR arr_0_idx IN 0 .. JSONB_ARRAY_LENGTH(pval) - 1 LOOP
          arr_0_item := pval -> arr_0_idx;
          -- .array.a0.0
          res := JSONB_TYPEOF(arr_0_item) = 'number' AND (arr_0_item)::INT8 = (arr_0_item)::FLOAT8 AND (arr_0_item)::INT8 >= 0;
          IF NOT res THEN
            EXIT;
          END IF;
        END LOOP;
      END IF;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'a1' THEN
      -- handle may a1 property
      -- .array.a1
      res := JSONB_TYPEOF(pval) = 'array';
      IF res THEN
        FOR arr_1_idx IN 0 .. JSONB_ARRAY_LENGTH(pval) - 1 LOOP
          arr_1_item := pval -> arr_1_idx;
          -- .array.a1.0
          res := JSONB_TYPEOF(arr_1_item) = 'string';
          IF NOT res THEN
            EXIT;
          END IF;
        END LOOP;
      END IF;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'a2' THEN
      -- handle may a2 property
      -- .array.a2
      res := JSONB_TYPEOF(pval) = 'array';
      IF res THEN
        FOR arr_2_idx IN 0 .. JSONB_ARRAY_LENGTH(pval) - 1 LOOP
          arr_2_item := pval -> arr_2_idx;
          -- .array.a2.0
          res := JSONB_TYPEOF(arr_2_item) = 'string' AND jm_is_valid_date(JSON_VALUE(arr_2_item, '$' RETURNING TEXT), NULL, NULL);
          IF NOT res THEN
            EXIT;
          END IF;
        END LOOP;
      END IF;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'a3' THEN
      -- handle may a3 property
      -- .array.a3
      res := JSONB_TYPEOF(pval) = 'array';
      IF res THEN
        FOR arr_3_idx IN 0 .. JSONB_ARRAY_LENGTH(pval) - 1 LOOP
          arr_3_item := pval -> arr_3_idx;
          -- .array.a3.0
          res := JSONB_TYPEOF(arr_3_item) = 'boolean';
          IF NOT res THEN
            EXIT;
          END IF;
        END LOOP;
      END IF;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'a4' THEN
      -- handle may a4 property
      -- .array.a4
      res := JSONB_TYPEOF(pval) = 'array';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION _jm_cst_0(value JSONB)
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  constants JSONB = JSONB '[false,true]';
BEGIN
  RETURN constants @> value;
END;
$$ LANGUAGE plpgsql;

-- check json_model_1_map_bool (.bool)
CREATE OR REPLACE FUNCTION _jm_f_2(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
BEGIN
  -- booleans: inference, predefs, constants, enum
  -- .bool
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = 'b0' THEN
      -- handle may b0 property
      -- .bool.b0
      res := JSONB_TYPEOF(pval) = 'boolean';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'b1' THEN
      -- handle may b1 property
      -- .bool.b1
      res := JSONB_TYPEOF(pval) = 'boolean';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'b2' THEN
      -- handle may b2 property
      -- .bool.b2
      res := JSONB_TYPEOF(pval) = 'boolean';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'b3' THEN
      -- handle may b3 property
      -- .bool.b3
      res := JSONB_TYPEOF(pval) = 'boolean' AND (pval)::BOOL = TRUE;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'b4' THEN
      -- handle may b4 property
      -- .bool.b4
      res := JSONB_TYPEOF(pval) = 'boolean' AND (pval)::BOOL = FALSE;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'b5' THEN
      -- handle may b5 property
      -- .bool.b5
      res := JSONB_TYPEOF(pval) IN ('null', 'boolean', 'number', 'string') AND _jm_cst_0(pval);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_f_3_map_cia0 (.constraints.cia0)
CREATE OR REPLACE FUNCTION _jm_f_4(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  arr_4_idx INT8;
  arr_4_item JSONB;
  ival_0 int;
BEGIN
  -- .constraints.cia0
  -- .constraints.cia0.'@'
  res := JSONB_TYPEOF(val) = 'array';
  IF res THEN
    FOR arr_4_idx IN 0 .. JSONB_ARRAY_LENGTH(val) - 1 LOOP
      arr_4_item := val -> arr_4_idx;
      -- .constraints.cia0.'@'.0
      res := JSONB_TYPEOF(arr_4_item) = 'number' AND (arr_4_item)::INT8 = (arr_4_item)::FLOAT8 AND (arr_4_item)::INT8 >= 0;
      IF NOT res THEN
        EXIT;
      END IF;
    END LOOP;
  END IF;
  IF res THEN
    ival_0 := JSONB_ARRAY_LENGTH(val);
    res := ival_0 = 3;
  END IF;
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_f_3_map_cia1 (.constraints.cia1)
CREATE OR REPLACE FUNCTION _jm_f_5(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  arr_5_idx INT8;
  arr_5_item JSONB;
  ival_1 int;
BEGIN
  -- .constraints.cia1
  -- .constraints.cia1.'@'
  res := JSONB_TYPEOF(val) = 'array';
  IF res THEN
    FOR arr_5_idx IN 0 .. JSONB_ARRAY_LENGTH(val) - 1 LOOP
      arr_5_item := val -> arr_5_idx;
      -- .constraints.cia1.'@'.0
      res := JSONB_TYPEOF(arr_5_item) = 'number' AND (arr_5_item)::INT8 = (arr_5_item)::FLOAT8 AND (arr_5_item)::INT8 >= 0;
      IF NOT res THEN
        EXIT;
      END IF;
    END LOOP;
  END IF;
  IF res THEN
    ival_1 := JSONB_ARRAY_LENGTH(val);
    res := ival_1 <> 4 AND ival_1 <= 5 AND ival_1 >= 2;
  END IF;
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_f_3_map_cia2 (.constraints.cia2)
CREATE OR REPLACE FUNCTION _jm_f_6(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  arr_6_idx INT8;
  arr_6_item JSONB;
  ival_2 int;
BEGIN
  -- .constraints.cia2
  -- .constraints.cia2.'@'
  res := JSONB_TYPEOF(val) = 'array';
  IF res THEN
    FOR arr_6_idx IN 0 .. JSONB_ARRAY_LENGTH(val) - 1 LOOP
      arr_6_item := val -> arr_6_idx;
      -- .constraints.cia2.'@'.0
      res := JSONB_TYPEOF(arr_6_item) = 'number' AND (arr_6_item)::INT8 = (arr_6_item)::FLOAT8 AND (arr_6_item)::INT8 >= 0;
      IF NOT res THEN
        EXIT;
      END IF;
    END LOOP;
  END IF;
  IF res THEN
    ival_2 := JSONB_ARRAY_LENGTH(val);
    res := ival_2 <= 4 AND ival_2 >= 3;
  END IF;
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_f_3_map_cii0 (.constraints.cii0)
CREATE OR REPLACE FUNCTION _jm_f_7(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .constraints.cii0
  RETURN JSONB_TYPEOF(val) = 'number' AND (val)::INT8 = (val)::FLOAT8 AND (val)::INT8 = 10;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_f_3_map_cii1 (.constraints.cii1)
CREATE OR REPLACE FUNCTION _jm_f_8(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  ival_3 int;
BEGIN
  -- .constraints.cii1
  -- .constraints.cii1.'@'
  res := JSONB_TYPEOF(val) = 'number' AND (val)::INT8 = (val)::FLOAT8 AND (val)::INT8 >= 0;
  IF res THEN
    ival_3 := (val)::INT8;
    res := ival_3 <> 10 AND ival_3 <= 12 AND ival_3 >= 8;
  END IF;
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_f_3_map_cii2 (.constraints.cii2)
CREATE OR REPLACE FUNCTION _jm_f_9(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  ival_4 int;
BEGIN
  -- .constraints.cii2
  -- .constraints.cii2.'@'
  res := JSONB_TYPEOF(val) = 'number' AND (val)::INT8 = (val)::FLOAT8 AND (val)::INT8 >= 0;
  IF res THEN
    ival_4 := (val)::INT8;
    res := ival_4 <= 9 AND ival_4 >= 8;
  END IF;
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_f_3_map_cin0 (.constraints.cin0)
CREATE OR REPLACE FUNCTION _jm_f_10(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  fval_0 FLOAT8;
BEGIN
  -- .constraints.cin0
  -- .constraints.cin0.'@'
  res := JSONB_TYPEOF(val) = 'number' AND (val)::FLOAT8 >= 0.0;
  IF res THEN
    fval_0 := (val)::FLOAT8;
    res := fval_0 = 10;
  END IF;
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_f_3_map_cin1 (.constraints.cin1)
CREATE OR REPLACE FUNCTION _jm_f_11(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  fval_1 FLOAT8;
BEGIN
  -- .constraints.cin1
  -- .constraints.cin1.'@'
  res := JSONB_TYPEOF(val) = 'number' AND (val)::FLOAT8 >= 0.0;
  IF res THEN
    fval_1 := (val)::FLOAT8;
    res := fval_1 <> 10 AND fval_1 <= 12 AND fval_1 >= 8;
  END IF;
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_f_3_map_cin2 (.constraints.cin2)
CREATE OR REPLACE FUNCTION _jm_f_12(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  fval_2 FLOAT8;
BEGIN
  -- .constraints.cin2
  -- .constraints.cin2.'@'
  res := JSONB_TYPEOF(val) = 'number' AND (val)::FLOAT8 >= 0.0;
  IF res THEN
    fval_2 := (val)::FLOAT8;
    res := fval_2 < 10 AND fval_2 > 7;
  END IF;
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- object .constraints.cio0.'@'
CREATE OR REPLACE FUNCTION _jm_obj_0(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- accept any object
  RETURN JSONB_TYPEOF(val) = 'object';
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_f_3_map_cio0 (.constraints.cio0)
CREATE OR REPLACE FUNCTION _jm_f_13(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  ival_5 int;
BEGIN
  -- .constraints.cio0
  -- .constraints.cio0.'@'
  res := _jm_obj_0(val, NULL, NULL);
  IF res THEN
    ival_5 := jm_object_size(val);
    res := ival_5 = 2;
  END IF;
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- object .constraints.cio1.'@'
CREATE OR REPLACE FUNCTION _jm_obj_1(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- accept any object
  RETURN JSONB_TYPEOF(val) = 'object';
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_f_3_map_cio1 (.constraints.cio1)
CREATE OR REPLACE FUNCTION _jm_f_14(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  ival_6 int;
BEGIN
  -- .constraints.cio1
  -- .constraints.cio1.'@'
  res := _jm_obj_1(val, NULL, NULL);
  IF res THEN
    ival_6 := jm_object_size(val);
    res := ival_6 <> 2 AND ival_6 <= 3 AND ival_6 >= 1;
  END IF;
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- object .constraints.cio2.'@'
CREATE OR REPLACE FUNCTION _jm_obj_2(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- accept any object
  RETURN JSONB_TYPEOF(val) = 'object';
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_f_3_map_cio2 (.constraints.cio2)
CREATE OR REPLACE FUNCTION _jm_f_15(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  ival_7 int;
BEGIN
  -- .constraints.cio2
  -- .constraints.cio2.'@'
  res := _jm_obj_2(val, NULL, NULL);
  IF res THEN
    ival_7 := jm_object_size(val);
    res := ival_7 <= 4 AND ival_7 >= 3;
  END IF;
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_f_3_map_cis0 (.constraints.cis0)
CREATE OR REPLACE FUNCTION _jm_f_16(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  ival_8 int;
BEGIN
  -- .constraints.cis0
  -- .constraints.cis0.'@'
  res := JSONB_TYPEOF(val) = 'string';
  IF res THEN
    ival_8 := LENGTH(JSON_VALUE(val, '$' RETURNING TEXT));
    res := ival_8 = 10;
  END IF;
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_f_3_map_cis1 (.constraints.cis1)
CREATE OR REPLACE FUNCTION _jm_f_17(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  ival_9 int;
BEGIN
  -- .constraints.cis1
  -- .constraints.cis1.'@'
  res := JSONB_TYPEOF(val) = 'string';
  IF res THEN
    ival_9 := LENGTH(JSON_VALUE(val, '$' RETURNING TEXT));
    res := ival_9 <> 10 AND ival_9 <= 12 AND ival_9 >= 8;
  END IF;
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_f_3_map_cis2 (.constraints.cis2)
CREATE OR REPLACE FUNCTION _jm_f_18(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  ival_10 int;
BEGIN
  -- .constraints.cis2
  -- .constraints.cis2.'@'
  res := JSONB_TYPEOF(val) = 'string';
  IF res THEN
    ival_10 := LENGTH(JSON_VALUE(val, '$' RETURNING TEXT));
    res := ival_10 <= 9 AND ival_10 >= 8;
  END IF;
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_f_3_map_cni0 (.constraints.cni0)
CREATE OR REPLACE FUNCTION _jm_f_19(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .constraints.cni0
  RETURN JSONB_TYPEOF(val) = 'number' AND (val)::INT8 = (val)::FLOAT8 AND (val)::INT8 = 42;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_f_3_map_cni1 (.constraints.cni1)
CREATE OR REPLACE FUNCTION _jm_f_20(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  ival_11 int;
  fval_3 FLOAT8;
BEGIN
  -- .constraints.cni1
  -- .constraints.cni1.'@'
  res := JSONB_TYPEOF(val) = 'number' AND (val)::INT8 = (val)::FLOAT8 AND (val)::INT8 >= 1;
  IF res THEN
    ival_11 := (val)::INT8;
    fval_3 := (val)::FLOAT8;
    res := fval_3 <> 42.0 AND ival_11 <= 99;
  END IF;
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_f_3_map_cni2 (.constraints.cni2)
CREATE OR REPLACE FUNCTION _jm_f_21(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .constraints.cni2
  RETURN JSONB_TYPEOF(val) = 'number' AND (val)::INT8 = (val)::FLOAT8 AND (val)::INT8 = 42;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_f_3_map_cnn0 (.constraints.cnn0)
CREATE OR REPLACE FUNCTION _jm_f_22(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  fval_4 FLOAT8;
BEGIN
  -- .constraints.cnn0
  -- .constraints.cnn0.'@'
  res := JSONB_TYPEOF(val) = 'number' AND (val)::FLOAT8 >= 0.0;
  IF res THEN
    fval_4 := (val)::FLOAT8;
    res := fval_4 = 42.1;
  END IF;
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_f_3_map_cnn1 (.constraints.cnn1)
CREATE OR REPLACE FUNCTION _jm_f_23(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  fval_5 FLOAT8;
BEGIN
  -- .constraints.cnn1
  -- .constraints.cnn1.'@'
  res := JSONB_TYPEOF(val) = 'number' AND (val)::FLOAT8 >= 0.0;
  IF res THEN
    fval_5 := (val)::FLOAT8;
    res := fval_5 <> 42.5 AND fval_5 <= 43.0 AND fval_5 >= 42.0;
  END IF;
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_f_3_map_cnn2 (.constraints.cnn2)
CREATE OR REPLACE FUNCTION _jm_f_24(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  fval_6 FLOAT8;
BEGIN
  -- .constraints.cnn2
  -- .constraints.cnn2.'@'
  res := JSONB_TYPEOF(val) = 'number' AND (val)::FLOAT8 >= 0.0;
  IF res THEN
    fval_6 := (val)::FLOAT8;
    res := fval_6 < 43.0 AND fval_6 > 42.0;
  END IF;
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_f_3_map_css0 (.constraints.css0)
CREATE OR REPLACE FUNCTION _jm_f_25(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  sval_0 TEXT;
BEGIN
  -- .constraints.css0
  -- .constraints.css0.'@'
  res := JSONB_TYPEOF(val) = 'string';
  IF res THEN
    sval_0 := JSON_VALUE(val, '$' RETURNING TEXT);
    res := sval_0 = 'Susie';
  END IF;
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_f_3_map_css1 (.constraints.css1)
CREATE OR REPLACE FUNCTION _jm_f_26(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  sval_1 TEXT;
BEGIN
  -- .constraints.css1
  -- .constraints.css1.'@'
  res := JSONB_TYPEOF(val) = 'string';
  IF res THEN
    sval_1 := JSON_VALUE(val, '$' RETURNING TEXT);
    res := sval_1 <> 'Hobbes' AND sval_1 <= 'Z' AND sval_1 >= 'A';
  END IF;
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_f_3_map_css2 (.constraints.css2)
CREATE OR REPLACE FUNCTION _jm_f_27(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  sval_2 TEXT;
BEGIN
  -- .constraints.css2
  -- .constraints.css2.'@'
  res := JSONB_TYPEOF(val) = 'string';
  IF res THEN
    sval_2 := JSON_VALUE(val, '$' RETURNING TEXT);
    res := sval_2 < 'Z' AND sval_2 > 'A';
  END IF;
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_f_3_map_cua0 (.constraints.cua0)
CREATE OR REPLACE FUNCTION _jm_f_28(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .constraints.cua0
  -- .constraints.cua0.'@'
  RETURN JSONB_TYPEOF(val) = 'array' AND jm_array_is_unique(val, NULL, NULL);
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION _jm_f_3_map(name TEXT)
RETURNS TEXT STRICT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  map JSONB := JSONB '{"cia0":"_jm_f_4","cia1":"_jm_f_5","cia2":"_jm_f_6","cii0":"_jm_f_7","cii1":"_jm_f_8","cii2":"_jm_f_9","cin0":"_jm_f_10","cin1":"_jm_f_11","cin2":"_jm_f_12","cio0":"_jm_f_13","cio1":"_jm_f_14","cio2":"_jm_f_15","cis0":"_jm_f_16","cis1":"_jm_f_17","cis2":"_jm_f_18","cni0":"_jm_f_19","cni1":"_jm_f_20","cni2":"_jm_f_21","cnn0":"_jm_f_22","cnn1":"_jm_f_23","cnn2":"_jm_f_24","css0":"_jm_f_25","css1":"_jm_f_26","css2":"_jm_f_27","cua0":"_jm_f_28"}';
BEGIN
  RETURN map->>name;
END;
$$ LANGUAGE plpgsql;

-- check json_model_1_map_constraints (.constraints)
CREATE OR REPLACE FUNCTION _jm_f_3(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  pfun TEXT;
  prop TEXT;
  pval JSONB;
BEGIN
  -- .constraints
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF _jm_f_3_map(prop) IS NOT NULL THEN
      -- handle 25 may props
      pfun := _jm_f_3_map(prop);
      IF NOT jm_call(pfun, pval, NULL, NULL) THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION _jm_cst_1(value JSONB)
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  constants JSONB = JSONB '[true,false]';
BEGIN
  RETURN constants @> value;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION _jm_cst_2(value JSONB)
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  constants JSONB = JSONB '[200,201,204]';
BEGIN
  RETURN constants @> value;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION _jm_cst_3(value JSONB)
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  constants JSONB = JSONB '["Susie","Calvin","Hobbes"]';
BEGIN
  RETURN constants @> value;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION _jm_cst_4(value JSONB)
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  constants JSONB = JSONB '["Susie",42,true,null]';
BEGIN
  RETURN constants @> value;
END;
$$ LANGUAGE plpgsql;

-- check json_model_1_map_enum (.enum)
CREATE OR REPLACE FUNCTION _jm_f_29(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
BEGIN
  -- an enumeration only contains constants
  -- .enum
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = 'e0' THEN
      -- handle may e0 property
      -- .enum.e0
      res := JSONB_TYPEOF(pval) IN ('null', 'boolean', 'number', 'string') AND _jm_cst_1(pval);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'e1' THEN
      -- handle may e1 property
      -- .enum.e1
      res := JSONB_TYPEOF(pval) IN ('null', 'boolean', 'number', 'string') AND _jm_cst_2(pval);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'e2' THEN
      -- handle may e2 property
      -- .enum.e2
      res := JSONB_TYPEOF(pval) IN ('null', 'boolean', 'number', 'string') AND _jm_cst_3(pval);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'e3' THEN
      -- handle may e3 property
      -- .enum.e3
      res := JSONB_TYPEOF(pval) IN ('null', 'boolean', 'number', 'string') AND _jm_cst_4(pval);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_f_30_map_f0 (.float.f0)
CREATE OR REPLACE FUNCTION _jm_f_31(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .float.f0
  RETURN JSONB_TYPEOF(val) = 'number' AND (val)::FLOAT8 >= 0.0;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_f_30_map_f1 (.float.f1)
CREATE OR REPLACE FUNCTION _jm_f_32(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .float.f1
  RETURN JSONB_TYPEOF(val) = 'number' AND (val)::FLOAT8 > 0.0;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_f_30_map_f2 (.float.f2)
CREATE OR REPLACE FUNCTION _jm_f_33(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .float.f2
  RETURN JSONB_TYPEOF(val) = 'number';
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_f_30_map_f3 (.float.f3)
CREATE OR REPLACE FUNCTION _jm_f_34(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .float.f3
  RETURN JSONB_TYPEOF(val) = 'number';
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_f_30_map_f4 (.float.f4)
CREATE OR REPLACE FUNCTION _jm_f_35(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .float.f4
  RETURN JSONB_TYPEOF(val) = 'number';
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_f_30_map_f5 (.float.f5)
CREATE OR REPLACE FUNCTION _jm_f_36(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .float.f5
  RETURN JSONB_TYPEOF(val) = 'number';
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_f_30_map_f6 (.float.f6)
CREATE OR REPLACE FUNCTION _jm_f_37(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .float.f6
  RETURN JSONB_TYPEOF(val) = 'number' AND (val)::FLOAT8 = 3.1415927;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_f_30_map_f7 (.float.f7)
CREATE OR REPLACE FUNCTION _jm_f_38(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .float.f7
  RETURN JSONB_TYPEOF(val) = 'number' AND (val)::FLOAT8 = 1e+100;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_f_30_map_f8 (.float.f8)
CREATE OR REPLACE FUNCTION _jm_f_39(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .float.f8
  RETURN JSONB_TYPEOF(val) = 'number' AND (val)::FLOAT8 = -42.1;
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION _jm_f_30_map(name TEXT)
RETURNS TEXT STRICT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  map JSONB := JSONB '{"f0":"_jm_f_31","f1":"_jm_f_32","f2":"_jm_f_33","f3":"_jm_f_34","f4":"_jm_f_35","f5":"_jm_f_36","f6":"_jm_f_37","f7":"_jm_f_38","f8":"_jm_f_39"}';
BEGIN
  RETURN map->>name;
END;
$$ LANGUAGE plpgsql;

-- check json_model_1_map_float (.float)
CREATE OR REPLACE FUNCTION _jm_f_30(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  pfun TEXT;
  prop TEXT;
  pval JSONB;
BEGIN
  -- floats: inference, predefs, constants
  -- .float
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF _jm_f_30_map(prop) IS NOT NULL THEN
      -- handle 9 may props
      pfun := _jm_f_30_map(prop);
      IF NOT jm_call(pfun, pval, NULL, NULL) THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_f_40_map_i0 (.int.i0)
CREATE OR REPLACE FUNCTION _jm_f_41(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .int.i0
  RETURN JSONB_TYPEOF(val) = 'number' AND (val)::INT8 = (val)::FLOAT8 AND (val)::INT8 >= 0;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_f_40_map_i1 (.int.i1)
CREATE OR REPLACE FUNCTION _jm_f_42(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .int.i1
  RETURN JSONB_TYPEOF(val) = 'number' AND (val)::INT8 = (val)::FLOAT8 AND (val)::INT8 >= 1;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_f_40_map_i2 (.int.i2)
CREATE OR REPLACE FUNCTION _jm_f_43(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .int.i2
  RETURN JSONB_TYPEOF(val) = 'number' AND (val)::INT8 = (val)::FLOAT8;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_f_40_map_i3 (.int.i3)
CREATE OR REPLACE FUNCTION _jm_f_44(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .int.i3
  RETURN JSONB_TYPEOF(val) = 'number' AND (val)::INT8 = (val)::FLOAT8;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_f_40_map_i4 (.int.i4)
CREATE OR REPLACE FUNCTION _jm_f_45(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .int.i4
  RETURN JSONB_TYPEOF(val) = 'number' AND (val)::INT8 = (val)::FLOAT8;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_f_40_map_i5 (.int.i5)
CREATE OR REPLACE FUNCTION _jm_f_46(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .int.i5
  RETURN JSONB_TYPEOF(val) = 'number' AND (val)::INT8 = (val)::FLOAT8;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_f_40_map_i6 (.int.i6)
CREATE OR REPLACE FUNCTION _jm_f_47(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .int.i6
  RETURN JSONB_TYPEOF(val) = 'number' AND (val)::INT8 = (val)::FLOAT8;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_f_40_map_i7 (.int.i7)
CREATE OR REPLACE FUNCTION _jm_f_48(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .int.i7
  RETURN JSONB_TYPEOF(val) = 'number' AND (val)::INT8 = (val)::FLOAT8 AND (val)::INT8 >= 0;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_f_40_map_i8 (.int.i8)
CREATE OR REPLACE FUNCTION _jm_f_49(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .int.i8
  RETURN JSONB_TYPEOF(val) = 'number' AND (val)::INT8 = (val)::FLOAT8 AND (val)::INT8 >= 0;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_f_40_map_i9 (.int.i9)
CREATE OR REPLACE FUNCTION _jm_f_50(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .int.i9
  RETURN JSONB_TYPEOF(val) = 'number' AND (val)::INT8 = (val)::FLOAT8 AND (val)::INT8 = 42;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_f_40_map_ia (.int.ia)
CREATE OR REPLACE FUNCTION _jm_f_51(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .int.ia
  RETURN JSONB_TYPEOF(val) = 'number' AND (val)::INT8 = (val)::FLOAT8 AND (val)::INT8 = -42;
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION _jm_f_40_map(name TEXT)
RETURNS TEXT STRICT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  map JSONB := JSONB '{"i0":"_jm_f_41","i1":"_jm_f_42","i2":"_jm_f_43","i3":"_jm_f_44","i4":"_jm_f_45","i5":"_jm_f_46","i6":"_jm_f_47","i7":"_jm_f_48","i8":"_jm_f_49","i9":"_jm_f_50","ia":"_jm_f_51"}';
BEGIN
  RETURN map->>name;
END;
$$ LANGUAGE plpgsql;

-- check json_model_1_map_int (.int)
CREATE OR REPLACE FUNCTION _jm_f_40(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  pfun TEXT;
  prop TEXT;
  pval JSONB;
BEGIN
  -- integers: inference, predefs, constants
  -- .int
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF _jm_f_40_map(prop) IS NOT NULL THEN
      -- handle 11 may props
      pfun := _jm_f_40_map(prop);
      IF NOT jm_call(pfun, pval, NULL, NULL) THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- object .merge.m0
CREATE OR REPLACE FUNCTION _jm_obj_3(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  must_count int;
  prop TEXT;
  pval JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  must_count := 0;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = 'a' THEN
      -- handle must a property
      must_count := must_count + 1;
      -- .merge.m0.a
      res := JSONB_TYPEOF(pval) = 'number' AND (pval)::INT8 = (pval)::FLOAT8 AND (pval)::INT8 >= 0;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'b' THEN
      -- handle may b property
      -- .merge.m0.b
      res := JSONB_TYPEOF(pval) = 'number' AND (pval)::INT8 = (pval)::FLOAT8 AND (pval)::INT8 >= 0;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN must_count = 1;
END;
$$ LANGUAGE PLpgSQL;

-- object .merge.m1.'|'.1
CREATE OR REPLACE FUNCTION _jm_obj_4(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  must_count int;
  prop TEXT;
  pval JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  must_count := 0;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = 'a' THEN
      -- handle must a property
      must_count := must_count + 1;
      -- .merge.m1.'|'.1.a
      res := JSONB_TYPEOF(pval) = 'number' AND (pval)::INT8 = (pval)::FLOAT8 AND (pval)::INT8 >= 0;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'c' THEN
      -- handle must c property
      must_count := must_count + 1;
      -- .merge.m1.'|'.1.c
      res := JSONB_TYPEOF(pval) = 'number' AND (pval)::INT8 = (pval)::FLOAT8 AND (pval)::INT8 >= 1;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN must_count = 2;
END;
$$ LANGUAGE PLpgSQL;

-- object .merge.m1.'|'.0
CREATE OR REPLACE FUNCTION _jm_obj_5(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  must_count int;
  prop TEXT;
  pval JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  must_count := 0;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = 'a' THEN
      -- handle must a property
      must_count := must_count + 1;
      -- .merge.m1.'|'.0.a
      res := JSONB_TYPEOF(pval) = 'number' AND (pval)::INT8 = (pval)::FLOAT8 AND (pval)::INT8 >= 0;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'b' THEN
      -- handle must b property
      must_count := must_count + 1;
      -- .merge.m1.'|'.0.b
      res := JSONB_TYPEOF(pval) = 'number' AND (pval)::INT8 = (pval)::FLOAT8 AND (pval)::INT8 >= 1;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN must_count = 2;
END;
$$ LANGUAGE PLpgSQL;

-- object .merge.m2.'|'.1
CREATE OR REPLACE FUNCTION _jm_obj_6(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  must_count int;
  prop TEXT;
  pval JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  must_count := 0;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = 'a' THEN
      -- handle must a property
      must_count := must_count + 1;
      -- .merge.m2.'|'.1.a
      res := JSONB_TYPEOF(pval) = 'number' AND (pval)::INT8 = (pval)::FLOAT8 AND (pval)::INT8 >= 0;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'c' THEN
      -- handle must c property
      must_count := must_count + 1;
      -- .merge.m2.'|'.1.c
      res := JSONB_TYPEOF(pval) = 'number' AND (pval)::INT8 = (pval)::FLOAT8 AND (pval)::INT8 >= 1;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN must_count = 2;
END;
$$ LANGUAGE PLpgSQL;

-- object .merge.m2.'|'.0
CREATE OR REPLACE FUNCTION _jm_obj_7(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  must_count int;
  prop TEXT;
  pval JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  must_count := 0;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = 'a' THEN
      -- handle must a property
      must_count := must_count + 1;
      -- .merge.m2.'|'.0.a
      res := JSONB_TYPEOF(pval) = 'number' AND (pval)::INT8 = (pval)::FLOAT8 AND (pval)::INT8 >= 0;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'b' THEN
      -- handle must b property
      must_count := must_count + 1;
      -- .merge.m2.'|'.0.b
      res := JSONB_TYPEOF(pval) = 'number' AND (pval)::INT8 = (pval)::FLOAT8 AND (pval)::INT8 >= 1;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN must_count = 2;
END;
$$ LANGUAGE PLpgSQL;

-- object .merge.m3.'|'.3
CREATE OR REPLACE FUNCTION _jm_obj_8(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  must_count int;
  prop TEXT;
  pval JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  must_count := 0;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = 'b' THEN
      -- handle must b property
      must_count := must_count + 1;
      -- .merge.m3.'|'.3.b
      res := JSONB_TYPEOF(pval) = 'number' AND (pval)::INT8 = (pval)::FLOAT8 AND (pval)::INT8 >= 0;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'd' THEN
      -- handle must d property
      must_count := must_count + 1;
      -- .merge.m3.'|'.3.d
      res := JSONB_TYPEOF(pval) = 'number' AND (pval)::INT8 = (pval)::FLOAT8 AND (pval)::INT8 >= 1;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN must_count = 2;
END;
$$ LANGUAGE PLpgSQL;

-- object .merge.m3.'|'.2
CREATE OR REPLACE FUNCTION _jm_obj_9(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  must_count int;
  prop TEXT;
  pval JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  must_count := 0;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = 'b' THEN
      -- handle must b property
      must_count := must_count + 1;
      -- .merge.m3.'|'.2.b
      res := JSONB_TYPEOF(pval) = 'number' AND (pval)::INT8 = (pval)::FLOAT8 AND (pval)::INT8 >= 0;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'c' THEN
      -- handle must c property
      must_count := must_count + 1;
      -- .merge.m3.'|'.2.c
      res := JSONB_TYPEOF(pval) = 'number' AND (pval)::INT8 = (pval)::FLOAT8 AND (pval)::INT8 >= 1;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN must_count = 2;
END;
$$ LANGUAGE PLpgSQL;

-- object .merge.m3.'|'.1
CREATE OR REPLACE FUNCTION _jm_obj_10(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  must_count int;
  prop TEXT;
  pval JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  must_count := 0;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = 'a' THEN
      -- handle must a property
      must_count := must_count + 1;
      -- .merge.m3.'|'.1.a
      res := JSONB_TYPEOF(pval) = 'number' AND (pval)::INT8 = (pval)::FLOAT8 AND (pval)::INT8 >= 0;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'd' THEN
      -- handle must d property
      must_count := must_count + 1;
      -- .merge.m3.'|'.1.d
      res := JSONB_TYPEOF(pval) = 'number' AND (pval)::INT8 = (pval)::FLOAT8 AND (pval)::INT8 >= 1;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN must_count = 2;
END;
$$ LANGUAGE PLpgSQL;

-- object .merge.m3.'|'.0
CREATE OR REPLACE FUNCTION _jm_obj_11(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  must_count int;
  prop TEXT;
  pval JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  must_count := 0;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = 'a' THEN
      -- handle must a property
      must_count := must_count + 1;
      -- .merge.m3.'|'.0.a
      res := JSONB_TYPEOF(pval) = 'number' AND (pval)::INT8 = (pval)::FLOAT8 AND (pval)::INT8 >= 0;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'c' THEN
      -- handle must c property
      must_count := must_count + 1;
      -- .merge.m3.'|'.0.c
      res := JSONB_TYPEOF(pval) = 'number' AND (pval)::INT8 = (pval)::FLOAT8 AND (pval)::INT8 >= 1;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN must_count = 2;
END;
$$ LANGUAGE PLpgSQL;

-- object .merge.m4
CREATE OR REPLACE FUNCTION _jm_obj_12(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  must_count int;
  prop TEXT;
  pval JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  must_count := 0;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = 'a' THEN
      -- handle must a property
      must_count := must_count + 1;
      -- .merge.m4.a
      res := JSONB_TYPEOF(pval) = 'number' AND (pval)::INT8 = (pval)::FLOAT8 AND (pval)::INT8 >= 0;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'b' THEN
      -- handle must b property
      must_count := must_count + 1;
      -- .merge.m4.b
      res := JSONB_TYPEOF(pval) = 'number' AND (pval)::INT8 = (pval)::FLOAT8 AND (pval)::INT8 >= 0;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'c' THEN
      -- handle must c property
      must_count := must_count + 1;
      -- .merge.m4.c
      res := JSONB_TYPEOF(pval) = 'number' AND (pval)::INT8 = (pval)::FLOAT8 AND (pval)::INT8 >= 0;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'd' THEN
      -- handle must d property
      must_count := must_count + 1;
      -- .merge.m4.d
      res := JSONB_TYPEOF(pval) = 'number' AND (pval)::INT8 = (pval)::FLOAT8 AND (pval)::INT8 >= 0;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN must_count = 4;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_1_map_merge (.merge)
CREATE OR REPLACE FUNCTION _jm_f_52(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
BEGIN
  -- merge object properties
  -- .merge
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = 'm0' THEN
      -- handle may m0 property
      -- .merge.m0
      res := _jm_obj_3(pval, NULL, NULL);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'm1' THEN
      -- handle may m1 property
      -- .merge.m1
      -- .merge.m1.'|'.0
      -- .merge.m1.'|'.1
      res := JSONB_TYPEOF(pval) = 'object' AND (_jm_obj_5(pval, NULL, NULL) OR _jm_obj_4(pval, NULL, NULL));
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'm2' THEN
      -- handle may m2 property
      -- .merge.m2
      -- .merge.m2.'|'.0
      -- .merge.m2.'|'.1
      res := JSONB_TYPEOF(pval) = 'object' AND (_jm_obj_7(pval, NULL, NULL) OR _jm_obj_6(pval, NULL, NULL));
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'm3' THEN
      -- handle may m3 property
      -- .merge.m3
      -- .merge.m3.'|'.0
      -- .merge.m3.'|'.1
      -- .merge.m3.'|'.2
      -- .merge.m3.'|'.3
      res := JSONB_TYPEOF(pval) = 'object' AND (_jm_obj_11(pval, NULL, NULL) OR _jm_obj_10(pval, NULL, NULL) OR _jm_obj_9(pval, NULL, NULL) OR _jm_obj_8(pval, NULL, NULL));
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'm4' THEN
      -- handle may m4 property
      -- .merge.m4
      res := _jm_obj_12(pval, NULL, NULL);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_1_map_null (.null)
CREATE OR REPLACE FUNCTION _jm_f_53(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
BEGIN
  -- null: inference, predefs, constants
  -- .null
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = 'n0' THEN
      -- handle may n0 property
      -- .null.n0
      res := JSONB_TYPEOF(pval) = 'null';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'n1' THEN
      -- handle may n1 property
      -- .null.n1
      res := JSONB_TYPEOF(pval) = 'null';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'n2' THEN
      -- handle may n2 property
      -- .null.n2
      res := JSONB_TYPEOF(pval) = 'null';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- object .object.o0
CREATE OR REPLACE FUNCTION _jm_obj_13(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  RETURN JSONB_TYPEOF(val) = 'object' AND jm_object_size(val) = 0;
END;
$$ LANGUAGE PLpgSQL;

-- object .object.o1
CREATE OR REPLACE FUNCTION _jm_obj_14(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  must_count int;
  prop TEXT;
  pval JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  must_count := 0;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = 'a' THEN
      -- handle must a property
      must_count := must_count + 1;
      -- .object.o1.a
      res := JSONB_TYPEOF(pval) = 'number' AND (pval)::INT8 = (pval)::FLOAT8 AND (pval)::INT8 >= 0;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'b' THEN
      -- handle must b property
      must_count := must_count + 1;
      -- .object.o1.b
      res := JSONB_TYPEOF(pval) = 'number' AND (pval)::INT8 = (pval)::FLOAT8 AND (pval)::INT8 >= 0;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'c' THEN
      -- handle must c property
      must_count := must_count + 1;
      -- .object.o1.c
      res := JSONB_TYPEOF(pval) = 'number' AND (pval)::INT8 = (pval)::FLOAT8 AND (pval)::INT8 >= 0;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN must_count = 3;
END;
$$ LANGUAGE PLpgSQL;

-- object .object.o2
CREATE OR REPLACE FUNCTION _jm_obj_15(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = 'a' THEN
      -- handle may a property
      -- .object.o2.a
      res := JSONB_TYPEOF(pval) = 'number' AND (pval)::INT8 = (pval)::FLOAT8 AND (pval)::INT8 >= 0;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- object .object.o3
CREATE OR REPLACE FUNCTION _jm_obj_16(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF STARTS_WITH(prop, 'a') THEN
      -- handle 1 re props
      -- .object.o3.'/^a/'
      res := JSONB_TYPEOF(pval) = 'number' AND (pval)::INT8 = (pval)::FLOAT8 AND (pval)::INT8 >= 0;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- object .object.o4
CREATE OR REPLACE FUNCTION _jm_obj_17(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF jm_is_valid_date(prop, NULL, NULL) THEN
      -- handle 1 key props
      -- .object.o4.'$DATE'
      res := JSONB_TYPEOF(pval) = 'string';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- object .object.o5
CREATE OR REPLACE FUNCTION _jm_obj_18(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    -- handle other props
    -- .object.o5.''
    res := JSONB_TYPEOF(pval) = 'number' AND (pval)::INT8 = (pval)::FLOAT8 AND (pval)::INT8 >= 0;
    IF NOT res THEN
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- object .object.o6
CREATE OR REPLACE FUNCTION _jm_obj_19(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- accept any object
  RETURN JSONB_TYPEOF(val) = 'object';
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_1_map_object (.object)
CREATE OR REPLACE FUNCTION _jm_f_54(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
BEGIN
  -- object map property names to values
  -- .object
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = 'o0' THEN
      -- handle may o0 property
      -- .object.o0
      res := _jm_obj_13(pval, NULL, NULL);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'o1' THEN
      -- handle may o1 property
      -- .object.o1
      res := _jm_obj_14(pval, NULL, NULL);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'o2' THEN
      -- handle may o2 property
      -- .object.o2
      res := _jm_obj_15(pval, NULL, NULL);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'o3' THEN
      -- handle may o3 property
      -- .object.o3
      res := _jm_obj_16(pval, NULL, NULL);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'o4' THEN
      -- handle may o4 property
      -- .object.o4
      res := _jm_obj_17(pval, NULL, NULL);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'o5' THEN
      -- handle may o5 property
      -- .object.o5
      res := _jm_obj_18(pval, NULL, NULL);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'o6' THEN
      -- handle may o6 property
      -- .object.o6
      res := _jm_obj_19(pval, NULL, NULL);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- object .or.o2.'|'.3
CREATE OR REPLACE FUNCTION _jm_obj_20(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- accept any object
  RETURN JSONB_TYPEOF(val) = 'object';
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_1_map_or (.or)
CREATE OR REPLACE FUNCTION _jm_f_55(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
BEGIN
  -- soft alternative, first match
  -- .or
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = 'o0' THEN
      -- handle may o0 property
      -- .or.o0
      -- .or.o0.'|'.0
      -- .or.o0.'|'.1
      res := JSONB_TYPEOF(pval) = 'boolean' OR JSONB_TYPEOF(pval) = 'number' AND (pval)::INT8 = (pval)::FLOAT8;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'o1' THEN
      -- handle may o1 property
      -- .or.o1
      -- .or.o1.'|'.0
      -- .or.o1.'|'.1
      res := JSONB_TYPEOF(pval) = 'string' AND jm_is_valid_date(JSON_VALUE(pval, '$' RETURNING TEXT), NULL, NULL) OR JSONB_TYPEOF(pval) = 'string' AND jm_is_valid_time(JSON_VALUE(pval, '$' RETURNING TEXT), NULL, NULL);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'o2' THEN
      -- handle may o2 property
      -- .or.o2
      -- .or.o2.'|'.0
      -- .or.o2.'|'.1
      -- .or.o2.'|'.2
      -- .or.o2.'|'.3
      res := JSONB_TYPEOF(pval) = 'number' AND (pval)::INT8 = (pval)::FLOAT8 AND (pval)::INT8 >= 0 OR JSONB_TYPEOF(pval) = 'string' AND jm_is_valid_uuid(JSON_VALUE(pval, '$' RETURNING TEXT), NULL, NULL) OR JSONB_TYPEOF(pval) = 'array' OR _jm_obj_20(pval, NULL, NULL);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_f_56_map_ANY (.predefs.ANY)
CREATE OR REPLACE FUNCTION _jm_f_57(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .predefs.ANY
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_f_56_map_BOOL (.predefs.BOOL)
CREATE OR REPLACE FUNCTION _jm_f_58(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .predefs.BOOL
  RETURN JSONB_TYPEOF(val) = 'boolean';
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_f_56_map_BOOLEAN (.predefs.BOOLEAN)
CREATE OR REPLACE FUNCTION _jm_f_59(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .predefs.BOOLEAN
  RETURN JSONB_TYPEOF(val) = 'boolean';
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_f_56_map_DATE (.predefs.DATE)
CREATE OR REPLACE FUNCTION _jm_f_60(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .predefs.DATE
  RETURN JSONB_TYPEOF(val) = 'string' AND jm_is_valid_date(JSON_VALUE(val, '$' RETURNING TEXT), NULL, NULL);
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_f_56_map_DATETIME (.predefs.DATETIME)
CREATE OR REPLACE FUNCTION _jm_f_61(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .predefs.DATETIME
  RETURN JSONB_TYPEOF(val) = 'string' AND jm_is_valid_datetime(JSON_VALUE(val, '$' RETURNING TEXT), NULL, NULL);
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_f_56_map_EMAIL (.predefs.EMAIL)
CREATE OR REPLACE FUNCTION _jm_f_62(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .predefs.EMAIL
  RETURN JSONB_TYPEOF(val) = 'string' AND jm_is_valid_email(JSON_VALUE(val, '$' RETURNING TEXT), NULL, NULL);
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_f_56_map_EXREG (.predefs.EXREG)
CREATE OR REPLACE FUNCTION _jm_f_63(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .predefs.EXREG
  RETURN JSONB_TYPEOF(val) = 'string' AND jm_is_valid_extreg(JSON_VALUE(val, '$' RETURNING TEXT), NULL, NULL);
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_f_56_map_F32 (.predefs.F32)
CREATE OR REPLACE FUNCTION _jm_f_64(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .predefs.F32
  RETURN JSONB_TYPEOF(val) = 'number';
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_f_56_map_F64 (.predefs.F64)
CREATE OR REPLACE FUNCTION _jm_f_65(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .predefs.F64
  RETURN JSONB_TYPEOF(val) = 'number';
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_f_56_map_FLOAT (.predefs.FLOAT)
CREATE OR REPLACE FUNCTION _jm_f_66(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .predefs.FLOAT
  RETURN JSONB_TYPEOF(val) = 'number';
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_f_56_map_I32 (.predefs.I32)
CREATE OR REPLACE FUNCTION _jm_f_67(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .predefs.I32
  RETURN JSONB_TYPEOF(val) = 'number' AND (val)::INT8 = (val)::FLOAT8;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_f_56_map_I64 (.predefs.I64)
CREATE OR REPLACE FUNCTION _jm_f_68(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .predefs.I64
  RETURN JSONB_TYPEOF(val) = 'number' AND (val)::INT8 = (val)::FLOAT8;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_f_56_map_INT (.predefs.INT)
CREATE OR REPLACE FUNCTION _jm_f_69(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .predefs.INT
  RETURN JSONB_TYPEOF(val) = 'number' AND (val)::INT8 = (val)::FLOAT8;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_f_56_map_INTEGER (.predefs.INTEGER)
CREATE OR REPLACE FUNCTION _jm_f_70(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .predefs.INTEGER
  RETURN JSONB_TYPEOF(val) = 'number' AND (val)::INT8 = (val)::FLOAT8;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_f_56_map_JSON (.predefs.JSON)
CREATE OR REPLACE FUNCTION _jm_f_71(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .predefs.JSON
  RETURN JSONB_TYPEOF(val) = 'string' AND jm_is_valid_json(JSON_VALUE(val, '$' RETURNING TEXT), NULL, NULL);
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_f_56_map_NONE (.predefs.NONE)
CREATE OR REPLACE FUNCTION _jm_f_72(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .predefs.NONE
  RETURN FALSE;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_f_56_map_NULL (.predefs.NULL)
CREATE OR REPLACE FUNCTION _jm_f_73(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .predefs.NULL
  RETURN JSONB_TYPEOF(val) = 'null';
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_f_56_map_NUMBER (.predefs.NUMBER)
CREATE OR REPLACE FUNCTION _jm_f_74(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .predefs.NUMBER
  RETURN JSONB_TYPEOF(val) = 'number';
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_f_56_map_REGEX (.predefs.REGEX)
CREATE OR REPLACE FUNCTION _jm_f_75(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .predefs.REGEX
  RETURN JSONB_TYPEOF(val) = 'string' AND jm_is_valid_regex(JSON_VALUE(val, '$' RETURNING TEXT), NULL, NULL);
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_f_56_map_STRING (.predefs.STRING)
CREATE OR REPLACE FUNCTION _jm_f_76(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .predefs.STRING
  RETURN JSONB_TYPEOF(val) = 'string';
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_f_56_map_TIME (.predefs.TIME)
CREATE OR REPLACE FUNCTION _jm_f_77(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .predefs.TIME
  RETURN JSONB_TYPEOF(val) = 'string' AND jm_is_valid_time(JSON_VALUE(val, '$' RETURNING TEXT), NULL, NULL);
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_f_56_map_U32 (.predefs.U32)
CREATE OR REPLACE FUNCTION _jm_f_78(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .predefs.U32
  RETURN JSONB_TYPEOF(val) = 'number' AND (val)::INT8 = (val)::FLOAT8 AND (val)::INT8 >= 0;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_f_56_map_U64 (.predefs.U64)
CREATE OR REPLACE FUNCTION _jm_f_79(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .predefs.U64
  RETURN JSONB_TYPEOF(val) = 'number' AND (val)::INT8 = (val)::FLOAT8 AND (val)::INT8 >= 0;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_f_56_map_URI (.predefs.URI)
CREATE OR REPLACE FUNCTION _jm_f_80(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .predefs.URI
  RETURN JSONB_TYPEOF(val) = 'string' AND jm_is_valid_url(JSON_VALUE(val, '$' RETURNING TEXT), NULL, NULL);
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_f_56_map_URL (.predefs.URL)
CREATE OR REPLACE FUNCTION _jm_f_81(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .predefs.URL
  RETURN JSONB_TYPEOF(val) = 'string' AND jm_is_valid_url(JSON_VALUE(val, '$' RETURNING TEXT), NULL, NULL);
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_f_56_map_UUID (.predefs.UUID)
CREATE OR REPLACE FUNCTION _jm_f_82(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .predefs.UUID
  RETURN JSONB_TYPEOF(val) = 'string' AND jm_is_valid_uuid(JSON_VALUE(val, '$' RETURNING TEXT), NULL, NULL);
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION _jm_f_56_map(name TEXT)
RETURNS TEXT STRICT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  map JSONB := JSONB '{"ANY":"_jm_f_57","BOOL":"_jm_f_58","BOOLEAN":"_jm_f_59","DATE":"_jm_f_60","DATETIME":"_jm_f_61","EMAIL":"_jm_f_62","EXREG":"_jm_f_63","F32":"_jm_f_64","F64":"_jm_f_65","FLOAT":"_jm_f_66","I32":"_jm_f_67","I64":"_jm_f_68","INT":"_jm_f_69","INTEGER":"_jm_f_70","JSON":"_jm_f_71","NONE":"_jm_f_72","NULL":"_jm_f_73","NUMBER":"_jm_f_74","REGEX":"_jm_f_75","STRING":"_jm_f_76","TIME":"_jm_f_77","U32":"_jm_f_78","U64":"_jm_f_79","URI":"_jm_f_80","URL":"_jm_f_81","UUID":"_jm_f_82"}';
BEGIN
  RETURN map->>name;
END;
$$ LANGUAGE plpgsql;

-- check json_model_1_map_predefs (.predefs)
CREATE OR REPLACE FUNCTION _jm_f_56(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  pfun TEXT;
  prop TEXT;
  pval JSONB;
BEGIN
  -- predefined models
  -- .predefs
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF _jm_f_56_map(prop) IS NOT NULL THEN
      -- handle 26 may props
      pfun := _jm_f_56_map(prop);
      IF NOT jm_call(pfun, pval, NULL, NULL) THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- regex=^(Calvin|Susie)$ opts=n
CREATE OR REPLACE FUNCTION _jm_re_0(val TEXT, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  RETURN regexp_like(val, '^(Calvin|Susie)$', 'n');
END;
$$ LANGUAGE plpgsql;

-- check json_model_1_map_string (.string)
CREATE OR REPLACE FUNCTION _jm_f_83(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
BEGIN
  -- strings: inference, predef, constants, regex
  -- .string
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = 's0' THEN
      -- handle may s0 property
      -- .string.s0
      res := JSONB_TYPEOF(pval) = 'string';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 's1' THEN
      -- handle may s1 property
      -- .string.s1
      res := JSONB_TYPEOF(pval) = 'string';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 's2' THEN
      -- handle may s2 property
      -- .string.s2
      res := JSONB_TYPEOF(pval) = 'string' AND JSON_VALUE(pval, '$' RETURNING TEXT) = 'Susie';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 's3' THEN
      -- handle may s3 property
      -- .string.s3
      res := JSONB_TYPEOF(pval) = 'string' AND JSON_VALUE(pval, '$' RETURNING TEXT) = 'Calvin';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 's4' THEN
      -- handle may s4 property
      -- .string.s4
      -- "/^(Calvin|Susie)$/"
      res := JSONB_TYPEOF(pval) = 'string' AND _jm_re_0(JSON_VALUE(pval, '$' RETURNING TEXT), NULL, NULL);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_1_map_tuple (.tuple)
CREATE OR REPLACE FUNCTION _jm_f_84(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
  arr_7_idx INT8;
  arr_7_item JSONB;
  ival_12 int;
  len_0 int;
  idx_0 INT8;
  ival_13 int;
BEGIN
  -- tuple items have a type
  -- .tuple
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = 't0' THEN
      -- handle may t0 property
      -- .tuple.t0
      res := JSONB_TYPEOF(pval) = 'array' AND JSONB_ARRAY_LENGTH(pval) = 0;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 't1' THEN
      -- handle may t1 property
      -- .tuple.t1
      -- .tuple.t1.'@'
      res := JSONB_TYPEOF(pval) = 'array';
      IF res THEN
        FOR arr_7_idx IN 0 .. JSONB_ARRAY_LENGTH(pval) - 1 LOOP
          arr_7_item := pval -> arr_7_idx;
          -- .tuple.t1.'@'.0
          res := JSONB_TYPEOF(arr_7_item) = 'number' AND (arr_7_item)::INT8 = (arr_7_item)::FLOAT8 AND (arr_7_item)::INT8 >= 0;
          IF NOT res THEN
            EXIT;
          END IF;
        END LOOP;
      END IF;
      IF res THEN
        ival_12 := JSONB_ARRAY_LENGTH(pval);
        res := ival_12 = 1;
      END IF;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 't2' THEN
      -- handle may t2 property
      -- .tuple.t2
      res := JSONB_TYPEOF(pval) = 'array' AND JSONB_ARRAY_LENGTH(pval) = 2;
      IF res THEN
        -- .tuple.t2.0
        res := JSONB_TYPEOF(pval -> 0) = 'number' AND (pval -> 0)::INT8 = (pval -> 0)::FLOAT8 AND (pval -> 0)::INT8 >= 0;
        IF res THEN
          -- .tuple.t2.1
          res := JSONB_TYPEOF(pval -> 1) = 'number' AND (pval -> 1)::INT8 = (pval -> 1)::FLOAT8 AND (pval -> 1)::INT8 >= 0;
        END IF;
      END IF;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 't3' THEN
      -- handle may t3 property
      -- .tuple.t3
      res := JSONB_TYPEOF(pval) = 'array' AND JSONB_ARRAY_LENGTH(pval) = 3;
      IF res THEN
        -- .tuple.t3.0
        res := JSONB_TYPEOF(pval -> 0) = 'boolean';
        IF res THEN
          -- .tuple.t3.1
          res := JSONB_TYPEOF(pval -> 1) = 'number' AND (pval -> 1)::INT8 = (pval -> 1)::FLOAT8 AND (pval -> 1)::INT8 >= 0;
          IF res THEN
            -- .tuple.t3.2
            res := JSONB_TYPEOF(pval -> 2) = 'string';
          END IF;
        END IF;
      END IF;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 't4' THEN
      -- handle may t4 property
      -- .tuple.t4
      -- .tuple.t4.'@'
      res := JSONB_TYPEOF(pval) = 'array';
      IF res THEN
        len_0 := JSONB_ARRAY_LENGTH(pval);
        IF len_0 > 0 THEN
          -- .tuple.t4.'@'.0
          res := JSONB_TYPEOF(pval -> 0) = 'string';
        END IF;
        IF res THEN
          FOR idx_0 IN 1 .. len_0-1 LOOP
            -- .tuple.t4.'@'.1
            res := JSONB_TYPEOF(pval -> idx_0) = 'number' AND (pval -> idx_0)::INT8 = (pval -> idx_0)::FLOAT8 AND (pval -> idx_0)::INT8 >= 0;
            IF NOT res THEN
              EXIT;
            END IF;
          END LOOP;
        END IF;
      END IF;
      IF res THEN
        ival_13 := JSONB_ARRAY_LENGTH(pval);
        res := ival_13 >= 2;
      END IF;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_1_map_xor (.xor)
CREATE OR REPLACE FUNCTION _jm_f_85(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
  xc_0 int;
  xr_0 bool;
  xc_1 int;
  xr_1 bool;
  is_0 bool;
BEGIN
  -- hard alternative, only one must match
  -- .xor
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = 'x0' THEN
      -- handle may x0 property
      -- .xor.x0
      -- .xor.x0.'|'.0
      -- .xor.x0.'|'.1
      res := JSONB_TYPEOF(pval) = 'boolean' OR JSONB_TYPEOF(pval) = 'number' AND (pval)::INT8 = (pval)::FLOAT8;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'x1' THEN
      -- handle may x1 property
      -- .xor.x1
      -- generic xor list
      xc_0 := 0;
      -- .xor.x1.'^'.0
      -- "/^a/"
      xr_0 := JSONB_TYPEOF(pval) = 'string' AND STARTS_WITH(JSON_VALUE(pval, '$' RETURNING TEXT), 'a');
      IF xr_0 THEN
        xc_0 := xc_0 + 1;
      END IF;
      -- .xor.x1.'^'.1
      -- "/z$/"
      xr_0 := JSONB_TYPEOF(pval) = 'string' AND RIGHT(JSON_VALUE(pval, '$' RETURNING TEXT), 1) = 'z';
      IF xr_0 THEN
        xc_0 := xc_0 + 1;
      END IF;
      res := xc_0 = 1;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'x2' THEN
      -- handle may x2 property
      -- .xor.x2
      -- generic xor list
      xc_1 := 0;
      -- .xor.x2.'^'.0
      xr_1 := JSONB_TYPEOF(pval) = 'number' AND (pval)::INT8 = (pval)::FLOAT8;
      IF xr_1 THEN
        xc_1 := xc_1 + 1;
      END IF;
      -- .xor.x2.'^'.1
      xr_1 := JSONB_TYPEOF(pval) = 'number' AND (pval)::INT8 = (pval)::FLOAT8 AND (pval)::INT8 >= 0;
      IF xr_1 THEN
        xc_1 := xc_1 + 1;
      END IF;
      res := xc_1 = 1;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'x3' THEN
      -- handle may x3 property
      -- .xor.x3
      -- not-case xor list
      -- .xor.x3.'^'.1
      is_0 := JSONB_TYPEOF(pval) = 'number' AND (pval)::INT8 = (pval)::FLOAT8 AND (pval)::INT8 >= 0;
      res := NOT is_0;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION json_model_1_map(name TEXT)
RETURNS TEXT STRICT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  map JSONB := JSONB '{"and":"_jm_f_0","array":"_jm_f_1","bool":"_jm_f_2","constraints":"_jm_f_3","enum":"_jm_f_29","float":"_jm_f_30","int":"_jm_f_40","merge":"_jm_f_52","null":"_jm_f_53","object":"_jm_f_54","or":"_jm_f_55","predefs":"_jm_f_56","string":"_jm_f_83","tuple":"_jm_f_84","xor":"_jm_f_85"}';
BEGIN
  RETURN map->>name;
END;
$$ LANGUAGE plpgsql;

-- check $ (.)
CREATE OR REPLACE FUNCTION json_model_1(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  pfun TEXT;
  prop TEXT;
  pval JSONB;
BEGIN
  -- A model to illustrate most design features
  -- .
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF json_model_1_map(prop) IS NOT NULL THEN
      -- handle 15 may props
      pfun := json_model_1_map(prop);
      IF NOT jm_call(pfun, pval, NULL, NULL) THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION check_model_map(name TEXT)
RETURNS TEXT STRICT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  map JSONB := JSONB '{"":"json_model_1","a":"json_model_2","b":"json_model_3","ab":"json_model_4","cd":"json_model_5"}';
BEGIN
  RETURN map->>name;
END;
$$ LANGUAGE plpgsql;

--
-- constant maps initialization
--
TRUNCATE jm_constant_maps;

--
-- JSON Model checking entry point
--
-- TODO INOUT rep?
CREATE OR REPLACE FUNCTION check_model(val JSONB, name TEXT, rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  fun TEXT;
BEGIN
  fun := check_model_map(name);
  IF fun IS NULL THEN
    RAISE EXCEPTION 'model for % not found', name;
  END IF;
  RETURN jm_call(fun, val, NULL, rep);
END;
$$ LANGUAGE plpgsql;
