#! /usr/bin/perl
#
# Generated by JSON Model Compiler version 2
# see https://github.com/clairey-zx81/json-model
#
use strict;
use warnings;
no warnings "uninitialized";
use re::engine::RE2;
use JSON::JsonModel;
use constant JMC_VERSION => '2';


sub json_model_2($$$);
sub json_model_3($$$);
sub json_model_4($$$);
sub json_model_5($$$);
sub _jm_f_0($$$);
sub _jm_f_1($$$);
sub _jm_f_3($$$);
sub _jm_f_4($$$);
sub _jm_f_5($$$);
sub _jm_f_6($$$);
sub _jm_f_7($$$);
sub _jm_f_8($$$);
my %_jm_f_2_map;
sub _jm_f_2($$$);
sub _jm_f_10($$$);
sub _jm_f_11($$$);
sub _jm_f_12($$$);
sub _jm_f_13($$$);
sub _jm_f_14($$$);
sub _jm_f_15($$$);
sub _jm_f_16($$$);
sub _jm_f_17($$$);
sub _jm_f_18($$$);
sub _jm_obj_0($$$);
sub _jm_f_19($$$);
sub _jm_obj_1($$$);
sub _jm_f_20($$$);
sub _jm_obj_2($$$);
sub _jm_f_21($$$);
sub _jm_f_22($$$);
sub _jm_f_23($$$);
sub _jm_f_24($$$);
sub _jm_f_25($$$);
sub _jm_f_26($$$);
sub _jm_f_27($$$);
sub _jm_f_28($$$);
sub _jm_f_29($$$);
sub _jm_f_30($$$);
sub _jm_f_31($$$);
sub _jm_f_32($$$);
sub _jm_f_33($$$);
sub _jm_f_34($$$);
my %_jm_f_9_map;
sub _jm_f_9($$$);
my %_jm_cst_0;
my %_jm_cst_1;
sub _jm_f_35($$$);
sub _jm_f_37($$$);
sub _jm_f_38($$$);
sub _jm_f_39($$$);
sub _jm_f_40($$$);
sub _jm_f_41($$$);
sub _jm_f_42($$$);
sub _jm_f_43($$$);
sub _jm_f_44($$$);
sub _jm_f_45($$$);
my %_jm_f_36_map;
sub _jm_f_36($$$);
sub _jm_f_47($$$);
sub _jm_f_48($$$);
sub _jm_f_49($$$);
sub _jm_f_50($$$);
sub _jm_f_51($$$);
sub _jm_f_52($$$);
sub _jm_f_53($$$);
sub _jm_f_54($$$);
sub _jm_f_55($$$);
sub _jm_f_56($$$);
sub _jm_f_57($$$);
my %_jm_f_46_map;
sub _jm_f_46($$$);
sub _jm_obj_3($$$);
sub _jm_obj_4($$$);
sub _jm_obj_5($$$);
sub _jm_obj_6($$$);
sub _jm_obj_7($$$);
sub _jm_obj_8($$$);
sub _jm_obj_9($$$);
sub _jm_obj_10($$$);
sub _jm_obj_11($$$);
sub _jm_obj_12($$$);
sub _jm_f_58($$$);
sub _jm_f_59($$$);
sub _jm_f_61($$$);
sub _jm_f_62($$$);
sub _jm_f_63($$$);
sub _jm_f_64($$$);
sub _jm_f_65($$$);
sub _jm_f_66($$$);
sub _jm_f_67($$$);
my %_jm_f_60_map;
sub _jm_f_60($$$);
sub _jm_obj_13($$$);
sub _jm_f_68($$$);
sub _jm_f_70($$$);
sub _jm_f_71($$$);
sub _jm_f_72($$$);
sub _jm_f_73($$$);
sub _jm_f_74($$$);
sub _jm_f_75($$$);
sub _jm_f_76($$$);
sub _jm_f_77($$$);
sub _jm_f_78($$$);
sub _jm_f_79($$$);
sub _jm_f_80($$$);
sub _jm_f_81($$$);
sub _jm_f_82($$$);
sub _jm_f_83($$$);
sub _jm_f_84($$$);
sub _jm_f_85($$$);
sub _jm_f_86($$$);
sub _jm_f_87($$$);
sub _jm_f_88($$$);
sub _jm_f_89($$$);
sub _jm_f_90($$$);
sub _jm_f_91($$$);
sub _jm_f_92($$$);
sub _jm_f_93($$$);
sub _jm_f_94($$$);
sub _jm_f_95($$$);
my %_jm_f_69_map;
sub _jm_f_69($$$);
sub _jm_f_96($$$);
sub _jm_f_97($$$);
sub _jm_f_98($$$);
my %json_model_1_map;
sub json_model_1($$$);
my %check_model_map;

# check $a (.'$a')
sub json_model_2($$$)
{
    my ($val, $path, $rep) = @_;
    # .'$a'
    return jm_is_string($val) && $val eq 'A';
}

# check $b (.'$b')
sub json_model_3($$$)
{
    my ($val, $path, $rep) = @_;
    # .'$b'
    return jm_is_string($val) && $val eq 'A';
}

# check $ab (.'$ab')
sub json_model_4($$$)
{
    my ($val, $path, $rep) = @_;
    # .'$ab'
    # check close must only props
    if (! jm_is_object($val))
    {
        return 0;
    }
    if (jm_obj_size($val) != 2)
    {
        return 0;
    }
    my $pval;
    my $res;
    if (! exists $$val{'a'})
    {
        return 0;
    }
    $pval = $$val{'a'};
    # .'$ab'.a
    $res = jm_is_integer($pval) && $pval >= 0;
    if (! $res)
    {
        return 0;
    }
    if (! exists $$val{'b'})
    {
        return 0;
    }
    $pval = $$val{'b'};
    # .'$ab'.b
    return jm_is_integer($pval) && $pval >= 0;
}

# check $cd (.'$cd')
sub json_model_5($$$)
{
    my ($val, $path, $rep) = @_;
    # .'$cd'
    # check close must only props
    if (! jm_is_object($val))
    {
        return 0;
    }
    if (jm_obj_size($val) != 2)
    {
        return 0;
    }
    my $pval;
    my $res;
    if (! exists $$val{'c'})
    {
        return 0;
    }
    $pval = $$val{'c'};
    # .'$cd'.c
    $res = jm_is_integer($pval) && $pval >= 0;
    if (! $res)
    {
        return 0;
    }
    if (! exists $$val{'d'})
    {
        return 0;
    }
    $pval = $$val{'d'};
    # .'$cd'.d
    return jm_is_integer($pval) && $pval >= 0;
}

# check json_model_1_map_and (.and)
sub _jm_f_0($$$)
{
    my ($val, $path, $rep) = @_;
    # conjunction, all must match
    # .and
    if (! jm_is_object($val))
    {
        return 0;
    }
    my $res;
    scalar keys %$val;
    while (my ($prop, $pval) = each %$val)
    {
        if ($prop eq 'a0')
        {
            # handle may a0 property
            # .and.a0
            $res = 1;
            if ($res)
            {
                # .and.a0.'&'.0
                $res = jm_is_string($pval) && jm_is_valid_date($pval, undef, $rep);
                if ($res)
                {
                    # .and.a0.'&'.1
                    # "/^2020-/"
                    $res = jm_is_string($pval) && jm_starts_with($pval, '2020-');
                }
            }
            if (! $res)
            {
                return 0;
            }
        }
        else
        {
            return 0;
        }
    }
    return 1;
}

# check json_model_1_map_array (.array)
sub _jm_f_1($$$)
{
    my ($val, $path, $rep) = @_;
    # example arrays
    # .array
    if (! jm_is_object($val))
    {
        return 0;
    }
    my $res;
    scalar keys %$val;
    while (my ($prop, $pval) = each %$val)
    {
        if ($prop eq 'a0')
        {
            # handle may a0 property
            # .array.a0
            $res = jm_is_array($pval);
            if ($res)
            {
                for my $arr_0_idx (0 .. $#$pval)
                {
                    my $arr_0_item = $$pval[$arr_0_idx];
                    # .array.a0.0
                    $res = jm_is_integer($arr_0_item) && $arr_0_item >= 0;
                    if (! $res)
                    {
                        last;
                    }
                }
            }
            if (! $res)
            {
                return 0;
            }
        }
        elsif ($prop eq 'a1')
        {
            # handle may a1 property
            # .array.a1
            $res = jm_is_array($pval);
            if ($res)
            {
                for my $arr_1_idx (0 .. $#$pval)
                {
                    my $arr_1_item = $$pval[$arr_1_idx];
                    # .array.a1.0
                    $res = jm_is_string($arr_1_item);
                    if (! $res)
                    {
                        last;
                    }
                }
            }
            if (! $res)
            {
                return 0;
            }
        }
        elsif ($prop eq 'a2')
        {
            # handle may a2 property
            # .array.a2
            $res = jm_is_array($pval);
            if ($res)
            {
                for my $arr_2_idx (0 .. $#$pval)
                {
                    my $arr_2_item = $$pval[$arr_2_idx];
                    # .array.a2.0
                    $res = jm_is_string($arr_2_item) && jm_is_valid_date($arr_2_item, undef, $rep);
                    if (! $res)
                    {
                        last;
                    }
                }
            }
            if (! $res)
            {
                return 0;
            }
        }
        elsif ($prop eq 'a3')
        {
            # handle may a3 property
            # .array.a3
            $res = jm_is_array($pval);
            if ($res)
            {
                for my $arr_3_idx (0 .. $#$pval)
                {
                    my $arr_3_item = $$pval[$arr_3_idx];
                    # .array.a3.0
                    $res = jm_is_boolean($arr_3_item);
                    if (! $res)
                    {
                        last;
                    }
                }
            }
            if (! $res)
            {
                return 0;
            }
        }
        elsif ($prop eq 'a4')
        {
            # handle may a4 property
            # .array.a4
            $res = jm_is_array($pval);
            if (! $res)
            {
                return 0;
            }
        }
        else
        {
            return 0;
        }
    }
    return 1;
}

# check _jm_f_2_map_b0 (.bool.b0)
sub _jm_f_3($$$)
{
    my ($val, $path, $rep) = @_;
    # .bool.b0
    return jm_is_boolean($val);
}

# check _jm_f_2_map_b1 (.bool.b1)
sub _jm_f_4($$$)
{
    my ($val, $path, $rep) = @_;
    # .bool.b1
    return jm_is_boolean($val);
}

# check _jm_f_2_map_b2 (.bool.b2)
sub _jm_f_5($$$)
{
    my ($val, $path, $rep) = @_;
    # .bool.b2
    return jm_is_boolean($val);
}

# check _jm_f_2_map_b3 (.bool.b3)
sub _jm_f_6($$$)
{
    my ($val, $path, $rep) = @_;
    # .bool.b3
    return jm_is_boolean($val) && $val == 1;
}

# check _jm_f_2_map_b4 (.bool.b4)
sub _jm_f_7($$$)
{
    my ($val, $path, $rep) = @_;
    # .bool.b4
    return jm_is_boolean($val) && $val == 0;
}

# check _jm_f_2_map_b5 (.bool.b5)
sub _jm_f_8($$$)
{
    my ($val, $path, $rep) = @_;
    # .bool.b5
    my $res = jm_is_boolean($val);
    if ($res)
    {
        # .bool.b5.'|'.0
        # .bool.b5.'|'.1
        $res = $val == 0 || $val == 1;
    }
    return $res;
}


# check json_model_1_map_bool (.bool)
sub _jm_f_2($$$)
{
    my ($val, $path, $rep) = @_;
    # booleans: inference, predefs, constants, enum
    # .bool
    if (! jm_is_object($val))
    {
        return 0;
    }
    my $pfun;
    scalar keys %$val;
    while (my ($prop, $pval) = each %$val)
    {
        if (($pfun = $_jm_f_2_map{$prop}))
        {
            # handle 6 may props
            if (defined($pfun) && ! &$pfun($pval, undef, $rep))
            {
                return 0;
            }
        }
        else
        {
            return 0;
        }
    }
    return 1;
}

# check _jm_f_9_map_cia0 (.constraints.cia0)
sub _jm_f_10($$$)
{
    my ($val, $path, $rep) = @_;
    # .constraints.cia0
    # .constraints.cia0.'@'
    my $res = jm_is_array($val);
    if ($res)
    {
        for my $arr_4_idx (0 .. $#$val)
        {
            my $arr_4_item = $$val[$arr_4_idx];
            # .constraints.cia0.'@'.0
            $res = jm_is_integer($arr_4_item) && $arr_4_item >= 0;
            if (! $res)
            {
                last;
            }
        }
    }
    if ($res)
    {
        my $ival_0 = scalar @$val;
        $res = $ival_0 == 3;
    }
    return $res;
}

# check _jm_f_9_map_cia1 (.constraints.cia1)
sub _jm_f_11($$$)
{
    my ($val, $path, $rep) = @_;
    # .constraints.cia1
    # .constraints.cia1.'@'
    my $res = jm_is_array($val);
    if ($res)
    {
        for my $arr_5_idx (0 .. $#$val)
        {
            my $arr_5_item = $$val[$arr_5_idx];
            # .constraints.cia1.'@'.0
            $res = jm_is_integer($arr_5_item) && $arr_5_item >= 0;
            if (! $res)
            {
                last;
            }
        }
    }
    if ($res)
    {
        my $ival_1 = scalar @$val;
        $res = $ival_1 != 4 && $ival_1 <= 5 && $ival_1 >= 2;
    }
    return $res;
}

# check _jm_f_9_map_cia2 (.constraints.cia2)
sub _jm_f_12($$$)
{
    my ($val, $path, $rep) = @_;
    # .constraints.cia2
    # .constraints.cia2.'@'
    my $res = jm_is_array($val);
    if ($res)
    {
        for my $arr_6_idx (0 .. $#$val)
        {
            my $arr_6_item = $$val[$arr_6_idx];
            # .constraints.cia2.'@'.0
            $res = jm_is_integer($arr_6_item) && $arr_6_item >= 0;
            if (! $res)
            {
                last;
            }
        }
    }
    if ($res)
    {
        my $ival_2 = scalar @$val;
        $res = $ival_2 <= 4 && $ival_2 >= 3;
    }
    return $res;
}

# check _jm_f_9_map_cii0 (.constraints.cii0)
sub _jm_f_13($$$)
{
    my ($val, $path, $rep) = @_;
    # .constraints.cii0
    return jm_is_integer($val) && $val == 10;
}

# check _jm_f_9_map_cii1 (.constraints.cii1)
sub _jm_f_14($$$)
{
    my ($val, $path, $rep) = @_;
    # .constraints.cii1
    # .constraints.cii1.'@'
    my $res = jm_is_integer($val) && $val >= 0;
    if ($res)
    {
        my $ival_3 = $val;
        $res = $ival_3 != 10 && $ival_3 <= 12 && $ival_3 >= 8;
    }
    return $res;
}

# check _jm_f_9_map_cii2 (.constraints.cii2)
sub _jm_f_15($$$)
{
    my ($val, $path, $rep) = @_;
    # .constraints.cii2
    # .constraints.cii2.'@'
    my $res = jm_is_integer($val) && $val >= 0;
    if ($res)
    {
        my $ival_4 = $val;
        $res = $ival_4 <= 9 && $ival_4 >= 8;
    }
    return $res;
}

# check _jm_f_9_map_cin0 (.constraints.cin0)
sub _jm_f_16($$$)
{
    my ($val, $path, $rep) = @_;
    # .constraints.cin0
    # .constraints.cin0.'@'
    my $res = jm_is_numeric($val) && $val >= 0.0;
    if ($res)
    {
        my $fval_0 = $val;
        $res = $fval_0 == 10;
    }
    return $res;
}

# check _jm_f_9_map_cin1 (.constraints.cin1)
sub _jm_f_17($$$)
{
    my ($val, $path, $rep) = @_;
    # .constraints.cin1
    # .constraints.cin1.'@'
    my $res = jm_is_numeric($val) && $val >= 0.0;
    if ($res)
    {
        my $fval_1 = $val;
        $res = $fval_1 != 10 && $fval_1 <= 12 && $fval_1 >= 8;
    }
    return $res;
}

# check _jm_f_9_map_cin2 (.constraints.cin2)
sub _jm_f_18($$$)
{
    my ($val, $path, $rep) = @_;
    # .constraints.cin2
    # .constraints.cin2.'@'
    my $res = jm_is_numeric($val) && $val >= 0.0;
    if ($res)
    {
        my $fval_2 = $val;
        $res = $fval_2 < 10 && $fval_2 > 7;
    }
    return $res;
}

# object .constraints.cio0.'@'
sub _jm_obj_0($$$)
{
    my ($val, $path, $rep) = @_;
    # accept any object
    return jm_is_object($val);
}

# check _jm_f_9_map_cio0 (.constraints.cio0)
sub _jm_f_19($$$)
{
    my ($val, $path, $rep) = @_;
    # .constraints.cio0
    # .constraints.cio0.'@'
    my $res = _jm_obj_0($val, $path, $rep);
    if ($res)
    {
        my $ival_5 = jm_obj_size($val);
        $res = $ival_5 == 2;
    }
    return $res;
}

# object .constraints.cio1.'@'
sub _jm_obj_1($$$)
{
    my ($val, $path, $rep) = @_;
    # accept any object
    return jm_is_object($val);
}

# check _jm_f_9_map_cio1 (.constraints.cio1)
sub _jm_f_20($$$)
{
    my ($val, $path, $rep) = @_;
    # .constraints.cio1
    # .constraints.cio1.'@'
    my $res = _jm_obj_1($val, $path, $rep);
    if ($res)
    {
        my $ival_6 = jm_obj_size($val);
        $res = $ival_6 != 2 && $ival_6 <= 3 && $ival_6 >= 1;
    }
    return $res;
}

# object .constraints.cio2.'@'
sub _jm_obj_2($$$)
{
    my ($val, $path, $rep) = @_;
    # accept any object
    return jm_is_object($val);
}

# check _jm_f_9_map_cio2 (.constraints.cio2)
sub _jm_f_21($$$)
{
    my ($val, $path, $rep) = @_;
    # .constraints.cio2
    # .constraints.cio2.'@'
    my $res = _jm_obj_2($val, $path, $rep);
    if ($res)
    {
        my $ival_7 = jm_obj_size($val);
        $res = $ival_7 <= 4 && $ival_7 >= 3;
    }
    return $res;
}

# check _jm_f_9_map_cis0 (.constraints.cis0)
sub _jm_f_22($$$)
{
    my ($val, $path, $rep) = @_;
    # .constraints.cis0
    # .constraints.cis0.'@'
    my $res = jm_is_string($val);
    if ($res)
    {
        my $ival_8 = length $val;
        $res = $ival_8 == 10;
    }
    return $res;
}

# check _jm_f_9_map_cis1 (.constraints.cis1)
sub _jm_f_23($$$)
{
    my ($val, $path, $rep) = @_;
    # .constraints.cis1
    # .constraints.cis1.'@'
    my $res = jm_is_string($val);
    if ($res)
    {
        my $ival_9 = length $val;
        $res = $ival_9 != 10 && $ival_9 <= 12 && $ival_9 >= 8;
    }
    return $res;
}

# check _jm_f_9_map_cis2 (.constraints.cis2)
sub _jm_f_24($$$)
{
    my ($val, $path, $rep) = @_;
    # .constraints.cis2
    # .constraints.cis2.'@'
    my $res = jm_is_string($val);
    if ($res)
    {
        my $ival_10 = length $val;
        $res = $ival_10 <= 9 && $ival_10 >= 8;
    }
    return $res;
}

# check _jm_f_9_map_cni0 (.constraints.cni0)
sub _jm_f_25($$$)
{
    my ($val, $path, $rep) = @_;
    # .constraints.cni0
    return jm_is_integer($val) && $val == 42;
}

# check _jm_f_9_map_cni1 (.constraints.cni1)
sub _jm_f_26($$$)
{
    my ($val, $path, $rep) = @_;
    # .constraints.cni1
    # .constraints.cni1.'@'
    my $res = jm_is_integer($val) && $val >= 1;
    if ($res)
    {
        my $ival_11 = $val;
        my $fval_3 = $val;
        $res = $fval_3 != 42.0 && $ival_11 <= 99;
    }
    return $res;
}

# check _jm_f_9_map_cni2 (.constraints.cni2)
sub _jm_f_27($$$)
{
    my ($val, $path, $rep) = @_;
    # .constraints.cni2
    return jm_is_integer($val) && $val == 42;
}

# check _jm_f_9_map_cnn0 (.constraints.cnn0)
sub _jm_f_28($$$)
{
    my ($val, $path, $rep) = @_;
    # .constraints.cnn0
    # .constraints.cnn0.'@'
    my $res = jm_is_numeric($val) && $val >= 0.0;
    if ($res)
    {
        my $fval_4 = $val;
        $res = $fval_4 == 42.1;
    }
    return $res;
}

# check _jm_f_9_map_cnn1 (.constraints.cnn1)
sub _jm_f_29($$$)
{
    my ($val, $path, $rep) = @_;
    # .constraints.cnn1
    # .constraints.cnn1.'@'
    my $res = jm_is_numeric($val) && $val >= 0.0;
    if ($res)
    {
        my $fval_5 = $val;
        $res = $fval_5 != 42.5 && $fval_5 <= 43.0 && $fval_5 >= 42.0;
    }
    return $res;
}

# check _jm_f_9_map_cnn2 (.constraints.cnn2)
sub _jm_f_30($$$)
{
    my ($val, $path, $rep) = @_;
    # .constraints.cnn2
    # .constraints.cnn2.'@'
    my $res = jm_is_numeric($val) && $val >= 0.0;
    if ($res)
    {
        my $fval_6 = $val;
        $res = $fval_6 < 43.0 && $fval_6 > 42.0;
    }
    return $res;
}

# check _jm_f_9_map_css0 (.constraints.css0)
sub _jm_f_31($$$)
{
    my ($val, $path, $rep) = @_;
    # .constraints.css0
    # .constraints.css0.'@'
    my $res = jm_is_string($val);
    if ($res)
    {
        my $sval_0 = $val;
        $res = $sval_0 eq 'Susie';
    }
    return $res;
}

# check _jm_f_9_map_css1 (.constraints.css1)
sub _jm_f_32($$$)
{
    my ($val, $path, $rep) = @_;
    # .constraints.css1
    # .constraints.css1.'@'
    my $res = jm_is_string($val);
    if ($res)
    {
        my $sval_1 = $val;
        $res = $sval_1 ne 'Hobbes' && $sval_1 le 'Z' && $sval_1 ge 'A';
    }
    return $res;
}

# check _jm_f_9_map_css2 (.constraints.css2)
sub _jm_f_33($$$)
{
    my ($val, $path, $rep) = @_;
    # .constraints.css2
    # .constraints.css2.'@'
    my $res = jm_is_string($val);
    if ($res)
    {
        my $sval_2 = $val;
        $res = $sval_2 lt 'Z' && $sval_2 gt 'A';
    }
    return $res;
}

# check _jm_f_9_map_cua0 (.constraints.cua0)
sub _jm_f_34($$$)
{
    my ($val, $path, $rep) = @_;
    # .constraints.cua0
    # .constraints.cua0.'@'
    my $res = jm_is_array($val);
    if ($res)
    {
        $res = jm_is_unique_array($val, $path, $rep);
    }
    return $res;
}


# check json_model_1_map_constraints (.constraints)
sub _jm_f_9($$$)
{
    my ($val, $path, $rep) = @_;
    # .constraints
    if (! jm_is_object($val))
    {
        return 0;
    }
    my $pfun;
    scalar keys %$val;
    while (my ($prop, $pval) = each %$val)
    {
        if (($pfun = $_jm_f_9_map{$prop}))
        {
            # handle 25 may props
            if (defined($pfun) && ! &$pfun($pval, undef, $rep))
            {
                return 0;
            }
        }
        else
        {
            return 0;
        }
    }
    return 1;
}



# check json_model_1_map_enum (.enum)
sub _jm_f_35($$$)
{
    my ($val, $path, $rep) = @_;
    # an enumeration only contains constants
    # .enum
    if (! jm_is_object($val))
    {
        return 0;
    }
    my $res;
    scalar keys %$val;
    while (my ($prop, $pval) = each %$val)
    {
        if ($prop eq 'e0')
        {
            # handle may e0 property
            # .enum.e0
            $res = jm_is_boolean($pval);
            if ($res)
            {
                # .enum.e0.'|'.0
                # .enum.e0.'|'.1
                $res = $pval == 1 || $pval == 0;
            }
            if (! $res)
            {
                return 0;
            }
        }
        elsif ($prop eq 'e1')
        {
            # handle may e1 property
            # .enum.e1
            $res = jm_is_integer($pval);
            if ($res)
            {
                # .enum.e1.'|'.0
                # .enum.e1.'|'.1
                # .enum.e1.'|'.2
                $res = jm_is_integer($pval) && $pval == 200 || jm_is_integer($pval) && $pval == 201 || jm_is_integer($pval) && $pval == 204;
            }
            if (! $res)
            {
                return 0;
            }
        }
        elsif ($prop eq 'e2')
        {
            # handle may e2 property
            # .enum.e2
            $res = jm_is_scalar($pval) && jm_is_string($pval) && exists $_jm_cst_0{$pval};
            if (! $res)
            {
                return 0;
            }
        }
        elsif ($prop eq 'e3')
        {
            # handle may e3 property
            # .enum.e3
            # .enum.e3.'|'.0
            # .enum.e3.'|'.1
            # .enum.e3.'|'.2
            $res = jm_is_scalar($pval) && jm_is_string($pval) && exists $_jm_cst_1{$pval} || jm_is_integer($pval) && $pval == 42 || jm_is_boolean($pval) && $pval == 1 || !defined($pval);
            if (! $res)
            {
                return 0;
            }
        }
        else
        {
            return 0;
        }
    }
    return 1;
}

# check _jm_f_36_map_f0 (.float.f0)
sub _jm_f_37($$$)
{
    my ($val, $path, $rep) = @_;
    # .float.f0
    return jm_is_numeric($val) && $val >= 0.0;
}

# check _jm_f_36_map_f1 (.float.f1)
sub _jm_f_38($$$)
{
    my ($val, $path, $rep) = @_;
    # .float.f1
    return jm_is_numeric($val) && $val > 0.0;
}

# check _jm_f_36_map_f2 (.float.f2)
sub _jm_f_39($$$)
{
    my ($val, $path, $rep) = @_;
    # .float.f2
    return jm_is_numeric($val);
}

# check _jm_f_36_map_f3 (.float.f3)
sub _jm_f_40($$$)
{
    my ($val, $path, $rep) = @_;
    # .float.f3
    return jm_is_numeric($val);
}

# check _jm_f_36_map_f4 (.float.f4)
sub _jm_f_41($$$)
{
    my ($val, $path, $rep) = @_;
    # .float.f4
    return jm_is_numeric($val);
}

# check _jm_f_36_map_f5 (.float.f5)
sub _jm_f_42($$$)
{
    my ($val, $path, $rep) = @_;
    # .float.f5
    return jm_is_numeric($val);
}

# check _jm_f_36_map_f6 (.float.f6)
sub _jm_f_43($$$)
{
    my ($val, $path, $rep) = @_;
    # .float.f6
    return jm_is_numeric($val) && $val == 3.1415927;
}

# check _jm_f_36_map_f7 (.float.f7)
sub _jm_f_44($$$)
{
    my ($val, $path, $rep) = @_;
    # .float.f7
    return jm_is_numeric($val) && $val == 1e+100;
}

# check _jm_f_36_map_f8 (.float.f8)
sub _jm_f_45($$$)
{
    my ($val, $path, $rep) = @_;
    # .float.f8
    return jm_is_numeric($val) && $val == -42.1;
}


# check json_model_1_map_float (.float)
sub _jm_f_36($$$)
{
    my ($val, $path, $rep) = @_;
    # floats: inference, predefs, constants
    # .float
    if (! jm_is_object($val))
    {
        return 0;
    }
    my $pfun;
    scalar keys %$val;
    while (my ($prop, $pval) = each %$val)
    {
        if (($pfun = $_jm_f_36_map{$prop}))
        {
            # handle 9 may props
            if (defined($pfun) && ! &$pfun($pval, undef, $rep))
            {
                return 0;
            }
        }
        else
        {
            return 0;
        }
    }
    return 1;
}

# check _jm_f_46_map_i0 (.int.i0)
sub _jm_f_47($$$)
{
    my ($val, $path, $rep) = @_;
    # .int.i0
    return jm_is_integer($val) && $val >= 0;
}

# check _jm_f_46_map_i1 (.int.i1)
sub _jm_f_48($$$)
{
    my ($val, $path, $rep) = @_;
    # .int.i1
    return jm_is_integer($val) && $val >= 1;
}

# check _jm_f_46_map_i2 (.int.i2)
sub _jm_f_49($$$)
{
    my ($val, $path, $rep) = @_;
    # .int.i2
    return jm_is_integer($val);
}

# check _jm_f_46_map_i3 (.int.i3)
sub _jm_f_50($$$)
{
    my ($val, $path, $rep) = @_;
    # .int.i3
    return jm_is_integer($val);
}

# check _jm_f_46_map_i4 (.int.i4)
sub _jm_f_51($$$)
{
    my ($val, $path, $rep) = @_;
    # .int.i4
    return jm_is_integer($val);
}

# check _jm_f_46_map_i5 (.int.i5)
sub _jm_f_52($$$)
{
    my ($val, $path, $rep) = @_;
    # .int.i5
    return jm_is_integer($val);
}

# check _jm_f_46_map_i6 (.int.i6)
sub _jm_f_53($$$)
{
    my ($val, $path, $rep) = @_;
    # .int.i6
    return jm_is_integer($val);
}

# check _jm_f_46_map_i7 (.int.i7)
sub _jm_f_54($$$)
{
    my ($val, $path, $rep) = @_;
    # .int.i7
    return jm_is_integer($val) && $val >= 0;
}

# check _jm_f_46_map_i8 (.int.i8)
sub _jm_f_55($$$)
{
    my ($val, $path, $rep) = @_;
    # .int.i8
    return jm_is_integer($val) && $val >= 0;
}

# check _jm_f_46_map_i9 (.int.i9)
sub _jm_f_56($$$)
{
    my ($val, $path, $rep) = @_;
    # .int.i9
    return jm_is_integer($val) && $val == 42;
}

# check _jm_f_46_map_ia (.int.ia)
sub _jm_f_57($$$)
{
    my ($val, $path, $rep) = @_;
    # .int.ia
    return jm_is_integer($val) && $val == -42;
}


# check json_model_1_map_int (.int)
sub _jm_f_46($$$)
{
    my ($val, $path, $rep) = @_;
    # integers: inference, predefs, constants
    # .int
    if (! jm_is_object($val))
    {
        return 0;
    }
    my $pfun;
    scalar keys %$val;
    while (my ($prop, $pval) = each %$val)
    {
        if (($pfun = $_jm_f_46_map{$prop}))
        {
            # handle 11 may props
            if (defined($pfun) && ! &$pfun($pval, undef, $rep))
            {
                return 0;
            }
        }
        else
        {
            return 0;
        }
    }
    return 1;
}

# object .merge.m0
sub _jm_obj_3($$$)
{
    my ($val, $path, $rep) = @_;
    if (! jm_is_object($val))
    {
        return 0;
    }
    my $res;
    my $must_count = 0;
    scalar keys %$val;
    while (my ($prop, $pval) = each %$val)
    {
        if ($prop eq 'a')
        {
            # handle must a property
            $must_count++;
            # .merge.m0.a
            $res = jm_is_integer($pval) && $pval >= 0;
            if (! $res)
            {
                return 0;
            }
        }
        elsif ($prop eq 'b')
        {
            # handle may b property
            # .merge.m0.b
            $res = jm_is_integer($pval) && $pval >= 0;
            if (! $res)
            {
                return 0;
            }
        }
        else
        {
            return 0;
        }
    }
    return $must_count == 1;
}

# object .merge.m1.'|'.1
sub _jm_obj_4($$$)
{
    my ($val, $path, $rep) = @_;
    # check close must only props
    if (! jm_is_object($val))
    {
        return 0;
    }
    if (jm_obj_size($val) != 2)
    {
        return 0;
    }
    my $pval;
    my $res;
    if (! exists $$val{'a'})
    {
        return 0;
    }
    $pval = $$val{'a'};
    # .merge.m1.'|'.1.a
    $res = jm_is_integer($pval) && $pval >= 0;
    if (! $res)
    {
        return 0;
    }
    if (! exists $$val{'c'})
    {
        return 0;
    }
    $pval = $$val{'c'};
    # .merge.m1.'|'.1.c
    return jm_is_integer($pval) && $pval >= 1;
}

# object .merge.m1.'|'.0
sub _jm_obj_5($$$)
{
    my ($val, $path, $rep) = @_;
    # check close must only props
    if (! jm_is_object($val))
    {
        return 0;
    }
    if (jm_obj_size($val) != 2)
    {
        return 0;
    }
    my $pval;
    my $res;
    if (! exists $$val{'a'})
    {
        return 0;
    }
    $pval = $$val{'a'};
    # .merge.m1.'|'.0.a
    $res = jm_is_integer($pval) && $pval >= 0;
    if (! $res)
    {
        return 0;
    }
    if (! exists $$val{'b'})
    {
        return 0;
    }
    $pval = $$val{'b'};
    # .merge.m1.'|'.0.b
    return jm_is_integer($pval) && $pval >= 1;
}

# object .merge.m2.'|'.1
sub _jm_obj_6($$$)
{
    my ($val, $path, $rep) = @_;
    # check close must only props
    if (! jm_is_object($val))
    {
        return 0;
    }
    if (jm_obj_size($val) != 2)
    {
        return 0;
    }
    my $pval;
    my $res;
    if (! exists $$val{'a'})
    {
        return 0;
    }
    $pval = $$val{'a'};
    # .merge.m2.'|'.1.a
    $res = jm_is_integer($pval) && $pval >= 0;
    if (! $res)
    {
        return 0;
    }
    if (! exists $$val{'c'})
    {
        return 0;
    }
    $pval = $$val{'c'};
    # .merge.m2.'|'.1.c
    return jm_is_integer($pval) && $pval >= 1;
}

# object .merge.m2.'|'.0
sub _jm_obj_7($$$)
{
    my ($val, $path, $rep) = @_;
    # check close must only props
    if (! jm_is_object($val))
    {
        return 0;
    }
    if (jm_obj_size($val) != 2)
    {
        return 0;
    }
    my $pval;
    my $res;
    if (! exists $$val{'a'})
    {
        return 0;
    }
    $pval = $$val{'a'};
    # .merge.m2.'|'.0.a
    $res = jm_is_integer($pval) && $pval >= 0;
    if (! $res)
    {
        return 0;
    }
    if (! exists $$val{'b'})
    {
        return 0;
    }
    $pval = $$val{'b'};
    # .merge.m2.'|'.0.b
    return jm_is_integer($pval) && $pval >= 1;
}

# object .merge.m3.'|'.3
sub _jm_obj_8($$$)
{
    my ($val, $path, $rep) = @_;
    # check close must only props
    if (! jm_is_object($val))
    {
        return 0;
    }
    if (jm_obj_size($val) != 2)
    {
        return 0;
    }
    my $pval;
    my $res;
    if (! exists $$val{'b'})
    {
        return 0;
    }
    $pval = $$val{'b'};
    # .merge.m3.'|'.3.b
    $res = jm_is_integer($pval) && $pval >= 0;
    if (! $res)
    {
        return 0;
    }
    if (! exists $$val{'d'})
    {
        return 0;
    }
    $pval = $$val{'d'};
    # .merge.m3.'|'.3.d
    return jm_is_integer($pval) && $pval >= 1;
}

# object .merge.m3.'|'.2
sub _jm_obj_9($$$)
{
    my ($val, $path, $rep) = @_;
    # check close must only props
    if (! jm_is_object($val))
    {
        return 0;
    }
    if (jm_obj_size($val) != 2)
    {
        return 0;
    }
    my $pval;
    my $res;
    if (! exists $$val{'b'})
    {
        return 0;
    }
    $pval = $$val{'b'};
    # .merge.m3.'|'.2.b
    $res = jm_is_integer($pval) && $pval >= 0;
    if (! $res)
    {
        return 0;
    }
    if (! exists $$val{'c'})
    {
        return 0;
    }
    $pval = $$val{'c'};
    # .merge.m3.'|'.2.c
    return jm_is_integer($pval) && $pval >= 1;
}

# object .merge.m3.'|'.1
sub _jm_obj_10($$$)
{
    my ($val, $path, $rep) = @_;
    # check close must only props
    if (! jm_is_object($val))
    {
        return 0;
    }
    if (jm_obj_size($val) != 2)
    {
        return 0;
    }
    my $pval;
    my $res;
    if (! exists $$val{'a'})
    {
        return 0;
    }
    $pval = $$val{'a'};
    # .merge.m3.'|'.1.a
    $res = jm_is_integer($pval) && $pval >= 0;
    if (! $res)
    {
        return 0;
    }
    if (! exists $$val{'d'})
    {
        return 0;
    }
    $pval = $$val{'d'};
    # .merge.m3.'|'.1.d
    return jm_is_integer($pval) && $pval >= 1;
}

# object .merge.m3.'|'.0
sub _jm_obj_11($$$)
{
    my ($val, $path, $rep) = @_;
    # check close must only props
    if (! jm_is_object($val))
    {
        return 0;
    }
    if (jm_obj_size($val) != 2)
    {
        return 0;
    }
    my $pval;
    my $res;
    if (! exists $$val{'a'})
    {
        return 0;
    }
    $pval = $$val{'a'};
    # .merge.m3.'|'.0.a
    $res = jm_is_integer($pval) && $pval >= 0;
    if (! $res)
    {
        return 0;
    }
    if (! exists $$val{'c'})
    {
        return 0;
    }
    $pval = $$val{'c'};
    # .merge.m3.'|'.0.c
    return jm_is_integer($pval) && $pval >= 1;
}

# object .merge.m4
sub _jm_obj_12($$$)
{
    my ($val, $path, $rep) = @_;
    # check close must only props
    if (! jm_is_object($val))
    {
        return 0;
    }
    if (jm_obj_size($val) != 4)
    {
        return 0;
    }
    my $pval;
    my $res;
    if (! exists $$val{'a'})
    {
        return 0;
    }
    $pval = $$val{'a'};
    # .merge.m4.a
    $res = jm_is_integer($pval) && $pval >= 0;
    if (! $res)
    {
        return 0;
    }
    if (! exists $$val{'b'})
    {
        return 0;
    }
    $pval = $$val{'b'};
    # .merge.m4.b
    $res = jm_is_integer($pval) && $pval >= 0;
    if (! $res)
    {
        return 0;
    }
    if (! exists $$val{'c'})
    {
        return 0;
    }
    $pval = $$val{'c'};
    # .merge.m4.c
    $res = jm_is_integer($pval) && $pval >= 0;
    if (! $res)
    {
        return 0;
    }
    if (! exists $$val{'d'})
    {
        return 0;
    }
    $pval = $$val{'d'};
    # .merge.m4.d
    return jm_is_integer($pval) && $pval >= 0;
}

# check json_model_1_map_merge (.merge)
sub _jm_f_58($$$)
{
    my ($val, $path, $rep) = @_;
    # merge object properties
    # .merge
    if (! jm_is_object($val))
    {
        return 0;
    }
    my $res;
    scalar keys %$val;
    while (my ($prop, $pval) = each %$val)
    {
        if ($prop eq 'm0')
        {
            # handle may m0 property
            # .merge.m0
            $res = _jm_obj_3($pval, undef, $rep);
            if (! $res)
            {
                return 0;
            }
        }
        elsif ($prop eq 'm1')
        {
            # handle may m1 property
            # .merge.m1
            $res = jm_is_object($pval);
            if ($res)
            {
                # .merge.m1.'|'.0
                # .merge.m1.'|'.1
                $res = _jm_obj_5($pval, undef, $rep) || _jm_obj_4($pval, undef, $rep);
            }
            if (! $res)
            {
                return 0;
            }
        }
        elsif ($prop eq 'm2')
        {
            # handle may m2 property
            # .merge.m2
            $res = jm_is_object($pval);
            if ($res)
            {
                # .merge.m2.'|'.0
                # .merge.m2.'|'.1
                $res = _jm_obj_7($pval, undef, $rep) || _jm_obj_6($pval, undef, $rep);
            }
            if (! $res)
            {
                return 0;
            }
        }
        elsif ($prop eq 'm3')
        {
            # handle may m3 property
            # .merge.m3
            $res = jm_is_object($pval);
            if ($res)
            {
                # .merge.m3.'|'.0
                # .merge.m3.'|'.1
                # .merge.m3.'|'.2
                # .merge.m3.'|'.3
                $res = _jm_obj_11($pval, undef, $rep) || _jm_obj_10($pval, undef, $rep) || _jm_obj_9($pval, undef, $rep) || _jm_obj_8($pval, undef, $rep);
            }
            if (! $res)
            {
                return 0;
            }
        }
        elsif ($prop eq 'm4')
        {
            # handle may m4 property
            # .merge.m4
            $res = _jm_obj_12($pval, undef, $rep);
            if (! $res)
            {
                return 0;
            }
        }
        else
        {
            return 0;
        }
    }
    return 1;
}

# check json_model_1_map_null (.null)
sub _jm_f_59($$$)
{
    my ($val, $path, $rep) = @_;
    # null: inference, predefs, constants
    # .null
    if (! jm_is_object($val))
    {
        return 0;
    }
    my $res;
    scalar keys %$val;
    while (my ($prop, $pval) = each %$val)
    {
        if ($prop eq 'n0')
        {
            # handle may n0 property
            # .null.n0
            $res = !defined($pval);
            if (! $res)
            {
                return 0;
            }
        }
        elsif ($prop eq 'n1')
        {
            # handle may n1 property
            # .null.n1
            $res = !defined($pval);
            if (! $res)
            {
                return 0;
            }
        }
        elsif ($prop eq 'n2')
        {
            # handle may n2 property
            # .null.n2
            $res = !defined($pval);
            if (! $res)
            {
                return 0;
            }
        }
        else
        {
            return 0;
        }
    }
    return 1;
}

# check _jm_f_60_map_o0 (.object.o0)
sub _jm_f_61($$$)
{
    my ($val, $path, $rep) = @_;
    # .object.o0
    return jm_is_object($val) && jm_obj_size($val) == 0;
}

# check _jm_f_60_map_o1 (.object.o1)
sub _jm_f_62($$$)
{
    my ($val, $path, $rep) = @_;
    # .object.o1
    # check close must only props
    if (! jm_is_object($val))
    {
        return 0;
    }
    if (jm_obj_size($val) != 3)
    {
        return 0;
    }
    my $pval;
    my $res;
    if (! exists $$val{'a'})
    {
        return 0;
    }
    $pval = $$val{'a'};
    # .object.o1.a
    $res = jm_is_integer($pval) && $pval >= 0;
    if (! $res)
    {
        return 0;
    }
    if (! exists $$val{'b'})
    {
        return 0;
    }
    $pval = $$val{'b'};
    # .object.o1.b
    $res = jm_is_integer($pval) && $pval >= 0;
    if (! $res)
    {
        return 0;
    }
    if (! exists $$val{'c'})
    {
        return 0;
    }
    $pval = $$val{'c'};
    # .object.o1.c
    return jm_is_integer($pval) && $pval >= 0;
}

# check _jm_f_60_map_o2 (.object.o2)
sub _jm_f_63($$$)
{
    my ($val, $path, $rep) = @_;
    # .object.o2
    if (! jm_is_object($val))
    {
        return 0;
    }
    my $res;
    scalar keys %$val;
    while (my ($prop, $pval) = each %$val)
    {
        if ($prop eq 'a')
        {
            # handle may a property
            # .object.o2.a
            $res = jm_is_integer($pval) && $pval >= 0;
            if (! $res)
            {
                return 0;
            }
        }
        else
        {
            return 0;
        }
    }
    return 1;
}

# check _jm_f_60_map_o3 (.object.o3)
sub _jm_f_64($$$)
{
    my ($val, $path, $rep) = @_;
    # .object.o3
    if (! jm_is_object($val))
    {
        return 0;
    }
    my $res;
    scalar keys %$val;
    while (my ($prop, $pval) = each %$val)
    {
        if (jm_starts_with($prop, 'a'))
        {
            # handle 1 re props
            # .object.o3.'/^a/'
            $res = jm_is_integer($pval) && $pval >= 0;
            if (! $res)
            {
                return 0;
            }
        }
        else
        {
            return 0;
        }
    }
    return 1;
}

# check _jm_f_60_map_o4 (.object.o4)
sub _jm_f_65($$$)
{
    my ($val, $path, $rep) = @_;
    # .object.o4
    if (! jm_is_object($val))
    {
        return 0;
    }
    my $res;
    scalar keys %$val;
    while (my ($prop, $pval) = each %$val)
    {
        if (jm_is_string($prop) && jm_is_valid_date($prop, undef, $rep))
        {
            # handle 1 key props
            # .object.o4.'$DATE'
            $res = jm_is_string($pval);
            if (! $res)
            {
                return 0;
            }
        }
        else
        {
            return 0;
        }
    }
    return 1;
}

# check _jm_f_60_map_o5 (.object.o5)
sub _jm_f_66($$$)
{
    my ($val, $path, $rep) = @_;
    # .object.o5
    if (! jm_is_object($val))
    {
        return 0;
    }
    my $res;
    scalar keys %$val;
    while (my ($prop, $pval) = each %$val)
    {
        # handle other props
        # .object.o5.''
        $res = jm_is_integer($pval) && $pval >= 0;
        if (! $res)
        {
            return 0;
        }
    }
    return 1;
}

# check _jm_f_60_map_o6 (.object.o6)
sub _jm_f_67($$$)
{
    my ($val, $path, $rep) = @_;
    # .object.o6
    # accept any object
    return jm_is_object($val);
}


# check json_model_1_map_object (.object)
sub _jm_f_60($$$)
{
    my ($val, $path, $rep) = @_;
    # object map property names to values
    # .object
    if (! jm_is_object($val))
    {
        return 0;
    }
    my $pfun;
    scalar keys %$val;
    while (my ($prop, $pval) = each %$val)
    {
        if (($pfun = $_jm_f_60_map{$prop}))
        {
            # handle 7 may props
            if (defined($pfun) && ! &$pfun($pval, undef, $rep))
            {
                return 0;
            }
        }
        else
        {
            return 0;
        }
    }
    return 1;
}

# object .or.o2.'|'.3
sub _jm_obj_13($$$)
{
    my ($val, $path, $rep) = @_;
    # accept any object
    return jm_is_object($val);
}

# check json_model_1_map_or (.or)
sub _jm_f_68($$$)
{
    my ($val, $path, $rep) = @_;
    # soft alternative, first match
    # .or
    if (! jm_is_object($val))
    {
        return 0;
    }
    my $res;
    scalar keys %$val;
    while (my ($prop, $pval) = each %$val)
    {
        if ($prop eq 'o0')
        {
            # handle may o0 property
            # .or.o0
            # .or.o0.'|'.0
            # .or.o0.'|'.1
            $res = jm_is_boolean($pval) || jm_is_integer($pval);
            if (! $res)
            {
                return 0;
            }
        }
        elsif ($prop eq 'o1')
        {
            # handle may o1 property
            # .or.o1
            # .or.o1.'|'.0
            # .or.o1.'|'.1
            $res = jm_is_string($pval) && jm_is_valid_date($pval, undef, $rep) || jm_is_string($pval) && jm_is_valid_time($pval, undef, $rep);
            if (! $res)
            {
                return 0;
            }
        }
        elsif ($prop eq 'o2')
        {
            # handle may o2 property
            # .or.o2
            # .or.o2.'|'.0
            # .or.o2.'|'.1
            # .or.o2.'|'.2
            # .or.o2.'|'.3
            $res = jm_is_integer($pval) && $pval >= 0 || jm_is_string($pval) && jm_is_valid_uuid($pval, undef, $rep) || jm_is_array($pval) || _jm_obj_13($pval, undef, $rep);
            if (! $res)
            {
                return 0;
            }
        }
        else
        {
            return 0;
        }
    }
    return 1;
}

# check _jm_f_69_map_ANY (.predefs.ANY)
sub _jm_f_70($$$)
{
    my ($val, $path, $rep) = @_;
    # .predefs.ANY
    return 1;
}

# check _jm_f_69_map_BOOL (.predefs.BOOL)
sub _jm_f_71($$$)
{
    my ($val, $path, $rep) = @_;
    # .predefs.BOOL
    return jm_is_boolean($val);
}

# check _jm_f_69_map_BOOLEAN (.predefs.BOOLEAN)
sub _jm_f_72($$$)
{
    my ($val, $path, $rep) = @_;
    # .predefs.BOOLEAN
    return jm_is_boolean($val);
}

# check _jm_f_69_map_DATE (.predefs.DATE)
sub _jm_f_73($$$)
{
    my ($val, $path, $rep) = @_;
    # .predefs.DATE
    return jm_is_string($val) && jm_is_valid_date($val, $path, $rep);
}

# check _jm_f_69_map_DATETIME (.predefs.DATETIME)
sub _jm_f_74($$$)
{
    my ($val, $path, $rep) = @_;
    # .predefs.DATETIME
    return jm_is_string($val) && jm_is_valid_datetime($val, $path, $rep);
}

# check _jm_f_69_map_EMAIL (.predefs.EMAIL)
sub _jm_f_75($$$)
{
    my ($val, $path, $rep) = @_;
    # .predefs.EMAIL
    return jm_is_string($val) && jm_is_valid_email($val, $path, $rep);
}

# check _jm_f_69_map_EXREG (.predefs.EXREG)
sub _jm_f_76($$$)
{
    my ($val, $path, $rep) = @_;
    # .predefs.EXREG
    return jm_is_string($val) && jm_is_valid_exreg($val, $path, $rep);
}

# check _jm_f_69_map_F32 (.predefs.F32)
sub _jm_f_77($$$)
{
    my ($val, $path, $rep) = @_;
    # .predefs.F32
    return jm_is_numeric($val);
}

# check _jm_f_69_map_F64 (.predefs.F64)
sub _jm_f_78($$$)
{
    my ($val, $path, $rep) = @_;
    # .predefs.F64
    return jm_is_numeric($val);
}

# check _jm_f_69_map_FLOAT (.predefs.FLOAT)
sub _jm_f_79($$$)
{
    my ($val, $path, $rep) = @_;
    # .predefs.FLOAT
    return jm_is_numeric($val);
}

# check _jm_f_69_map_I32 (.predefs.I32)
sub _jm_f_80($$$)
{
    my ($val, $path, $rep) = @_;
    # .predefs.I32
    return jm_is_integer($val);
}

# check _jm_f_69_map_I64 (.predefs.I64)
sub _jm_f_81($$$)
{
    my ($val, $path, $rep) = @_;
    # .predefs.I64
    return jm_is_integer($val);
}

# check _jm_f_69_map_INT (.predefs.INT)
sub _jm_f_82($$$)
{
    my ($val, $path, $rep) = @_;
    # .predefs.INT
    return jm_is_integer($val);
}

# check _jm_f_69_map_INTEGER (.predefs.INTEGER)
sub _jm_f_83($$$)
{
    my ($val, $path, $rep) = @_;
    # .predefs.INTEGER
    return jm_is_integer($val);
}

# check _jm_f_69_map_JSON (.predefs.JSON)
sub _jm_f_84($$$)
{
    my ($val, $path, $rep) = @_;
    # .predefs.JSON
    return jm_is_string($val) && jm_is_valid_json($val, $path, $rep);
}

# check _jm_f_69_map_NONE (.predefs.NONE)
sub _jm_f_85($$$)
{
    my ($val, $path, $rep) = @_;
    # .predefs.NONE
    return 0;
}

# check _jm_f_69_map_NULL (.predefs.NULL)
sub _jm_f_86($$$)
{
    my ($val, $path, $rep) = @_;
    # .predefs.NULL
    return !defined($val);
}

# check _jm_f_69_map_NUMBER (.predefs.NUMBER)
sub _jm_f_87($$$)
{
    my ($val, $path, $rep) = @_;
    # .predefs.NUMBER
    return jm_is_numeric($val);
}

# check _jm_f_69_map_REGEX (.predefs.REGEX)
sub _jm_f_88($$$)
{
    my ($val, $path, $rep) = @_;
    # .predefs.REGEX
    return jm_is_string($val) && jm_is_valid_regex($val, $path, $rep);
}

# check _jm_f_69_map_STRING (.predefs.STRING)
sub _jm_f_89($$$)
{
    my ($val, $path, $rep) = @_;
    # .predefs.STRING
    return jm_is_string($val);
}

# check _jm_f_69_map_TIME (.predefs.TIME)
sub _jm_f_90($$$)
{
    my ($val, $path, $rep) = @_;
    # .predefs.TIME
    return jm_is_string($val) && jm_is_valid_time($val, $path, $rep);
}

# check _jm_f_69_map_U32 (.predefs.U32)
sub _jm_f_91($$$)
{
    my ($val, $path, $rep) = @_;
    # .predefs.U32
    return jm_is_integer($val) && $val >= 0;
}

# check _jm_f_69_map_U64 (.predefs.U64)
sub _jm_f_92($$$)
{
    my ($val, $path, $rep) = @_;
    # .predefs.U64
    return jm_is_integer($val) && $val >= 0;
}

# check _jm_f_69_map_URI (.predefs.URI)
sub _jm_f_93($$$)
{
    my ($val, $path, $rep) = @_;
    # .predefs.URI
    return jm_is_string($val) && jm_is_valid_url($val, $path, $rep);
}

# check _jm_f_69_map_URL (.predefs.URL)
sub _jm_f_94($$$)
{
    my ($val, $path, $rep) = @_;
    # .predefs.URL
    return jm_is_string($val) && jm_is_valid_url($val, $path, $rep);
}

# check _jm_f_69_map_UUID (.predefs.UUID)
sub _jm_f_95($$$)
{
    my ($val, $path, $rep) = @_;
    # .predefs.UUID
    return jm_is_string($val) && jm_is_valid_uuid($val, $path, $rep);
}


# check json_model_1_map_predefs (.predefs)
sub _jm_f_69($$$)
{
    my ($val, $path, $rep) = @_;
    # predefined models
    # .predefs
    if (! jm_is_object($val))
    {
        return 0;
    }
    my $pfun;
    scalar keys %$val;
    while (my ($prop, $pval) = each %$val)
    {
        if (($pfun = $_jm_f_69_map{$prop}))
        {
            # handle 26 may props
            if (defined($pfun) && ! &$pfun($pval, undef, $rep))
            {
                return 0;
            }
        }
        else
        {
            return 0;
        }
    }
    return 1;
}

sub _jm_re_0($$$)
{
    my ($val, $path, $rep) = @_;
    my $res = $val =~ /^(Calvin|Susie)$/;
    return $res;
}

# check json_model_1_map_string (.string)
sub _jm_f_96($$$)
{
    my ($val, $path, $rep) = @_;
    # strings: inference, predef, constants, regex
    # .string
    if (! jm_is_object($val))
    {
        return 0;
    }
    my $res;
    scalar keys %$val;
    while (my ($prop, $pval) = each %$val)
    {
        if ($prop eq 's0')
        {
            # handle may s0 property
            # .string.s0
            $res = jm_is_string($pval);
            if (! $res)
            {
                return 0;
            }
        }
        elsif ($prop eq 's1')
        {
            # handle may s1 property
            # .string.s1
            $res = jm_is_string($pval);
            if (! $res)
            {
                return 0;
            }
        }
        elsif ($prop eq 's2')
        {
            # handle may s2 property
            # .string.s2
            $res = jm_is_string($pval) && $pval eq 'Susie';
            if (! $res)
            {
                return 0;
            }
        }
        elsif ($prop eq 's3')
        {
            # handle may s3 property
            # .string.s3
            $res = jm_is_string($pval) && $pval eq 'Calvin';
            if (! $res)
            {
                return 0;
            }
        }
        elsif ($prop eq 's4')
        {
            # handle may s4 property
            # .string.s4
            # "/^(Calvin|Susie)$/"
            $res = jm_is_string($pval) && _jm_re_0($pval, undef, $rep);
            if (! $res)
            {
                return 0;
            }
        }
        else
        {
            return 0;
        }
    }
    return 1;
}

# check json_model_1_map_tuple (.tuple)
sub _jm_f_97($$$)
{
    my ($val, $path, $rep) = @_;
    # tuple items have a type
    # .tuple
    if (! jm_is_object($val))
    {
        return 0;
    }
    my $res;
    scalar keys %$val;
    while (my ($prop, $pval) = each %$val)
    {
        if ($prop eq 't0')
        {
            # handle may t0 property
            # .tuple.t0
            $res = jm_is_array($pval) && scalar @$pval == 0;
            if (! $res)
            {
                return 0;
            }
        }
        elsif ($prop eq 't1')
        {
            # handle may t1 property
            # .tuple.t1
            # .tuple.t1.'@'
            $res = jm_is_array($pval);
            if ($res)
            {
                for my $arr_7_idx (0 .. $#$pval)
                {
                    my $arr_7_item = $$pval[$arr_7_idx];
                    # .tuple.t1.'@'.0
                    $res = jm_is_integer($arr_7_item) && $arr_7_item >= 0;
                    if (! $res)
                    {
                        last;
                    }
                }
            }
            if ($res)
            {
                my $ival_12 = scalar @$pval;
                $res = $ival_12 == 1;
            }
            if (! $res)
            {
                return 0;
            }
        }
        elsif ($prop eq 't2')
        {
            # handle may t2 property
            # .tuple.t2
            $res = jm_is_array($pval) && scalar @$pval == 2;
            if ($res)
            {
                # .tuple.t2.0
                $res = jm_is_integer($$pval[0]) && $$pval[0] >= 0;
                if ($res)
                {
                    # .tuple.t2.1
                    $res = jm_is_integer($$pval[1]) && $$pval[1] >= 0;
                }
            }
            if (! $res)
            {
                return 0;
            }
        }
        elsif ($prop eq 't3')
        {
            # handle may t3 property
            # .tuple.t3
            $res = jm_is_array($pval) && scalar @$pval == 3;
            if ($res)
            {
                # .tuple.t3.0
                $res = jm_is_boolean($$pval[0]);
                if ($res)
                {
                    # .tuple.t3.1
                    $res = jm_is_integer($$pval[1]) && $$pval[1] >= 0;
                    if ($res)
                    {
                        # .tuple.t3.2
                        $res = jm_is_string($$pval[2]);
                    }
                }
            }
            if (! $res)
            {
                return 0;
            }
        }
        elsif ($prop eq 't4')
        {
            # handle may t4 property
            # .tuple.t4
            # .tuple.t4.'@'
            $res = jm_is_array($pval);
            if ($res)
            {
                my $len_0 = scalar @$pval;
                if ($len_0 > 0)
                {
                    # .tuple.t4.'@'.0
                    $res = jm_is_string($$pval[0]);
                }
                if ($res)
                {
                    for my $idx_0 (1 .. $len_0 - 1)
                    {
                        # .tuple.t4.'@'.1
                        $res = jm_is_integer($$pval[$idx_0]) && $$pval[$idx_0] >= 0;
                        if (! $res)
                        {
                            last;
                        }
                    }
                }
            }
            if ($res)
            {
                my $ival_13 = scalar @$pval;
                $res = $ival_13 >= 2;
            }
            if (! $res)
            {
                return 0;
            }
        }
        else
        {
            return 0;
        }
    }
    return 1;
}

# check json_model_1_map_xor (.xor)
sub _jm_f_98($$$)
{
    my ($val, $path, $rep) = @_;
    # hard alternative, only one must match
    # .xor
    if (! jm_is_object($val))
    {
        return 0;
    }
    my $res;
    scalar keys %$val;
    while (my ($prop, $pval) = each %$val)
    {
        if ($prop eq 'x0')
        {
            # handle may x0 property
            # .xor.x0
            # .xor.x0.'|'.0
            # .xor.x0.'|'.1
            $res = jm_is_boolean($pval) || jm_is_integer($pval);
            if (! $res)
            {
                return 0;
            }
        }
        elsif ($prop eq 'x1')
        {
            # handle may x1 property
            # .xor.x1
            # generic xor list
            my $xc_0 = 0;
            # .xor.x1.'^'.0
            # "/^a/"
            my $xr_0 = jm_is_string($pval) && jm_starts_with($pval, 'a');
            if ($xr_0)
            {
                $xc_0++;
            }
            # .xor.x1.'^'.1
            # "/z$/"
            $xr_0 = jm_is_string($pval) && jm_ends_with($pval, 'z');
            if ($xr_0)
            {
                $xc_0++;
            }
            $res = $xc_0 == 1;
            if (! $res)
            {
                return 0;
            }
        }
        elsif ($prop eq 'x2')
        {
            # handle may x2 property
            # .xor.x2
            # generic xor list
            my $xc_1 = 0;
            # .xor.x2.'^'.0
            my $xr_1 = jm_is_integer($pval);
            if ($xr_1)
            {
                $xc_1++;
            }
            # .xor.x2.'^'.1
            $xr_1 = jm_is_integer($pval) && $pval >= 0;
            if ($xr_1)
            {
                $xc_1++;
            }
            $res = $xc_1 == 1;
            if (! $res)
            {
                return 0;
            }
        }
        elsif ($prop eq 'x3')
        {
            # handle may x3 property
            # .xor.x3
            # not-case xor list
            # .xor.x3.'^'.1
            my $is_0 = jm_is_integer($pval) && $pval >= 0;
            $res = ! $is_0;
            if (! $res)
            {
                return 0;
            }
        }
        else
        {
            return 0;
        }
    }
    return 1;
}


# check $ (.)
sub json_model_1($$$)
{
    my ($val, $path, $rep) = @_;
    # A model to illustrate most design features
    # .
    if (! jm_is_object($val))
    {
        return 0;
    }
    my $pfun;
    scalar keys %$val;
    while (my ($prop, $pval) = each %$val)
    {
        if (($pfun = $json_model_1_map{$prop}))
        {
            # handle 15 may props
            if (defined($pfun) && ! &$pfun($pval, undef, $rep))
            {
                return 0;
            }
        }
        else
        {
            return 0;
        }
    }
    return 1;
}


# initialization of global variables

our $initialized = 0;

sub check_model_init()
{
    if (!$initialized)
    {
        $initialized = 1;
        %_jm_f_2_map = (
            'b0' => \&_jm_f_3,
            'b1' => \&_jm_f_4,
            'b2' => \&_jm_f_5,
            'b3' => \&_jm_f_6,
            'b4' => \&_jm_f_7,
            'b5' => \&_jm_f_8,
        );
        %_jm_f_9_map = (
            'cia0' => \&_jm_f_10,
            'cia1' => \&_jm_f_11,
            'cia2' => \&_jm_f_12,
            'cii0' => \&_jm_f_13,
            'cii1' => \&_jm_f_14,
            'cii2' => \&_jm_f_15,
            'cin0' => \&_jm_f_16,
            'cin1' => \&_jm_f_17,
            'cin2' => \&_jm_f_18,
            'cio0' => \&_jm_f_19,
            'cio1' => \&_jm_f_20,
            'cio2' => \&_jm_f_21,
            'cis0' => \&_jm_f_22,
            'cis1' => \&_jm_f_23,
            'cis2' => \&_jm_f_24,
            'cni0' => \&_jm_f_25,
            'cni1' => \&_jm_f_26,
            'cni2' => \&_jm_f_27,
            'cnn0' => \&_jm_f_28,
            'cnn1' => \&_jm_f_29,
            'cnn2' => \&_jm_f_30,
            'css0' => \&_jm_f_31,
            'css1' => \&_jm_f_32,
            'css2' => \&_jm_f_33,
            'cua0' => \&_jm_f_34,
        );
        %_jm_cst_0 = (
            'Susie' => 1,
            'Calvin' => 1,
            'Hobbes' => 1,
        );
        %_jm_cst_1 = (
            'Susie' => 1,
        );
        %_jm_f_36_map = (
            'f0' => \&_jm_f_37,
            'f1' => \&_jm_f_38,
            'f2' => \&_jm_f_39,
            'f3' => \&_jm_f_40,
            'f4' => \&_jm_f_41,
            'f5' => \&_jm_f_42,
            'f6' => \&_jm_f_43,
            'f7' => \&_jm_f_44,
            'f8' => \&_jm_f_45,
        );
        %_jm_f_46_map = (
            'i0' => \&_jm_f_47,
            'i1' => \&_jm_f_48,
            'i2' => \&_jm_f_49,
            'i3' => \&_jm_f_50,
            'i4' => \&_jm_f_51,
            'i5' => \&_jm_f_52,
            'i6' => \&_jm_f_53,
            'i7' => \&_jm_f_54,
            'i8' => \&_jm_f_55,
            'i9' => \&_jm_f_56,
            'ia' => \&_jm_f_57,
        );
        %_jm_f_60_map = (
            'o0' => \&_jm_f_61,
            'o1' => \&_jm_f_62,
            'o2' => \&_jm_f_63,
            'o3' => \&_jm_f_64,
            'o4' => \&_jm_f_65,
            'o5' => \&_jm_f_66,
            'o6' => \&_jm_f_67,
        );
        %_jm_f_69_map = (
            'ANY' => \&_jm_f_70,
            'BOOL' => \&_jm_f_71,
            'BOOLEAN' => \&_jm_f_72,
            'DATE' => \&_jm_f_73,
            'DATETIME' => \&_jm_f_74,
            'EMAIL' => \&_jm_f_75,
            'EXREG' => \&_jm_f_76,
            'F32' => \&_jm_f_77,
            'F64' => \&_jm_f_78,
            'FLOAT' => \&_jm_f_79,
            'I32' => \&_jm_f_80,
            'I64' => \&_jm_f_81,
            'INT' => \&_jm_f_82,
            'INTEGER' => \&_jm_f_83,
            'JSON' => \&_jm_f_84,
            'NONE' => \&_jm_f_85,
            'NULL' => \&_jm_f_86,
            'NUMBER' => \&_jm_f_87,
            'REGEX' => \&_jm_f_88,
            'STRING' => \&_jm_f_89,
            'TIME' => \&_jm_f_90,
            'U32' => \&_jm_f_91,
            'U64' => \&_jm_f_92,
            'URI' => \&_jm_f_93,
            'URL' => \&_jm_f_94,
            'UUID' => \&_jm_f_95,
        );
        %json_model_1_map = (
            'and' => \&_jm_f_0,
            'array' => \&_jm_f_1,
            'bool' => \&_jm_f_2,
            'constraints' => \&_jm_f_9,
            'enum' => \&_jm_f_35,
            'float' => \&_jm_f_36,
            'int' => \&_jm_f_46,
            'merge' => \&_jm_f_58,
            'null' => \&_jm_f_59,
            'object' => \&_jm_f_60,
            'or' => \&_jm_f_68,
            'predefs' => \&_jm_f_69,
            'string' => \&_jm_f_96,
            'tuple' => \&_jm_f_97,
            'xor' => \&_jm_f_98,
        );
        %check_model_map = (
            '' => \&json_model_1,
            'a' => \&json_model_2,
            'b' => \&json_model_3,
            'ab' => \&json_model_4,
            'cd' => \&json_model_5,
        );
    }
}

sub check_model_free()
{
    if ($initialized)
    {
        $initialized = 0;
        %_jm_f_2_map = ();
        %_jm_f_9_map = ();
        %_jm_cst_0 = ();
        %_jm_cst_1 = ();
        %_jm_f_36_map = ();
        %_jm_f_46_map = ();
        %_jm_f_60_map = ();
        %_jm_f_69_map = ();
        %json_model_1_map = ();
        %check_model_map = ();
    }
}

sub check_model($$$)
{
    my ($json, $name, $rep) = @_;
    die "unexpected model name \"$name\"" unless exists $check_model_map{$name};
    my $path = defined $rep ? [] : undef;
    return $check_model_map{$name}($json, $path, $rep);
}

#
# SCRIPT EXECUTION
#
check_model_init();
jm_main(\&check_model, \%check_model_map, JMC_VERSION);
check_model_free();
