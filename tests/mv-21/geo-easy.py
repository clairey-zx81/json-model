#! /bin/env python
#
# Generated by JSON Model Compiler version 2
# see https://github.com/clairey-zx81/json-model
#
from typing import Callable
import re2 as re
from json_model.runtime import *
__version__ = "2"

def check_model_fun(name: str) -> CheckFun:
    """Return check function for JSON model name."""
    return check_model_map[name]

# entry point for generated checkers
def check_model(val: Jsonable, name: str = "", rep: Report = None) -> bool:
    """Check val validity against JSON Model name."""
    if name not in check_model_map:
        raise Exception(f"unexpected model name: {name}")
    checker = check_model_map[name]
    return checker(val, [], rep)

_jm_map_0: dict[str, str]
_jm_map_1: dict[str, str]
check_model_map: PropMap

# check $position (.'$position')
def json_model_2(val: Jsonable, path: Path, rep: Report) -> bool:
    # .'$position'
    # .'$position'.'@'
    res: bool = isinstance(val, list)
    if res:
        for arr_0_idx, arr_0_item in enumerate(val):
            arr_0_lpath: Path = (path + [ arr_0_idx ]) if path is not None else None
            # .'$position'.'@'.0
            res = isinstance(arr_0_item, (int, float)) and not isinstance(arr_0_item, bool)
            if not res:
                rep is None or rep.append(("not a -1.0 loose float [.'$position'.'@'.0]", arr_0_lpath if path is not None else None))
                break
    if not res:
        rep is None or rep.append(("not array or unexpected array [.'$position'.'@']", path))
    if res:
        ival_0: int = len(val)
        res = ival_0 <= 3 and ival_0 >= 2
        if not res:
            rep is None or rep.append(("constraints failed [.'$position']", path))
    return res

# check $coord_array (.'$coord_array')
def json_model_3(val: Jsonable, path: Path, rep: Report) -> bool:
    # .'$coord_array'
    # .'$coord_array'.'@'
    res: bool = isinstance(val, list)
    if res:
        for arr_1_idx, arr_1_item in enumerate(val):
            arr_1_lpath: Path = (path + [ arr_1_idx ]) if path is not None else None
            # .'$coord_array'.'@'.0
            res = json_model_2(arr_1_item, arr_1_lpath if path is not None else None, rep)
            if not res:
                rep is None or rep.append(("unexpected $position [.'$coord_array'.'@'.0]", arr_1_lpath if path is not None else None))
                break
    if not res:
        rep is None or rep.append(("not array or unexpected array [.'$coord_array'.'@']", path))
    if res:
        ival_1: int = len(val)
        res = ival_1 >= 2
        if not res:
            rep is None or rep.append(("constraints failed [.'$coord_array']", path))
    return res

# check $linear_ring (.'$linear_ring')
def json_model_4(val: Jsonable, path: Path, rep: Report) -> bool:
    # .'$linear_ring'
    # .'$linear_ring'.'@'
    res: bool = isinstance(val, list)
    if res:
        for arr_2_idx, arr_2_item in enumerate(val):
            arr_2_lpath: Path = (path + [ arr_2_idx ]) if path is not None else None
            # .'$linear_ring'.'@'.0
            res = json_model_2(arr_2_item, arr_2_lpath if path is not None else None, rep)
            if not res:
                rep is None or rep.append(("unexpected $position [.'$linear_ring'.'@'.0]", arr_2_lpath if path is not None else None))
                break
    if not res:
        rep is None or rep.append(("not array or unexpected array [.'$linear_ring'.'@']", path))
    if res:
        ival_2: int = len(val)
        res = ival_2 >= 4
        if not res:
            rep is None or rep.append(("constraints failed [.'$linear_ring']", path))
    return res

# check $Point (.'$Point')
def json_model_5(val: Jsonable, path: Path, rep: Report) -> bool:
    # .'$Point'
    # check open must/may only props
    if not isinstance(val, dict):
        rep is None or rep.append(("not an object [.'$Point']", path))
        return False
    lpath: Path
    pval: Jsonable
    res: bool
    if not ((pval := val.get("type", UNDEFINED)) != UNDEFINED):
        rep is None or rep.append(("missing mandatory prop <type> [.'$Point']", path))
        return False
    lpath = (path + [ "type" ]) if path is not None else None
    # .'$Point'.type
    res = isinstance(pval, str) and pval == "Point"
    if not res:
        rep is None or rep.append(("unexpected Point [.'$Point'.type]", lpath if path is not None else None))
        rep is None or rep.append(("unexpected value for mandatory prop <type> [.'$Point']", lpath if path is not None else None))
        return False
    if not ((pval := val.get("coordinates", UNDEFINED)) != UNDEFINED):
        rep is None or rep.append(("missing mandatory prop <coordinates> [.'$Point']", path))
        return False
    lpath = (path + [ "coordinates" ]) if path is not None else None
    # .'$Point'.coordinates
    res = json_model_2(pval, lpath if path is not None else None, rep)
    if not res:
        rep is None or rep.append(("unexpected $position [.'$Point'.coordinates]", lpath if path is not None else None))
        rep is None or rep.append(("unexpected value for mandatory prop <coordinates> [.'$Point']", lpath if path is not None else None))
        return False
    if (pval := val.get("bbox", UNDEFINED)) != UNDEFINED:
        lpath = (path + [ "bbox" ]) if path is not None else None
        # .'$Point'.bbox
        res = isinstance(pval, list)
        if res:
            for arr_3_idx, arr_3_item in enumerate(pval):
                arr_3_lpath: Path = ((lpath if path is not None else None) + [ arr_3_idx ]) if (lpath if path is not None else None) is not None else None
                # .'$Point'.bbox.0
                res = isinstance(arr_3_item, (int, float)) and not isinstance(arr_3_item, bool)
                if not res:
                    rep is None or rep.append(("not a -1.0 loose float [.'$Point'.bbox.0]", arr_3_lpath if (lpath if path is not None else None) is not None else None))
                    break
        if not res:
            rep is None or rep.append(("not array or unexpected array [.'$Point'.bbox]", lpath if path is not None else None))
            rep is None or rep.append(("unexpected value for optional prop <bbox> [.'$Point']", lpath if path is not None else None))
            return False
    return True

# check $MultiPoint (.'$MultiPoint')
def json_model_6(val: Jsonable, path: Path, rep: Report) -> bool:
    # .'$MultiPoint'
    # check open must/may only props
    if not isinstance(val, dict):
        rep is None or rep.append(("not an object [.'$MultiPoint']", path))
        return False
    lpath: Path
    pval: Jsonable
    res: bool
    if not ((pval := val.get("type", UNDEFINED)) != UNDEFINED):
        rep is None or rep.append(("missing mandatory prop <type> [.'$MultiPoint']", path))
        return False
    lpath = (path + [ "type" ]) if path is not None else None
    # .'$MultiPoint'.type
    res = isinstance(pval, str) and pval == "MultiPoint"
    if not res:
        rep is None or rep.append(("unexpected MultiPoint [.'$MultiPoint'.type]", lpath if path is not None else None))
        rep is None or rep.append(("unexpected value for mandatory prop <type> [.'$MultiPoint']", lpath if path is not None else None))
        return False
    if not ((pval := val.get("coordinates", UNDEFINED)) != UNDEFINED):
        rep is None or rep.append(("missing mandatory prop <coordinates> [.'$MultiPoint']", path))
        return False
    lpath = (path + [ "coordinates" ]) if path is not None else None
    # .'$MultiPoint'.coordinates
    res = isinstance(pval, list)
    if res:
        for arr_4_idx, arr_4_item in enumerate(pval):
            arr_4_lpath: Path = ((lpath if path is not None else None) + [ arr_4_idx ]) if (lpath if path is not None else None) is not None else None
            # .'$MultiPoint'.coordinates.0
            res = json_model_2(arr_4_item, arr_4_lpath if (lpath if path is not None else None) is not None else None, rep)
            if not res:
                rep is None or rep.append(("unexpected $position [.'$MultiPoint'.coordinates.0]", arr_4_lpath if (lpath if path is not None else None) is not None else None))
                break
    if not res:
        rep is None or rep.append(("not array or unexpected array [.'$MultiPoint'.coordinates]", lpath if path is not None else None))
        rep is None or rep.append(("unexpected value for mandatory prop <coordinates> [.'$MultiPoint']", lpath if path is not None else None))
        return False
    if (pval := val.get("bbox", UNDEFINED)) != UNDEFINED:
        lpath = (path + [ "bbox" ]) if path is not None else None
        # .'$MultiPoint'.bbox
        res = isinstance(pval, list)
        if res:
            for arr_5_idx, arr_5_item in enumerate(pval):
                arr_5_lpath: Path = ((lpath if path is not None else None) + [ arr_5_idx ]) if (lpath if path is not None else None) is not None else None
                # .'$MultiPoint'.bbox.0
                res = isinstance(arr_5_item, (int, float)) and not isinstance(arr_5_item, bool)
                if not res:
                    rep is None or rep.append(("not a -1.0 loose float [.'$MultiPoint'.bbox.0]", arr_5_lpath if (lpath if path is not None else None) is not None else None))
                    break
        if not res:
            rep is None or rep.append(("not array or unexpected array [.'$MultiPoint'.bbox]", lpath if path is not None else None))
            rep is None or rep.append(("unexpected value for optional prop <bbox> [.'$MultiPoint']", lpath if path is not None else None))
            return False
    return True

# check $LineString (.'$LineString')
def json_model_7(val: Jsonable, path: Path, rep: Report) -> bool:
    # .'$LineString'
    # check open must/may only props
    if not isinstance(val, dict):
        rep is None or rep.append(("not an object [.'$LineString']", path))
        return False
    lpath: Path
    pval: Jsonable
    res: bool
    if not ((pval := val.get("type", UNDEFINED)) != UNDEFINED):
        rep is None or rep.append(("missing mandatory prop <type> [.'$LineString']", path))
        return False
    lpath = (path + [ "type" ]) if path is not None else None
    # .'$LineString'.type
    res = isinstance(pval, str) and pval == "LineString"
    if not res:
        rep is None or rep.append(("unexpected LineString [.'$LineString'.type]", lpath if path is not None else None))
        rep is None or rep.append(("unexpected value for mandatory prop <type> [.'$LineString']", lpath if path is not None else None))
        return False
    if not ((pval := val.get("coordinates", UNDEFINED)) != UNDEFINED):
        rep is None or rep.append(("missing mandatory prop <coordinates> [.'$LineString']", path))
        return False
    lpath = (path + [ "coordinates" ]) if path is not None else None
    # .'$LineString'.coordinates
    res = json_model_3(pval, lpath if path is not None else None, rep)
    if not res:
        rep is None or rep.append(("unexpected $coord_array [.'$LineString'.coordinates]", lpath if path is not None else None))
        rep is None or rep.append(("unexpected value for mandatory prop <coordinates> [.'$LineString']", lpath if path is not None else None))
        return False
    if (pval := val.get("bbox", UNDEFINED)) != UNDEFINED:
        lpath = (path + [ "bbox" ]) if path is not None else None
        # .'$LineString'.bbox
        res = isinstance(pval, list)
        if res:
            for arr_6_idx, arr_6_item in enumerate(pval):
                arr_6_lpath: Path = ((lpath if path is not None else None) + [ arr_6_idx ]) if (lpath if path is not None else None) is not None else None
                # .'$LineString'.bbox.0
                res = isinstance(arr_6_item, (int, float)) and not isinstance(arr_6_item, bool)
                if not res:
                    rep is None or rep.append(("not a -1.0 loose float [.'$LineString'.bbox.0]", arr_6_lpath if (lpath if path is not None else None) is not None else None))
                    break
        if not res:
            rep is None or rep.append(("not array or unexpected array [.'$LineString'.bbox]", lpath if path is not None else None))
            rep is None or rep.append(("unexpected value for optional prop <bbox> [.'$LineString']", lpath if path is not None else None))
            return False
    return True

# check $MultiLineString (.'$MultiLineString')
def json_model_8(val: Jsonable, path: Path, rep: Report) -> bool:
    # .'$MultiLineString'
    # check open must/may only props
    if not isinstance(val, dict):
        rep is None or rep.append(("not an object [.'$MultiLineString']", path))
        return False
    lpath: Path
    pval: Jsonable
    res: bool
    if not ((pval := val.get("type", UNDEFINED)) != UNDEFINED):
        rep is None or rep.append(("missing mandatory prop <type> [.'$MultiLineString']", path))
        return False
    lpath = (path + [ "type" ]) if path is not None else None
    # .'$MultiLineString'.type
    res = isinstance(pval, str) and pval == "MultiLineString"
    if not res:
        rep is None or rep.append(("unexpected MultiLineString [.'$MultiLineString'.type]", lpath if path is not None else None))
        rep is None or rep.append(("unexpected value for mandatory prop <type> [.'$MultiLineString']", lpath if path is not None else None))
        return False
    if not ((pval := val.get("coordinates", UNDEFINED)) != UNDEFINED):
        rep is None or rep.append(("missing mandatory prop <coordinates> [.'$MultiLineString']", path))
        return False
    lpath = (path + [ "coordinates" ]) if path is not None else None
    # .'$MultiLineString'.coordinates
    res = isinstance(pval, list)
    if res:
        for arr_7_idx, arr_7_item in enumerate(pval):
            arr_7_lpath: Path = ((lpath if path is not None else None) + [ arr_7_idx ]) if (lpath if path is not None else None) is not None else None
            # .'$MultiLineString'.coordinates.0
            res = json_model_3(arr_7_item, arr_7_lpath if (lpath if path is not None else None) is not None else None, rep)
            if not res:
                rep is None or rep.append(("unexpected $coord_array [.'$MultiLineString'.coordinates.0]", arr_7_lpath if (lpath if path is not None else None) is not None else None))
                break
    if not res:
        rep is None or rep.append(("not array or unexpected array [.'$MultiLineString'.coordinates]", lpath if path is not None else None))
        rep is None or rep.append(("unexpected value for mandatory prop <coordinates> [.'$MultiLineString']", lpath if path is not None else None))
        return False
    if (pval := val.get("bbox", UNDEFINED)) != UNDEFINED:
        lpath = (path + [ "bbox" ]) if path is not None else None
        # .'$MultiLineString'.bbox
        res = isinstance(pval, list)
        if res:
            for arr_8_idx, arr_8_item in enumerate(pval):
                arr_8_lpath: Path = ((lpath if path is not None else None) + [ arr_8_idx ]) if (lpath if path is not None else None) is not None else None
                # .'$MultiLineString'.bbox.0
                res = isinstance(arr_8_item, (int, float)) and not isinstance(arr_8_item, bool)
                if not res:
                    rep is None or rep.append(("not a -1.0 loose float [.'$MultiLineString'.bbox.0]", arr_8_lpath if (lpath if path is not None else None) is not None else None))
                    break
        if not res:
            rep is None or rep.append(("not array or unexpected array [.'$MultiLineString'.bbox]", lpath if path is not None else None))
            rep is None or rep.append(("unexpected value for optional prop <bbox> [.'$MultiLineString']", lpath if path is not None else None))
            return False
    return True

# check $Polygon (.'$Polygon')
def json_model_9(val: Jsonable, path: Path, rep: Report) -> bool:
    # .'$Polygon'
    # check open must/may only props
    if not isinstance(val, dict):
        rep is None or rep.append(("not an object [.'$Polygon']", path))
        return False
    lpath: Path
    pval: Jsonable
    res: bool
    if not ((pval := val.get("type", UNDEFINED)) != UNDEFINED):
        rep is None or rep.append(("missing mandatory prop <type> [.'$Polygon']", path))
        return False
    lpath = (path + [ "type" ]) if path is not None else None
    # .'$Polygon'.type
    res = isinstance(pval, str) and pval == "Polygon"
    if not res:
        rep is None or rep.append(("unexpected Polygon [.'$Polygon'.type]", lpath if path is not None else None))
        rep is None or rep.append(("unexpected value for mandatory prop <type> [.'$Polygon']", lpath if path is not None else None))
        return False
    if not ((pval := val.get("coordinates", UNDEFINED)) != UNDEFINED):
        rep is None or rep.append(("missing mandatory prop <coordinates> [.'$Polygon']", path))
        return False
    lpath = (path + [ "coordinates" ]) if path is not None else None
    # .'$Polygon'.coordinates
    res = isinstance(pval, list)
    if res:
        for arr_9_idx, arr_9_item in enumerate(pval):
            arr_9_lpath: Path = ((lpath if path is not None else None) + [ arr_9_idx ]) if (lpath if path is not None else None) is not None else None
            # .'$Polygon'.coordinates.0
            res = json_model_4(arr_9_item, arr_9_lpath if (lpath if path is not None else None) is not None else None, rep)
            if not res:
                rep is None or rep.append(("unexpected $linear_ring [.'$Polygon'.coordinates.0]", arr_9_lpath if (lpath if path is not None else None) is not None else None))
                break
    if not res:
        rep is None or rep.append(("not array or unexpected array [.'$Polygon'.coordinates]", lpath if path is not None else None))
        rep is None or rep.append(("unexpected value for mandatory prop <coordinates> [.'$Polygon']", lpath if path is not None else None))
        return False
    if (pval := val.get("bbox", UNDEFINED)) != UNDEFINED:
        lpath = (path + [ "bbox" ]) if path is not None else None
        # .'$Polygon'.bbox
        res = isinstance(pval, list)
        if res:
            for arr_10_idx, arr_10_item in enumerate(pval):
                arr_10_lpath: Path = ((lpath if path is not None else None) + [ arr_10_idx ]) if (lpath if path is not None else None) is not None else None
                # .'$Polygon'.bbox.0
                res = isinstance(arr_10_item, (int, float)) and not isinstance(arr_10_item, bool)
                if not res:
                    rep is None or rep.append(("not a -1.0 loose float [.'$Polygon'.bbox.0]", arr_10_lpath if (lpath if path is not None else None) is not None else None))
                    break
        if not res:
            rep is None or rep.append(("not array or unexpected array [.'$Polygon'.bbox]", lpath if path is not None else None))
            rep is None or rep.append(("unexpected value for optional prop <bbox> [.'$Polygon']", lpath if path is not None else None))
            return False
    return True

# check $MultiPolygon (.'$MultiPolygon')
def json_model_10(val: Jsonable, path: Path, rep: Report) -> bool:
    # .'$MultiPolygon'
    # check open must/may only props
    if not isinstance(val, dict):
        rep is None or rep.append(("not an object [.'$MultiPolygon']", path))
        return False
    lpath: Path
    pval: Jsonable
    res: bool
    if not ((pval := val.get("type", UNDEFINED)) != UNDEFINED):
        rep is None or rep.append(("missing mandatory prop <type> [.'$MultiPolygon']", path))
        return False
    lpath = (path + [ "type" ]) if path is not None else None
    # .'$MultiPolygon'.type
    res = isinstance(pval, str) and pval == "MultiPolygon"
    if not res:
        rep is None or rep.append(("unexpected MultiPolygon [.'$MultiPolygon'.type]", lpath if path is not None else None))
        rep is None or rep.append(("unexpected value for mandatory prop <type> [.'$MultiPolygon']", lpath if path is not None else None))
        return False
    if not ((pval := val.get("coordinates", UNDEFINED)) != UNDEFINED):
        rep is None or rep.append(("missing mandatory prop <coordinates> [.'$MultiPolygon']", path))
        return False
    lpath = (path + [ "coordinates" ]) if path is not None else None
    # .'$MultiPolygon'.coordinates
    res = isinstance(pval, list)
    if res:
        for arr_11_idx, arr_11_item in enumerate(pval):
            arr_11_lpath: Path = ((lpath if path is not None else None) + [ arr_11_idx ]) if (lpath if path is not None else None) is not None else None
            # .'$MultiPolygon'.coordinates.0
            res = isinstance(arr_11_item, list)
            if res:
                for arr_12_idx, arr_12_item in enumerate(arr_11_item):
                    arr_12_lpath: Path = ((arr_11_lpath if (lpath if path is not None else None) is not None else None) + [ arr_12_idx ]) if (arr_11_lpath if (lpath if path is not None else None) is not None else None) is not None else None
                    # .'$MultiPolygon'.coordinates.0.0
                    res = json_model_4(arr_12_item, arr_12_lpath if (arr_11_lpath if (lpath if path is not None else None) is not None else None) is not None else None, rep)
                    if not res:
                        rep is None or rep.append(("unexpected $linear_ring [.'$MultiPolygon'.coordinates.0.0]", arr_12_lpath if (arr_11_lpath if (lpath if path is not None else None) is not None else None) is not None else None))
                        break
            if not res:
                rep is None or rep.append(("not array or unexpected array [.'$MultiPolygon'.coordinates.0]", arr_11_lpath if (lpath if path is not None else None) is not None else None))
                break
    if not res:
        rep is None or rep.append(("not array or unexpected array [.'$MultiPolygon'.coordinates]", lpath if path is not None else None))
        rep is None or rep.append(("unexpected value for mandatory prop <coordinates> [.'$MultiPolygon']", lpath if path is not None else None))
        return False
    if (pval := val.get("bbox", UNDEFINED)) != UNDEFINED:
        lpath = (path + [ "bbox" ]) if path is not None else None
        # .'$MultiPolygon'.bbox
        res = isinstance(pval, list)
        if res:
            for arr_13_idx, arr_13_item in enumerate(pval):
                arr_13_lpath: Path = ((lpath if path is not None else None) + [ arr_13_idx ]) if (lpath if path is not None else None) is not None else None
                # .'$MultiPolygon'.bbox.0
                res = isinstance(arr_13_item, (int, float)) and not isinstance(arr_13_item, bool)
                if not res:
                    rep is None or rep.append(("not a -1.0 loose float [.'$MultiPolygon'.bbox.0]", arr_13_lpath if (lpath if path is not None else None) is not None else None))
                    break
        if not res:
            rep is None or rep.append(("not array or unexpected array [.'$MultiPolygon'.bbox]", lpath if path is not None else None))
            rep is None or rep.append(("unexpected value for optional prop <bbox> [.'$MultiPolygon']", lpath if path is not None else None))
            return False
    return True


# check $geometry (.'$geometry')
def json_model_11(val: Jsonable, path: Path, rep: Report) -> bool:
    res: bool
    # .'$geometry'
    iso_0: bool = isinstance(val, dict)
    res = iso_0
    if res:
        if "type" in val:
            tag_0: Jsonable = val.get("type", UNDEFINED)
            fun_0: CheckFun = _jm_map_0.get(tag_0, UNDEFINED)
            if fun_0 != UNDEFINED:
                res = fun_0(val, path, rep)
            else:
                res = False
                rep is None or rep.append(("tag <type> value not found [.'$geometry'.'|']", path))
        else:
            res = False
            rep is None or rep.append(("tag prop <type> is missing [.'$geometry'.'|']", path))
    else:
        rep is None or rep.append(("value is not an object [.'$geometry'.'|']", path))
    return res

# check $GeometryCollection (.'$GeometryCollection')
def json_model_12(val: Jsonable, path: Path, rep: Report) -> bool:
    # .'$GeometryCollection'
    # check open must/may only props
    if not isinstance(val, dict):
        rep is None or rep.append(("not an object [.'$GeometryCollection']", path))
        return False
    lpath: Path
    pval: Jsonable
    res: bool
    if not ((pval := val.get("type", UNDEFINED)) != UNDEFINED):
        rep is None or rep.append(("missing mandatory prop <type> [.'$GeometryCollection']", path))
        return False
    lpath = (path + [ "type" ]) if path is not None else None
    # .'$GeometryCollection'.type
    res = isinstance(pval, str) and pval == "GeometryCollection"
    if not res:
        rep is None or rep.append(("unexpected GeometryCollection [.'$GeometryCollection'.type]", lpath if path is not None else None))
        rep is None or rep.append(("unexpected value for mandatory prop <type> [.'$GeometryCollection']", lpath if path is not None else None))
        return False
    if not ((pval := val.get("geometries", UNDEFINED)) != UNDEFINED):
        rep is None or rep.append(("missing mandatory prop <geometries> [.'$GeometryCollection']", path))
        return False
    lpath = (path + [ "geometries" ]) if path is not None else None
    # .'$GeometryCollection'.geometries
    res = isinstance(pval, list)
    if res:
        for arr_14_idx, arr_14_item in enumerate(pval):
            arr_14_lpath: Path = ((lpath if path is not None else None) + [ arr_14_idx ]) if (lpath if path is not None else None) is not None else None
            # .'$GeometryCollection'.geometries.0
            res = json_model_11(arr_14_item, arr_14_lpath if (lpath if path is not None else None) is not None else None, rep)
            if not res:
                rep is None or rep.append(("unexpected $geometry [.'$GeometryCollection'.geometries.0]", arr_14_lpath if (lpath if path is not None else None) is not None else None))
                break
    if not res:
        rep is None or rep.append(("not array or unexpected array [.'$GeometryCollection'.geometries]", lpath if path is not None else None))
        rep is None or rep.append(("unexpected value for mandatory prop <geometries> [.'$GeometryCollection']", lpath if path is not None else None))
        return False
    if (pval := val.get("bbox", UNDEFINED)) != UNDEFINED:
        lpath = (path + [ "bbox" ]) if path is not None else None
        # .'$GeometryCollection'.bbox
        res = isinstance(pval, list)
        if res:
            for arr_15_idx, arr_15_item in enumerate(pval):
                arr_15_lpath: Path = ((lpath if path is not None else None) + [ arr_15_idx ]) if (lpath if path is not None else None) is not None else None
                # .'$GeometryCollection'.bbox.0
                res = isinstance(arr_15_item, (int, float)) and not isinstance(arr_15_item, bool)
                if not res:
                    rep is None or rep.append(("not a -1.0 loose float [.'$GeometryCollection'.bbox.0]", arr_15_lpath if (lpath if path is not None else None) is not None else None))
                    break
        if not res:
            rep is None or rep.append(("not array or unexpected array [.'$GeometryCollection'.bbox]", lpath if path is not None else None))
            rep is None or rep.append(("unexpected value for optional prop <bbox> [.'$GeometryCollection']", lpath if path is not None else None))
            return False
    return True

# object .'$Feature'.properties.'|'.1
def _jm_obj_0(val: Jsonable, path: Path, rep: Report) -> bool:
    if not isinstance(val, dict):
        rep is None or rep.append(("not an object [.'$Feature'.properties.'|'.1]", path))
        return False
    # accept any object
    return True

# check $Feature (.'$Feature')
def json_model_13(val: Jsonable, path: Path, rep: Report) -> bool:
    # .'$Feature'
    # check open must/may only props
    if not isinstance(val, dict):
        rep is None or rep.append(("not an object [.'$Feature']", path))
        return False
    lpath: Path
    pval: Jsonable
    res: bool
    if not ((pval := val.get("type", UNDEFINED)) != UNDEFINED):
        rep is None or rep.append(("missing mandatory prop <type> [.'$Feature']", path))
        return False
    lpath = (path + [ "type" ]) if path is not None else None
    # .'$Feature'.type
    res = isinstance(pval, str) and pval == "Feature"
    if not res:
        rep is None or rep.append(("unexpected Feature [.'$Feature'.type]", lpath if path is not None else None))
        rep is None or rep.append(("unexpected value for mandatory prop <type> [.'$Feature']", lpath if path is not None else None))
        return False
    if not ((pval := val.get("geometry", UNDEFINED)) != UNDEFINED):
        rep is None or rep.append(("missing mandatory prop <geometry> [.'$Feature']", path))
        return False
    lpath = (path + [ "geometry" ]) if path is not None else None
    # .'$Feature'.geometry
    # .'$Feature'.geometry.'|'.0
    res = pval is None
    if not res:
        rep is None or rep.append(("not null [.'$Feature'.geometry.'|'.0]", lpath if path is not None else None))
    if not res:
        # .'$Feature'.geometry.'|'.1
        res = json_model_11(pval, lpath if path is not None else None, rep)
        if not res:
            rep is None or rep.append(("unexpected $geometry [.'$Feature'.geometry.'|'.1]", lpath if path is not None else None))
        if not res:
            # .'$Feature'.geometry.'|'.2
            res = json_model_12(pval, lpath if path is not None else None, rep)
            if not res:
                rep is None or rep.append(("unexpected $GeometryCollection [.'$Feature'.geometry.'|'.2]", lpath if path is not None else None))
    if res:
        rep is None or rep.clear()
    else:
        rep is None or rep.append(("no model matched [.'$Feature'.geometry.'|']", lpath if path is not None else None))
        rep is None or rep.append(("unexpected value for mandatory prop <geometry> [.'$Feature']", lpath if path is not None else None))
        return False
    if not ((pval := val.get("properties", UNDEFINED)) != UNDEFINED):
        rep is None or rep.append(("missing mandatory prop <properties> [.'$Feature']", path))
        return False
    lpath = (path + [ "properties" ]) if path is not None else None
    # .'$Feature'.properties
    # .'$Feature'.properties.'|'.0
    res = pval is None
    if not res:
        rep is None or rep.append(("not null [.'$Feature'.properties.'|'.0]", lpath if path is not None else None))
    if not res:
        # .'$Feature'.properties.'|'.1
        res = _jm_obj_0(pval, lpath if path is not None else None, rep)
        if not res:
            rep is None or rep.append(("unexpected element [.'$Feature'.properties.'|'.1]", lpath if path is not None else None))
    if res:
        rep is None or rep.clear()
    else:
        rep is None or rep.append(("no model matched [.'$Feature'.properties.'|']", lpath if path is not None else None))
        rep is None or rep.append(("unexpected value for mandatory prop <properties> [.'$Feature']", lpath if path is not None else None))
        return False
    if (pval := val.get("id", UNDEFINED)) != UNDEFINED:
        lpath = (path + [ "id" ]) if path is not None else None
        # .'$Feature'.id
        # .'$Feature'.id.'|'.0
        res = isinstance(pval, str)
        if not res:
            rep is None or rep.append(("unexpected string [.'$Feature'.id.'|'.0]", lpath if path is not None else None))
        if not res:
            # .'$Feature'.id.'|'.1
            res = isinstance(pval, (int, float)) and not isinstance(pval, bool)
            if not res:
                rep is None or rep.append(("not a -1.0 loose float [.'$Feature'.id.'|'.1]", lpath if path is not None else None))
        if res:
            rep is None or rep.clear()
        else:
            rep is None or rep.append(("no model matched [.'$Feature'.id.'|']", lpath if path is not None else None))
            rep is None or rep.append(("unexpected value for optional prop <id> [.'$Feature']", lpath if path is not None else None))
            return False
    if (pval := val.get("bbox", UNDEFINED)) != UNDEFINED:
        lpath = (path + [ "bbox" ]) if path is not None else None
        # .'$Feature'.bbox
        res = isinstance(pval, list)
        if res:
            for arr_16_idx, arr_16_item in enumerate(pval):
                arr_16_lpath: Path = ((lpath if path is not None else None) + [ arr_16_idx ]) if (lpath if path is not None else None) is not None else None
                # .'$Feature'.bbox.0
                res = isinstance(arr_16_item, (int, float)) and not isinstance(arr_16_item, bool)
                if not res:
                    rep is None or rep.append(("not a -1.0 loose float [.'$Feature'.bbox.0]", arr_16_lpath if (lpath if path is not None else None) is not None else None))
                    break
        if not res:
            rep is None or rep.append(("not array or unexpected array [.'$Feature'.bbox]", lpath if path is not None else None))
            rep is None or rep.append(("unexpected value for optional prop <bbox> [.'$Feature']", lpath if path is not None else None))
            return False
    return True

# check $FeatureCollection (.'$FeatureCollection')
def json_model_14(val: Jsonable, path: Path, rep: Report) -> bool:
    # .'$FeatureCollection'
    # check open must/may only props
    if not isinstance(val, dict):
        rep is None or rep.append(("not an object [.'$FeatureCollection']", path))
        return False
    lpath: Path
    pval: Jsonable
    res: bool
    if not ((pval := val.get("type", UNDEFINED)) != UNDEFINED):
        rep is None or rep.append(("missing mandatory prop <type> [.'$FeatureCollection']", path))
        return False
    lpath = (path + [ "type" ]) if path is not None else None
    # .'$FeatureCollection'.type
    res = isinstance(pval, str) and pval == "FeatureCollection"
    if not res:
        rep is None or rep.append(("unexpected FeatureCollection [.'$FeatureCollection'.type]", lpath if path is not None else None))
        rep is None or rep.append(("unexpected value for mandatory prop <type> [.'$FeatureCollection']", lpath if path is not None else None))
        return False
    if not ((pval := val.get("features", UNDEFINED)) != UNDEFINED):
        rep is None or rep.append(("missing mandatory prop <features> [.'$FeatureCollection']", path))
        return False
    lpath = (path + [ "features" ]) if path is not None else None
    # .'$FeatureCollection'.features
    res = isinstance(pval, list)
    if res:
        for arr_17_idx, arr_17_item in enumerate(pval):
            arr_17_lpath: Path = ((lpath if path is not None else None) + [ arr_17_idx ]) if (lpath if path is not None else None) is not None else None
            # .'$FeatureCollection'.features.0
            res = json_model_13(arr_17_item, arr_17_lpath if (lpath if path is not None else None) is not None else None, rep)
            if not res:
                rep is None or rep.append(("unexpected $Feature [.'$FeatureCollection'.features.0]", arr_17_lpath if (lpath if path is not None else None) is not None else None))
                break
    if not res:
        rep is None or rep.append(("not array or unexpected array [.'$FeatureCollection'.features]", lpath if path is not None else None))
        rep is None or rep.append(("unexpected value for mandatory prop <features> [.'$FeatureCollection']", lpath if path is not None else None))
        return False
    if (pval := val.get("bbox", UNDEFINED)) != UNDEFINED:
        lpath = (path + [ "bbox" ]) if path is not None else None
        # .'$FeatureCollection'.bbox
        res = isinstance(pval, list)
        if res:
            for arr_18_idx, arr_18_item in enumerate(pval):
                arr_18_lpath: Path = ((lpath if path is not None else None) + [ arr_18_idx ]) if (lpath if path is not None else None) is not None else None
                # .'$FeatureCollection'.bbox.0
                res = isinstance(arr_18_item, (int, float)) and not isinstance(arr_18_item, bool)
                if not res:
                    rep is None or rep.append(("not a -1.0 loose float [.'$FeatureCollection'.bbox.0]", arr_18_lpath if (lpath if path is not None else None) is not None else None))
                    break
        if not res:
            rep is None or rep.append(("not array or unexpected array [.'$FeatureCollection'.bbox]", lpath if path is not None else None))
            rep is None or rep.append(("unexpected value for optional prop <bbox> [.'$FeatureCollection']", lpath if path is not None else None))
            return False
    return True


# check $ (.)
def json_model_1(val: Jsonable, path: Path, rep: Report) -> bool:
    res: bool
    # Easy Geo JSON Model JSON_MODEL_LOOSE_FLOAT
    # .
    iso_1: bool = isinstance(val, dict)
    res = iso_1
    if res:
        if "type" in val:
            tag_1: Jsonable = val.get("type", UNDEFINED)
            fun_1: CheckFun = _jm_map_1.get(tag_1, UNDEFINED)
            if fun_1 != UNDEFINED:
                res = fun_1(val, path, rep)
            else:
                res = False
                rep is None or rep.append(("tag <type> value not found [.'|']", path))
        else:
            res = False
            rep is None or rep.append(("tag prop <type> is missing [.'|']", path))
    else:
        rep is None or rep.append(("value is not an object [.'|']", path))
    if not res:
        res = json_model_11(val, path, rep)
    return res


# initialization guard
initialized: bool = False

# differed module initializations
def check_model_init():
    global initialized
    if not initialized:
        initialized = True
        global _jm_map_0
        _jm_map_0 = {
            "Point": json_model_5,
            "MultiPoint": json_model_6,
            "LineString": json_model_7,
            "MultiLineString": json_model_8,
            "Polygon": json_model_9,
            "MultiPolygon": json_model_10,
        }
        global _jm_map_1
        _jm_map_1 = {
            "GeometryCollection": json_model_12,
            "Feature": json_model_13,
            "FeatureCollection": json_model_14,
        }
        global check_model_map
        check_model_map = {
            "": json_model_1,
            "position": json_model_2,
            "coord_array": json_model_3,
            "linear_ring": json_model_4,
            "Point": json_model_5,
            "MultiPoint": json_model_6,
            "LineString": json_model_7,
            "MultiLineString": json_model_8,
            "Polygon": json_model_9,
            "MultiPolygon": json_model_10,
            "geometry": json_model_11,
            "GeometryCollection": json_model_12,
            "Feature": json_model_13,
            "FeatureCollection": json_model_14,
        }

# differed module cleanup
def check_model_free():
    global initialized
    if initialized:
        initialized = False

if __name__ == "__main__":
    check_model_init()
    main(check_model_fun, check_model_map, __version__)
    check_model_free()
