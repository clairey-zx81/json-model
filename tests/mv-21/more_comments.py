#! /bin/env python
#
# Generated by JSON Model Compiler version 2
# see https://github.com/clairey-zx81/json-model
#
from typing import Callable
import re2 as re
from json_model.runtime import *
__version__ = "2"

def check_model_fun(name: str) -> CheckFun:
    """Return check function for JSON model name."""
    return check_model_map[name]

# entry point for generated checkers
def check_model(val: Jsonable, name: str = "", rep: Report = None) -> bool:
    """Check val validity agains JSON Model name."""
    if name not in check_model_map:
        raise Exception(f"unexpected model name: {name}")
    checker = check_model_map[name]
    return checker(val, [], rep)

check_model_map: PropMap

# check $Pp (.'$Pp')
def json_model_2(val: Jsonable, path: Path, rep: Report) -> bool:
    res: bool
    # .'$Pp'
    res = isinstance(val, int) and not isinstance(val, bool) and val >= 0
    if not res:
        rep is None or rep.append(("not a 0 strict int [.'$Pp']", path))
    return res

# check $Qq (.'$Qq')
def json_model_3(val: Jsonable, path: Path, rep: Report) -> bool:
    res: bool
    # .'$Qq'
    res = isinstance(val, list)
    if res:
        for arr_0_idx, arr_0_item in enumerate(val):
            arr_0_lpath: Path = (path + [ arr_0_idx ]) if path is not None else None
            # .'$Qq'.0
            res = json_model_2(arr_0_item, arr_0_lpath if path is not None else None, rep)
            if not res:
                rep is None or rep.append(("unexpected $Pp [.'$Qq'.0]", arr_0_lpath if path is not None else None))
                break
    if not res:
        rep is None or rep.append(("not array or unexpected array [.'$Qq']", path))
    return res

# object .o
def _jm_obj_0(val: Jsonable, path: Path, rep: Report) -> bool:
    if not isinstance(val, dict):
        rep is None or rep.append(("not an object [.o]", path))
        return False
    res: bool
    for prop, pval in val.items():
        lpath_1: Path = (path + [ prop ]) if path is not None else None
        if prop == "p":
            # handle may p property
            # .o.p
            res = json_model_2(pval, lpath_1 if path is not None else None, rep)
            if not res:
                rep is None or rep.append(("unexpected $Pp [.o.p]", lpath_1 if path is not None else None))
                rep is None or rep.append(("invalid optional prop value [.o.p]", lpath_1 if path is not None else None))
                return False
        elif prop == "q":
            # handle may q property
            # .o.q
            res = json_model_3(pval, lpath_1 if path is not None else None, rep)
            if not res:
                rep is None or rep.append(("unexpected $Qq [.o.q]", lpath_1 if path is not None else None))
                rep is None or rep.append(("invalid optional prop value [.o.q]", lpath_1 if path is not None else None))
                return False
        elif prop == "t":
            # handle may t property
            # .o.t
            res = isinstance(pval, list) and len(pval) == 2
            if res:
                lpath_2: Path = ((lpath_1 if path is not None else None) + [ 0 ]) if (lpath_1 if path is not None else None) is not None else None
                # .o.t.0
                res = isinstance(pval[0], bool)
                if not res:
                    rep is None or rep.append(("not a bool [.o.t.0]", lpath_2 if (lpath_1 if path is not None else None) is not None else None))
                if res:
                    lpath_2 = ((lpath_1 if path is not None else None) + [ 1 ]) if (lpath_1 if path is not None else None) is not None else None
                    # .o.t.1
                    res = isinstance(pval[1], int) and not isinstance(pval[1], bool) and pval[1] >= 0
                    if not res:
                        rep is None or rep.append(("not a 0 strict int [.o.t.1]", lpath_2 if (lpath_1 if path is not None else None) is not None else None))
            if not res:
                rep is None or rep.append(("not array or unexpected array [.o.t]", lpath_1 if path is not None else None))
                rep is None or rep.append(("invalid optional prop value [.o.t]", lpath_1 if path is not None else None))
                return False
        else:
            rep is None or rep.append(("unexpected prop [.o]", lpath_1 if path is not None else None))
            return False
    return True

# check $ (.)
def json_model_1(val: Jsonable, path: Path, rep: Report) -> bool:
    # trivial and non trivial comments
    # .
    if not isinstance(val, dict):
        rep is None or rep.append(("not an object [.]", path))
        return False
    res: bool
    for prop, pval in val.items():
        lpath_0: Path = (path + [ prop ]) if path is not None else None
        if prop == "o":
            # handle may o property
            # an object
            # .o
            res = _jm_obj_0(pval, lpath_0 if path is not None else None, rep)
            if not res:
                rep is None or rep.append(("unexpected element [.o]", lpath_0 if path is not None else None))
                rep is None or rep.append(("invalid optional prop value [.o]", lpath_0 if path is not None else None))
                return False
        else:
            rep is None or rep.append(("unexpected prop [.]", lpath_0 if path is not None else None))
            return False
    return True


# initialization guard
initialized: bool = False

# differed module initializations
def check_model_init():
    global initialized
    if not initialized:
        initialized = True
        global check_model_map
        check_model_map = {
            "": json_model_1,
            "Pp": json_model_2,
            "Qq": json_model_3,
        }

# differed module cleanup
def check_model_free():
    global initialized
    if initialized:
        initialized = False

if __name__ == "__main__":
    check_model_init()
    main(check_model_fun, check_model_map, __version__)
    check_model_free()
