--
-- Generated by JSON Model Compiler version 2.0b0
-- see https://github.com/clairey-zx81/json-model
--
-- JSON_MODEL_VERSION is 2.0b0
CREATE EXTENSION IF NOT EXISTS json_model;

-- regex=. opts=n
CREATE OR REPLACE FUNCTION _jm_re_0(val TEXT, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  RETURN regexp_like(val, '.', 'n');
END;
$$ LANGUAGE plpgsql;

-- check $neStr (.'$neStr')
CREATE OR REPLACE FUNCTION json_model_2(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$neStr'
  -- "/./"
  res := JSONB_TYPEOF(val) = 'string' AND _jm_re_0(JSON_VALUE(val, '$' RETURNING TEXT), path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check $neStrList (.'$neStrList')
CREATE OR REPLACE FUNCTION json_model_3(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  arr_0_idx INT8;
  arr_0_item JSONB;
  ival_0 int;
BEGIN
  -- .'$neStrList'
  -- .'$neStrList'.'@'
  res := JSONB_TYPEOF(val) = 'array';
  IF res THEN
    FOR arr_0_idx IN 0 .. JSONB_ARRAY_LENGTH(val) - 1 LOOP
      arr_0_item := val -> arr_0_idx;
      -- .'$neStrList'.'@'.0
      res := json_model_2(arr_0_item, NULL, rep);
      IF NOT res THEN
        EXIT;
      END IF;
    END LOOP;
  END IF;
  IF res THEN
    ival_0 := JSONB_ARRAY_LENGTH(val);
    res := jm_array_is_unique(val, path, rep) AND ival_0 >= 1;
  END IF;
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION _jm_cst_0(value JSONB)
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  constants JSONB = JSONB '["agpl_3","apache_1_1","apache_2_0","artistic_1","artistic_2","bsd","freebsd","gfdl_1_2","gfdl_1_3","gpl_1","gpl_2","gpl_3","lgpl_2_1","lgpl_3_0","mit","mozilla_1_0","mozilla_1_1","openssl","perl_5","postgresql","qpl_1_0","ssleay","sun","zlib","open_source","restricted","unrestricted","unknown"]';
BEGIN
  RETURN constants @> value;
END;
$$ LANGUAGE plpgsql;

-- check $License (.'$License')
CREATE OR REPLACE FUNCTION json_model_4(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$License'
  res := JSONB_TYPEOF(val) IN ('null', 'boolean', 'number', 'string') AND _jm_cst_0(val);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check $LicenseList (.'$LicenseList')
CREATE OR REPLACE FUNCTION json_model_5(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  arr_1_idx INT8;
  arr_1_item JSONB;
  ival_1 int;
BEGIN
  -- .'$LicenseList'
  -- .'$LicenseList'.'@'
  res := JSONB_TYPEOF(val) = 'array';
  IF res THEN
    FOR arr_1_idx IN 0 .. JSONB_ARRAY_LENGTH(val) - 1 LOOP
      arr_1_item := val -> arr_1_idx;
      -- .'$LicenseList'.'@'.0
      res := json_model_4(arr_1_item, NULL, rep);
      IF NOT res THEN
        EXIT;
      END IF;
    END LOOP;
  END IF;
  IF res THEN
    ival_1 := JSONB_ARRAY_LENGTH(val);
    res := jm_array_is_unique(val, path, rep) AND ival_1 >= 1;
  END IF;
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- regex=^[Xx]_ opts=n
CREATE OR REPLACE FUNCTION _jm_re_1(val TEXT, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  RETURN regexp_like(val, '^[Xx]_', 'n');
END;
$$ LANGUAGE plpgsql;

-- object .'$Provide'
CREATE OR REPLACE FUNCTION _jm_obj_0(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  must_count int;
  prop TEXT;
  pval JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  must_count := 0;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = 'file' THEN
      -- handle must file property
      must_count := must_count + 1;
      -- .'$Provide'.file
      res := JSONB_TYPEOF(pval) = 'string';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'version' THEN
      -- handle must version property
      must_count := must_count + 1;
      -- .'$Provide'.version
      res := json_model_10(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'abstract' THEN
      -- handle may abstract property
      -- .'$Provide'.abstract
      res := JSONB_TYPEOF(pval) = 'string';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'docfile' THEN
      -- handle may docfile property
      -- .'$Provide'.docfile
      res := JSONB_TYPEOF(pval) = 'string';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF _jm_re_1(prop, path, rep) THEN
      -- handle 1 re props
      -- .'$Provide'.'/^[Xx]_/'
      res := TRUE;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  IF must_count <> 2 THEN
    RETURN FALSE;
  END IF;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check $Provide (.'$Provide')
CREATE OR REPLACE FUNCTION json_model_6(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$Provide'
  res := _jm_obj_0(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION _jm_cst_1(value JSONB)
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  constants JSONB = JSONB '["stable","testing","unstable"]';
BEGIN
  RETURN constants @> value;
END;
$$ LANGUAGE plpgsql;

-- check $Status (.'$Status')
CREATE OR REPLACE FUNCTION json_model_7(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$Status'
  res := JSONB_TYPEOF(val) IN ('null', 'boolean', 'number', 'string') AND _jm_cst_1(val);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- object .'$Resources'.bugtracker
CREATE OR REPLACE FUNCTION _jm_obj_2(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = 'web' THEN
      -- handle may web property
      -- .'$Resources'.bugtracker.web
      res := JSONB_TYPEOF(pval) = 'string' AND jm_is_valid_url(JSON_VALUE(pval, '$' RETURNING TEXT), NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'mailto' THEN
      -- handle may mailto property
      -- .'$Resources'.bugtracker.mailto
      res := JSONB_TYPEOF(pval) = 'string' AND jm_is_valid_email(JSON_VALUE(pval, '$' RETURNING TEXT), NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF _jm_re_1(prop, path, rep) THEN
      -- handle 1 re props
      -- .'$Resources'.bugtracker.'/^[Xx]_/'
      res := TRUE;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- object .'$Resources'.repository
CREATE OR REPLACE FUNCTION _jm_obj_3(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = 'url' THEN
      -- handle may url property
      -- .'$Resources'.repository.url
      res := JSONB_TYPEOF(pval) = 'string' AND jm_is_valid_url(JSON_VALUE(pval, '$' RETURNING TEXT), NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'web' THEN
      -- handle may web property
      -- .'$Resources'.repository.web
      res := JSONB_TYPEOF(pval) = 'string' AND jm_is_valid_url(JSON_VALUE(pval, '$' RETURNING TEXT), NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'type' THEN
      -- handle may type property
      -- .'$Resources'.repository.type
      -- "/./"
      res := JSONB_TYPEOF(pval) = 'string' AND _jm_re_0(JSON_VALUE(pval, '$' RETURNING TEXT), NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- object .'$Resources'
CREATE OR REPLACE FUNCTION _jm_obj_1(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = 'homepage' THEN
      -- handle may homepage property
      -- .'$Resources'.homepage
      res := JSONB_TYPEOF(pval) = 'string' AND jm_is_valid_url(JSON_VALUE(pval, '$' RETURNING TEXT), NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'bugtracker' THEN
      -- handle may bugtracker property
      -- .'$Resources'.bugtracker
      res := _jm_obj_2(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'repository' THEN
      -- handle may repository property
      -- .'$Resources'.repository
      res := _jm_obj_3(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check $Resources (.'$Resources')
CREATE OR REPLACE FUNCTION json_model_8(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$Resources'
  res := _jm_obj_1(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- regex=^\d+\.\d+\.\d+[-_A-Za-z0-9]*$ opts=n
CREATE OR REPLACE FUNCTION _jm_re_2(val TEXT, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  RETURN regexp_like(val, '^\d+\.\d+\.\d+[-_A-Za-z0-9]*$', 'n');
END;
$$ LANGUAGE plpgsql;

-- check $SemVer (.'$SemVer')
CREATE OR REPLACE FUNCTION json_model_9(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$SemVer'
  -- "/^\\d+\\.\\d+\\.\\d+[-_A-Za-z0-9]*$/"
  res := JSONB_TYPEOF(val) = 'string' AND _jm_re_2(JSON_VALUE(val, '$' RETURNING TEXT), path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check $Version (.'$Version')
CREATE OR REPLACE FUNCTION json_model_10(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$Version'
  -- .'$Version'.'|'.0
  res := json_model_9(val, path, rep);
  IF NOT res THEN
    -- .'$Version'.'|'.1
    res := JSONB_TYPEOF(val) = 'number' AND (val)::INT8 = (val)::FLOAT8 AND (val)::INT8 = 0;
  END IF;
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- regex=^(<=|<|>=|>|!=|==)$ opts=n
CREATE OR REPLACE FUNCTION _jm_re_3(val TEXT, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  RETURN regexp_like(val, '^(<=|<|>=|>|!=|==)$', 'n');
END;
$$ LANGUAGE plpgsql;

-- check $Ops (.'$Ops')
CREATE OR REPLACE FUNCTION json_model_11(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$Ops'
  -- "/^(<=|<|>=|>|!=|==)$/"
  res := JSONB_TYPEOF(val) = 'string' AND _jm_re_3(JSON_VALUE(val, '$' RETURNING TEXT), path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- regex=^\s*(<=|<|>=|>|!=|==)\s*(\d+\.\d+\.\d+[-_A-Za-z0-9]*)\s*(,\s*(<=|<|>=|>|!=|==)\s*(\d+\.\d+\.\d+[-_A-Za-z0-9]*))*\s*$ opts=n
CREATE OR REPLACE FUNCTION _jm_re_4(val TEXT, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  RETURN regexp_like(val, '^\s*(<=|<|>=|>|!=|==)\s*(\d+\.\d+\.\d+[-_A-Za-z0-9]*)\s*(,\s*(<=|<|>=|>|!=|==)\s*(\d+\.\d+\.\d+[-_A-Za-z0-9]*))*\s*$', 'n');
END;
$$ LANGUAGE plpgsql;

-- check $VersionRange (.'$VersionRange')
CREATE OR REPLACE FUNCTION json_model_12(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$VersionRange'
  -- "/^\\s*(<=|<|>=|>|!=|==)\\s*(\\d+\\.\\d+\\.\\d+[-_A-Za-z0-9]*)\\s*(,\\s*(<=|<|>=|>|!=|==)\\s*(\\d+\\.\\d+\\.\\d+[-_A-Za-z0-9]*))*\\s*$/"
  res := JSONB_TYPEOF(val) = 'string' AND _jm_re_4(JSON_VALUE(val, '$' RETURNING TEXT), path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION _jm_cst_2(value JSONB)
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  constants JSONB = JSONB '["configure","build","test","runtime","develop"]';
BEGIN
  RETURN constants @> value;
END;
$$ LANGUAGE plpgsql;

-- check $Phase (.'$Phase')
CREATE OR REPLACE FUNCTION json_model_13(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$Phase'
  res := JSONB_TYPEOF(val) IN ('null', 'boolean', 'number', 'string') AND _jm_cst_2(val);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION _jm_cst_3(value JSONB)
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  constants JSONB = JSONB '["requires","recommends","suggests","conflicts"]';
BEGIN
  RETURN constants @> value;
END;
$$ LANGUAGE plpgsql;

-- check $Relation (.'$Relation')
CREATE OR REPLACE FUNCTION json_model_14(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$Relation'
  res := JSONB_TYPEOF(val) IN ('null', 'boolean', 'number', 'string') AND _jm_cst_3(val);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- object .'$Prereq'
CREATE OR REPLACE FUNCTION _jm_obj_4(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    -- handle other props
    -- .'$Prereq'.''
    -- .'$Prereq'.''.'|'.0
    res := json_model_10(pval, NULL, rep);
    IF NOT res THEN
      -- .'$Prereq'.''.'|'.1
      res := json_model_12(pval, NULL, rep);
    END IF;
    IF NOT res THEN
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check $Prereq (.'$Prereq')
CREATE OR REPLACE FUNCTION json_model_15(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$Prereq'
  res := _jm_obj_4(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- object .'$Prereqs'.'$Phase'
CREATE OR REPLACE FUNCTION _jm_obj_6(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF json_model_14(TO_JSONB(prop), NULL, rep) THEN
      -- handle 1 key props
      -- .'$Prereqs'.'$Phase'.'$Relation'
      res := json_model_15(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF _jm_re_1(prop, path, rep) THEN
      -- handle 1 re props
      -- .'$Prereqs'.'$Phase'.'/^[Xx]_/'
      res := TRUE;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- object .'$Prereqs'
CREATE OR REPLACE FUNCTION _jm_obj_5(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF json_model_13(TO_JSONB(prop), NULL, rep) THEN
      -- handle 1 key props
      -- .'$Prereqs'.'$Phase'
      res := _jm_obj_6(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF _jm_re_1(prop, path, rep) THEN
      -- handle 1 re props
      -- .'$Prereqs'.'/^[Xx]_/'
      res := TRUE;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check $Prereqs (.'$Prereqs')
CREATE OR REPLACE FUNCTION json_model_16(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$Prereqs'
  res := _jm_obj_5(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_7_mup_abstract (.abstract)
CREATE OR REPLACE FUNCTION _jm_f_0(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .abstract
  res := JSONB_TYPEOF(val) = 'string';
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- object .license.'^'.2
CREATE OR REPLACE FUNCTION _jm_obj_8(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    -- handle other props
    -- .license.'^'.2.''
    res := JSONB_TYPEOF(pval) = 'string' AND jm_is_valid_url(JSON_VALUE(pval, '$' RETURNING TEXT), NULL, rep);
    IF NOT res THEN
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_7_mup_license (.license)
CREATE OR REPLACE FUNCTION _jm_f_1(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  xc_0 int;
  xr_0 bool;
BEGIN
  -- .license
  -- generic xor list
  xc_0 := 0;
  -- .license.'^'.0
  xr_0 := json_model_4(val, path, rep);
  IF xr_0 THEN
    xc_0 := xc_0 + 1;
  END IF;
  -- .license.'^'.1
  xr_0 := json_model_5(val, path, rep);
  IF xr_0 THEN
    xc_0 := xc_0 + 1;
  END IF;
  IF xc_0 <= 1 THEN
    -- .license.'^'.2
    xr_0 := _jm_obj_8(val, path, rep);
    IF xr_0 THEN
      xc_0 := xc_0 + 1;
    END IF;
  END IF;
  res := xc_0 = 1;
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_7_mup_maintainer (.maintainer)
CREATE OR REPLACE FUNCTION _jm_f_2(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .maintainer
  -- .maintainer.'|'.0
  res := json_model_2(val, path, rep);
  IF NOT res THEN
    -- .maintainer.'|'.1
    res := json_model_3(val, path, rep);
  END IF;
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- object .'meta-spec'
CREATE OR REPLACE FUNCTION _jm_obj_9(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  must_count int;
  prop TEXT;
  pval JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  must_count := 0;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = 'version' THEN
      -- handle must version property
      must_count := must_count + 1;
      -- .'meta-spec'.version
      res := JSONB_TYPEOF(pval) = 'string' AND JSON_VALUE(pval, '$' RETURNING TEXT) = '1.0.0';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'url' THEN
      -- handle may url property
      -- .'meta-spec'.url
      res := JSONB_TYPEOF(pval) = 'string' AND jm_is_valid_url(JSON_VALUE(pval, '$' RETURNING TEXT), NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF _jm_re_1(prop, path, rep) THEN
      -- handle 1 re props
      -- .'meta-spec'.'/^[Xx]_/'
      res := TRUE;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  IF must_count <> 1 THEN
    RETURN FALSE;
  END IF;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_7_mup_meta-spec (.'meta-spec')
CREATE OR REPLACE FUNCTION _jm_f_3(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'meta-spec'
  res := _jm_obj_9(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_7_mup_name (.name)
CREATE OR REPLACE FUNCTION _jm_f_4(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .name
  res := json_model_2(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- object .provides
CREATE OR REPLACE FUNCTION _jm_obj_10(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    -- handle other props
    -- .provides.''
    res := json_model_6(pval, NULL, rep);
    IF NOT res THEN
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_7_mup_provides (.provides)
CREATE OR REPLACE FUNCTION _jm_f_5(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .provides
  res := _jm_obj_10(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_7_mup_version (.version)
CREATE OR REPLACE FUNCTION _jm_f_6(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .version
  res := JSONB_TYPEOF(val) = 'string';
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION _jm_obj_7_mup(name TEXT)
RETURNS TEXT STRICT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  map JSONB := JSONB '{"abstract":"_jm_f_0","license":"_jm_f_1","maintainer":"_jm_f_2","meta-spec":"_jm_f_3","name":"_jm_f_4","provides":"_jm_f_5","version":"_jm_f_6"}';
BEGIN
  RETURN map->>name;
END;
$$ LANGUAGE plpgsql;

-- check _jm_obj_7_map_description (.description)
CREATE OR REPLACE FUNCTION _jm_f_7(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .description
  res := JSONB_TYPEOF(val) = 'string';
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_7_map_generated_by (.generated_by)
CREATE OR REPLACE FUNCTION _jm_f_8(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .generated_by
  res := JSONB_TYPEOF(val) = 'string';
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- object .no_index
CREATE OR REPLACE FUNCTION _jm_obj_11(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = 'file' THEN
      -- handle may file property
      -- .no_index.file
      res := json_model_3(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'directory' THEN
      -- handle may directory property
      -- .no_index.directory
      res := json_model_3(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_7_map_no_index (.no_index)
CREATE OR REPLACE FUNCTION _jm_f_9(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .no_index
  res := _jm_obj_11(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_7_map_prereqs (.prereqs)
CREATE OR REPLACE FUNCTION _jm_f_10(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .prereqs
  res := json_model_16(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_7_map_release_status (.release_status)
CREATE OR REPLACE FUNCTION _jm_f_11(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .release_status
  res := json_model_7(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_7_map_resources (.resources)
CREATE OR REPLACE FUNCTION _jm_f_12(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .resources
  res := json_model_8(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_7_map_tags (.tags)
CREATE OR REPLACE FUNCTION _jm_f_13(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .tags
  res := json_model_3(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_7_map_url (.url)
CREATE OR REPLACE FUNCTION _jm_f_14(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .url
  res := JSONB_TYPEOF(val) = 'string' AND jm_is_valid_url(JSON_VALUE(val, '$' RETURNING TEXT), path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION _jm_obj_7_map(name TEXT)
RETURNS TEXT STRICT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  map JSONB := JSONB '{"description":"_jm_f_7","generated_by":"_jm_f_8","no_index":"_jm_f_9","prereqs":"_jm_f_10","release_status":"_jm_f_11","resources":"_jm_f_12","tags":"_jm_f_13","url":"_jm_f_14"}';
BEGIN
  RETURN map->>name;
END;
$$ LANGUAGE plpgsql;

-- object .
CREATE OR REPLACE FUNCTION _jm_obj_7(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  pfun TEXT;
  must_count int;
  prop TEXT;
  pval JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  must_count := 0;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF _jm_obj_7_mup(prop) IS NOT NULL THEN
      -- handle 7 mandatory props
      pfun := _jm_obj_7_mup(prop);
      must_count := must_count + 1;
      IF NOT jm_call(pfun, pval, NULL, rep) THEN
        RETURN FALSE;
      END IF;
    ELSEIF _jm_obj_7_map(prop) IS NOT NULL THEN
      -- handle 8 may props
      pfun := _jm_obj_7_map(prop);
      IF NOT jm_call(pfun, pval, NULL, rep) THEN
        RETURN FALSE;
      END IF;
    ELSEIF _jm_re_1(prop, path, rep) THEN
      -- handle 1 re props
      -- .'/^[Xx]_/'
      res := TRUE;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  IF must_count <> 7 THEN
    RETURN FALSE;
  END IF;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check $ (.)
CREATE OR REPLACE FUNCTION json_model_1(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .
  res := _jm_obj_7(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION check_model_map(name TEXT)
RETURNS TEXT STRICT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  map JSONB := JSONB '{"":"json_model_1","neStr":"json_model_2","neStrList":"json_model_3","License":"json_model_4","LicenseList":"json_model_5","Provide":"json_model_6","Status":"json_model_7","Resources":"json_model_8","SemVer":"json_model_9","Version":"json_model_10","Ops":"json_model_11","VersionRange":"json_model_12","Phase":"json_model_13","Relation":"json_model_14","Prereq":"json_model_15","Prereqs":"json_model_16"}';
BEGIN
  RETURN map->>name;
END;
$$ LANGUAGE plpgsql;

--
-- constant maps initialization
--
TRUNCATE jm_constant_maps;


--
-- JSON Model checking entry point
--
-- TODO INOUT rep?
CREATE OR REPLACE FUNCTION check_model(val JSONB, name TEXT, rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  fun TEXT;
BEGIN
  fun := check_model_map(name);
  IF fun IS NULL THEN
    RAISE EXCEPTION 'model for % not found', name;
  END IF;
  RETURN jm_call(fun, val, NULL, rep);
END;
$$ LANGUAGE plpgsql;
