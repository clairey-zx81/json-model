--
-- Generated by JSON Model Compiler version 2
-- see https://github.com/clairey-zx81/json-model
--
-- JSON_MODEL_VERSION is 2
CREATE EXTENSION IF NOT EXISTS json_model;

-- regex=. opts=n
CREATE OR REPLACE FUNCTION _jm_re_0(val TEXT, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  RETURN regexp_like(val, '.', 'n');
END;
$$ LANGUAGE plpgsql;

-- check $neStr (.'$neStr')
CREATE OR REPLACE FUNCTION json_model_2(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .'$neStr'
  -- "/./"
  RETURN JSONB_TYPEOF(val) = 'string' AND _jm_re_0(JSON_VALUE(val, '$' RETURNING TEXT), NULL, NULL);
END;
$$ LANGUAGE PLpgSQL;

-- check $neStrList (.'$neStrList')
CREATE OR REPLACE FUNCTION json_model_3(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  arr_0_idx INT8;
  arr_0_item JSONB;
  ival_0 int;
BEGIN
  -- .'$neStrList'
  -- .'$neStrList'.'@'
  res := JSONB_TYPEOF(val) = 'array';
  IF res THEN
    FOR arr_0_idx IN 0 .. JSONB_ARRAY_LENGTH(val) - 1 LOOP
      arr_0_item := val -> arr_0_idx;
      -- .'$neStrList'.'@'.0
      res := json_model_2(arr_0_item, NULL, NULL);
      IF NOT res THEN
        EXIT;
      END IF;
    END LOOP;
  END IF;
  IF res THEN
    ival_0 := JSONB_ARRAY_LENGTH(val);
    res := jm_array_is_unique(val, NULL, NULL) AND ival_0 >= 1;
  END IF;
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION _jm_cst_0(value JSONB)
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  constants JSONB = JSONB '["agpl_3","apache_1_1","apache_2_0","artistic_1","artistic_2","bsd","freebsd","gfdl_1_2","gfdl_1_3","gpl_1","gpl_2","gpl_3","lgpl_2_1","lgpl_3_0","mit","mozilla_1_0","mozilla_1_1","openssl","perl_5","postgresql","qpl_1_0","ssleay","sun","zlib","open_source","restricted","unrestricted","unknown"]';
BEGIN
  RETURN constants @> value;
END;
$$ LANGUAGE plpgsql;

-- check $License (.'$License')
CREATE OR REPLACE FUNCTION json_model_4(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .'$License'
  RETURN JSONB_TYPEOF(val) IN ('null', 'boolean', 'number', 'string') AND _jm_cst_0(val);
END;
$$ LANGUAGE PLpgSQL;

-- check $LicenseList (.'$LicenseList')
CREATE OR REPLACE FUNCTION json_model_5(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  arr_1_idx INT8;
  arr_1_item JSONB;
  ival_1 int;
BEGIN
  -- .'$LicenseList'
  -- .'$LicenseList'.'@'
  res := JSONB_TYPEOF(val) = 'array';
  IF res THEN
    FOR arr_1_idx IN 0 .. JSONB_ARRAY_LENGTH(val) - 1 LOOP
      arr_1_item := val -> arr_1_idx;
      -- .'$LicenseList'.'@'.0
      res := json_model_4(arr_1_item, NULL, NULL);
      IF NOT res THEN
        EXIT;
      END IF;
    END LOOP;
  END IF;
  IF res THEN
    ival_1 := JSONB_ARRAY_LENGTH(val);
    res := jm_array_is_unique(val, NULL, NULL) AND ival_1 >= 1;
  END IF;
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- regex=^[Xx]_ opts=n
CREATE OR REPLACE FUNCTION _jm_re_1(val TEXT, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  RETURN regexp_like(val, '^[Xx]_', 'n');
END;
$$ LANGUAGE plpgsql;

-- check $Provide (.'$Provide')
CREATE OR REPLACE FUNCTION json_model_6(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  must_count int;
  prop TEXT;
  pval JSONB;
BEGIN
  -- .'$Provide'
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  must_count := 0;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = 'file' THEN
      -- handle must file property
      must_count := must_count + 1;
      -- .'$Provide'.file
      res := JSONB_TYPEOF(pval) = 'string';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'version' THEN
      -- handle must version property
      must_count := must_count + 1;
      -- .'$Provide'.version
      res := json_model_10(pval, NULL, NULL);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'docfile' THEN
      -- handle may docfile property
      -- .'$Provide'.docfile
      res := JSONB_TYPEOF(pval) = 'string';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'abstract' THEN
      -- handle may abstract property
      -- .'$Provide'.abstract
      res := JSONB_TYPEOF(pval) = 'string';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF _jm_re_1(prop, NULL, NULL) THEN
      -- handle 1 re props
      -- .'$Provide'.'/^[Xx]_/'
      res := TRUE;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN must_count = 2;
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION _jm_cst_1(value JSONB)
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  constants JSONB = JSONB '["stable","testing","unstable"]';
BEGIN
  RETURN constants @> value;
END;
$$ LANGUAGE plpgsql;

-- check $Status (.'$Status')
CREATE OR REPLACE FUNCTION json_model_7(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .'$Status'
  RETURN JSONB_TYPEOF(val) IN ('null', 'boolean', 'number', 'string') AND _jm_cst_1(val);
END;
$$ LANGUAGE PLpgSQL;

-- object .'$Resources'.bugtracker
CREATE OR REPLACE FUNCTION _jm_obj_0(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = 'web' THEN
      -- handle may web property
      -- .'$Resources'.bugtracker.web
      res := JSONB_TYPEOF(pval) = 'string' AND jm_is_valid_url(JSON_VALUE(pval, '$' RETURNING TEXT), NULL, NULL);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'mailto' THEN
      -- handle may mailto property
      -- .'$Resources'.bugtracker.mailto
      res := JSONB_TYPEOF(pval) = 'string' AND jm_is_valid_email(JSON_VALUE(pval, '$' RETURNING TEXT), NULL, NULL);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF _jm_re_1(prop, NULL, NULL) THEN
      -- handle 1 re props
      -- .'$Resources'.bugtracker.'/^[Xx]_/'
      res := TRUE;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- object .'$Resources'.repository
CREATE OR REPLACE FUNCTION _jm_obj_1(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = 'url' THEN
      -- handle may url property
      -- .'$Resources'.repository.url
      res := JSONB_TYPEOF(pval) = 'string' AND jm_is_valid_url(JSON_VALUE(pval, '$' RETURNING TEXT), NULL, NULL);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'web' THEN
      -- handle may web property
      -- .'$Resources'.repository.web
      res := JSONB_TYPEOF(pval) = 'string' AND jm_is_valid_url(JSON_VALUE(pval, '$' RETURNING TEXT), NULL, NULL);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'type' THEN
      -- handle may type property
      -- .'$Resources'.repository.type
      -- "/./"
      res := JSONB_TYPEOF(pval) = 'string' AND _jm_re_0(JSON_VALUE(pval, '$' RETURNING TEXT), NULL, NULL);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check $Resources (.'$Resources')
CREATE OR REPLACE FUNCTION json_model_8(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
BEGIN
  -- .'$Resources'
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = 'homepage' THEN
      -- handle may homepage property
      -- .'$Resources'.homepage
      res := JSONB_TYPEOF(pval) = 'string' AND jm_is_valid_url(JSON_VALUE(pval, '$' RETURNING TEXT), NULL, NULL);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'bugtracker' THEN
      -- handle may bugtracker property
      -- .'$Resources'.bugtracker
      res := _jm_obj_0(pval, NULL, NULL);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'repository' THEN
      -- handle may repository property
      -- .'$Resources'.repository
      res := _jm_obj_1(pval, NULL, NULL);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- regex=^\d+\.\d+\.\d+[-_A-Za-z0-9]*$ opts=n
CREATE OR REPLACE FUNCTION _jm_re_2(val TEXT, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  RETURN regexp_like(val, '^\d+\.\d+\.\d+[-_A-Za-z0-9]*$', 'n');
END;
$$ LANGUAGE plpgsql;

-- check $SemVer (.'$SemVer')
CREATE OR REPLACE FUNCTION json_model_9(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .'$SemVer'
  -- "/^\\d+\\.\\d+\\.\\d+[-_A-Za-z0-9]*$/"
  RETURN JSONB_TYPEOF(val) = 'string' AND _jm_re_2(JSON_VALUE(val, '$' RETURNING TEXT), NULL, NULL);
END;
$$ LANGUAGE PLpgSQL;

-- check $Version (.'$Version')
CREATE OR REPLACE FUNCTION json_model_10(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .'$Version'
  -- .'$Version'.'|'.0
  -- .'$Version'.'|'.1
  RETURN json_model_9(val, NULL, NULL) OR JSONB_TYPEOF(val) = 'number' AND (val)::INT8 = (val)::FLOAT8 AND (val)::INT8 = 0;
END;
$$ LANGUAGE PLpgSQL;

-- regex=^(<=|<|>=|>|!=|==)$ opts=n
CREATE OR REPLACE FUNCTION _jm_re_3(val TEXT, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  RETURN regexp_like(val, '^(<=|<|>=|>|!=|==)$', 'n');
END;
$$ LANGUAGE plpgsql;

-- check $Ops (.'$Ops')
CREATE OR REPLACE FUNCTION json_model_11(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .'$Ops'
  -- "/^(<=|<|>=|>|!=|==)$/"
  RETURN JSONB_TYPEOF(val) = 'string' AND _jm_re_3(JSON_VALUE(val, '$' RETURNING TEXT), NULL, NULL);
END;
$$ LANGUAGE PLpgSQL;

-- regex=^\s*(<=|<|>=|>|!=|==)\s*(\d+\.\d+\.\d+[-_A-Za-z0-9]*)\s*(,\s*(<=|<|>=|>|!=|==)\s*(\d+\.\d+\.\d+[-_A-Za-z0-9]*))*\s*$ opts=n
CREATE OR REPLACE FUNCTION _jm_re_4(val TEXT, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  RETURN regexp_like(val, '^\s*(<=|<|>=|>|!=|==)\s*(\d+\.\d+\.\d+[-_A-Za-z0-9]*)\s*(,\s*(<=|<|>=|>|!=|==)\s*(\d+\.\d+\.\d+[-_A-Za-z0-9]*))*\s*$', 'n');
END;
$$ LANGUAGE plpgsql;

-- check $VersionRange (.'$VersionRange')
CREATE OR REPLACE FUNCTION json_model_12(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .'$VersionRange'
  -- "/^\\s*(<=|<|>=|>|!=|==)\\s*(\\d+\\.\\d+\\.\\d+[-_A-Za-z0-9]*)\\s*(,\\s*(<=|<|>=|>|!=|==)\\s*(\\d+\\.\\d+\\.\\d+[-_A-Za-z0-9]*))*\\s*$/"
  RETURN JSONB_TYPEOF(val) = 'string' AND _jm_re_4(JSON_VALUE(val, '$' RETURNING TEXT), NULL, NULL);
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION _jm_cst_2(value JSONB)
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  constants JSONB = JSONB '["configure","build","test","runtime","develop"]';
BEGIN
  RETURN constants @> value;
END;
$$ LANGUAGE plpgsql;

-- check $Phase (.'$Phase')
CREATE OR REPLACE FUNCTION json_model_13(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .'$Phase'
  RETURN JSONB_TYPEOF(val) IN ('null', 'boolean', 'number', 'string') AND _jm_cst_2(val);
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION _jm_cst_3(value JSONB)
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  constants JSONB = JSONB '["requires","recommends","suggests","conflicts"]';
BEGIN
  RETURN constants @> value;
END;
$$ LANGUAGE plpgsql;

-- check $Relation (.'$Relation')
CREATE OR REPLACE FUNCTION json_model_14(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .'$Relation'
  RETURN JSONB_TYPEOF(val) IN ('null', 'boolean', 'number', 'string') AND _jm_cst_3(val);
END;
$$ LANGUAGE PLpgSQL;

-- check $Prereq (.'$Prereq')
CREATE OR REPLACE FUNCTION json_model_15(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
BEGIN
  -- .'$Prereq'
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    -- handle other props
    -- .'$Prereq'.''
    -- .'$Prereq'.''.'|'.0
    -- .'$Prereq'.''.'|'.1
    res := json_model_10(pval, NULL, NULL) OR json_model_12(pval, NULL, NULL);
    IF NOT res THEN
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- object .'$Prereqs'.'$Phase'
CREATE OR REPLACE FUNCTION _jm_obj_2(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF json_model_14(TO_JSONB(prop), NULL, NULL) THEN
      -- handle 1 key props
      -- .'$Prereqs'.'$Phase'.'$Relation'
      res := json_model_15(pval, NULL, NULL);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF _jm_re_1(prop, NULL, NULL) THEN
      -- handle 1 re props
      -- .'$Prereqs'.'$Phase'.'/^[Xx]_/'
      res := TRUE;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check $Prereqs (.'$Prereqs')
CREATE OR REPLACE FUNCTION json_model_16(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
BEGIN
  -- .'$Prereqs'
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF json_model_13(TO_JSONB(prop), NULL, NULL) THEN
      -- handle 1 key props
      -- .'$Prereqs'.'$Phase'
      res := _jm_obj_2(pval, NULL, NULL);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF _jm_re_1(prop, NULL, NULL) THEN
      -- handle 1 re props
      -- .'$Prereqs'.'/^[Xx]_/'
      res := TRUE;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- object .license.'|'.2
CREATE OR REPLACE FUNCTION _jm_obj_3(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    -- handle other props
    -- .license.'|'.2.''
    res := JSONB_TYPEOF(pval) = 'string' AND jm_is_valid_url(JSON_VALUE(pval, '$' RETURNING TEXT), NULL, NULL);
    IF NOT res THEN
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- object .provides
CREATE OR REPLACE FUNCTION _jm_obj_4(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    -- handle other props
    -- .provides.''
    res := json_model_6(pval, NULL, NULL);
    IF NOT res THEN
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- object .'meta-spec'
CREATE OR REPLACE FUNCTION _jm_obj_5(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  must_count int;
  prop TEXT;
  pval JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  must_count := 0;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = 'version' THEN
      -- handle must version property
      must_count := must_count + 1;
      -- .'meta-spec'.version
      res := JSONB_TYPEOF(pval) = 'string' AND JSON_VALUE(pval, '$' RETURNING TEXT) = '1.0.0';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'url' THEN
      -- handle may url property
      -- .'meta-spec'.url
      res := JSONB_TYPEOF(pval) = 'string' AND jm_is_valid_url(JSON_VALUE(pval, '$' RETURNING TEXT), NULL, NULL);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF _jm_re_1(prop, NULL, NULL) THEN
      -- handle 1 re props
      -- .'meta-spec'.'/^[Xx]_/'
      res := TRUE;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN must_count = 1;
END;
$$ LANGUAGE PLpgSQL;

-- object .no_index
CREATE OR REPLACE FUNCTION _jm_obj_6(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = 'file' THEN
      -- handle may file property
      -- .no_index.file
      res := json_model_3(pval, NULL, NULL);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'directory' THEN
      -- handle may directory property
      -- .no_index.directory
      res := json_model_3(pval, NULL, NULL);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check $ (.)
CREATE OR REPLACE FUNCTION json_model_1(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  must_count int;
  prop TEXT;
  pval JSONB;
BEGIN
  -- .
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  must_count := 0;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = 'name' THEN
      -- handle must name property
      must_count := must_count + 1;
      -- .name
      res := json_model_2(pval, NULL, NULL);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'license' THEN
      -- handle must license property
      must_count := must_count + 1;
      -- .license
      -- .license.'|'.0
      -- .license.'|'.1
      -- .license.'|'.2
      res := json_model_4(pval, NULL, NULL) OR json_model_5(pval, NULL, NULL) OR _jm_obj_3(pval, NULL, NULL);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'version' THEN
      -- handle must version property
      must_count := must_count + 1;
      -- .version
      res := JSONB_TYPEOF(pval) = 'string';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'abstract' THEN
      -- handle must abstract property
      must_count := must_count + 1;
      -- .abstract
      res := JSONB_TYPEOF(pval) = 'string';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'provides' THEN
      -- handle must provides property
      must_count := must_count + 1;
      -- .provides
      res := _jm_obj_4(pval, NULL, NULL);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'meta-spec' THEN
      -- handle must meta-spec property
      must_count := must_count + 1;
      -- .'meta-spec'
      res := _jm_obj_5(pval, NULL, NULL);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'maintainer' THEN
      -- handle must maintainer property
      must_count := must_count + 1;
      -- .maintainer
      -- .maintainer.'|'.0
      -- .maintainer.'|'.1
      res := json_model_2(pval, NULL, NULL) OR json_model_3(pval, NULL, NULL);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'url' THEN
      -- handle may url property
      -- .url
      res := JSONB_TYPEOF(pval) = 'string' AND jm_is_valid_url(JSON_VALUE(pval, '$' RETURNING TEXT), NULL, NULL);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'tags' THEN
      -- handle may tags property
      -- .tags
      res := json_model_3(pval, NULL, NULL);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'prereqs' THEN
      -- handle may prereqs property
      -- .prereqs
      res := json_model_16(pval, NULL, NULL);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'no_index' THEN
      -- handle may no_index property
      -- .no_index
      res := _jm_obj_6(pval, NULL, NULL);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'resources' THEN
      -- handle may resources property
      -- .resources
      res := json_model_8(pval, NULL, NULL);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'description' THEN
      -- handle may description property
      -- .description
      res := JSONB_TYPEOF(pval) = 'string';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'generated_by' THEN
      -- handle may generated_by property
      -- .generated_by
      res := JSONB_TYPEOF(pval) = 'string';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'release_status' THEN
      -- handle may release_status property
      -- .release_status
      res := json_model_7(pval, NULL, NULL);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF _jm_re_1(prop, NULL, NULL) THEN
      -- handle 1 re props
      -- .'/^[Xx]_/'
      res := TRUE;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN must_count = 7;
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION check_model_map(name TEXT)
RETURNS TEXT STRICT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  map JSONB := JSONB '{"":"json_model_1","neStr":"json_model_2","neStrList":"json_model_3","License":"json_model_4","LicenseList":"json_model_5","Provide":"json_model_6","Status":"json_model_7","Resources":"json_model_8","SemVer":"json_model_9","Version":"json_model_10","Ops":"json_model_11","VersionRange":"json_model_12","Phase":"json_model_13","Relation":"json_model_14","Prereq":"json_model_15","Prereqs":"json_model_16"}';
BEGIN
  RETURN map->>name;
END;
$$ LANGUAGE plpgsql;

--
-- constant maps initialization
--
TRUNCATE jm_constant_maps;

--
-- JSON Model checking entry point
--
-- TODO INOUT rep?
CREATE OR REPLACE FUNCTION check_model(val JSONB, name TEXT, rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  fun TEXT;
BEGIN
  fun := check_model_map(name);
  IF fun IS NULL THEN
    RAISE EXCEPTION 'model for % not found', name;
  END IF;
  RETURN jm_call(fun, val, NULL, rep);
END;
$$ LANGUAGE plpgsql;
