//
// Generated by JSON Model Compiler version 2.0b1
// see https://github.com/clairey-zx81/json-model
//

// regular expression engine
#include <stddef.h>
#include <cre2.h>

#include <json-model.h>
#define JSON_MODEL_VERSION "2.0b1"

static cre2_regexp_t *_jm_re_0_re2 = NULL;
static int _jm_re_0_nn = 0;
static bool _jm_re_0(const char *s, jm_path_t *path, jm_report_t *rep);
static bool json_model_2(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool json_model_3(const json_t *val, jm_path_t *path, jm_report_t *rep);
static jm_constant_t _jm_cst_0[28];
static bool json_model_4(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool json_model_5(const json_t *val, jm_path_t *path, jm_report_t *rep);
static cre2_regexp_t *_jm_re_1_re2 = NULL;
static int _jm_re_1_nn = 0;
static bool _jm_re_1(const char *s, jm_path_t *path, jm_report_t *rep);
static bool json_model_6(const json_t *val, jm_path_t *path, jm_report_t *rep);
static jm_constant_t _jm_cst_1[3];
static bool json_model_7(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool json_model_8(const json_t *val, jm_path_t *path, jm_report_t *rep);
static cre2_regexp_t *_jm_re_2_re2 = NULL;
static int _jm_re_2_nn = 0;
static bool _jm_re_2(const char *s, jm_path_t *path, jm_report_t *rep);
static bool json_model_9(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool json_model_10(const json_t *val, jm_path_t *path, jm_report_t *rep);
static cre2_regexp_t *_jm_re_3_re2 = NULL;
static int _jm_re_3_nn = 0;
static bool _jm_re_3(const char *s, jm_path_t *path, jm_report_t *rep);
static bool json_model_11(const json_t *val, jm_path_t *path, jm_report_t *rep);
static cre2_regexp_t *_jm_re_4_re2 = NULL;
static int _jm_re_4_nn = 0;
static bool _jm_re_4(const char *s, jm_path_t *path, jm_report_t *rep);
static bool json_model_12(const json_t *val, jm_path_t *path, jm_report_t *rep);
static jm_constant_t _jm_cst_2[5];
static bool json_model_13(const json_t *val, jm_path_t *path, jm_report_t *rep);
static jm_constant_t _jm_cst_3[4];
static bool json_model_14(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool json_model_15(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool json_model_16(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_0(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_1(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_2(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_3(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_4(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_5(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_6(const json_t *val, jm_path_t *path, jm_report_t *rep);
static jm_propmap_t _jm_obj_7_mup_tab[7];
static bool _jm_f_7(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_8(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_9(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_10(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_11(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_12(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_13(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_14(const json_t *val, jm_path_t *path, jm_report_t *rep);
static jm_propmap_t _jm_obj_7_map_tab[8];
static bool json_model_1(const json_t *val, jm_path_t *path, jm_report_t *rep);
jm_propmap_t check_model_map_tab[16];
const size_t check_model_map_size = 16;

static bool _jm_re_0(const char *s, jm_path_t *path, jm_report_t *rep)
{
    size_t slen = strlen(s);
    return cre2_match(_jm_re_0_re2, s, slen, 0, slen, CRE2_UNANCHORED, NULL, 0);
}

// check $neStr (.'$neStr')
static bool json_model_2(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .'$neStr'
    // "/./"
    res = json_is_string(val) && _jm_re_0(json_string_value(val), path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected /./ [.'$neStr']", path);
    }
    return res;
}

// check $neStrList (.'$neStrList')
static bool json_model_3(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .'$neStrList'
    // .'$neStrList'.'@'
    res = json_is_array(val);
    if (res)
    {
        size_t arr_0_idx;
        json_t *arr_0_item;
        json_array_foreach(val, arr_0_idx, arr_0_item)
        {
            jm_path_t arr_0_lpath = (jm_path_t) { NULL, arr_0_idx, path, NULL };
            // .'$neStrList'.'@'.0
            res = json_model_2(arr_0_item, (path ? &arr_0_lpath : NULL), rep);
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "unexpected $neStr [.'$neStrList'.'@'.0]", (path ? &arr_0_lpath : NULL));
            }
            if (! res)
            {
                break;
            }
        }
    }
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "not array or unexpected array [.'$neStrList'.'@']", path);
    }
    if (res)
    {
        int64_t ival_0 = json_array_size(val);
        res = jm_array_is_unique(val, path, rep) && ival_0 >= 1;
        if (! res)
        {
            if (rep) jm_report_add_entry(rep, "constraints failed [.'$neStrList']", path);
        }
    }
    return res;
}


// check $License (.'$License')
static bool json_model_4(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .'$License'
    res = jm_json_is_scalar(val) && json_is_string(val) && jm_search_cst(&(jm_constant_t) { cst_is_string, { .s = json_string_value(val) } }, _jm_cst_0, 28);;
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "value not in enum [.'$License'.'|']", path);
    }
    return res;
}

// check $LicenseList (.'$LicenseList')
static bool json_model_5(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .'$LicenseList'
    // .'$LicenseList'.'@'
    res = json_is_array(val);
    if (res)
    {
        size_t arr_1_idx;
        json_t *arr_1_item;
        json_array_foreach(val, arr_1_idx, arr_1_item)
        {
            jm_path_t arr_1_lpath = (jm_path_t) { NULL, arr_1_idx, path, NULL };
            // .'$LicenseList'.'@'.0
            res = json_model_4(arr_1_item, (path ? &arr_1_lpath : NULL), rep);
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "unexpected $License [.'$LicenseList'.'@'.0]", (path ? &arr_1_lpath : NULL));
            }
            if (! res)
            {
                break;
            }
        }
    }
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "not array or unexpected array [.'$LicenseList'.'@']", path);
    }
    if (res)
    {
        int64_t ival_1 = json_array_size(val);
        res = jm_array_is_unique(val, path, rep) && ival_1 >= 1;
        if (! res)
        {
            if (rep) jm_report_add_entry(rep, "constraints failed [.'$LicenseList']", path);
        }
    }
    return res;
}

static bool _jm_re_1(const char *s, jm_path_t *path, jm_report_t *rep)
{
    size_t slen = strlen(s);
    return cre2_match(_jm_re_1_re2, s, slen, 0, slen, CRE2_UNANCHORED, NULL, 0);
}

// object .'$Provide'
static bool _jm_obj_0(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    if (! json_is_object(val))
    {
        if (rep) jm_report_add_entry(rep, "not an object [.'$Provide']", path);
        return false;
    }
    bool res;
    int64_t must_count = 0;
    const char *prop;
    json_t *pval;
    json_object_foreach((json_t *) val, prop, pval)
    {
        jm_path_t lpath_0 = (jm_path_t) { prop, 0, path, NULL };
        if (strcmp(prop, "file") == 0)
        {
            // handle must file property
            must_count += 1;
            // .'$Provide'.file
            res = json_is_string(pval);
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "unexpected string [.'$Provide'.file]", (path ? &lpath_0 : NULL));
            }
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "invalid mandatory prop value [.'$Provide'.file]", (path ? &lpath_0 : NULL));
                return false;
            }
        }
        else if (strcmp(prop, "version") == 0)
        {
            // handle must version property
            must_count += 1;
            // .'$Provide'.version
            res = json_model_10(pval, (path ? &lpath_0 : NULL), rep);
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "unexpected $Version [.'$Provide'.version]", (path ? &lpath_0 : NULL));
            }
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "invalid mandatory prop value [.'$Provide'.version]", (path ? &lpath_0 : NULL));
                return false;
            }
        }
        else if (strcmp(prop, "abstract") == 0)
        {
            // handle may abstract property
            // .'$Provide'.abstract
            res = json_is_string(pval);
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "unexpected string [.'$Provide'.abstract]", (path ? &lpath_0 : NULL));
            }
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "invalid optional prop value [.'$Provide'.abstract]", (path ? &lpath_0 : NULL));
                return false;
            }
        }
        else if (strcmp(prop, "docfile") == 0)
        {
            // handle may docfile property
            // .'$Provide'.docfile
            res = json_is_string(pval);
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "unexpected string [.'$Provide'.docfile]", (path ? &lpath_0 : NULL));
            }
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "invalid optional prop value [.'$Provide'.docfile]", (path ? &lpath_0 : NULL));
                return false;
            }
        }
        else if (_jm_re_1(prop, path, rep))
        {
            // handle 1 re props
            // .'$Provide'.'/^[Xx]_/'
            res = true;
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "unexpected $ANY [.'$Provide'.'/^[Xx]_/']", (path ? &lpath_0 : NULL));
            }
            if (! res)
            {
                return false;
            }
        }
        else
        {
            if (rep) jm_report_add_entry(rep, "unexpected prop [.'$Provide']", (path ? &lpath_0 : NULL));
            return false;
        }
    }
    if (must_count != 2)
    {
        if (rep != NULL)
        {
            if (! (json_object_get(val, "file") != NULL))
            {
                if (rep) jm_report_add_entry(rep, "missing mandatory prop <file> [.'$Provide']", path);
            }
            if (! (json_object_get(val, "version") != NULL))
            {
                if (rep) jm_report_add_entry(rep, "missing mandatory prop <version> [.'$Provide']", path);
            }
        }
        return false;
    }
    return true;
}

// check $Provide (.'$Provide')
static bool json_model_6(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .'$Provide'
    res = _jm_obj_0(val, path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected element [.'$Provide']", path);
    }
    return res;
}


// check $Status (.'$Status')
static bool json_model_7(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .'$Status'
    res = jm_json_is_scalar(val) && json_is_string(val) && jm_search_cst(&(jm_constant_t) { cst_is_string, { .s = json_string_value(val) } }, _jm_cst_1, 3);;
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "value not in enum [.'$Status'.'|']", path);
    }
    return res;
}

// object .'$Resources'.bugtracker
static bool _jm_obj_2(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    if (! json_is_object(val))
    {
        if (rep) jm_report_add_entry(rep, "not an object [.'$Resources'.bugtracker]", path);
        return false;
    }
    bool res;
    const char *prop;
    json_t *pval;
    json_object_foreach((json_t *) val, prop, pval)
    {
        jm_path_t lpath_2 = (jm_path_t) { prop, 0, path, NULL };
        if (strcmp(prop, "web") == 0)
        {
            // handle may web property
            // .'$Resources'.bugtracker.web
            res = jm_is_valid_url(json_string_value(pval), (path ? &lpath_2 : NULL), rep);
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "unexpected $URL [.'$Resources'.bugtracker.web]", (path ? &lpath_2 : NULL));
            }
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "invalid optional prop value [.'$Resources'.bugtracker.web]", (path ? &lpath_2 : NULL));
                return false;
            }
        }
        else if (strcmp(prop, "mailto") == 0)
        {
            // handle may mailto property
            // .'$Resources'.bugtracker.mailto
            res = jm_is_valid_email(json_string_value(pval), (path ? &lpath_2 : NULL), rep);
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "unexpected $EMAIL [.'$Resources'.bugtracker.mailto]", (path ? &lpath_2 : NULL));
            }
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "invalid optional prop value [.'$Resources'.bugtracker.mailto]", (path ? &lpath_2 : NULL));
                return false;
            }
        }
        else if (_jm_re_1(prop, path, rep))
        {
            // handle 1 re props
            // .'$Resources'.bugtracker.'/^[Xx]_/'
            res = true;
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "unexpected $ANY [.'$Resources'.bugtracker.'/^[Xx]_/']", (path ? &lpath_2 : NULL));
            }
            if (! res)
            {
                return false;
            }
        }
        else
        {
            if (rep) jm_report_add_entry(rep, "unexpected prop [.'$Resources'.bugtracker]", (path ? &lpath_2 : NULL));
            return false;
        }
    }
    return true;
}

// object .'$Resources'.repository
static bool _jm_obj_3(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    if (! json_is_object(val))
    {
        if (rep) jm_report_add_entry(rep, "not an object [.'$Resources'.repository]", path);
        return false;
    }
    bool res;
    const char *prop;
    json_t *pval;
    json_object_foreach((json_t *) val, prop, pval)
    {
        jm_path_t lpath_3 = (jm_path_t) { prop, 0, path, NULL };
        if (strcmp(prop, "url") == 0)
        {
            // handle may url property
            // .'$Resources'.repository.url
            res = jm_is_valid_url(json_string_value(pval), (path ? &lpath_3 : NULL), rep);
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "unexpected $URL [.'$Resources'.repository.url]", (path ? &lpath_3 : NULL));
            }
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "invalid optional prop value [.'$Resources'.repository.url]", (path ? &lpath_3 : NULL));
                return false;
            }
        }
        else if (strcmp(prop, "web") == 0)
        {
            // handle may web property
            // .'$Resources'.repository.web
            res = jm_is_valid_url(json_string_value(pval), (path ? &lpath_3 : NULL), rep);
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "unexpected $URL [.'$Resources'.repository.web]", (path ? &lpath_3 : NULL));
            }
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "invalid optional prop value [.'$Resources'.repository.web]", (path ? &lpath_3 : NULL));
                return false;
            }
        }
        else if (strcmp(prop, "type") == 0)
        {
            // handle may type property
            // .'$Resources'.repository.type
            // "/./"
            res = json_is_string(pval) && _jm_re_0(json_string_value(pval), (path ? &lpath_3 : NULL), rep);
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "unexpected /./ [.'$Resources'.repository.type]", (path ? &lpath_3 : NULL));
            }
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "invalid optional prop value [.'$Resources'.repository.type]", (path ? &lpath_3 : NULL));
                return false;
            }
        }
        else
        {
            if (rep) jm_report_add_entry(rep, "unexpected prop [.'$Resources'.repository]", (path ? &lpath_3 : NULL));
            return false;
        }
    }
    return true;
}

// object .'$Resources'
static bool _jm_obj_1(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    if (! json_is_object(val))
    {
        if (rep) jm_report_add_entry(rep, "not an object [.'$Resources']", path);
        return false;
    }
    bool res;
    const char *prop;
    json_t *pval;
    json_object_foreach((json_t *) val, prop, pval)
    {
        jm_path_t lpath_1 = (jm_path_t) { prop, 0, path, NULL };
        if (strcmp(prop, "homepage") == 0)
        {
            // handle may homepage property
            // .'$Resources'.homepage
            res = jm_is_valid_url(json_string_value(pval), (path ? &lpath_1 : NULL), rep);
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "unexpected $URL [.'$Resources'.homepage]", (path ? &lpath_1 : NULL));
            }
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "invalid optional prop value [.'$Resources'.homepage]", (path ? &lpath_1 : NULL));
                return false;
            }
        }
        else if (strcmp(prop, "bugtracker") == 0)
        {
            // handle may bugtracker property
            // .'$Resources'.bugtracker
            res = _jm_obj_2(pval, (path ? &lpath_1 : NULL), rep);
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "unexpected element [.'$Resources'.bugtracker]", (path ? &lpath_1 : NULL));
            }
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "invalid optional prop value [.'$Resources'.bugtracker]", (path ? &lpath_1 : NULL));
                return false;
            }
        }
        else if (strcmp(prop, "repository") == 0)
        {
            // handle may repository property
            // .'$Resources'.repository
            res = _jm_obj_3(pval, (path ? &lpath_1 : NULL), rep);
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "unexpected element [.'$Resources'.repository]", (path ? &lpath_1 : NULL));
            }
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "invalid optional prop value [.'$Resources'.repository]", (path ? &lpath_1 : NULL));
                return false;
            }
        }
        else
        {
            if (rep) jm_report_add_entry(rep, "unexpected prop [.'$Resources']", (path ? &lpath_1 : NULL));
            return false;
        }
    }
    return true;
}

// check $Resources (.'$Resources')
static bool json_model_8(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .'$Resources'
    res = _jm_obj_1(val, path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected element [.'$Resources']", path);
    }
    return res;
}

static bool _jm_re_2(const char *s, jm_path_t *path, jm_report_t *rep)
{
    size_t slen = strlen(s);
    return cre2_match(_jm_re_2_re2, s, slen, 0, slen, CRE2_UNANCHORED, NULL, 0);
}

// check $SemVer (.'$SemVer')
static bool json_model_9(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .'$SemVer'
    // "/^\\d+\\.\\d+\\.\\d+[-_A-Za-z0-9]*$/"
    res = json_is_string(val) && _jm_re_2(json_string_value(val), path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected /^\\d+\\.\\d+\\.\\d+[-_A-Za-z0-9]*$/ [.'$SemVer']", path);
    }
    return res;
}

// check $Version (.'$Version')
static bool json_model_10(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .'$Version'
    // .'$Version'.'|'.0
    res = json_model_9(val, path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected $SemVer [.'$Version'.'|'.0]", path);
    }
    if (! res)
    {
        // .'$Version'.'|'.1
        res = json_is_integer(val) && json_integer_value(val) == 0;
        if (! res)
        {
            if (rep) jm_report_add_entry(rep, "unexpected =0 [.'$Version'.'|'.1]", path);
        }
    }
    if (res)
    {
        if (rep) jm_report_free_entries(rep);
    }
    else
    {
        if (rep) jm_report_add_entry(rep, "no model matched [.'$Version'.'|']", path);
    }
    return res;
}

static bool _jm_re_3(const char *s, jm_path_t *path, jm_report_t *rep)
{
    size_t slen = strlen(s);
    return cre2_match(_jm_re_3_re2, s, slen, 0, slen, CRE2_UNANCHORED, NULL, 0);
}

// check $Ops (.'$Ops')
static bool json_model_11(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .'$Ops'
    // "/^(<=|<|>=|>|!=|==)$/"
    res = json_is_string(val) && _jm_re_3(json_string_value(val), path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected /^(<=|<|>=|>|!=|==)$/ [.'$Ops']", path);
    }
    return res;
}

static bool _jm_re_4(const char *s, jm_path_t *path, jm_report_t *rep)
{
    size_t slen = strlen(s);
    return cre2_match(_jm_re_4_re2, s, slen, 0, slen, CRE2_UNANCHORED, NULL, 0);
}

// check $VersionRange (.'$VersionRange')
static bool json_model_12(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .'$VersionRange'
    // "/^\\s*(<=|<|>=|>|!=|==)\\s*(\\d+\\.\\d+\\.\\d+[-_A-Za-z0-9]*)\\s*(,\\s*(<=|<|>=|>|!=|==)\\s*(\\d+\\.\\d+\\.\\d+[-_A-Za-z0-9]*))*\\s*$/"
    res = json_is_string(val) && _jm_re_4(json_string_value(val), path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected /^\\s*(<=|<|>=|>|!=|==)\\s*(\\d+\\.\\d+\\.\\d+[-_A-Za-z0-9]*)\\s*(,\\s*(<=|<|>=|>|!=|==)\\s*(\\d+\\.\\d+\\.\\d+[-_A-Za-z0-9]*))*\\s*$/ [.'$VersionRange']", path);
    }
    return res;
}


// check $Phase (.'$Phase')
static bool json_model_13(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .'$Phase'
    res = jm_json_is_scalar(val) && json_is_string(val) && jm_search_cst(&(jm_constant_t) { cst_is_string, { .s = json_string_value(val) } }, _jm_cst_2, 5);;
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "value not in enum [.'$Phase'.'|']", path);
    }
    return res;
}


// check $Relation (.'$Relation')
static bool json_model_14(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .'$Relation'
    res = jm_json_is_scalar(val) && json_is_string(val) && jm_search_cst(&(jm_constant_t) { cst_is_string, { .s = json_string_value(val) } }, _jm_cst_3, 4);;
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "value not in enum [.'$Relation'.'|']", path);
    }
    return res;
}

// object .'$Prereq'
static bool _jm_obj_4(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    if (! json_is_object(val))
    {
        if (rep) jm_report_add_entry(rep, "not an object [.'$Prereq']", path);
        return false;
    }
    bool res;
    const char *prop;
    json_t *pval;
    json_object_foreach((json_t *) val, prop, pval)
    {
        jm_path_t lpath_4 = (jm_path_t) { prop, 0, path, NULL };
        // handle other props
        // .'$Prereq'.''
        // .'$Prereq'.''.'|'.0
        res = json_model_10(pval, (path ? &lpath_4 : NULL), rep);
        if (! res)
        {
            if (rep) jm_report_add_entry(rep, "unexpected $Version [.'$Prereq'.''.'|'.0]", (path ? &lpath_4 : NULL));
        }
        if (! res)
        {
            // .'$Prereq'.''.'|'.1
            res = json_model_12(pval, (path ? &lpath_4 : NULL), rep);
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "unexpected $VersionRange [.'$Prereq'.''.'|'.1]", (path ? &lpath_4 : NULL));
            }
        }
        if (res)
        {
            if (rep) jm_report_free_entries(rep);
        }
        else
        {
            if (rep) jm_report_add_entry(rep, "no model matched [.'$Prereq'.''.'|']", (path ? &lpath_4 : NULL));
        }
        if (! res)
        {
            return false;
        }
    }
    return true;
}

// check $Prereq (.'$Prereq')
static bool json_model_15(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .'$Prereq'
    res = _jm_obj_4(val, path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected element [.'$Prereq']", path);
    }
    return res;
}

// object .'$Prereqs'.'$Phase'
static bool _jm_obj_6(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    if (! json_is_object(val))
    {
        if (rep) jm_report_add_entry(rep, "not an object [.'$Prereqs'.'$Phase']", path);
        return false;
    }
    bool res;
    const char *prop;
    json_t *pval;
    json_object_foreach((json_t *) val, prop, pval)
    {
        jm_path_t lpath_6 = (jm_path_t) { prop, 0, path, NULL };
        if (jm_check_fun_string(json_model_14, prop, (path ? &lpath_6 : NULL), rep))
        {
            // handle 1 key props
            // .'$Prereqs'.'$Phase'.'$Relation'
            res = json_model_15(pval, (path ? &lpath_6 : NULL), rep);
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "unexpected $Prereq [.'$Prereqs'.'$Phase'.'$Relation']", (path ? &lpath_6 : NULL));
            }
            if (! res)
            {
                return false;
            }
        }
        else if (_jm_re_1(prop, path, rep))
        {
            // handle 1 re props
            // .'$Prereqs'.'$Phase'.'/^[Xx]_/'
            res = true;
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "unexpected $ANY [.'$Prereqs'.'$Phase'.'/^[Xx]_/']", (path ? &lpath_6 : NULL));
            }
            if (! res)
            {
                return false;
            }
        }
        else
        {
            if (rep) jm_report_add_entry(rep, "unexpected prop [.'$Prereqs'.'$Phase']", (path ? &lpath_6 : NULL));
            return false;
        }
    }
    return true;
}

// object .'$Prereqs'
static bool _jm_obj_5(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    if (! json_is_object(val))
    {
        if (rep) jm_report_add_entry(rep, "not an object [.'$Prereqs']", path);
        return false;
    }
    bool res;
    const char *prop;
    json_t *pval;
    json_object_foreach((json_t *) val, prop, pval)
    {
        jm_path_t lpath_5 = (jm_path_t) { prop, 0, path, NULL };
        if (jm_check_fun_string(json_model_13, prop, (path ? &lpath_5 : NULL), rep))
        {
            // handle 1 key props
            // .'$Prereqs'.'$Phase'
            res = _jm_obj_6(pval, (path ? &lpath_5 : NULL), rep);
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "unexpected element [.'$Prereqs'.'$Phase']", (path ? &lpath_5 : NULL));
            }
            if (! res)
            {
                return false;
            }
        }
        else if (_jm_re_1(prop, path, rep))
        {
            // handle 1 re props
            // .'$Prereqs'.'/^[Xx]_/'
            res = true;
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "unexpected $ANY [.'$Prereqs'.'/^[Xx]_/']", (path ? &lpath_5 : NULL));
            }
            if (! res)
            {
                return false;
            }
        }
        else
        {
            if (rep) jm_report_add_entry(rep, "unexpected prop [.'$Prereqs']", (path ? &lpath_5 : NULL));
            return false;
        }
    }
    return true;
}

// check $Prereqs (.'$Prereqs')
static bool json_model_16(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .'$Prereqs'
    res = _jm_obj_5(val, path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected element [.'$Prereqs']", path);
    }
    return res;
}

// check _jm_obj_7_mup_abstract (.abstract)
static bool _jm_f_0(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .abstract
    res = json_is_string(val);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected string [.abstract]", path);
    }
    return res;
}

// object .license.'^'.2
static bool _jm_obj_8(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    if (! json_is_object(val))
    {
        if (rep) jm_report_add_entry(rep, "not an object [.license.'^'.2]", path);
        return false;
    }
    bool res;
    const char *prop;
    json_t *pval;
    json_object_foreach((json_t *) val, prop, pval)
    {
        jm_path_t lpath_8 = (jm_path_t) { prop, 0, path, NULL };
        // handle other props
        // .license.'^'.2.''
        res = jm_is_valid_url(json_string_value(pval), (path ? &lpath_8 : NULL), rep);
        if (! res)
        {
            if (rep) jm_report_add_entry(rep, "unexpected $URL [.license.'^'.2.'']", (path ? &lpath_8 : NULL));
        }
        if (! res)
        {
            return false;
        }
    }
    return true;
}

// check _jm_obj_7_mup_license (.license)
static bool _jm_f_1(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .license
    // generic xor list
    int64_t xc_0 = 0;
    bool xr_0;
    // .license.'^'.0
    xr_0 = json_model_4(val, path, rep);
    if (! xr_0)
    {
        if (rep) jm_report_add_entry(rep, "unexpected $License [.license.'^'.0]", path);
    }
    if (xr_0)
    {
        xc_0 += 1;
    }
    // .license.'^'.1
    xr_0 = json_model_5(val, path, rep);
    if (! xr_0)
    {
        if (rep) jm_report_add_entry(rep, "unexpected $LicenseList [.license.'^'.1]", path);
    }
    if (xr_0)
    {
        xc_0 += 1;
    }
    if (xc_0 <= 1)
    {
        // .license.'^'.2
        xr_0 = _jm_obj_8(val, path, rep);
        if (! xr_0)
        {
            if (rep) jm_report_add_entry(rep, "unexpected element [.license.'^'.2]", path);
        }
        if (xr_0)
        {
            xc_0 += 1;
        }
    }
    res = xc_0 == 1;
    if (res)
    {
        if (rep) jm_report_free_entries(rep);
    }
    else
    {
        if (rep) jm_report_add_entry(rep, "not one model match [.license.'^']", path);
    }
    return res;
}

// check _jm_obj_7_mup_maintainer (.maintainer)
static bool _jm_f_2(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .maintainer
    // .maintainer.'|'.0
    res = json_model_2(val, path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected $neStr [.maintainer.'|'.0]", path);
    }
    if (! res)
    {
        // .maintainer.'|'.1
        res = json_model_3(val, path, rep);
        if (! res)
        {
            if (rep) jm_report_add_entry(rep, "unexpected $neStrList [.maintainer.'|'.1]", path);
        }
    }
    if (res)
    {
        if (rep) jm_report_free_entries(rep);
    }
    else
    {
        if (rep) jm_report_add_entry(rep, "no model matched [.maintainer.'|']", path);
    }
    return res;
}

// object .'meta-spec'
static bool _jm_obj_9(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    if (! json_is_object(val))
    {
        if (rep) jm_report_add_entry(rep, "not an object [.'meta-spec']", path);
        return false;
    }
    bool res;
    int64_t must_count = 0;
    const char *prop;
    json_t *pval;
    json_object_foreach((json_t *) val, prop, pval)
    {
        jm_path_t lpath_9 = (jm_path_t) { prop, 0, path, NULL };
        if (strcmp(prop, "version") == 0)
        {
            // handle must version property
            must_count += 1;
            // .'meta-spec'.version
            res = json_is_string(pval) && strcmp(json_string_value(pval), "1.0.0") == 0;
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "unexpected _1.0.0 [.'meta-spec'.version]", (path ? &lpath_9 : NULL));
            }
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "invalid mandatory prop value [.'meta-spec'.version]", (path ? &lpath_9 : NULL));
                return false;
            }
        }
        else if (strcmp(prop, "url") == 0)
        {
            // handle may url property
            // .'meta-spec'.url
            res = jm_is_valid_url(json_string_value(pval), (path ? &lpath_9 : NULL), rep);
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "unexpected $URL [.'meta-spec'.url]", (path ? &lpath_9 : NULL));
            }
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "invalid optional prop value [.'meta-spec'.url]", (path ? &lpath_9 : NULL));
                return false;
            }
        }
        else if (_jm_re_1(prop, path, rep))
        {
            // handle 1 re props
            // .'meta-spec'.'/^[Xx]_/'
            res = true;
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "unexpected $ANY [.'meta-spec'.'/^[Xx]_/']", (path ? &lpath_9 : NULL));
            }
            if (! res)
            {
                return false;
            }
        }
        else
        {
            if (rep) jm_report_add_entry(rep, "unexpected prop [.'meta-spec']", (path ? &lpath_9 : NULL));
            return false;
        }
    }
    if (must_count != 1)
    {
        if (rep != NULL)
        {
            if (! (json_object_get(val, "version") != NULL))
            {
                if (rep) jm_report_add_entry(rep, "missing mandatory prop <version> [.'meta-spec']", path);
            }
        }
        return false;
    }
    return true;
}

// check _jm_obj_7_mup_meta-spec (.'meta-spec')
static bool _jm_f_3(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .'meta-spec'
    res = _jm_obj_9(val, path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected element [.'meta-spec']", path);
    }
    return res;
}

// check _jm_obj_7_mup_name (.name)
static bool _jm_f_4(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .name
    res = json_model_2(val, path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected $neStr [.name]", path);
    }
    return res;
}

// object .provides
static bool _jm_obj_10(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    if (! json_is_object(val))
    {
        if (rep) jm_report_add_entry(rep, "not an object [.provides]", path);
        return false;
    }
    bool res;
    const char *prop;
    json_t *pval;
    json_object_foreach((json_t *) val, prop, pval)
    {
        jm_path_t lpath_10 = (jm_path_t) { prop, 0, path, NULL };
        // handle other props
        // .provides.''
        res = json_model_6(pval, (path ? &lpath_10 : NULL), rep);
        if (! res)
        {
            if (rep) jm_report_add_entry(rep, "unexpected $Provide [.provides.'']", (path ? &lpath_10 : NULL));
        }
        if (! res)
        {
            return false;
        }
    }
    return true;
}

// check _jm_obj_7_mup_provides (.provides)
static bool _jm_f_5(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .provides
    res = _jm_obj_10(val, path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected element [.provides]", path);
    }
    return res;
}

// check _jm_obj_7_mup_version (.version)
static bool _jm_f_6(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .version
    res = json_is_string(val);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected string [.version]", path);
    }
    return res;
}

static jm_check_fun_t _jm_obj_7_mup(const char *pname)
{
    return jm_search_propmap(pname, _jm_obj_7_mup_tab, 7);
}

// check _jm_obj_7_map_description (.description)
static bool _jm_f_7(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .description
    res = json_is_string(val);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected string [.description]", path);
    }
    return res;
}

// check _jm_obj_7_map_generated_by (.generated_by)
static bool _jm_f_8(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .generated_by
    res = json_is_string(val);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected string [.generated_by]", path);
    }
    return res;
}

// object .no_index
static bool _jm_obj_11(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    if (! json_is_object(val))
    {
        if (rep) jm_report_add_entry(rep, "not an object [.no_index]", path);
        return false;
    }
    bool res;
    const char *prop;
    json_t *pval;
    json_object_foreach((json_t *) val, prop, pval)
    {
        jm_path_t lpath_11 = (jm_path_t) { prop, 0, path, NULL };
        if (strcmp(prop, "file") == 0)
        {
            // handle may file property
            // .no_index.file
            res = json_model_3(pval, (path ? &lpath_11 : NULL), rep);
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "unexpected $neStrList [.no_index.file]", (path ? &lpath_11 : NULL));
            }
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "invalid optional prop value [.no_index.file]", (path ? &lpath_11 : NULL));
                return false;
            }
        }
        else if (strcmp(prop, "directory") == 0)
        {
            // handle may directory property
            // .no_index.directory
            res = json_model_3(pval, (path ? &lpath_11 : NULL), rep);
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "unexpected $neStrList [.no_index.directory]", (path ? &lpath_11 : NULL));
            }
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "invalid optional prop value [.no_index.directory]", (path ? &lpath_11 : NULL));
                return false;
            }
        }
        else
        {
            if (rep) jm_report_add_entry(rep, "unexpected prop [.no_index]", (path ? &lpath_11 : NULL));
            return false;
        }
    }
    return true;
}

// check _jm_obj_7_map_no_index (.no_index)
static bool _jm_f_9(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .no_index
    res = _jm_obj_11(val, path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected element [.no_index]", path);
    }
    return res;
}

// check _jm_obj_7_map_prereqs (.prereqs)
static bool _jm_f_10(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .prereqs
    res = json_model_16(val, path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected $Prereqs [.prereqs]", path);
    }
    return res;
}

// check _jm_obj_7_map_release_status (.release_status)
static bool _jm_f_11(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .release_status
    res = json_model_7(val, path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected $Status [.release_status]", path);
    }
    return res;
}

// check _jm_obj_7_map_resources (.resources)
static bool _jm_f_12(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .resources
    res = json_model_8(val, path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected $Resources [.resources]", path);
    }
    return res;
}

// check _jm_obj_7_map_tags (.tags)
static bool _jm_f_13(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .tags
    res = json_model_3(val, path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected $neStrList [.tags]", path);
    }
    return res;
}

// check _jm_obj_7_map_url (.url)
static bool _jm_f_14(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .url
    res = jm_is_valid_url(json_string_value(val), path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected $URL [.url]", path);
    }
    return res;
}

static jm_check_fun_t _jm_obj_7_map(const char *pname)
{
    return jm_search_propmap(pname, _jm_obj_7_map_tab, 8);
}

// object .
static bool _jm_obj_7(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    if (! json_is_object(val))
    {
        if (rep) jm_report_add_entry(rep, "not an object [.]", path);
        return false;
    }
    bool res;
    jm_check_fun_t pfun;
    int64_t must_count = 0;
    const char *prop;
    json_t *pval;
    json_object_foreach((json_t *) val, prop, pval)
    {
        jm_path_t lpath_7 = (jm_path_t) { prop, 0, path, NULL };
        if ((pfun = _jm_obj_7_mup(prop)))
        {
            // handle 7 mandatory props
            if (pfun != NULL)
            {
                must_count += 1;
                if (! pfun(pval, (path ? &lpath_7 : NULL), rep))
                {
                    if (rep) jm_report_add_entry(rep, "invalid mandatory prop value [.]", (path ? &lpath_7 : NULL));
                    return false;
                }
            }
        }
        else if ((pfun = _jm_obj_7_map(prop)))
        {
            // handle 8 may props
            if (pfun != NULL && ! pfun(pval, (path ? &lpath_7 : NULL), rep))
            {
                if (rep) jm_report_add_entry(rep, "invalid optional prop value [.]", (path ? &lpath_7 : NULL));
                return false;
            }
        }
        else if (_jm_re_1(prop, path, rep))
        {
            // handle 1 re props
            // .'/^[Xx]_/'
            res = true;
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "unexpected $ANY [.'/^[Xx]_/']", (path ? &lpath_7 : NULL));
            }
            if (! res)
            {
                return false;
            }
        }
        else
        {
            if (rep) jm_report_add_entry(rep, "unexpected prop [.]", (path ? &lpath_7 : NULL));
            return false;
        }
    }
    if (must_count != 7)
    {
        if (rep != NULL)
        {
            if (! (json_object_get(val, "abstract") != NULL))
            {
                if (rep) jm_report_add_entry(rep, "missing mandatory prop <abstract> [.]", path);
            }
            if (! (json_object_get(val, "license") != NULL))
            {
                if (rep) jm_report_add_entry(rep, "missing mandatory prop <license> [.]", path);
            }
            if (! (json_object_get(val, "maintainer") != NULL))
            {
                if (rep) jm_report_add_entry(rep, "missing mandatory prop <maintainer> [.]", path);
            }
            if (! (json_object_get(val, "meta-spec") != NULL))
            {
                if (rep) jm_report_add_entry(rep, "missing mandatory prop <meta-spec> [.]", path);
            }
            if (! (json_object_get(val, "name") != NULL))
            {
                if (rep) jm_report_add_entry(rep, "missing mandatory prop <name> [.]", path);
            }
            if (! (json_object_get(val, "provides") != NULL))
            {
                if (rep) jm_report_add_entry(rep, "missing mandatory prop <provides> [.]", path);
            }
            if (! (json_object_get(val, "version") != NULL))
            {
                if (rep) jm_report_add_entry(rep, "missing mandatory prop <version> [.]", path);
            }
        }
        return false;
    }
    return true;
}

// check $ (.)
static bool json_model_1(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .
    res = _jm_obj_7(val, path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected element [.]", path);
    }
    return res;
}

jm_check_fun_t check_model_map(const char *pname)
{
    return jm_search_propmap(pname, check_model_map_tab, 16);
}

static bool initialized = false;

const char *check_model_init(void)
{
    if (!initialized)
    {
        initialized = true;
        jm_version_string = JSON_MODEL_VERSION;
        _jm_re_0_re2 = cre2_new(".", strlen("."), NULL);
        if (cre2_error_code(_jm_re_0_re2))
            return cre2_error_string(_jm_re_0_re2);
        _jm_re_0_nn = cre2_num_capturing_groups(_jm_re_0_re2) + 1;
        // initialize sorted set _jm_cst_0
        _jm_cst_0[0] = (jm_constant_t) { cst_is_string, { .s = "agpl_3" } };
        _jm_cst_0[1] = (jm_constant_t) { cst_is_string, { .s = "apache_1_1" } };
        _jm_cst_0[2] = (jm_constant_t) { cst_is_string, { .s = "apache_2_0" } };
        _jm_cst_0[3] = (jm_constant_t) { cst_is_string, { .s = "artistic_1" } };
        _jm_cst_0[4] = (jm_constant_t) { cst_is_string, { .s = "artistic_2" } };
        _jm_cst_0[5] = (jm_constant_t) { cst_is_string, { .s = "bsd" } };
        _jm_cst_0[6] = (jm_constant_t) { cst_is_string, { .s = "freebsd" } };
        _jm_cst_0[7] = (jm_constant_t) { cst_is_string, { .s = "gfdl_1_2" } };
        _jm_cst_0[8] = (jm_constant_t) { cst_is_string, { .s = "gfdl_1_3" } };
        _jm_cst_0[9] = (jm_constant_t) { cst_is_string, { .s = "gpl_1" } };
        _jm_cst_0[10] = (jm_constant_t) { cst_is_string, { .s = "gpl_2" } };
        _jm_cst_0[11] = (jm_constant_t) { cst_is_string, { .s = "gpl_3" } };
        _jm_cst_0[12] = (jm_constant_t) { cst_is_string, { .s = "lgpl_2_1" } };
        _jm_cst_0[13] = (jm_constant_t) { cst_is_string, { .s = "lgpl_3_0" } };
        _jm_cst_0[14] = (jm_constant_t) { cst_is_string, { .s = "mit" } };
        _jm_cst_0[15] = (jm_constant_t) { cst_is_string, { .s = "mozilla_1_0" } };
        _jm_cst_0[16] = (jm_constant_t) { cst_is_string, { .s = "mozilla_1_1" } };
        _jm_cst_0[17] = (jm_constant_t) { cst_is_string, { .s = "openssl" } };
        _jm_cst_0[18] = (jm_constant_t) { cst_is_string, { .s = "perl_5" } };
        _jm_cst_0[19] = (jm_constant_t) { cst_is_string, { .s = "postgresql" } };
        _jm_cst_0[20] = (jm_constant_t) { cst_is_string, { .s = "qpl_1_0" } };
        _jm_cst_0[21] = (jm_constant_t) { cst_is_string, { .s = "ssleay" } };
        _jm_cst_0[22] = (jm_constant_t) { cst_is_string, { .s = "sun" } };
        _jm_cst_0[23] = (jm_constant_t) { cst_is_string, { .s = "zlib" } };
        _jm_cst_0[24] = (jm_constant_t) { cst_is_string, { .s = "open_source" } };
        _jm_cst_0[25] = (jm_constant_t) { cst_is_string, { .s = "restricted" } };
        _jm_cst_0[26] = (jm_constant_t) { cst_is_string, { .s = "unrestricted" } };
        _jm_cst_0[27] = (jm_constant_t) { cst_is_string, { .s = "unknown" } };
        jm_sort_cst(_jm_cst_0, 28);
        _jm_re_1_re2 = cre2_new("^[Xx]_", strlen("^[Xx]_"), NULL);
        if (cre2_error_code(_jm_re_1_re2))
            return cre2_error_string(_jm_re_1_re2);
        _jm_re_1_nn = cre2_num_capturing_groups(_jm_re_1_re2) + 1;
        // initialize sorted set _jm_cst_1
        _jm_cst_1[0] = (jm_constant_t) { cst_is_string, { .s = "stable" } };
        _jm_cst_1[1] = (jm_constant_t) { cst_is_string, { .s = "testing" } };
        _jm_cst_1[2] = (jm_constant_t) { cst_is_string, { .s = "unstable" } };
        jm_sort_cst(_jm_cst_1, 3);
        _jm_re_2_re2 = cre2_new("^\\d+\\.\\d+\\.\\d+[-_A-Za-z0-9]*$", strlen("^\\d+\\.\\d+\\.\\d+[-_A-Za-z0-9]*$"), NULL);
        if (cre2_error_code(_jm_re_2_re2))
            return cre2_error_string(_jm_re_2_re2);
        _jm_re_2_nn = cre2_num_capturing_groups(_jm_re_2_re2) + 1;
        _jm_re_3_re2 = cre2_new("^(<=|<|>=|>|!=|==)$", strlen("^(<=|<|>=|>|!=|==)$"), NULL);
        if (cre2_error_code(_jm_re_3_re2))
            return cre2_error_string(_jm_re_3_re2);
        _jm_re_3_nn = cre2_num_capturing_groups(_jm_re_3_re2) + 1;
        _jm_re_4_re2 = cre2_new("^\\s*(<=|<|>=|>|!=|==)\\s*(\\d+\\.\\d+\\.\\d+[-_A-Za-z0-9]*)\\s*(,\\s*(<=|<|>=|>|!=|==)\\s*(\\d+\\.\\d+\\.\\d+[-_A-Za-z0-9]*))*\\s*$", strlen("^\\s*(<=|<|>=|>|!=|==)\\s*(\\d+\\.\\d+\\.\\d+[-_A-Za-z0-9]*)\\s*(,\\s*(<=|<|>=|>|!=|==)\\s*(\\d+\\.\\d+\\.\\d+[-_A-Za-z0-9]*))*\\s*$"), NULL);
        if (cre2_error_code(_jm_re_4_re2))
            return cre2_error_string(_jm_re_4_re2);
        _jm_re_4_nn = cre2_num_capturing_groups(_jm_re_4_re2) + 1;
        // initialize sorted set _jm_cst_2
        _jm_cst_2[0] = (jm_constant_t) { cst_is_string, { .s = "configure" } };
        _jm_cst_2[1] = (jm_constant_t) { cst_is_string, { .s = "build" } };
        _jm_cst_2[2] = (jm_constant_t) { cst_is_string, { .s = "test" } };
        _jm_cst_2[3] = (jm_constant_t) { cst_is_string, { .s = "runtime" } };
        _jm_cst_2[4] = (jm_constant_t) { cst_is_string, { .s = "develop" } };
        jm_sort_cst(_jm_cst_2, 5);
        // initialize sorted set _jm_cst_3
        _jm_cst_3[0] = (jm_constant_t) { cst_is_string, { .s = "requires" } };
        _jm_cst_3[1] = (jm_constant_t) { cst_is_string, { .s = "recommends" } };
        _jm_cst_3[2] = (jm_constant_t) { cst_is_string, { .s = "suggests" } };
        _jm_cst_3[3] = (jm_constant_t) { cst_is_string, { .s = "conflicts" } };
        jm_sort_cst(_jm_cst_3, 4);
        _jm_obj_7_mup_tab[0] = (jm_propmap_t) { "abstract", _jm_f_0 };
        _jm_obj_7_mup_tab[1] = (jm_propmap_t) { "license", _jm_f_1 };
        _jm_obj_7_mup_tab[2] = (jm_propmap_t) { "maintainer", _jm_f_2 };
        _jm_obj_7_mup_tab[3] = (jm_propmap_t) { "meta-spec", _jm_f_3 };
        _jm_obj_7_mup_tab[4] = (jm_propmap_t) { "name", _jm_f_4 };
        _jm_obj_7_mup_tab[5] = (jm_propmap_t) { "provides", _jm_f_5 };
        _jm_obj_7_mup_tab[6] = (jm_propmap_t) { "version", _jm_f_6 };
        jm_sort_propmap(_jm_obj_7_mup_tab, 7);
        _jm_obj_7_map_tab[0] = (jm_propmap_t) { "description", _jm_f_7 };
        _jm_obj_7_map_tab[1] = (jm_propmap_t) { "generated_by", _jm_f_8 };
        _jm_obj_7_map_tab[2] = (jm_propmap_t) { "no_index", _jm_f_9 };
        _jm_obj_7_map_tab[3] = (jm_propmap_t) { "prereqs", _jm_f_10 };
        _jm_obj_7_map_tab[4] = (jm_propmap_t) { "release_status", _jm_f_11 };
        _jm_obj_7_map_tab[5] = (jm_propmap_t) { "resources", _jm_f_12 };
        _jm_obj_7_map_tab[6] = (jm_propmap_t) { "tags", _jm_f_13 };
        _jm_obj_7_map_tab[7] = (jm_propmap_t) { "url", _jm_f_14 };
        jm_sort_propmap(_jm_obj_7_map_tab, 8);
        check_model_map_tab[0] = (jm_propmap_t) { "", json_model_1 };
        check_model_map_tab[1] = (jm_propmap_t) { "neStr", json_model_2 };
        check_model_map_tab[2] = (jm_propmap_t) { "neStrList", json_model_3 };
        check_model_map_tab[3] = (jm_propmap_t) { "License", json_model_4 };
        check_model_map_tab[4] = (jm_propmap_t) { "LicenseList", json_model_5 };
        check_model_map_tab[5] = (jm_propmap_t) { "Provide", json_model_6 };
        check_model_map_tab[6] = (jm_propmap_t) { "Status", json_model_7 };
        check_model_map_tab[7] = (jm_propmap_t) { "Resources", json_model_8 };
        check_model_map_tab[8] = (jm_propmap_t) { "SemVer", json_model_9 };
        check_model_map_tab[9] = (jm_propmap_t) { "Version", json_model_10 };
        check_model_map_tab[10] = (jm_propmap_t) { "Ops", json_model_11 };
        check_model_map_tab[11] = (jm_propmap_t) { "VersionRange", json_model_12 };
        check_model_map_tab[12] = (jm_propmap_t) { "Phase", json_model_13 };
        check_model_map_tab[13] = (jm_propmap_t) { "Relation", json_model_14 };
        check_model_map_tab[14] = (jm_propmap_t) { "Prereq", json_model_15 };
        check_model_map_tab[15] = (jm_propmap_t) { "Prereqs", json_model_16 };
        jm_sort_propmap(check_model_map_tab, 16);
    }
    return NULL;
}

void check_model_free(void)
{
    if (initialized)
    {
        initialized = false;

        // cleanup code
        cre2_delete(_jm_re_0_re2);
        _jm_re_0_re2 = NULL;
        _jm_re_0_nn = 0;
        cre2_delete(_jm_re_1_re2);
        _jm_re_1_re2 = NULL;
        _jm_re_1_nn = 0;
        cre2_delete(_jm_re_2_re2);
        _jm_re_2_re2 = NULL;
        _jm_re_2_nn = 0;
        cre2_delete(_jm_re_3_re2);
        _jm_re_3_re2 = NULL;
        _jm_re_3_nn = 0;
        cre2_delete(_jm_re_4_re2);
        _jm_re_4_re2 = NULL;
        _jm_re_4_nn = 0;
    }
}

/*
 * # API
 *
 * ```c
 * bool error;
 * char *message;
 *
 * bool valid = check(json_value, "model-name", &error, &message);
 *
 * if (message)
 *    free(message), message = NULL;
 * ```
 *
 * - `error` is set of there was an error during initialization or if the model does not exists.
 * - `message` is provided if a non NULL pointer is passed, and must be freed by the caller.
 */
bool
check_model(const json_t *val, const char *name, bool *error, char **reasons)
{
    return jm_generic_entry(check_model_init, check_model_map, val, name, error, reasons);
}
