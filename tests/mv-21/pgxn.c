//
// Generated by JSON Model Compiler version 2
// see https://github.com/clairey-zx81/json-model
//

// regular expression engine
#include <stddef.h>
#include <cre2.h>

#include <json-model.h>
#define JSON_MODEL_VERSION "2"

static cre2_regexp_t *_jm_re_0_re2 = NULL;
static int _jm_re_0_nn = 0;
static bool _jm_re_0(const char *s, jm_path_t *path, jm_report_t *rep);
static bool json_model_2(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool json_model_3(const json_t *val, jm_path_t *path, jm_report_t *rep);
static INLINE bool _jm_cst_0_str_test(const char *);
static bool json_model_4(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool json_model_5(const json_t *val, jm_path_t *path, jm_report_t *rep);
static cre2_regexp_t *_jm_re_1_re2 = NULL;
static int _jm_re_1_nn = 0;
static bool _jm_re_1(const char *s, jm_path_t *path, jm_report_t *rep);
static bool json_model_6(const json_t *val, jm_path_t *path, jm_report_t *rep);
static INLINE bool _jm_cst_1_str_test(const char *);
static bool json_model_7(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_obj_0(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_obj_1(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool json_model_8(const json_t *val, jm_path_t *path, jm_report_t *rep);
static cre2_regexp_t *_jm_re_2_re2 = NULL;
static int _jm_re_2_nn = 0;
static bool _jm_re_2(const char *s, jm_path_t *path, jm_report_t *rep);
static bool json_model_9(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool json_model_10(const json_t *val, jm_path_t *path, jm_report_t *rep);
static cre2_regexp_t *_jm_re_3_re2 = NULL;
static int _jm_re_3_nn = 0;
static bool _jm_re_3(const char *s, jm_path_t *path, jm_report_t *rep);
static bool json_model_11(const json_t *val, jm_path_t *path, jm_report_t *rep);
static cre2_regexp_t *_jm_re_4_re2 = NULL;
static int _jm_re_4_nn = 0;
static bool _jm_re_4(const char *s, jm_path_t *path, jm_report_t *rep);
static bool json_model_12(const json_t *val, jm_path_t *path, jm_report_t *rep);
static INLINE bool _jm_cst_2_str_test(const char *);
static bool json_model_13(const json_t *val, jm_path_t *path, jm_report_t *rep);
static INLINE bool _jm_cst_3_str_test(const char *);
static bool json_model_14(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool json_model_15(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_obj_2(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool json_model_16(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_obj_3(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_obj_4(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_obj_5(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_obj_6(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool json_model_1(const json_t *val, jm_path_t *path, jm_report_t *rep);
jm_propmap_t check_model_map_tab[16];
const size_t check_model_map_size = 16;

static bool _jm_re_0(const char *s, jm_path_t *path, jm_report_t *rep)
{
    size_t slen = strlen(s);
    return cre2_match(_jm_re_0_re2, s, slen, 0, slen, CRE2_UNANCHORED, NULL, 0);
}

// check $neStr (.'$neStr')
static bool json_model_2(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    // .'$neStr'
    // "/./"
    bool res = json_is_string(val) && _jm_re_0(json_string_value(val), path, rep);
    if (unlikely(! res))
    {
        if (rep) jm_report_add_entry(rep, "unexpected /./ [.'$neStr']", path);
    }
    return res;
}

// check $neStrList (.'$neStrList')
static bool json_model_3(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    // .'$neStrList'
    // .'$neStrList'.'@'
    bool res = json_is_array(val);
    if (res)
    {
        size_t arr_0_idx;
        json_t *arr_0_item;
        json_array_foreach(val, arr_0_idx, arr_0_item)
        {
            jm_path_t arr_0_lpath = (jm_path_t) { NULL, arr_0_idx, path, NULL };
            // .'$neStrList'.'@'.0
            res = json_model_2(arr_0_item, (path ? &arr_0_lpath : NULL), rep);
            if (unlikely(! res))
            {
                if (rep) jm_report_add_entry(rep, "unexpected $neStr [.'$neStrList'.'@'.0]", (path ? &arr_0_lpath : NULL));
                break;
            }
        }
    }
    if (unlikely(! res))
    {
        if (rep) jm_report_add_entry(rep, "not array or unexpected array [.'$neStrList'.'@']", path);
    }
    if (likely(res))
    {
        int64_t ival_0 = json_array_size(val);
        res = jm_array_is_unique(val, path, rep) && ival_0 >= 1;
        if (unlikely(! res))
        {
            if (rep) jm_report_add_entry(rep, "constraints failed [.'$neStrList']", path);
        }
    }
    return res;
}

static INLINE bool _jm_cst_0_str_test(const char *s)
{
    return jm_str_eq_4(s, 0x00647362)  // "bsd"
        || jm_str_eq_4(s, 0x0074696d)  // "mit"
        || jm_str_eq_4(s, 0x006e7573)  // "sun"
        || jm_str_eq_5(s, 0x0000000062696c7aLL)  // "zlib"
        || jm_str_eq_6(s, 0x000000315f6c7067LL)  // "gpl_1"
        || jm_str_eq_6(s, 0x000000325f6c7067LL)  // "gpl_2"
        || jm_str_eq_6(s, 0x000000335f6c7067LL)  // "gpl_3"
        || jm_str_eq_7(s, 0x0000335f6c706761LL)  // "agpl_3"
        || jm_str_eq_7(s, 0x0000355f6c726570LL)  // "perl_5"
        || jm_str_eq_7(s, 0x00007961656c7373LL)  // "ssleay"
        || jm_str_eq_8(s, 0x0064736265657266LL)  // "freebsd"
        || jm_str_eq_8(s, 0x006c73736e65706fLL)  // "openssl"
        || jm_str_eq_8(s, 0x00305f315f6c7071LL)  // "qpl_1_0"
        || jm_str_eq_8(s, 0x006e776f6e6b6e75LL)  // "unknown"
        || jm_str_eq_8(s, 0x325f315f6c646667LL) && jm_str_eq_0(s + 8)  // "gfdl_1_2"
        || jm_str_eq_8(s, 0x335f315f6c646667LL) && jm_str_eq_0(s + 8)  // "gfdl_1_3"
        || jm_str_eq_8(s, 0x315f325f6c70676cLL) && jm_str_eq_0(s + 8)  // "lgpl_2_1"
        || jm_str_eq_8(s, 0x305f335f6c70676cLL) && jm_str_eq_0(s + 8)  // "lgpl_3_0"
        || jm_str_eq_8(s, 0x315f656863617061LL) && jm_str_eq_3(s + 8, 0x0000315f)  // "apache_1_1"
        || jm_str_eq_8(s, 0x325f656863617061LL) && jm_str_eq_3(s + 8, 0x0000305f)  // "apache_2_0"
        || jm_str_eq_8(s, 0x6369747369747261LL) && jm_str_eq_3(s + 8, 0x0000315f)  // "artistic_1"
        || jm_str_eq_8(s, 0x6369747369747261LL) && jm_str_eq_3(s + 8, 0x0000325f)  // "artistic_2"
        || jm_str_eq_8(s, 0x7365726774736f70LL) && jm_str_eq_3(s + 8, 0x00006c71)  // "postgresql"
        || jm_str_eq_8(s, 0x7463697274736572LL) && jm_str_eq_3(s + 8, 0x00006465)  // "restricted"
        || jm_str_eq_8(s, 0x5f616c6c697a6f6dLL) && jm_str_eq_4(s + 8, 0x00305f31)  // "mozilla_1_0"
        || jm_str_eq_8(s, 0x5f616c6c697a6f6dLL) && jm_str_eq_4(s + 8, 0x00315f31)  // "mozilla_1_1"
        || jm_str_eq_8(s, 0x756f735f6e65706fLL) && jm_str_eq_4(s + 8, 0x00656372)  // "open_source"
        || jm_str_eq_8(s, 0x6972747365726e75LL) && jm_str_eq_5(s + 8, 0x0000000064657463LL)  // "unrestricted"
    ;
}

// check $License (.'$License')
static bool json_model_4(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    // .'$License'
    bool res = json_is_string(val) && _jm_cst_0_str_test(json_string_value(val));
    if (unlikely(! res))
    {
        if (rep) jm_report_add_entry(rep, "value not in enum [.'$License'.'|']", path);
    }
    return res;
}

// check $LicenseList (.'$LicenseList')
static bool json_model_5(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    // .'$LicenseList'
    // .'$LicenseList'.'@'
    bool res = json_is_array(val);
    if (res)
    {
        size_t arr_1_idx;
        json_t *arr_1_item;
        json_array_foreach(val, arr_1_idx, arr_1_item)
        {
            jm_path_t arr_1_lpath = (jm_path_t) { NULL, arr_1_idx, path, NULL };
            // .'$LicenseList'.'@'.0
            res = json_model_4(arr_1_item, (path ? &arr_1_lpath : NULL), rep);
            if (unlikely(! res))
            {
                if (rep) jm_report_add_entry(rep, "unexpected $License [.'$LicenseList'.'@'.0]", (path ? &arr_1_lpath : NULL));
                break;
            }
        }
    }
    if (unlikely(! res))
    {
        if (rep) jm_report_add_entry(rep, "not array or unexpected array [.'$LicenseList'.'@']", path);
    }
    if (likely(res))
    {
        int64_t ival_1 = json_array_size(val);
        res = jm_array_is_unique(val, path, rep) && ival_1 >= 1;
        if (unlikely(! res))
        {
            if (rep) jm_report_add_entry(rep, "constraints failed [.'$LicenseList']", path);
        }
    }
    return res;
}

static bool _jm_re_1(const char *s, jm_path_t *path, jm_report_t *rep)
{
    size_t slen = strlen(s);
    return cre2_match(_jm_re_1_re2, s, slen, 0, slen, CRE2_UNANCHORED, NULL, 0);
}

// check $Provide (.'$Provide')
static bool json_model_6(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    // .'$Provide'
    if (unlikely(! json_is_object(val)))
    {
        if (rep) jm_report_add_entry(rep, "not an object [.'$Provide']", path);
        return false;
    }
    bool res;
    int64_t must_count = 0;
    const char *prop;
    json_t *pval;
    json_object_foreach((json_t *) val, prop, pval)
    {
        jm_path_t lpath_0 = (jm_path_t) { prop, 0, path, NULL };
        if (unlikely(jm_str_eq_5(prop, 0x00000000656c6966LL)))
        {
            // handle must file property
            must_count += 1;
            // .'$Provide'.file
            res = json_is_string(pval);
            if (unlikely(! res))
            {
                if (rep) jm_report_add_entry(rep, "unexpected string [.'$Provide'.file]", (path ? &lpath_0 : NULL));
                if (rep) jm_report_add_entry(rep, "invalid mandatory prop value [.'$Provide'.file]", (path ? &lpath_0 : NULL));
                return false;
            }
        }
        else if (unlikely(jm_str_eq_8(prop, 0x006e6f6973726576LL)))
        {
            // handle must version property
            must_count += 1;
            // .'$Provide'.version
            res = json_model_10(pval, (path ? &lpath_0 : NULL), rep);
            if (unlikely(! res))
            {
                if (rep) jm_report_add_entry(rep, "unexpected $Version [.'$Provide'.version]", (path ? &lpath_0 : NULL));
                if (rep) jm_report_add_entry(rep, "invalid mandatory prop value [.'$Provide'.version]", (path ? &lpath_0 : NULL));
                return false;
            }
        }
        else if (unlikely(jm_str_eq_8(prop, 0x00656c6966636f64LL)))
        {
            // handle may docfile property
            // .'$Provide'.docfile
            res = json_is_string(pval);
            if (unlikely(! res))
            {
                if (rep) jm_report_add_entry(rep, "unexpected string [.'$Provide'.docfile]", (path ? &lpath_0 : NULL));
                if (rep) jm_report_add_entry(rep, "invalid optional prop value [.'$Provide'.docfile]", (path ? &lpath_0 : NULL));
                return false;
            }
        }
        else if (jm_str_eq_8(prop, 0x7463617274736261LL) && jm_str_eq_0(prop + 8))
        {
            // handle may abstract property
            // .'$Provide'.abstract
            res = json_is_string(pval);
            if (unlikely(! res))
            {
                if (rep) jm_report_add_entry(rep, "unexpected string [.'$Provide'.abstract]", (path ? &lpath_0 : NULL));
                if (rep) jm_report_add_entry(rep, "invalid optional prop value [.'$Provide'.abstract]", (path ? &lpath_0 : NULL));
                return false;
            }
        }
        else if (likely(_jm_re_1(prop, path, rep)))
            // handle 1 re props
            // .'$Provide'.'/^[Xx]_/'
            res = true;
        else
        {
            if (rep) jm_report_add_entry(rep, "unexpected prop [.'$Provide']", (path ? &lpath_0 : NULL));
            return false;
        }
    }
    if (unlikely(must_count != 2))
    {
        if (likely(rep != NULL))
        {
            if (! (json_object_get(val, "file") != NULL))
            {
                if (rep) jm_report_add_entry(rep, "missing mandatory prop <file> [.'$Provide']", path);
            }
            if (! (json_object_get(val, "version") != NULL))
            {
                if (rep) jm_report_add_entry(rep, "missing mandatory prop <version> [.'$Provide']", path);
            }
        }
        return false;
    }
    return true;
}

static INLINE bool _jm_cst_1_str_test(const char *s)
{
    return jm_str_eq_7(s, 0x0000656c62617473LL)  // "stable"
        || jm_str_eq_8(s, 0x00676e6974736574LL)  // "testing"
        || jm_str_eq_8(s, 0x656c626174736e75LL) && jm_str_eq_0(s + 8)  // "unstable"
    ;
}

// check $Status (.'$Status')
static bool json_model_7(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    // .'$Status'
    bool res = json_is_string(val) && _jm_cst_1_str_test(json_string_value(val));
    if (unlikely(! res))
    {
        if (rep) jm_report_add_entry(rep, "value not in enum [.'$Status'.'|']", path);
    }
    return res;
}

// object .'$Resources'.bugtracker
static INLINE bool _jm_obj_0(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    if (unlikely(! json_is_object(val)))
    {
        if (rep) jm_report_add_entry(rep, "not an object [.'$Resources'.bugtracker]", path);
        return false;
    }
    bool res;
    const char *prop;
    json_t *pval;
    json_object_foreach((json_t *) val, prop, pval)
    {
        jm_path_t lpath_2 = (jm_path_t) { prop, 0, path, NULL };
        if (unlikely(jm_str_eq_4(prop, 0x00626577)))
        {
            // handle may web property
            // .'$Resources'.bugtracker.web
            res = jm_is_valid_url(json_string_value(pval), (path ? &lpath_2 : NULL), rep);
            if (unlikely(! res))
            {
                if (rep) jm_report_add_entry(rep, "unexpected $URL [.'$Resources'.bugtracker.web]", (path ? &lpath_2 : NULL));
                if (rep) jm_report_add_entry(rep, "invalid optional prop value [.'$Resources'.bugtracker.web]", (path ? &lpath_2 : NULL));
                return false;
            }
        }
        else if (jm_str_eq_7(prop, 0x00006f746c69616dLL))
        {
            // handle may mailto property
            // .'$Resources'.bugtracker.mailto
            res = jm_is_valid_email(json_string_value(pval), (path ? &lpath_2 : NULL), rep);
            if (unlikely(! res))
            {
                if (rep) jm_report_add_entry(rep, "unexpected $EMAIL [.'$Resources'.bugtracker.mailto]", (path ? &lpath_2 : NULL));
                if (rep) jm_report_add_entry(rep, "invalid optional prop value [.'$Resources'.bugtracker.mailto]", (path ? &lpath_2 : NULL));
                return false;
            }
        }
        else if (likely(_jm_re_1(prop, path, rep)))
            // handle 1 re props
            // .'$Resources'.bugtracker.'/^[Xx]_/'
            res = true;
        else
        {
            if (rep) jm_report_add_entry(rep, "unexpected prop [.'$Resources'.bugtracker]", (path ? &lpath_2 : NULL));
            return false;
        }
    }
    return true;
}

// object .'$Resources'.repository
static INLINE bool _jm_obj_1(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    if (unlikely(! json_is_object(val)))
    {
        if (rep) jm_report_add_entry(rep, "not an object [.'$Resources'.repository]", path);
        return false;
    }
    bool res;
    const char *prop;
    json_t *pval;
    json_object_foreach((json_t *) val, prop, pval)
    {
        jm_path_t lpath_3 = (jm_path_t) { prop, 0, path, NULL };
        if (unlikely(jm_str_eq_4(prop, 0x006c7275)))
        {
            // handle may url property
            // .'$Resources'.repository.url
            res = jm_is_valid_url(json_string_value(pval), (path ? &lpath_3 : NULL), rep);
            if (unlikely(! res))
            {
                if (rep) jm_report_add_entry(rep, "unexpected $URL [.'$Resources'.repository.url]", (path ? &lpath_3 : NULL));
                if (rep) jm_report_add_entry(rep, "invalid optional prop value [.'$Resources'.repository.url]", (path ? &lpath_3 : NULL));
                return false;
            }
        }
        else if (jm_str_eq_4(prop, 0x00626577))
        {
            // handle may web property
            // .'$Resources'.repository.web
            res = jm_is_valid_url(json_string_value(pval), (path ? &lpath_3 : NULL), rep);
            if (unlikely(! res))
            {
                if (rep) jm_report_add_entry(rep, "unexpected $URL [.'$Resources'.repository.web]", (path ? &lpath_3 : NULL));
                if (rep) jm_report_add_entry(rep, "invalid optional prop value [.'$Resources'.repository.web]", (path ? &lpath_3 : NULL));
                return false;
            }
        }
        else if (likely(jm_str_eq_5(prop, 0x0000000065707974LL)))
        {
            // handle may type property
            // .'$Resources'.repository.type
            // "/./"
            res = json_is_string(pval) && _jm_re_0(json_string_value(pval), (path ? &lpath_3 : NULL), rep);
            if (unlikely(! res))
            {
                if (rep) jm_report_add_entry(rep, "unexpected /./ [.'$Resources'.repository.type]", (path ? &lpath_3 : NULL));
                if (rep) jm_report_add_entry(rep, "invalid optional prop value [.'$Resources'.repository.type]", (path ? &lpath_3 : NULL));
                return false;
            }
        }
        else
        {
            if (rep) jm_report_add_entry(rep, "unexpected prop [.'$Resources'.repository]", (path ? &lpath_3 : NULL));
            return false;
        }
    }
    return true;
}

// check $Resources (.'$Resources')
static bool json_model_8(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    // .'$Resources'
    if (unlikely(! json_is_object(val)))
    {
        if (rep) jm_report_add_entry(rep, "not an object [.'$Resources']", path);
        return false;
    }
    bool res;
    const char *prop;
    json_t *pval;
    json_object_foreach((json_t *) val, prop, pval)
    {
        jm_path_t lpath_1 = (jm_path_t) { prop, 0, path, NULL };
        if (unlikely(jm_str_eq_8(prop, 0x65676170656d6f68LL) && jm_str_eq_0(prop + 8)))
        {
            // handle may homepage property
            // .'$Resources'.homepage
            res = jm_is_valid_url(json_string_value(pval), (path ? &lpath_1 : NULL), rep);
            if (unlikely(! res))
            {
                if (rep) jm_report_add_entry(rep, "unexpected $URL [.'$Resources'.homepage]", (path ? &lpath_1 : NULL));
                if (rep) jm_report_add_entry(rep, "invalid optional prop value [.'$Resources'.homepage]", (path ? &lpath_1 : NULL));
                return false;
            }
        }
        else if (jm_str_eq_8(prop, 0x6b63617274677562LL) && jm_str_eq_3(prop + 8, 0x00007265))
        {
            // handle may bugtracker property
            // .'$Resources'.bugtracker
            res = _jm_obj_0(pval, (path ? &lpath_1 : NULL), rep);
            if (unlikely(! res))
            {
                if (rep) jm_report_add_entry(rep, "unexpected element [.'$Resources'.bugtracker]", (path ? &lpath_1 : NULL));
                if (rep) jm_report_add_entry(rep, "invalid optional prop value [.'$Resources'.bugtracker]", (path ? &lpath_1 : NULL));
                return false;
            }
        }
        else if (likely(jm_str_eq_8(prop, 0x6f7469736f706572LL) && jm_str_eq_3(prop + 8, 0x00007972)))
        {
            // handle may repository property
            // .'$Resources'.repository
            res = _jm_obj_1(pval, (path ? &lpath_1 : NULL), rep);
            if (unlikely(! res))
            {
                if (rep) jm_report_add_entry(rep, "unexpected element [.'$Resources'.repository]", (path ? &lpath_1 : NULL));
                if (rep) jm_report_add_entry(rep, "invalid optional prop value [.'$Resources'.repository]", (path ? &lpath_1 : NULL));
                return false;
            }
        }
        else
        {
            if (rep) jm_report_add_entry(rep, "unexpected prop [.'$Resources']", (path ? &lpath_1 : NULL));
            return false;
        }
    }
    return true;
}

static bool _jm_re_2(const char *s, jm_path_t *path, jm_report_t *rep)
{
    size_t slen = strlen(s);
    return cre2_match(_jm_re_2_re2, s, slen, 0, slen, CRE2_UNANCHORED, NULL, 0);
}

// check $SemVer (.'$SemVer')
static bool json_model_9(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    // .'$SemVer'
    // "/^\\d+\\.\\d+\\.\\d+[-_A-Za-z0-9]*$/"
    bool res = json_is_string(val) && _jm_re_2(json_string_value(val), path, rep);
    if (unlikely(! res))
    {
        if (rep) jm_report_add_entry(rep, "unexpected /^\\d+\\.\\d+\\.\\d+[-_A-Za-z0-9]*$/ [.'$SemVer']", path);
    }
    return res;
}

// check $Version (.'$Version')
static bool json_model_10(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    // .'$Version'
    // .'$Version'.'|'.0
    bool res = json_model_9(val, path, rep);
    if (unlikely(! res))
    {
        if (rep) jm_report_add_entry(rep, "unexpected $SemVer [.'$Version'.'|'.0]", path);
    }
    if (! res)
    {
        // .'$Version'.'|'.1
        res = json_is_integer(val) && json_integer_value(val) == 0;
        if (unlikely(! res))
        {
            if (rep) jm_report_add_entry(rep, "unexpected =0 [.'$Version'.'|'.1]", path);
        }
    }
    if (likely(res))
    {
        if (rep) jm_report_free_entries(rep);
    }
    else
    {
        if (rep) jm_report_add_entry(rep, "no model matched [.'$Version'.'|']", path);
    }
    return res;
}

static bool _jm_re_3(const char *s, jm_path_t *path, jm_report_t *rep)
{
    size_t slen = strlen(s);
    return cre2_match(_jm_re_3_re2, s, slen, 0, slen, CRE2_UNANCHORED, NULL, 0);
}

// check $Ops (.'$Ops')
static bool json_model_11(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    // .'$Ops'
    // "/^(<=|<|>=|>|!=|==)$/"
    bool res = json_is_string(val) && _jm_re_3(json_string_value(val), path, rep);
    if (unlikely(! res))
    {
        if (rep) jm_report_add_entry(rep, "unexpected /^(<=|<|>=|>|!=|==)$/ [.'$Ops']", path);
    }
    return res;
}

static bool _jm_re_4(const char *s, jm_path_t *path, jm_report_t *rep)
{
    size_t slen = strlen(s);
    return cre2_match(_jm_re_4_re2, s, slen, 0, slen, CRE2_UNANCHORED, NULL, 0);
}

// check $VersionRange (.'$VersionRange')
static bool json_model_12(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    // .'$VersionRange'
    // "/^\\s*(<=|<|>=|>|!=|==)\\s*(\\d+\\.\\d+\\.\\d+[-_A-Za-z0-9]*)\\s*(,\\s*(<=|<|>=|>|!=|==)\\s*(\\d+\\.\\d+\\.\\d+[-_A-Za-z0-9]*))*\\s*$/"
    bool res = json_is_string(val) && _jm_re_4(json_string_value(val), path, rep);
    if (unlikely(! res))
    {
        if (rep) jm_report_add_entry(rep, "unexpected /^\\s*(<=|<|>=|>|!=|==)\\s*(\\d+\\.\\d+\\.\\d+[-_A-Za-z0-9]*)\\s*(,\\s*(<=|<|>=|>|!=|==)\\s*(\\d+\\.\\d+\\.\\d+[-_A-Za-z0-9]*))*\\s*$/ [.'$VersionRange']", path);
    }
    return res;
}

static INLINE bool _jm_cst_2_str_test(const char *s)
{
    return jm_str_eq_5(s, 0x0000000074736574LL)  // "test"
        || jm_str_eq_6(s, 0x000000646c697562LL)  // "build"
        || jm_str_eq_8(s, 0x00706f6c65766564LL)  // "develop"
        || jm_str_eq_8(s, 0x00656d69746e7572LL)  // "runtime"
        || jm_str_eq_8(s, 0x72756769666e6f63LL) && jm_str_eq_2(s + 8, 0x00000065)  // "configure"
    ;
}

// check $Phase (.'$Phase')
static bool json_model_13(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    // .'$Phase'
    bool res = json_is_string(val) && _jm_cst_2_str_test(json_string_value(val));
    if (unlikely(! res))
    {
        if (rep) jm_report_add_entry(rep, "value not in enum [.'$Phase'.'|']", path);
    }
    return res;
}

static INLINE bool _jm_cst_3_str_test(const char *s)
{
    return jm_str_eq_8(s, 0x7365726975716572LL) && jm_str_eq_0(s + 8)  // "requires"
        || jm_str_eq_8(s, 0x7374736567677573LL) && jm_str_eq_0(s + 8)  // "suggests"
        || jm_str_eq_8(s, 0x7463696c666e6f63LL) && jm_str_eq_2(s + 8, 0x00000073)  // "conflicts"
        || jm_str_eq_8(s, 0x6e656d6d6f636572LL) && jm_str_eq_3(s + 8, 0x00007364)  // "recommends"
    ;
}

// check $Relation (.'$Relation')
static bool json_model_14(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    // .'$Relation'
    bool res = json_is_string(val) && _jm_cst_3_str_test(json_string_value(val));
    if (unlikely(! res))
    {
        if (rep) jm_report_add_entry(rep, "value not in enum [.'$Relation'.'|']", path);
    }
    return res;
}

// check $Prereq (.'$Prereq')
static bool json_model_15(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    // .'$Prereq'
    if (unlikely(! json_is_object(val)))
    {
        if (rep) jm_report_add_entry(rep, "not an object [.'$Prereq']", path);
        return false;
    }
    bool res;
    const char *prop;
    json_t *pval;
    json_object_foreach((json_t *) val, prop, pval)
    {
        jm_path_t lpath_4 = (jm_path_t) { prop, 0, path, NULL };
        // handle other props
        // .'$Prereq'.''
        // .'$Prereq'.''.'|'.0
        res = json_model_10(pval, (path ? &lpath_4 : NULL), rep);
        if (unlikely(! res))
        {
            if (rep) jm_report_add_entry(rep, "unexpected $Version [.'$Prereq'.''.'|'.0]", (path ? &lpath_4 : NULL));
        }
        if (! res)
        {
            // .'$Prereq'.''.'|'.1
            res = json_model_12(pval, (path ? &lpath_4 : NULL), rep);
            if (unlikely(! res))
            {
                if (rep) jm_report_add_entry(rep, "unexpected $VersionRange [.'$Prereq'.''.'|'.1]", (path ? &lpath_4 : NULL));
            }
        }
        if (likely(res))
        {
            if (rep) jm_report_free_entries(rep);
        }
        else
        {
            if (rep) jm_report_add_entry(rep, "no model matched [.'$Prereq'.''.'|']", (path ? &lpath_4 : NULL));
            return false;
        }
    }
    return true;
}

// object .'$Prereqs'.'$Phase'
static INLINE bool _jm_obj_2(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    if (unlikely(! json_is_object(val)))
    {
        if (rep) jm_report_add_entry(rep, "not an object [.'$Prereqs'.'$Phase']", path);
        return false;
    }
    bool res;
    const char *prop;
    json_t *pval;
    json_object_foreach((json_t *) val, prop, pval)
    {
        jm_path_t lpath_6 = (jm_path_t) { prop, 0, path, NULL };
        if (jm_check_fun_string(json_model_14, prop, (path ? &lpath_6 : NULL), rep))
        {
            // handle 1 key props
            // .'$Prereqs'.'$Phase'.'$Relation'
            res = json_model_15(pval, (path ? &lpath_6 : NULL), rep);
            if (unlikely(! res))
            {
                if (rep) jm_report_add_entry(rep, "unexpected $Prereq [.'$Prereqs'.'$Phase'.'$Relation']", (path ? &lpath_6 : NULL));
                return false;
            }
        }
        else if (likely(_jm_re_1(prop, path, rep)))
            // handle 1 re props
            // .'$Prereqs'.'$Phase'.'/^[Xx]_/'
            res = true;
        else
        {
            if (rep) jm_report_add_entry(rep, "unexpected prop [.'$Prereqs'.'$Phase']", (path ? &lpath_6 : NULL));
            return false;
        }
    }
    return true;
}

// check $Prereqs (.'$Prereqs')
static bool json_model_16(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    // .'$Prereqs'
    if (unlikely(! json_is_object(val)))
    {
        if (rep) jm_report_add_entry(rep, "not an object [.'$Prereqs']", path);
        return false;
    }
    bool res;
    const char *prop;
    json_t *pval;
    json_object_foreach((json_t *) val, prop, pval)
    {
        jm_path_t lpath_5 = (jm_path_t) { prop, 0, path, NULL };
        if (jm_check_fun_string(json_model_13, prop, (path ? &lpath_5 : NULL), rep))
        {
            // handle 1 key props
            // .'$Prereqs'.'$Phase'
            res = _jm_obj_2(pval, (path ? &lpath_5 : NULL), rep);
            if (unlikely(! res))
            {
                if (rep) jm_report_add_entry(rep, "unexpected element [.'$Prereqs'.'$Phase']", (path ? &lpath_5 : NULL));
                return false;
            }
        }
        else if (likely(_jm_re_1(prop, path, rep)))
            // handle 1 re props
            // .'$Prereqs'.'/^[Xx]_/'
            res = true;
        else
        {
            if (rep) jm_report_add_entry(rep, "unexpected prop [.'$Prereqs']", (path ? &lpath_5 : NULL));
            return false;
        }
    }
    return true;
}

// object .license.'|'.2
static INLINE bool _jm_obj_3(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    if (unlikely(! json_is_object(val)))
    {
        if (rep) jm_report_add_entry(rep, "not an object [.license.'|'.2]", path);
        return false;
    }
    bool res;
    const char *prop;
    json_t *pval;
    json_object_foreach((json_t *) val, prop, pval)
    {
        jm_path_t lpath_8 = (jm_path_t) { prop, 0, path, NULL };
        // handle other props
        // .license.'|'.2.''
        res = jm_is_valid_url(json_string_value(pval), (path ? &lpath_8 : NULL), rep);
        if (unlikely(! res))
        {
            if (rep) jm_report_add_entry(rep, "unexpected $URL [.license.'|'.2.'']", (path ? &lpath_8 : NULL));
            return false;
        }
    }
    return true;
}

// object .provides
static INLINE bool _jm_obj_4(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    if (unlikely(! json_is_object(val)))
    {
        if (rep) jm_report_add_entry(rep, "not an object [.provides]", path);
        return false;
    }
    bool res;
    const char *prop;
    json_t *pval;
    json_object_foreach((json_t *) val, prop, pval)
    {
        jm_path_t lpath_9 = (jm_path_t) { prop, 0, path, NULL };
        // handle other props
        // .provides.''
        res = json_model_6(pval, (path ? &lpath_9 : NULL), rep);
        if (unlikely(! res))
        {
            if (rep) jm_report_add_entry(rep, "unexpected $Provide [.provides.'']", (path ? &lpath_9 : NULL));
            return false;
        }
    }
    return true;
}

// object .'meta-spec'
static INLINE bool _jm_obj_5(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    if (unlikely(! json_is_object(val)))
    {
        if (rep) jm_report_add_entry(rep, "not an object [.'meta-spec']", path);
        return false;
    }
    bool res;
    int64_t must_count = 0;
    const char *prop;
    json_t *pval;
    json_object_foreach((json_t *) val, prop, pval)
    {
        jm_path_t lpath_10 = (jm_path_t) { prop, 0, path, NULL };
        if (jm_str_eq_8(prop, 0x006e6f6973726576LL))
        {
            // handle must version property
            must_count += 1;
            // .'meta-spec'.version
            res = json_is_string(pval) && jm_str_eq_6(json_string_value(pval), 0x000000302e302e31LL);
            if (unlikely(! res))
            {
                if (rep) jm_report_add_entry(rep, "unexpected _1.0.0 [.'meta-spec'.version]", (path ? &lpath_10 : NULL));
                if (rep) jm_report_add_entry(rep, "invalid mandatory prop value [.'meta-spec'.version]", (path ? &lpath_10 : NULL));
                return false;
            }
        }
        else if (jm_str_eq_4(prop, 0x006c7275))
        {
            // handle may url property
            // .'meta-spec'.url
            res = jm_is_valid_url(json_string_value(pval), (path ? &lpath_10 : NULL), rep);
            if (unlikely(! res))
            {
                if (rep) jm_report_add_entry(rep, "unexpected $URL [.'meta-spec'.url]", (path ? &lpath_10 : NULL));
                if (rep) jm_report_add_entry(rep, "invalid optional prop value [.'meta-spec'.url]", (path ? &lpath_10 : NULL));
                return false;
            }
        }
        else if (likely(_jm_re_1(prop, path, rep)))
            // handle 1 re props
            // .'meta-spec'.'/^[Xx]_/'
            res = true;
        else
        {
            if (rep) jm_report_add_entry(rep, "unexpected prop [.'meta-spec']", (path ? &lpath_10 : NULL));
            return false;
        }
    }
    if (unlikely(must_count != 1))
    {
        if (likely(rep != NULL))
        {
            if (! (json_object_get(val, "version") != NULL))
            {
                if (rep) jm_report_add_entry(rep, "missing mandatory prop <version> [.'meta-spec']", path);
            }
        }
        return false;
    }
    return true;
}

// object .no_index
static INLINE bool _jm_obj_6(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    if (unlikely(! json_is_object(val)))
    {
        if (rep) jm_report_add_entry(rep, "not an object [.no_index]", path);
        return false;
    }
    bool res;
    const char *prop;
    json_t *pval;
    json_object_foreach((json_t *) val, prop, pval)
    {
        jm_path_t lpath_11 = (jm_path_t) { prop, 0, path, NULL };
        if (jm_str_eq_5(prop, 0x00000000656c6966LL))
        {
            // handle may file property
            // .no_index.file
            res = json_model_3(pval, (path ? &lpath_11 : NULL), rep);
            if (unlikely(! res))
            {
                if (rep) jm_report_add_entry(rep, "unexpected $neStrList [.no_index.file]", (path ? &lpath_11 : NULL));
                if (rep) jm_report_add_entry(rep, "invalid optional prop value [.no_index.file]", (path ? &lpath_11 : NULL));
                return false;
            }
        }
        else if (likely(jm_str_eq_8(prop, 0x726f746365726964LL) && jm_str_eq_2(prop + 8, 0x00000079)))
        {
            // handle may directory property
            // .no_index.directory
            res = json_model_3(pval, (path ? &lpath_11 : NULL), rep);
            if (unlikely(! res))
            {
                if (rep) jm_report_add_entry(rep, "unexpected $neStrList [.no_index.directory]", (path ? &lpath_11 : NULL));
                if (rep) jm_report_add_entry(rep, "invalid optional prop value [.no_index.directory]", (path ? &lpath_11 : NULL));
                return false;
            }
        }
        else
        {
            if (rep) jm_report_add_entry(rep, "unexpected prop [.no_index]", (path ? &lpath_11 : NULL));
            return false;
        }
    }
    return true;
}

// check $ (.)
static bool json_model_1(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    // .
    if (unlikely(! json_is_object(val)))
    {
        if (rep) jm_report_add_entry(rep, "not an object [.]", path);
        return false;
    }
    bool res;
    int64_t must_count = 0;
    const char *prop;
    json_t *pval;
    json_object_foreach((json_t *) val, prop, pval)
    {
        jm_path_t lpath_7 = (jm_path_t) { prop, 0, path, NULL };
        if (unlikely(jm_str_eq_5(prop, 0x00000000656d616eLL)))
        {
            // handle must name property
            must_count += 1;
            // .name
            res = json_model_2(pval, (path ? &lpath_7 : NULL), rep);
            if (unlikely(! res))
            {
                if (rep) jm_report_add_entry(rep, "unexpected $neStr [.name]", (path ? &lpath_7 : NULL));
                if (rep) jm_report_add_entry(rep, "invalid mandatory prop value [.name]", (path ? &lpath_7 : NULL));
                return false;
            }
        }
        else if (unlikely(jm_str_eq_8(prop, 0x0065736e6563696cLL)))
        {
            // handle must license property
            must_count += 1;
            // .license
            // .license.'|'.0
            res = json_model_4(pval, (path ? &lpath_7 : NULL), rep);
            if (unlikely(! res))
            {
                if (rep) jm_report_add_entry(rep, "unexpected $License [.license.'|'.0]", (path ? &lpath_7 : NULL));
            }
            if (! res)
            {
                // .license.'|'.1
                res = json_model_5(pval, (path ? &lpath_7 : NULL), rep);
                if (unlikely(! res))
                {
                    if (rep) jm_report_add_entry(rep, "unexpected $LicenseList [.license.'|'.1]", (path ? &lpath_7 : NULL));
                }
                if (! res)
                {
                    // .license.'|'.2
                    res = _jm_obj_3(pval, (path ? &lpath_7 : NULL), rep);
                    if (unlikely(! res))
                    {
                        if (rep) jm_report_add_entry(rep, "unexpected element [.license.'|'.2]", (path ? &lpath_7 : NULL));
                    }
                }
            }
            if (likely(res))
            {
                if (rep) jm_report_free_entries(rep);
            }
            else
            {
                if (rep) jm_report_add_entry(rep, "no model matched [.license.'|']", (path ? &lpath_7 : NULL));
                if (rep) jm_report_add_entry(rep, "invalid mandatory prop value [.license]", (path ? &lpath_7 : NULL));
                return false;
            }
        }
        else if (unlikely(jm_str_eq_8(prop, 0x006e6f6973726576LL)))
        {
            // handle must version property
            must_count += 1;
            // .version
            res = json_is_string(pval);
            if (unlikely(! res))
            {
                if (rep) jm_report_add_entry(rep, "unexpected string [.version]", (path ? &lpath_7 : NULL));
                if (rep) jm_report_add_entry(rep, "invalid mandatory prop value [.version]", (path ? &lpath_7 : NULL));
                return false;
            }
        }
        else if (unlikely(jm_str_eq_8(prop, 0x7463617274736261LL) && jm_str_eq_0(prop + 8)))
        {
            // handle must abstract property
            must_count += 1;
            // .abstract
            res = json_is_string(pval);
            if (unlikely(! res))
            {
                if (rep) jm_report_add_entry(rep, "unexpected string [.abstract]", (path ? &lpath_7 : NULL));
                if (rep) jm_report_add_entry(rep, "invalid mandatory prop value [.abstract]", (path ? &lpath_7 : NULL));
                return false;
            }
        }
        else if (unlikely(jm_str_eq_8(prop, 0x73656469766f7270LL) && jm_str_eq_0(prop + 8)))
        {
            // handle must provides property
            must_count += 1;
            // .provides
            res = _jm_obj_4(pval, (path ? &lpath_7 : NULL), rep);
            if (unlikely(! res))
            {
                if (rep) jm_report_add_entry(rep, "unexpected element [.provides]", (path ? &lpath_7 : NULL));
                if (rep) jm_report_add_entry(rep, "invalid mandatory prop value [.provides]", (path ? &lpath_7 : NULL));
                return false;
            }
        }
        else if (unlikely(jm_str_eq_8(prop, 0x6570732d6174656dLL) && jm_str_eq_2(prop + 8, 0x00000063)))
        {
            // handle must meta-spec property
            must_count += 1;
            // .'meta-spec'
            res = _jm_obj_5(pval, (path ? &lpath_7 : NULL), rep);
            if (unlikely(! res))
            {
                if (rep) jm_report_add_entry(rep, "unexpected element [.'meta-spec']", (path ? &lpath_7 : NULL));
                if (rep) jm_report_add_entry(rep, "invalid mandatory prop value [.'meta-spec']", (path ? &lpath_7 : NULL));
                return false;
            }
        }
        else if (unlikely(jm_str_eq_8(prop, 0x6e6961746e69616dLL) && jm_str_eq_3(prop + 8, 0x00007265)))
        {
            // handle must maintainer property
            must_count += 1;
            // .maintainer
            // .maintainer.'|'.0
            res = json_model_2(pval, (path ? &lpath_7 : NULL), rep);
            if (unlikely(! res))
            {
                if (rep) jm_report_add_entry(rep, "unexpected $neStr [.maintainer.'|'.0]", (path ? &lpath_7 : NULL));
            }
            if (! res)
            {
                // .maintainer.'|'.1
                res = json_model_3(pval, (path ? &lpath_7 : NULL), rep);
                if (unlikely(! res))
                {
                    if (rep) jm_report_add_entry(rep, "unexpected $neStrList [.maintainer.'|'.1]", (path ? &lpath_7 : NULL));
                }
            }
            if (likely(res))
            {
                if (rep) jm_report_free_entries(rep);
            }
            else
            {
                if (rep) jm_report_add_entry(rep, "no model matched [.maintainer.'|']", (path ? &lpath_7 : NULL));
                if (rep) jm_report_add_entry(rep, "invalid mandatory prop value [.maintainer]", (path ? &lpath_7 : NULL));
                return false;
            }
        }
        else if (unlikely(jm_str_eq_4(prop, 0x006c7275)))
        {
            // handle may url property
            // .url
            res = jm_is_valid_url(json_string_value(pval), (path ? &lpath_7 : NULL), rep);
            if (unlikely(! res))
            {
                if (rep) jm_report_add_entry(rep, "unexpected $URL [.url]", (path ? &lpath_7 : NULL));
                if (rep) jm_report_add_entry(rep, "invalid optional prop value [.url]", (path ? &lpath_7 : NULL));
                return false;
            }
        }
        else if (unlikely(jm_str_eq_5(prop, 0x0000000073676174LL)))
        {
            // handle may tags property
            // .tags
            res = json_model_3(pval, (path ? &lpath_7 : NULL), rep);
            if (unlikely(! res))
            {
                if (rep) jm_report_add_entry(rep, "unexpected $neStrList [.tags]", (path ? &lpath_7 : NULL));
                if (rep) jm_report_add_entry(rep, "invalid optional prop value [.tags]", (path ? &lpath_7 : NULL));
                return false;
            }
        }
        else if (unlikely(jm_str_eq_8(prop, 0x0073716572657270LL)))
        {
            // handle may prereqs property
            // .prereqs
            res = json_model_16(pval, (path ? &lpath_7 : NULL), rep);
            if (unlikely(! res))
            {
                if (rep) jm_report_add_entry(rep, "unexpected $Prereqs [.prereqs]", (path ? &lpath_7 : NULL));
                if (rep) jm_report_add_entry(rep, "invalid optional prop value [.prereqs]", (path ? &lpath_7 : NULL));
                return false;
            }
        }
        else if (unlikely(jm_str_eq_8(prop, 0x7865646e695f6f6eLL) && jm_str_eq_0(prop + 8)))
        {
            // handle may no_index property
            // .no_index
            res = _jm_obj_6(pval, (path ? &lpath_7 : NULL), rep);
            if (unlikely(! res))
            {
                if (rep) jm_report_add_entry(rep, "unexpected element [.no_index]", (path ? &lpath_7 : NULL));
                if (rep) jm_report_add_entry(rep, "invalid optional prop value [.no_index]", (path ? &lpath_7 : NULL));
                return false;
            }
        }
        else if (unlikely(jm_str_eq_8(prop, 0x656372756f736572LL) && jm_str_eq_2(prop + 8, 0x00000073)))
        {
            // handle may resources property
            // .resources
            res = json_model_8(pval, (path ? &lpath_7 : NULL), rep);
            if (unlikely(! res))
            {
                if (rep) jm_report_add_entry(rep, "unexpected $Resources [.resources]", (path ? &lpath_7 : NULL));
                if (rep) jm_report_add_entry(rep, "invalid optional prop value [.resources]", (path ? &lpath_7 : NULL));
                return false;
            }
        }
        else if (unlikely(jm_str_eq_8(prop, 0x7470697263736564LL) && jm_str_eq_4(prop + 8, 0x006e6f69)))
        {
            // handle may description property
            // .description
            res = json_is_string(pval);
            if (unlikely(! res))
            {
                if (rep) jm_report_add_entry(rep, "unexpected string [.description]", (path ? &lpath_7 : NULL));
                if (rep) jm_report_add_entry(rep, "invalid optional prop value [.description]", (path ? &lpath_7 : NULL));
                return false;
            }
        }
        else if (unlikely(jm_str_eq_8(prop, 0x65746172656e6567LL) && jm_str_eq_5(prop + 8, 0x0000000079625f64LL)))
        {
            // handle may generated_by property
            // .generated_by
            res = json_is_string(pval);
            if (unlikely(! res))
            {
                if (rep) jm_report_add_entry(rep, "unexpected string [.generated_by]", (path ? &lpath_7 : NULL));
                if (rep) jm_report_add_entry(rep, "invalid optional prop value [.generated_by]", (path ? &lpath_7 : NULL));
                return false;
            }
        }
        else if (jm_str_eq_8(prop, 0x5f657361656c6572LL) && jm_str_eq_7(prop + 8, 0x0000737574617473LL))
        {
            // handle may release_status property
            // .release_status
            res = json_model_7(pval, (path ? &lpath_7 : NULL), rep);
            if (unlikely(! res))
            {
                if (rep) jm_report_add_entry(rep, "unexpected $Status [.release_status]", (path ? &lpath_7 : NULL));
                if (rep) jm_report_add_entry(rep, "invalid optional prop value [.release_status]", (path ? &lpath_7 : NULL));
                return false;
            }
        }
        else if (likely(_jm_re_1(prop, path, rep)))
            // handle 1 re props
            // .'/^[Xx]_/'
            res = true;
        else
        {
            if (rep) jm_report_add_entry(rep, "unexpected prop [.]", (path ? &lpath_7 : NULL));
            return false;
        }
    }
    if (unlikely(must_count != 7))
    {
        if (likely(rep != NULL))
        {
            if (! (json_object_get(val, "abstract") != NULL))
            {
                if (rep) jm_report_add_entry(rep, "missing mandatory prop <abstract> [.]", path);
            }
            if (! (json_object_get(val, "license") != NULL))
            {
                if (rep) jm_report_add_entry(rep, "missing mandatory prop <license> [.]", path);
            }
            if (! (json_object_get(val, "maintainer") != NULL))
            {
                if (rep) jm_report_add_entry(rep, "missing mandatory prop <maintainer> [.]", path);
            }
            if (! (json_object_get(val, "meta-spec") != NULL))
            {
                if (rep) jm_report_add_entry(rep, "missing mandatory prop <meta-spec> [.]", path);
            }
            if (! (json_object_get(val, "name") != NULL))
            {
                if (rep) jm_report_add_entry(rep, "missing mandatory prop <name> [.]", path);
            }
            if (! (json_object_get(val, "provides") != NULL))
            {
                if (rep) jm_report_add_entry(rep, "missing mandatory prop <provides> [.]", path);
            }
            if (! (json_object_get(val, "version") != NULL))
            {
                if (rep) jm_report_add_entry(rep, "missing mandatory prop <version> [.]", path);
            }
        }
        return false;
    }
    return true;
}

jm_check_fun_t check_model_map(const char *pname)
{
    return jm_search_propmap(pname, check_model_map_tab, 16);
}

static bool initialized = false;

const char *check_model_init(void)
{
    if (!initialized)
    {
        initialized = true;
        jm_version_string = JSON_MODEL_VERSION;
        _jm_re_0_re2 = cre2_new(".", strlen("."), NULL);
        if (cre2_error_code(_jm_re_0_re2))
            return cre2_error_string(_jm_re_0_re2);
        _jm_re_0_nn = cre2_num_capturing_groups(_jm_re_0_re2) + 1;
        _jm_re_1_re2 = cre2_new("^[Xx]_", strlen("^[Xx]_"), NULL);
        if (cre2_error_code(_jm_re_1_re2))
            return cre2_error_string(_jm_re_1_re2);
        _jm_re_1_nn = cre2_num_capturing_groups(_jm_re_1_re2) + 1;
        _jm_re_2_re2 = cre2_new("^\\d+\\.\\d+\\.\\d+[-_A-Za-z0-9]*$", strlen("^\\d+\\.\\d+\\.\\d+[-_A-Za-z0-9]*$"), NULL);
        if (cre2_error_code(_jm_re_2_re2))
            return cre2_error_string(_jm_re_2_re2);
        _jm_re_2_nn = cre2_num_capturing_groups(_jm_re_2_re2) + 1;
        _jm_re_3_re2 = cre2_new("^(<=|<|>=|>|!=|==)$", strlen("^(<=|<|>=|>|!=|==)$"), NULL);
        if (cre2_error_code(_jm_re_3_re2))
            return cre2_error_string(_jm_re_3_re2);
        _jm_re_3_nn = cre2_num_capturing_groups(_jm_re_3_re2) + 1;
        _jm_re_4_re2 = cre2_new("^\\s*(<=|<|>=|>|!=|==)\\s*(\\d+\\.\\d+\\.\\d+[-_A-Za-z0-9]*)\\s*(,\\s*(<=|<|>=|>|!=|==)\\s*(\\d+\\.\\d+\\.\\d+[-_A-Za-z0-9]*))*\\s*$", strlen("^\\s*(<=|<|>=|>|!=|==)\\s*(\\d+\\.\\d+\\.\\d+[-_A-Za-z0-9]*)\\s*(,\\s*(<=|<|>=|>|!=|==)\\s*(\\d+\\.\\d+\\.\\d+[-_A-Za-z0-9]*))*\\s*$"), NULL);
        if (cre2_error_code(_jm_re_4_re2))
            return cre2_error_string(_jm_re_4_re2);
        _jm_re_4_nn = cre2_num_capturing_groups(_jm_re_4_re2) + 1;
        check_model_map_tab[0] = (jm_propmap_t) { "", json_model_1 };
        check_model_map_tab[1] = (jm_propmap_t) { "neStr", json_model_2 };
        check_model_map_tab[2] = (jm_propmap_t) { "neStrList", json_model_3 };
        check_model_map_tab[3] = (jm_propmap_t) { "License", json_model_4 };
        check_model_map_tab[4] = (jm_propmap_t) { "LicenseList", json_model_5 };
        check_model_map_tab[5] = (jm_propmap_t) { "Provide", json_model_6 };
        check_model_map_tab[6] = (jm_propmap_t) { "Status", json_model_7 };
        check_model_map_tab[7] = (jm_propmap_t) { "Resources", json_model_8 };
        check_model_map_tab[8] = (jm_propmap_t) { "SemVer", json_model_9 };
        check_model_map_tab[9] = (jm_propmap_t) { "Version", json_model_10 };
        check_model_map_tab[10] = (jm_propmap_t) { "Ops", json_model_11 };
        check_model_map_tab[11] = (jm_propmap_t) { "VersionRange", json_model_12 };
        check_model_map_tab[12] = (jm_propmap_t) { "Phase", json_model_13 };
        check_model_map_tab[13] = (jm_propmap_t) { "Relation", json_model_14 };
        check_model_map_tab[14] = (jm_propmap_t) { "Prereq", json_model_15 };
        check_model_map_tab[15] = (jm_propmap_t) { "Prereqs", json_model_16 };
        jm_sort_propmap(check_model_map_tab, 16);
    }
    return NULL;
}

void check_model_free(void)
{
    if (initialized)
    {
        initialized = false;

        // cleanup code
        cre2_delete(_jm_re_0_re2);
        _jm_re_0_re2 = NULL;
        _jm_re_0_nn = 0;
        cre2_delete(_jm_re_1_re2);
        _jm_re_1_re2 = NULL;
        _jm_re_1_nn = 0;
        cre2_delete(_jm_re_2_re2);
        _jm_re_2_re2 = NULL;
        _jm_re_2_nn = 0;
        cre2_delete(_jm_re_3_re2);
        _jm_re_3_re2 = NULL;
        _jm_re_3_nn = 0;
        cre2_delete(_jm_re_4_re2);
        _jm_re_4_re2 = NULL;
        _jm_re_4_nn = 0;
    }
}

/*
 * # API
 *
 * ```c
 * bool error;
 * char *message;
 *
 * bool valid = check(json_value, "model-name", &error, &message);
 *
 * if (message)
 *    free(message), message = NULL;
 * ```
 *
 * - `error` is set of there was an error during initialization or if the model does not exists.
 * - `message` is provided if a non NULL pointer is passed, and must be freed by the caller.
 */
bool
check_model(const json_t *val, const char *name, bool *error, char **reasons)
{
    return jm_generic_entry(check_model_init, check_model_map, val, name, error, reasons);
}
