//
// Generated by JSON Model Compiler version 2
// see https://github.com/clairey-zx81/json-model
//

// regular expression engine
#include <stddef.h>
#include <cre2.h>

#include <json-model.h>
#define JSON_MODEL_VERSION "2"

static bool json_model_2(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool json_model_3(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool json_model_4(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool json_model_5(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool json_model_6(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool json_model_7(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool json_model_8(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool json_model_9(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool json_model_10(const json_t *val, jm_path_t *path, jm_report_t *rep);
static jm_constmap_t _jm_map_0_tab[6];
static bool json_model_11(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool json_model_12(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_obj_0(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool json_model_13(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool json_model_14(const json_t *val, jm_path_t *path, jm_report_t *rep);
static jm_constmap_t _jm_map_1_tab[3];
static bool json_model_1(const json_t *val, jm_path_t *path, jm_report_t *rep);
jm_propmap_t check_model_map_tab[14];
const size_t check_model_map_size = 14;

// check $position (.'$position')
static bool json_model_2(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .'$position'
    // .'$position'.'@'
    res = json_is_array(val);
    if (res)
    {
        size_t arr_0_idx;
        json_t *arr_0_item;
        json_array_foreach(val, arr_0_idx, arr_0_item)
        {
            jm_path_t arr_0_lpath = (jm_path_t) { NULL, arr_0_idx, path, NULL };
            // .'$position'.'@'.0
            res = json_is_number(arr_0_item);
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "not a -1.0 loose float [.'$position'.'@'.0]", (path ? &arr_0_lpath : NULL));
                break;
            }
        }
    }
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "not array or unexpected array [.'$position'.'@']", path);
    }
    if (res)
    {
        int64_t ival_0 = json_array_size(val);
        res = ival_0 <= 3 && ival_0 >= 2;
        if (! res)
        {
            if (rep) jm_report_add_entry(rep, "constraints failed [.'$position']", path);
        }
    }
    return res;
}

// check $coord_array (.'$coord_array')
static bool json_model_3(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .'$coord_array'
    // .'$coord_array'.'@'
    res = json_is_array(val);
    if (res)
    {
        size_t arr_1_idx;
        json_t *arr_1_item;
        json_array_foreach(val, arr_1_idx, arr_1_item)
        {
            jm_path_t arr_1_lpath = (jm_path_t) { NULL, arr_1_idx, path, NULL };
            // .'$coord_array'.'@'.0
            res = json_model_2(arr_1_item, (path ? &arr_1_lpath : NULL), rep);
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "unexpected $position [.'$coord_array'.'@'.0]", (path ? &arr_1_lpath : NULL));
                break;
            }
        }
    }
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "not array or unexpected array [.'$coord_array'.'@']", path);
    }
    if (res)
    {
        int64_t ival_1 = json_array_size(val);
        res = ival_1 >= 2;
        if (! res)
        {
            if (rep) jm_report_add_entry(rep, "constraints failed [.'$coord_array']", path);
        }
    }
    return res;
}

// check $linear_ring (.'$linear_ring')
static bool json_model_4(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .'$linear_ring'
    // .'$linear_ring'.'@'
    res = json_is_array(val);
    if (res)
    {
        size_t arr_2_idx;
        json_t *arr_2_item;
        json_array_foreach(val, arr_2_idx, arr_2_item)
        {
            jm_path_t arr_2_lpath = (jm_path_t) { NULL, arr_2_idx, path, NULL };
            // .'$linear_ring'.'@'.0
            res = json_model_2(arr_2_item, (path ? &arr_2_lpath : NULL), rep);
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "unexpected $position [.'$linear_ring'.'@'.0]", (path ? &arr_2_lpath : NULL));
                break;
            }
        }
    }
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "not array or unexpected array [.'$linear_ring'.'@']", path);
    }
    if (res)
    {
        int64_t ival_2 = json_array_size(val);
        res = ival_2 >= 4;
        if (! res)
        {
            if (rep) jm_report_add_entry(rep, "constraints failed [.'$linear_ring']", path);
        }
    }
    return res;
}

// check $Point (.'$Point')
static bool json_model_5(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    // .'$Point'
    // check open must/may only props
    if (! json_is_object(val))
    {
        if (rep) jm_report_add_entry(rep, "not an object [.'$Point']", path);
        return false;
    }
    jm_path_t lpath;
    json_t * pval;
    bool res;
    if (! ((pval = json_object_get(val, "type")) != NULL))
    {
        if (rep) jm_report_add_entry(rep, "missing mandatory prop <type> [.'$Point']", path);
        return false;
    }
    lpath = (jm_path_t) { "type", 0, path, NULL };
    // .'$Point'.type
    res = json_is_string(pval) && jm_str_eq_6(json_string_value(pval), 0x000000746e696f50LL);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected Point [.'$Point'.type]", (path ? &lpath : NULL));
        if (rep) jm_report_add_entry(rep, "unexpected value for mandatory prop <type> [.'$Point']", (path ? &lpath : NULL));
        return false;
    }
    if (! ((pval = json_object_get(val, "coordinates")) != NULL))
    {
        if (rep) jm_report_add_entry(rep, "missing mandatory prop <coordinates> [.'$Point']", path);
        return false;
    }
    lpath = (jm_path_t) { "coordinates", 0, path, NULL };
    // .'$Point'.coordinates
    res = json_model_2(pval, (path ? &lpath : NULL), rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected $position [.'$Point'.coordinates]", (path ? &lpath : NULL));
        if (rep) jm_report_add_entry(rep, "unexpected value for mandatory prop <coordinates> [.'$Point']", (path ? &lpath : NULL));
        return false;
    }
    if ((pval = json_object_get(val, "bbox")) != NULL)
    {
        lpath = (jm_path_t) { "bbox", 0, path, NULL };
        // .'$Point'.bbox
        res = json_is_array(pval);
        if (res)
        {
            size_t arr_3_idx;
            json_t *arr_3_item;
            json_array_foreach(pval, arr_3_idx, arr_3_item)
            {
                jm_path_t arr_3_lpath = (jm_path_t) { NULL, arr_3_idx, (path ? &lpath : NULL), NULL };
                // .'$Point'.bbox.0
                res = json_is_number(arr_3_item);
                if (! res)
                {
                    if (rep) jm_report_add_entry(rep, "not a -1.0 loose float [.'$Point'.bbox.0]", ((path ? &lpath : NULL) ? &arr_3_lpath : NULL));
                    break;
                }
            }
        }
        if (! res)
        {
            if (rep) jm_report_add_entry(rep, "not array or unexpected array [.'$Point'.bbox]", (path ? &lpath : NULL));
            if (rep) jm_report_add_entry(rep, "unexpected value for optional prop <bbox> [.'$Point']", (path ? &lpath : NULL));
            return false;
        }
    }
    return true;
}

// check $MultiPoint (.'$MultiPoint')
static bool json_model_6(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    // .'$MultiPoint'
    // check open must/may only props
    if (! json_is_object(val))
    {
        if (rep) jm_report_add_entry(rep, "not an object [.'$MultiPoint']", path);
        return false;
    }
    jm_path_t lpath;
    json_t * pval;
    bool res;
    if (! ((pval = json_object_get(val, "type")) != NULL))
    {
        if (rep) jm_report_add_entry(rep, "missing mandatory prop <type> [.'$MultiPoint']", path);
        return false;
    }
    lpath = (jm_path_t) { "type", 0, path, NULL };
    // .'$MultiPoint'.type
    res = json_is_string(pval) && jm_str_eq_8(json_string_value(pval), 0x696f5069746c754dLL) && jm_str_eq_3(json_string_value(pval) + 8, 0x0000746e);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected MultiPoint [.'$MultiPoint'.type]", (path ? &lpath : NULL));
        if (rep) jm_report_add_entry(rep, "unexpected value for mandatory prop <type> [.'$MultiPoint']", (path ? &lpath : NULL));
        return false;
    }
    if (! ((pval = json_object_get(val, "coordinates")) != NULL))
    {
        if (rep) jm_report_add_entry(rep, "missing mandatory prop <coordinates> [.'$MultiPoint']", path);
        return false;
    }
    lpath = (jm_path_t) { "coordinates", 0, path, NULL };
    // .'$MultiPoint'.coordinates
    res = json_is_array(pval);
    if (res)
    {
        size_t arr_4_idx;
        json_t *arr_4_item;
        json_array_foreach(pval, arr_4_idx, arr_4_item)
        {
            jm_path_t arr_4_lpath = (jm_path_t) { NULL, arr_4_idx, (path ? &lpath : NULL), NULL };
            // .'$MultiPoint'.coordinates.0
            res = json_model_2(arr_4_item, ((path ? &lpath : NULL) ? &arr_4_lpath : NULL), rep);
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "unexpected $position [.'$MultiPoint'.coordinates.0]", ((path ? &lpath : NULL) ? &arr_4_lpath : NULL));
                break;
            }
        }
    }
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "not array or unexpected array [.'$MultiPoint'.coordinates]", (path ? &lpath : NULL));
        if (rep) jm_report_add_entry(rep, "unexpected value for mandatory prop <coordinates> [.'$MultiPoint']", (path ? &lpath : NULL));
        return false;
    }
    if ((pval = json_object_get(val, "bbox")) != NULL)
    {
        lpath = (jm_path_t) { "bbox", 0, path, NULL };
        // .'$MultiPoint'.bbox
        res = json_is_array(pval);
        if (res)
        {
            size_t arr_5_idx;
            json_t *arr_5_item;
            json_array_foreach(pval, arr_5_idx, arr_5_item)
            {
                jm_path_t arr_5_lpath = (jm_path_t) { NULL, arr_5_idx, (path ? &lpath : NULL), NULL };
                // .'$MultiPoint'.bbox.0
                res = json_is_number(arr_5_item);
                if (! res)
                {
                    if (rep) jm_report_add_entry(rep, "not a -1.0 loose float [.'$MultiPoint'.bbox.0]", ((path ? &lpath : NULL) ? &arr_5_lpath : NULL));
                    break;
                }
            }
        }
        if (! res)
        {
            if (rep) jm_report_add_entry(rep, "not array or unexpected array [.'$MultiPoint'.bbox]", (path ? &lpath : NULL));
            if (rep) jm_report_add_entry(rep, "unexpected value for optional prop <bbox> [.'$MultiPoint']", (path ? &lpath : NULL));
            return false;
        }
    }
    return true;
}

// check $LineString (.'$LineString')
static bool json_model_7(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    // .'$LineString'
    // check open must/may only props
    if (! json_is_object(val))
    {
        if (rep) jm_report_add_entry(rep, "not an object [.'$LineString']", path);
        return false;
    }
    jm_path_t lpath;
    json_t * pval;
    bool res;
    if (! ((pval = json_object_get(val, "type")) != NULL))
    {
        if (rep) jm_report_add_entry(rep, "missing mandatory prop <type> [.'$LineString']", path);
        return false;
    }
    lpath = (jm_path_t) { "type", 0, path, NULL };
    // .'$LineString'.type
    res = json_is_string(pval) && jm_str_eq_8(json_string_value(pval), 0x69727453656e694cLL) && jm_str_eq_3(json_string_value(pval) + 8, 0x0000676e);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected LineString [.'$LineString'.type]", (path ? &lpath : NULL));
        if (rep) jm_report_add_entry(rep, "unexpected value for mandatory prop <type> [.'$LineString']", (path ? &lpath : NULL));
        return false;
    }
    if (! ((pval = json_object_get(val, "coordinates")) != NULL))
    {
        if (rep) jm_report_add_entry(rep, "missing mandatory prop <coordinates> [.'$LineString']", path);
        return false;
    }
    lpath = (jm_path_t) { "coordinates", 0, path, NULL };
    // .'$LineString'.coordinates
    res = json_model_3(pval, (path ? &lpath : NULL), rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected $coord_array [.'$LineString'.coordinates]", (path ? &lpath : NULL));
        if (rep) jm_report_add_entry(rep, "unexpected value for mandatory prop <coordinates> [.'$LineString']", (path ? &lpath : NULL));
        return false;
    }
    if ((pval = json_object_get(val, "bbox")) != NULL)
    {
        lpath = (jm_path_t) { "bbox", 0, path, NULL };
        // .'$LineString'.bbox
        res = json_is_array(pval);
        if (res)
        {
            size_t arr_6_idx;
            json_t *arr_6_item;
            json_array_foreach(pval, arr_6_idx, arr_6_item)
            {
                jm_path_t arr_6_lpath = (jm_path_t) { NULL, arr_6_idx, (path ? &lpath : NULL), NULL };
                // .'$LineString'.bbox.0
                res = json_is_number(arr_6_item);
                if (! res)
                {
                    if (rep) jm_report_add_entry(rep, "not a -1.0 loose float [.'$LineString'.bbox.0]", ((path ? &lpath : NULL) ? &arr_6_lpath : NULL));
                    break;
                }
            }
        }
        if (! res)
        {
            if (rep) jm_report_add_entry(rep, "not array or unexpected array [.'$LineString'.bbox]", (path ? &lpath : NULL));
            if (rep) jm_report_add_entry(rep, "unexpected value for optional prop <bbox> [.'$LineString']", (path ? &lpath : NULL));
            return false;
        }
    }
    return true;
}

// check $MultiLineString (.'$MultiLineString')
static bool json_model_8(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    // .'$MultiLineString'
    // check open must/may only props
    if (! json_is_object(val))
    {
        if (rep) jm_report_add_entry(rep, "not an object [.'$MultiLineString']", path);
        return false;
    }
    jm_path_t lpath;
    json_t * pval;
    bool res;
    if (! ((pval = json_object_get(val, "type")) != NULL))
    {
        if (rep) jm_report_add_entry(rep, "missing mandatory prop <type> [.'$MultiLineString']", path);
        return false;
    }
    lpath = (jm_path_t) { "type", 0, path, NULL };
    // .'$MultiLineString'.type
    res = json_is_string(pval) && jm_str_eq_8(json_string_value(pval), 0x6e694c69746c754dLL) && jm_str_eq_8(json_string_value(pval) + 8, 0x00676e6972745365LL);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected MultiLineString [.'$MultiLineString'.type]", (path ? &lpath : NULL));
        if (rep) jm_report_add_entry(rep, "unexpected value for mandatory prop <type> [.'$MultiLineString']", (path ? &lpath : NULL));
        return false;
    }
    if (! ((pval = json_object_get(val, "coordinates")) != NULL))
    {
        if (rep) jm_report_add_entry(rep, "missing mandatory prop <coordinates> [.'$MultiLineString']", path);
        return false;
    }
    lpath = (jm_path_t) { "coordinates", 0, path, NULL };
    // .'$MultiLineString'.coordinates
    res = json_is_array(pval);
    if (res)
    {
        size_t arr_7_idx;
        json_t *arr_7_item;
        json_array_foreach(pval, arr_7_idx, arr_7_item)
        {
            jm_path_t arr_7_lpath = (jm_path_t) { NULL, arr_7_idx, (path ? &lpath : NULL), NULL };
            // .'$MultiLineString'.coordinates.0
            res = json_model_3(arr_7_item, ((path ? &lpath : NULL) ? &arr_7_lpath : NULL), rep);
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "unexpected $coord_array [.'$MultiLineString'.coordinates.0]", ((path ? &lpath : NULL) ? &arr_7_lpath : NULL));
                break;
            }
        }
    }
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "not array or unexpected array [.'$MultiLineString'.coordinates]", (path ? &lpath : NULL));
        if (rep) jm_report_add_entry(rep, "unexpected value for mandatory prop <coordinates> [.'$MultiLineString']", (path ? &lpath : NULL));
        return false;
    }
    if ((pval = json_object_get(val, "bbox")) != NULL)
    {
        lpath = (jm_path_t) { "bbox", 0, path, NULL };
        // .'$MultiLineString'.bbox
        res = json_is_array(pval);
        if (res)
        {
            size_t arr_8_idx;
            json_t *arr_8_item;
            json_array_foreach(pval, arr_8_idx, arr_8_item)
            {
                jm_path_t arr_8_lpath = (jm_path_t) { NULL, arr_8_idx, (path ? &lpath : NULL), NULL };
                // .'$MultiLineString'.bbox.0
                res = json_is_number(arr_8_item);
                if (! res)
                {
                    if (rep) jm_report_add_entry(rep, "not a -1.0 loose float [.'$MultiLineString'.bbox.0]", ((path ? &lpath : NULL) ? &arr_8_lpath : NULL));
                    break;
                }
            }
        }
        if (! res)
        {
            if (rep) jm_report_add_entry(rep, "not array or unexpected array [.'$MultiLineString'.bbox]", (path ? &lpath : NULL));
            if (rep) jm_report_add_entry(rep, "unexpected value for optional prop <bbox> [.'$MultiLineString']", (path ? &lpath : NULL));
            return false;
        }
    }
    return true;
}

// check $Polygon (.'$Polygon')
static bool json_model_9(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    // .'$Polygon'
    // check open must/may only props
    if (! json_is_object(val))
    {
        if (rep) jm_report_add_entry(rep, "not an object [.'$Polygon']", path);
        return false;
    }
    jm_path_t lpath;
    json_t * pval;
    bool res;
    if (! ((pval = json_object_get(val, "type")) != NULL))
    {
        if (rep) jm_report_add_entry(rep, "missing mandatory prop <type> [.'$Polygon']", path);
        return false;
    }
    lpath = (jm_path_t) { "type", 0, path, NULL };
    // .'$Polygon'.type
    res = json_is_string(pval) && jm_str_eq_8(json_string_value(pval), 0x006e6f67796c6f50LL);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected Polygon [.'$Polygon'.type]", (path ? &lpath : NULL));
        if (rep) jm_report_add_entry(rep, "unexpected value for mandatory prop <type> [.'$Polygon']", (path ? &lpath : NULL));
        return false;
    }
    if (! ((pval = json_object_get(val, "coordinates")) != NULL))
    {
        if (rep) jm_report_add_entry(rep, "missing mandatory prop <coordinates> [.'$Polygon']", path);
        return false;
    }
    lpath = (jm_path_t) { "coordinates", 0, path, NULL };
    // .'$Polygon'.coordinates
    res = json_is_array(pval);
    if (res)
    {
        size_t arr_9_idx;
        json_t *arr_9_item;
        json_array_foreach(pval, arr_9_idx, arr_9_item)
        {
            jm_path_t arr_9_lpath = (jm_path_t) { NULL, arr_9_idx, (path ? &lpath : NULL), NULL };
            // .'$Polygon'.coordinates.0
            res = json_model_4(arr_9_item, ((path ? &lpath : NULL) ? &arr_9_lpath : NULL), rep);
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "unexpected $linear_ring [.'$Polygon'.coordinates.0]", ((path ? &lpath : NULL) ? &arr_9_lpath : NULL));
                break;
            }
        }
    }
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "not array or unexpected array [.'$Polygon'.coordinates]", (path ? &lpath : NULL));
        if (rep) jm_report_add_entry(rep, "unexpected value for mandatory prop <coordinates> [.'$Polygon']", (path ? &lpath : NULL));
        return false;
    }
    if ((pval = json_object_get(val, "bbox")) != NULL)
    {
        lpath = (jm_path_t) { "bbox", 0, path, NULL };
        // .'$Polygon'.bbox
        res = json_is_array(pval);
        if (res)
        {
            size_t arr_10_idx;
            json_t *arr_10_item;
            json_array_foreach(pval, arr_10_idx, arr_10_item)
            {
                jm_path_t arr_10_lpath = (jm_path_t) { NULL, arr_10_idx, (path ? &lpath : NULL), NULL };
                // .'$Polygon'.bbox.0
                res = json_is_number(arr_10_item);
                if (! res)
                {
                    if (rep) jm_report_add_entry(rep, "not a -1.0 loose float [.'$Polygon'.bbox.0]", ((path ? &lpath : NULL) ? &arr_10_lpath : NULL));
                    break;
                }
            }
        }
        if (! res)
        {
            if (rep) jm_report_add_entry(rep, "not array or unexpected array [.'$Polygon'.bbox]", (path ? &lpath : NULL));
            if (rep) jm_report_add_entry(rep, "unexpected value for optional prop <bbox> [.'$Polygon']", (path ? &lpath : NULL));
            return false;
        }
    }
    return true;
}

// check $MultiPolygon (.'$MultiPolygon')
static bool json_model_10(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    // .'$MultiPolygon'
    // check open must/may only props
    if (! json_is_object(val))
    {
        if (rep) jm_report_add_entry(rep, "not an object [.'$MultiPolygon']", path);
        return false;
    }
    jm_path_t lpath;
    json_t * pval;
    bool res;
    if (! ((pval = json_object_get(val, "type")) != NULL))
    {
        if (rep) jm_report_add_entry(rep, "missing mandatory prop <type> [.'$MultiPolygon']", path);
        return false;
    }
    lpath = (jm_path_t) { "type", 0, path, NULL };
    // .'$MultiPolygon'.type
    res = json_is_string(pval) && jm_str_eq_8(json_string_value(pval), 0x6c6f5069746c754dLL) && jm_str_eq_5(json_string_value(pval) + 8, 0x000000006e6f6779LL);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected MultiPolygon [.'$MultiPolygon'.type]", (path ? &lpath : NULL));
        if (rep) jm_report_add_entry(rep, "unexpected value for mandatory prop <type> [.'$MultiPolygon']", (path ? &lpath : NULL));
        return false;
    }
    if (! ((pval = json_object_get(val, "coordinates")) != NULL))
    {
        if (rep) jm_report_add_entry(rep, "missing mandatory prop <coordinates> [.'$MultiPolygon']", path);
        return false;
    }
    lpath = (jm_path_t) { "coordinates", 0, path, NULL };
    // .'$MultiPolygon'.coordinates
    res = json_is_array(pval);
    if (res)
    {
        size_t arr_11_idx;
        json_t *arr_11_item;
        json_array_foreach(pval, arr_11_idx, arr_11_item)
        {
            jm_path_t arr_11_lpath = (jm_path_t) { NULL, arr_11_idx, (path ? &lpath : NULL), NULL };
            // .'$MultiPolygon'.coordinates.0
            res = json_is_array(arr_11_item);
            if (res)
            {
                size_t arr_12_idx;
                json_t *arr_12_item;
                json_array_foreach(arr_11_item, arr_12_idx, arr_12_item)
                {
                    jm_path_t arr_12_lpath = (jm_path_t) { NULL, arr_12_idx, ((path ? &lpath : NULL) ? &arr_11_lpath : NULL), NULL };
                    // .'$MultiPolygon'.coordinates.0.0
                    res = json_model_4(arr_12_item, (((path ? &lpath : NULL) ? &arr_11_lpath : NULL) ? &arr_12_lpath : NULL), rep);
                    if (! res)
                    {
                        if (rep) jm_report_add_entry(rep, "unexpected $linear_ring [.'$MultiPolygon'.coordinates.0.0]", (((path ? &lpath : NULL) ? &arr_11_lpath : NULL) ? &arr_12_lpath : NULL));
                        break;
                    }
                }
            }
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "not array or unexpected array [.'$MultiPolygon'.coordinates.0]", ((path ? &lpath : NULL) ? &arr_11_lpath : NULL));
                break;
            }
        }
    }
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "not array or unexpected array [.'$MultiPolygon'.coordinates]", (path ? &lpath : NULL));
        if (rep) jm_report_add_entry(rep, "unexpected value for mandatory prop <coordinates> [.'$MultiPolygon']", (path ? &lpath : NULL));
        return false;
    }
    if ((pval = json_object_get(val, "bbox")) != NULL)
    {
        lpath = (jm_path_t) { "bbox", 0, path, NULL };
        // .'$MultiPolygon'.bbox
        res = json_is_array(pval);
        if (res)
        {
            size_t arr_13_idx;
            json_t *arr_13_item;
            json_array_foreach(pval, arr_13_idx, arr_13_item)
            {
                jm_path_t arr_13_lpath = (jm_path_t) { NULL, arr_13_idx, (path ? &lpath : NULL), NULL };
                // .'$MultiPolygon'.bbox.0
                res = json_is_number(arr_13_item);
                if (! res)
                {
                    if (rep) jm_report_add_entry(rep, "not a -1.0 loose float [.'$MultiPolygon'.bbox.0]", ((path ? &lpath : NULL) ? &arr_13_lpath : NULL));
                    break;
                }
            }
        }
        if (! res)
        {
            if (rep) jm_report_add_entry(rep, "not array or unexpected array [.'$MultiPolygon'.bbox]", (path ? &lpath : NULL));
            if (rep) jm_report_add_entry(rep, "unexpected value for optional prop <bbox> [.'$MultiPolygon']", (path ? &lpath : NULL));
            return false;
        }
    }
    return true;
}

static INLINE jm_check_fun_t _jm_map_0(json_t *val)
{
    jm_constant_t cst;
    jm_set_cst(&cst, val);
    return jm_search_constmap(&cst, _jm_map_0_tab, 6);
}

// check $geometry (.'$geometry')
static bool json_model_11(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .'$geometry'
    bool iso_0 = json_is_object(val);
    res = iso_0;
    if (res)
    {
        if (json_object_get(val, "type") != NULL)
        {
            json_t * tag_0 = json_object_get(val, "type");
            jm_check_fun_t fun_0 = _jm_map_0(tag_0);
            if (fun_0 != NULL)
                res = fun_0(val, path, rep);
            else
            {
                res = false;
                if (rep) jm_report_add_entry(rep, "tag <type> value not found [.'$geometry'.'|']", path);
            }
        }
        else
        {
            res = false;
            if (rep) jm_report_add_entry(rep, "tag prop <type> is missing [.'$geometry'.'|']", path);
        }
    }
    else
    {
        if (rep) jm_report_add_entry(rep, "value is not an object [.'$geometry'.'|']", path);
    }
    return res;
}

// check $GeometryCollection (.'$GeometryCollection')
static bool json_model_12(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    // .'$GeometryCollection'
    // check open must/may only props
    if (! json_is_object(val))
    {
        if (rep) jm_report_add_entry(rep, "not an object [.'$GeometryCollection']", path);
        return false;
    }
    jm_path_t lpath;
    json_t * pval;
    bool res;
    if (! ((pval = json_object_get(val, "type")) != NULL))
    {
        if (rep) jm_report_add_entry(rep, "missing mandatory prop <type> [.'$GeometryCollection']", path);
        return false;
    }
    lpath = (jm_path_t) { "type", 0, path, NULL };
    // .'$GeometryCollection'.type
    res = json_is_string(pval) && jm_str_eq_8(json_string_value(pval), 0x797274656d6f6547LL) && jm_str_eq_8(json_string_value(pval) + 8, 0x697463656c6c6f43LL) && jm_str_eq_3(json_string_value(pval) + 16, 0x00006e6f);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected GeometryCollection [.'$GeometryCollection'.type]", (path ? &lpath : NULL));
        if (rep) jm_report_add_entry(rep, "unexpected value for mandatory prop <type> [.'$GeometryCollection']", (path ? &lpath : NULL));
        return false;
    }
    if (! ((pval = json_object_get(val, "geometries")) != NULL))
    {
        if (rep) jm_report_add_entry(rep, "missing mandatory prop <geometries> [.'$GeometryCollection']", path);
        return false;
    }
    lpath = (jm_path_t) { "geometries", 0, path, NULL };
    // .'$GeometryCollection'.geometries
    res = json_is_array(pval);
    if (res)
    {
        size_t arr_14_idx;
        json_t *arr_14_item;
        json_array_foreach(pval, arr_14_idx, arr_14_item)
        {
            jm_path_t arr_14_lpath = (jm_path_t) { NULL, arr_14_idx, (path ? &lpath : NULL), NULL };
            // .'$GeometryCollection'.geometries.0
            res = json_model_11(arr_14_item, ((path ? &lpath : NULL) ? &arr_14_lpath : NULL), rep);
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "unexpected $geometry [.'$GeometryCollection'.geometries.0]", ((path ? &lpath : NULL) ? &arr_14_lpath : NULL));
                break;
            }
        }
    }
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "not array or unexpected array [.'$GeometryCollection'.geometries]", (path ? &lpath : NULL));
        if (rep) jm_report_add_entry(rep, "unexpected value for mandatory prop <geometries> [.'$GeometryCollection']", (path ? &lpath : NULL));
        return false;
    }
    if ((pval = json_object_get(val, "bbox")) != NULL)
    {
        lpath = (jm_path_t) { "bbox", 0, path, NULL };
        // .'$GeometryCollection'.bbox
        res = json_is_array(pval);
        if (res)
        {
            size_t arr_15_idx;
            json_t *arr_15_item;
            json_array_foreach(pval, arr_15_idx, arr_15_item)
            {
                jm_path_t arr_15_lpath = (jm_path_t) { NULL, arr_15_idx, (path ? &lpath : NULL), NULL };
                // .'$GeometryCollection'.bbox.0
                res = json_is_number(arr_15_item);
                if (! res)
                {
                    if (rep) jm_report_add_entry(rep, "not a -1.0 loose float [.'$GeometryCollection'.bbox.0]", ((path ? &lpath : NULL) ? &arr_15_lpath : NULL));
                    break;
                }
            }
        }
        if (! res)
        {
            if (rep) jm_report_add_entry(rep, "not array or unexpected array [.'$GeometryCollection'.bbox]", (path ? &lpath : NULL));
            if (rep) jm_report_add_entry(rep, "unexpected value for optional prop <bbox> [.'$GeometryCollection']", (path ? &lpath : NULL));
            return false;
        }
    }
    return true;
}

// object .'$Feature'.properties.'|'.1
static INLINE bool _jm_obj_0(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    if (! json_is_object(val))
    {
        if (rep) jm_report_add_entry(rep, "not an object [.'$Feature'.properties.'|'.1]", path);
        return false;
    }
    // accept any object
    return true;
}

// check $Feature (.'$Feature')
static bool json_model_13(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    // .'$Feature'
    // check open must/may only props
    if (! json_is_object(val))
    {
        if (rep) jm_report_add_entry(rep, "not an object [.'$Feature']", path);
        return false;
    }
    jm_path_t lpath;
    json_t * pval;
    bool res;
    if (! ((pval = json_object_get(val, "type")) != NULL))
    {
        if (rep) jm_report_add_entry(rep, "missing mandatory prop <type> [.'$Feature']", path);
        return false;
    }
    lpath = (jm_path_t) { "type", 0, path, NULL };
    // .'$Feature'.type
    res = json_is_string(pval) && jm_str_eq_8(json_string_value(pval), 0x0065727574616546LL);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected Feature [.'$Feature'.type]", (path ? &lpath : NULL));
        if (rep) jm_report_add_entry(rep, "unexpected value for mandatory prop <type> [.'$Feature']", (path ? &lpath : NULL));
        return false;
    }
    if (! ((pval = json_object_get(val, "geometry")) != NULL))
    {
        if (rep) jm_report_add_entry(rep, "missing mandatory prop <geometry> [.'$Feature']", path);
        return false;
    }
    lpath = (jm_path_t) { "geometry", 0, path, NULL };
    // .'$Feature'.geometry
    // .'$Feature'.geometry.'|'.0
    res = json_is_null(pval);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "not null [.'$Feature'.geometry.'|'.0]", (path ? &lpath : NULL));
    }
    if (! res)
    {
        // .'$Feature'.geometry.'|'.1
        res = json_model_11(pval, (path ? &lpath : NULL), rep);
        if (! res)
        {
            if (rep) jm_report_add_entry(rep, "unexpected $geometry [.'$Feature'.geometry.'|'.1]", (path ? &lpath : NULL));
        }
        if (! res)
        {
            // .'$Feature'.geometry.'|'.2
            res = json_model_12(pval, (path ? &lpath : NULL), rep);
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "unexpected $GeometryCollection [.'$Feature'.geometry.'|'.2]", (path ? &lpath : NULL));
            }
        }
    }
    if (res)
    {
        if (rep) jm_report_free_entries(rep);
    }
    else
    {
        if (rep) jm_report_add_entry(rep, "no model matched [.'$Feature'.geometry.'|']", (path ? &lpath : NULL));
        if (rep) jm_report_add_entry(rep, "unexpected value for mandatory prop <geometry> [.'$Feature']", (path ? &lpath : NULL));
        return false;
    }
    if (! ((pval = json_object_get(val, "properties")) != NULL))
    {
        if (rep) jm_report_add_entry(rep, "missing mandatory prop <properties> [.'$Feature']", path);
        return false;
    }
    lpath = (jm_path_t) { "properties", 0, path, NULL };
    // .'$Feature'.properties
    // .'$Feature'.properties.'|'.0
    res = json_is_null(pval);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "not null [.'$Feature'.properties.'|'.0]", (path ? &lpath : NULL));
    }
    if (! res)
    {
        // .'$Feature'.properties.'|'.1
        res = _jm_obj_0(pval, (path ? &lpath : NULL), rep);
        if (! res)
        {
            if (rep) jm_report_add_entry(rep, "unexpected element [.'$Feature'.properties.'|'.1]", (path ? &lpath : NULL));
        }
    }
    if (res)
    {
        if (rep) jm_report_free_entries(rep);
    }
    else
    {
        if (rep) jm_report_add_entry(rep, "no model matched [.'$Feature'.properties.'|']", (path ? &lpath : NULL));
        if (rep) jm_report_add_entry(rep, "unexpected value for mandatory prop <properties> [.'$Feature']", (path ? &lpath : NULL));
        return false;
    }
    if ((pval = json_object_get(val, "id")) != NULL)
    {
        lpath = (jm_path_t) { "id", 0, path, NULL };
        // .'$Feature'.id
        // .'$Feature'.id.'|'.0
        res = json_is_string(pval);
        if (! res)
        {
            if (rep) jm_report_add_entry(rep, "unexpected string [.'$Feature'.id.'|'.0]", (path ? &lpath : NULL));
        }
        if (! res)
        {
            // .'$Feature'.id.'|'.1
            res = json_is_number(pval);
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "not a -1.0 loose float [.'$Feature'.id.'|'.1]", (path ? &lpath : NULL));
            }
        }
        if (res)
        {
            if (rep) jm_report_free_entries(rep);
        }
        else
        {
            if (rep) jm_report_add_entry(rep, "no model matched [.'$Feature'.id.'|']", (path ? &lpath : NULL));
            if (rep) jm_report_add_entry(rep, "unexpected value for optional prop <id> [.'$Feature']", (path ? &lpath : NULL));
            return false;
        }
    }
    if ((pval = json_object_get(val, "bbox")) != NULL)
    {
        lpath = (jm_path_t) { "bbox", 0, path, NULL };
        // .'$Feature'.bbox
        res = json_is_array(pval);
        if (res)
        {
            size_t arr_16_idx;
            json_t *arr_16_item;
            json_array_foreach(pval, arr_16_idx, arr_16_item)
            {
                jm_path_t arr_16_lpath = (jm_path_t) { NULL, arr_16_idx, (path ? &lpath : NULL), NULL };
                // .'$Feature'.bbox.0
                res = json_is_number(arr_16_item);
                if (! res)
                {
                    if (rep) jm_report_add_entry(rep, "not a -1.0 loose float [.'$Feature'.bbox.0]", ((path ? &lpath : NULL) ? &arr_16_lpath : NULL));
                    break;
                }
            }
        }
        if (! res)
        {
            if (rep) jm_report_add_entry(rep, "not array or unexpected array [.'$Feature'.bbox]", (path ? &lpath : NULL));
            if (rep) jm_report_add_entry(rep, "unexpected value for optional prop <bbox> [.'$Feature']", (path ? &lpath : NULL));
            return false;
        }
    }
    return true;
}

// check $FeatureCollection (.'$FeatureCollection')
static bool json_model_14(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    // .'$FeatureCollection'
    // check open must/may only props
    if (! json_is_object(val))
    {
        if (rep) jm_report_add_entry(rep, "not an object [.'$FeatureCollection']", path);
        return false;
    }
    jm_path_t lpath;
    json_t * pval;
    bool res;
    if (! ((pval = json_object_get(val, "type")) != NULL))
    {
        if (rep) jm_report_add_entry(rep, "missing mandatory prop <type> [.'$FeatureCollection']", path);
        return false;
    }
    lpath = (jm_path_t) { "type", 0, path, NULL };
    // .'$FeatureCollection'.type
    res = json_is_string(pval) && jm_str_eq_8(json_string_value(pval), 0x4365727574616546LL) && jm_str_eq_8(json_string_value(pval) + 8, 0x6f697463656c6c6fLL) && jm_str_eq_2(json_string_value(pval) + 16, 0x0000006e);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected FeatureCollection [.'$FeatureCollection'.type]", (path ? &lpath : NULL));
        if (rep) jm_report_add_entry(rep, "unexpected value for mandatory prop <type> [.'$FeatureCollection']", (path ? &lpath : NULL));
        return false;
    }
    if (! ((pval = json_object_get(val, "features")) != NULL))
    {
        if (rep) jm_report_add_entry(rep, "missing mandatory prop <features> [.'$FeatureCollection']", path);
        return false;
    }
    lpath = (jm_path_t) { "features", 0, path, NULL };
    // .'$FeatureCollection'.features
    res = json_is_array(pval);
    if (res)
    {
        size_t arr_17_idx;
        json_t *arr_17_item;
        json_array_foreach(pval, arr_17_idx, arr_17_item)
        {
            jm_path_t arr_17_lpath = (jm_path_t) { NULL, arr_17_idx, (path ? &lpath : NULL), NULL };
            // .'$FeatureCollection'.features.0
            res = json_model_13(arr_17_item, ((path ? &lpath : NULL) ? &arr_17_lpath : NULL), rep);
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "unexpected $Feature [.'$FeatureCollection'.features.0]", ((path ? &lpath : NULL) ? &arr_17_lpath : NULL));
                break;
            }
        }
    }
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "not array or unexpected array [.'$FeatureCollection'.features]", (path ? &lpath : NULL));
        if (rep) jm_report_add_entry(rep, "unexpected value for mandatory prop <features> [.'$FeatureCollection']", (path ? &lpath : NULL));
        return false;
    }
    if ((pval = json_object_get(val, "bbox")) != NULL)
    {
        lpath = (jm_path_t) { "bbox", 0, path, NULL };
        // .'$FeatureCollection'.bbox
        res = json_is_array(pval);
        if (res)
        {
            size_t arr_18_idx;
            json_t *arr_18_item;
            json_array_foreach(pval, arr_18_idx, arr_18_item)
            {
                jm_path_t arr_18_lpath = (jm_path_t) { NULL, arr_18_idx, (path ? &lpath : NULL), NULL };
                // .'$FeatureCollection'.bbox.0
                res = json_is_number(arr_18_item);
                if (! res)
                {
                    if (rep) jm_report_add_entry(rep, "not a -1.0 loose float [.'$FeatureCollection'.bbox.0]", ((path ? &lpath : NULL) ? &arr_18_lpath : NULL));
                    break;
                }
            }
        }
        if (! res)
        {
            if (rep) jm_report_add_entry(rep, "not array or unexpected array [.'$FeatureCollection'.bbox]", (path ? &lpath : NULL));
            if (rep) jm_report_add_entry(rep, "unexpected value for optional prop <bbox> [.'$FeatureCollection']", (path ? &lpath : NULL));
            return false;
        }
    }
    return true;
}

static INLINE jm_check_fun_t _jm_map_1(json_t *val)
{
    jm_constant_t cst;
    jm_set_cst(&cst, val);
    return jm_search_constmap(&cst, _jm_map_1_tab, 3);
}

// check $ (.)
static bool json_model_1(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // Easy Geo JSON Model JSON_MODEL_LOOSE_FLOAT
    // .
    bool iso_1 = json_is_object(val);
    res = iso_1;
    if (res)
    {
        if (json_object_get(val, "type") != NULL)
        {
            json_t * tag_1 = json_object_get(val, "type");
            jm_check_fun_t fun_1 = _jm_map_1(tag_1);
            if (fun_1 != NULL)
                res = fun_1(val, path, rep);
            else
            {
                res = false;
                if (rep) jm_report_add_entry(rep, "tag <type> value not found [.'|']", path);
            }
        }
        else
        {
            res = false;
            if (rep) jm_report_add_entry(rep, "tag prop <type> is missing [.'|']", path);
        }
    }
    else
    {
        if (rep) jm_report_add_entry(rep, "value is not an object [.'|']", path);
    }
    if (! res)
        res = json_model_11(val, path, rep);
    return res;
}

jm_check_fun_t check_model_map(const char *pname)
{
    return jm_search_propmap(pname, check_model_map_tab, 14);
}

static bool initialized = false;

const char *check_model_init(void)
{
    if (!initialized)
    {
        initialized = true;
        jm_version_string = JSON_MODEL_VERSION;
        _jm_map_0_tab[0] = (jm_constmap_t) { (jm_constant_t) { cst_is_string, { .s = "Point" } }, json_model_5 };
        _jm_map_0_tab[1] = (jm_constmap_t) { (jm_constant_t) { cst_is_string, { .s = "MultiPoint" } }, json_model_6 };
        _jm_map_0_tab[2] = (jm_constmap_t) { (jm_constant_t) { cst_is_string, { .s = "LineString" } }, json_model_7 };
        _jm_map_0_tab[3] = (jm_constmap_t) { (jm_constant_t) { cst_is_string, { .s = "MultiLineString" } }, json_model_8 };
        _jm_map_0_tab[4] = (jm_constmap_t) { (jm_constant_t) { cst_is_string, { .s = "Polygon" } }, json_model_9 };
        _jm_map_0_tab[5] = (jm_constmap_t) { (jm_constant_t) { cst_is_string, { .s = "MultiPolygon" } }, json_model_10 };
        jm_sort_constmap(_jm_map_0_tab, 6);
        _jm_map_1_tab[0] = (jm_constmap_t) { (jm_constant_t) { cst_is_string, { .s = "GeometryCollection" } }, json_model_12 };
        _jm_map_1_tab[1] = (jm_constmap_t) { (jm_constant_t) { cst_is_string, { .s = "Feature" } }, json_model_13 };
        _jm_map_1_tab[2] = (jm_constmap_t) { (jm_constant_t) { cst_is_string, { .s = "FeatureCollection" } }, json_model_14 };
        jm_sort_constmap(_jm_map_1_tab, 3);
        check_model_map_tab[0] = (jm_propmap_t) { "", json_model_1 };
        check_model_map_tab[1] = (jm_propmap_t) { "position", json_model_2 };
        check_model_map_tab[2] = (jm_propmap_t) { "coord_array", json_model_3 };
        check_model_map_tab[3] = (jm_propmap_t) { "linear_ring", json_model_4 };
        check_model_map_tab[4] = (jm_propmap_t) { "Point", json_model_5 };
        check_model_map_tab[5] = (jm_propmap_t) { "MultiPoint", json_model_6 };
        check_model_map_tab[6] = (jm_propmap_t) { "LineString", json_model_7 };
        check_model_map_tab[7] = (jm_propmap_t) { "MultiLineString", json_model_8 };
        check_model_map_tab[8] = (jm_propmap_t) { "Polygon", json_model_9 };
        check_model_map_tab[9] = (jm_propmap_t) { "MultiPolygon", json_model_10 };
        check_model_map_tab[10] = (jm_propmap_t) { "geometry", json_model_11 };
        check_model_map_tab[11] = (jm_propmap_t) { "GeometryCollection", json_model_12 };
        check_model_map_tab[12] = (jm_propmap_t) { "Feature", json_model_13 };
        check_model_map_tab[13] = (jm_propmap_t) { "FeatureCollection", json_model_14 };
        jm_sort_propmap(check_model_map_tab, 14);
    }
    return NULL;
}

void check_model_free(void)
{
    if (initialized)
        initialized = false;

        // cleanup code
}

/*
 * # API
 *
 * ```c
 * bool error;
 * char *message;
 *
 * bool valid = check(json_value, "model-name", &error, &message);
 *
 * if (message)
 *    free(message), message = NULL;
 * ```
 *
 * - `error` is set of there was an error during initialization or if the model does not exists.
 * - `message` is provided if a non NULL pointer is passed, and must be freed by the caller.
 */
bool
check_model(const json_t *val, const char *name, bool *error, char **reasons)
{
    return jm_generic_entry(check_model_init, check_model_map, val, name, error, reasons);
}
