//
// Generated by JSON Model Compiler version 2
// see https://github.com/clairey-zx81/json-model
//

// regular expression engine
#include <stddef.h>
#include <cre2.h>

#include <json-model.h>
#define JSON_MODEL_VERSION "2"

static bool json_model_2(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool json_model_3(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool json_model_4(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool json_model_5(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool json_model_6(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool json_model_7(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool json_model_8(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool json_model_9(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool json_model_10(const json_t *val, jm_path_t *path, jm_report_t *rep);
static jm_constmap_t _jm_map_0_tab[6];
static bool json_model_11(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool json_model_12(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool json_model_13(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool json_model_14(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool json_model_1(const json_t *val, jm_path_t *path, jm_report_t *rep);
jm_propmap_t check_model_map_tab[14];
const size_t check_model_map_size = 14;

// check $position (.'$position')
static bool json_model_2(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .'$position'
    // .'$position'.'@'
    res = json_is_array(val);
    if (res)
    {
        size_t arr_0_idx;
        json_t *arr_0_item;
        json_array_foreach(val, arr_0_idx, arr_0_item)
        {
            jm_path_t arr_0_lpath = (jm_path_t) { NULL, arr_0_idx, path, NULL };
            // .'$position'.'@'.0
            res = json_is_number(arr_0_item);
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "not a -1.0 loose float [.'$position'.'@'.0]", (path ? &arr_0_lpath : NULL));
                break;
            }
        }
    }
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "not array or unexpected array [.'$position'.'@']", path);
    }
    if (res)
    {
        int64_t ival_0 = json_array_size(val);
        res = ival_0 <= 3 && ival_0 >= 2;
        if (! res)
        {
            if (rep) jm_report_add_entry(rep, "constraints failed [.'$position']", path);
        }
    }
    return res;
}

// check $coord_array (.'$coord_array')
static bool json_model_3(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .'$coord_array'
    // .'$coord_array'.'@'
    res = json_is_array(val);
    if (res)
    {
        size_t arr_1_idx;
        json_t *arr_1_item;
        json_array_foreach(val, arr_1_idx, arr_1_item)
        {
            jm_path_t arr_1_lpath = (jm_path_t) { NULL, arr_1_idx, path, NULL };
            // .'$coord_array'.'@'.0
            res = json_model_2(arr_1_item, (path ? &arr_1_lpath : NULL), rep);
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "unexpected $position [.'$coord_array'.'@'.0]", (path ? &arr_1_lpath : NULL));
                break;
            }
        }
    }
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "not array or unexpected array [.'$coord_array'.'@']", path);
    }
    if (res)
    {
        int64_t ival_1 = json_array_size(val);
        res = ival_1 >= 2;
        if (! res)
        {
            if (rep) jm_report_add_entry(rep, "constraints failed [.'$coord_array']", path);
        }
    }
    return res;
}

// check $linear_ring (.'$linear_ring')
static bool json_model_4(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .'$linear_ring'
    // .'$linear_ring'.'@'
    res = json_is_array(val);
    if (res)
    {
        size_t arr_2_idx;
        json_t *arr_2_item;
        json_array_foreach(val, arr_2_idx, arr_2_item)
        {
            jm_path_t arr_2_lpath = (jm_path_t) { NULL, arr_2_idx, path, NULL };
            // .'$linear_ring'.'@'.0
            res = json_model_2(arr_2_item, (path ? &arr_2_lpath : NULL), rep);
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "unexpected $position [.'$linear_ring'.'@'.0]", (path ? &arr_2_lpath : NULL));
                break;
            }
        }
    }
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "not array or unexpected array [.'$linear_ring'.'@']", path);
    }
    if (res)
    {
        int64_t ival_2 = json_array_size(val);
        res = ival_2 >= 4;
        if (! res)
        {
            if (rep) jm_report_add_entry(rep, "constraints failed [.'$linear_ring']", path);
        }
    }
    return res;
}

// object .'$Point'
static INLINE bool _jm_obj_0(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    // check must only props
    if (! json_is_object(val))
    {
        if (rep) jm_report_add_entry(rep, "not an object [.'$Point']", path);
        return false;
    }
    json_t * pval;
    bool res;
    if (! (json_object_get(val, "type") != NULL))
    {
        if (rep) jm_report_add_entry(rep, "missing mandatory prop <type> [.'$Point']", path);
        return false;
    }
    pval = json_object_get(val, "type");
    // .'$Point'.type
    res = json_is_string(pval) && strcmp(json_string_value(pval), "Point") == 0;
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected Point [.'$Point'.type]", path);
        if (rep) jm_report_add_entry(rep, "unexpected value for mandatory prop <type> [.'$Point']", path);
        return false;
    }
    if (! (json_object_get(val, "coordinates") != NULL))
    {
        if (rep) jm_report_add_entry(rep, "missing mandatory prop <coordinates> [.'$Point']", path);
        return false;
    }
    pval = json_object_get(val, "coordinates");
    // .'$Point'.coordinates
    res = json_model_2(pval, path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected $position [.'$Point'.coordinates]", path);
        if (rep) jm_report_add_entry(rep, "unexpected value for mandatory prop <coordinates> [.'$Point']", path);
        return false;
    }
    if (json_object_get(val, "bbox") != NULL)
    {
        pval = json_object_get(val, "bbox");
        // .'$Point'.bbox
        res = json_is_array(pval);
        if (res)
        {
            size_t arr_3_idx;
            json_t *arr_3_item;
            json_array_foreach(pval, arr_3_idx, arr_3_item)
            {
                jm_path_t arr_3_lpath = (jm_path_t) { NULL, arr_3_idx, path, NULL };
                // .'$Point'.bbox.0
                res = json_is_number(arr_3_item);
                if (! res)
                {
                    if (rep) jm_report_add_entry(rep, "not a -1.0 loose float [.'$Point'.bbox.0]", (path ? &arr_3_lpath : NULL));
                    break;
                }
            }
        }
        if (! res)
        {
            if (rep) jm_report_add_entry(rep, "not array or unexpected array [.'$Point'.bbox]", path);
            if (rep) jm_report_add_entry(rep, "unexpected value for optional prop <bbox> [.'$Point']", path);
            return false;
        }
    }
    return true;
}

// check $Point (.'$Point')
static bool json_model_5(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .'$Point'
    res = _jm_obj_0(val, path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected element [.'$Point']", path);
    }
    return res;
}

// object .'$MultiPoint'
static INLINE bool _jm_obj_1(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    // check must only props
    if (! json_is_object(val))
    {
        if (rep) jm_report_add_entry(rep, "not an object [.'$MultiPoint']", path);
        return false;
    }
    json_t * pval;
    bool res;
    if (! (json_object_get(val, "type") != NULL))
    {
        if (rep) jm_report_add_entry(rep, "missing mandatory prop <type> [.'$MultiPoint']", path);
        return false;
    }
    pval = json_object_get(val, "type");
    // .'$MultiPoint'.type
    res = json_is_string(pval) && strcmp(json_string_value(pval), "MultiPoint") == 0;
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected MultiPoint [.'$MultiPoint'.type]", path);
        if (rep) jm_report_add_entry(rep, "unexpected value for mandatory prop <type> [.'$MultiPoint']", path);
        return false;
    }
    if (! (json_object_get(val, "coordinates") != NULL))
    {
        if (rep) jm_report_add_entry(rep, "missing mandatory prop <coordinates> [.'$MultiPoint']", path);
        return false;
    }
    pval = json_object_get(val, "coordinates");
    // .'$MultiPoint'.coordinates
    res = json_is_array(pval);
    if (res)
    {
        size_t arr_4_idx;
        json_t *arr_4_item;
        json_array_foreach(pval, arr_4_idx, arr_4_item)
        {
            jm_path_t arr_4_lpath = (jm_path_t) { NULL, arr_4_idx, path, NULL };
            // .'$MultiPoint'.coordinates.0
            res = json_model_2(arr_4_item, (path ? &arr_4_lpath : NULL), rep);
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "unexpected $position [.'$MultiPoint'.coordinates.0]", (path ? &arr_4_lpath : NULL));
                break;
            }
        }
    }
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "not array or unexpected array [.'$MultiPoint'.coordinates]", path);
        if (rep) jm_report_add_entry(rep, "unexpected value for mandatory prop <coordinates> [.'$MultiPoint']", path);
        return false;
    }
    if (json_object_get(val, "bbox") != NULL)
    {
        pval = json_object_get(val, "bbox");
        // .'$MultiPoint'.bbox
        res = json_is_array(pval);
        if (res)
        {
            size_t arr_5_idx;
            json_t *arr_5_item;
            json_array_foreach(pval, arr_5_idx, arr_5_item)
            {
                jm_path_t arr_5_lpath = (jm_path_t) { NULL, arr_5_idx, path, NULL };
                // .'$MultiPoint'.bbox.0
                res = json_is_number(arr_5_item);
                if (! res)
                {
                    if (rep) jm_report_add_entry(rep, "not a -1.0 loose float [.'$MultiPoint'.bbox.0]", (path ? &arr_5_lpath : NULL));
                    break;
                }
            }
        }
        if (! res)
        {
            if (rep) jm_report_add_entry(rep, "not array or unexpected array [.'$MultiPoint'.bbox]", path);
            if (rep) jm_report_add_entry(rep, "unexpected value for optional prop <bbox> [.'$MultiPoint']", path);
            return false;
        }
    }
    return true;
}

// check $MultiPoint (.'$MultiPoint')
static bool json_model_6(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .'$MultiPoint'
    res = _jm_obj_1(val, path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected element [.'$MultiPoint']", path);
    }
    return res;
}

// object .'$LineString'
static INLINE bool _jm_obj_2(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    // check must only props
    if (! json_is_object(val))
    {
        if (rep) jm_report_add_entry(rep, "not an object [.'$LineString']", path);
        return false;
    }
    json_t * pval;
    bool res;
    if (! (json_object_get(val, "type") != NULL))
    {
        if (rep) jm_report_add_entry(rep, "missing mandatory prop <type> [.'$LineString']", path);
        return false;
    }
    pval = json_object_get(val, "type");
    // .'$LineString'.type
    res = json_is_string(pval) && strcmp(json_string_value(pval), "LineString") == 0;
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected LineString [.'$LineString'.type]", path);
        if (rep) jm_report_add_entry(rep, "unexpected value for mandatory prop <type> [.'$LineString']", path);
        return false;
    }
    if (! (json_object_get(val, "coordinates") != NULL))
    {
        if (rep) jm_report_add_entry(rep, "missing mandatory prop <coordinates> [.'$LineString']", path);
        return false;
    }
    pval = json_object_get(val, "coordinates");
    // .'$LineString'.coordinates
    res = json_model_3(pval, path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected $coord_array [.'$LineString'.coordinates]", path);
        if (rep) jm_report_add_entry(rep, "unexpected value for mandatory prop <coordinates> [.'$LineString']", path);
        return false;
    }
    if (json_object_get(val, "bbox") != NULL)
    {
        pval = json_object_get(val, "bbox");
        // .'$LineString'.bbox
        res = json_is_array(pval);
        if (res)
        {
            size_t arr_6_idx;
            json_t *arr_6_item;
            json_array_foreach(pval, arr_6_idx, arr_6_item)
            {
                jm_path_t arr_6_lpath = (jm_path_t) { NULL, arr_6_idx, path, NULL };
                // .'$LineString'.bbox.0
                res = json_is_number(arr_6_item);
                if (! res)
                {
                    if (rep) jm_report_add_entry(rep, "not a -1.0 loose float [.'$LineString'.bbox.0]", (path ? &arr_6_lpath : NULL));
                    break;
                }
            }
        }
        if (! res)
        {
            if (rep) jm_report_add_entry(rep, "not array or unexpected array [.'$LineString'.bbox]", path);
            if (rep) jm_report_add_entry(rep, "unexpected value for optional prop <bbox> [.'$LineString']", path);
            return false;
        }
    }
    return true;
}

// check $LineString (.'$LineString')
static bool json_model_7(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .'$LineString'
    res = _jm_obj_2(val, path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected element [.'$LineString']", path);
    }
    return res;
}

// object .'$MultiLineString'
static INLINE bool _jm_obj_3(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    // check must only props
    if (! json_is_object(val))
    {
        if (rep) jm_report_add_entry(rep, "not an object [.'$MultiLineString']", path);
        return false;
    }
    json_t * pval;
    bool res;
    if (! (json_object_get(val, "type") != NULL))
    {
        if (rep) jm_report_add_entry(rep, "missing mandatory prop <type> [.'$MultiLineString']", path);
        return false;
    }
    pval = json_object_get(val, "type");
    // .'$MultiLineString'.type
    res = json_is_string(pval) && strcmp(json_string_value(pval), "MultiLineString") == 0;
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected MultiLineString [.'$MultiLineString'.type]", path);
        if (rep) jm_report_add_entry(rep, "unexpected value for mandatory prop <type> [.'$MultiLineString']", path);
        return false;
    }
    if (! (json_object_get(val, "coordinates") != NULL))
    {
        if (rep) jm_report_add_entry(rep, "missing mandatory prop <coordinates> [.'$MultiLineString']", path);
        return false;
    }
    pval = json_object_get(val, "coordinates");
    // .'$MultiLineString'.coordinates
    res = json_is_array(pval);
    if (res)
    {
        size_t arr_7_idx;
        json_t *arr_7_item;
        json_array_foreach(pval, arr_7_idx, arr_7_item)
        {
            jm_path_t arr_7_lpath = (jm_path_t) { NULL, arr_7_idx, path, NULL };
            // .'$MultiLineString'.coordinates.0
            res = json_model_3(arr_7_item, (path ? &arr_7_lpath : NULL), rep);
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "unexpected $coord_array [.'$MultiLineString'.coordinates.0]", (path ? &arr_7_lpath : NULL));
                break;
            }
        }
    }
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "not array or unexpected array [.'$MultiLineString'.coordinates]", path);
        if (rep) jm_report_add_entry(rep, "unexpected value for mandatory prop <coordinates> [.'$MultiLineString']", path);
        return false;
    }
    if (json_object_get(val, "bbox") != NULL)
    {
        pval = json_object_get(val, "bbox");
        // .'$MultiLineString'.bbox
        res = json_is_array(pval);
        if (res)
        {
            size_t arr_8_idx;
            json_t *arr_8_item;
            json_array_foreach(pval, arr_8_idx, arr_8_item)
            {
                jm_path_t arr_8_lpath = (jm_path_t) { NULL, arr_8_idx, path, NULL };
                // .'$MultiLineString'.bbox.0
                res = json_is_number(arr_8_item);
                if (! res)
                {
                    if (rep) jm_report_add_entry(rep, "not a -1.0 loose float [.'$MultiLineString'.bbox.0]", (path ? &arr_8_lpath : NULL));
                    break;
                }
            }
        }
        if (! res)
        {
            if (rep) jm_report_add_entry(rep, "not array or unexpected array [.'$MultiLineString'.bbox]", path);
            if (rep) jm_report_add_entry(rep, "unexpected value for optional prop <bbox> [.'$MultiLineString']", path);
            return false;
        }
    }
    return true;
}

// check $MultiLineString (.'$MultiLineString')
static bool json_model_8(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .'$MultiLineString'
    res = _jm_obj_3(val, path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected element [.'$MultiLineString']", path);
    }
    return res;
}

// object .'$Polygon'
static INLINE bool _jm_obj_4(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    // check must only props
    if (! json_is_object(val))
    {
        if (rep) jm_report_add_entry(rep, "not an object [.'$Polygon']", path);
        return false;
    }
    json_t * pval;
    bool res;
    if (! (json_object_get(val, "type") != NULL))
    {
        if (rep) jm_report_add_entry(rep, "missing mandatory prop <type> [.'$Polygon']", path);
        return false;
    }
    pval = json_object_get(val, "type");
    // .'$Polygon'.type
    res = json_is_string(pval) && strcmp(json_string_value(pval), "Polygon") == 0;
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected Polygon [.'$Polygon'.type]", path);
        if (rep) jm_report_add_entry(rep, "unexpected value for mandatory prop <type> [.'$Polygon']", path);
        return false;
    }
    if (! (json_object_get(val, "coordinates") != NULL))
    {
        if (rep) jm_report_add_entry(rep, "missing mandatory prop <coordinates> [.'$Polygon']", path);
        return false;
    }
    pval = json_object_get(val, "coordinates");
    // .'$Polygon'.coordinates
    res = json_is_array(pval);
    if (res)
    {
        size_t arr_9_idx;
        json_t *arr_9_item;
        json_array_foreach(pval, arr_9_idx, arr_9_item)
        {
            jm_path_t arr_9_lpath = (jm_path_t) { NULL, arr_9_idx, path, NULL };
            // .'$Polygon'.coordinates.0
            res = json_model_4(arr_9_item, (path ? &arr_9_lpath : NULL), rep);
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "unexpected $linear_ring [.'$Polygon'.coordinates.0]", (path ? &arr_9_lpath : NULL));
                break;
            }
        }
    }
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "not array or unexpected array [.'$Polygon'.coordinates]", path);
        if (rep) jm_report_add_entry(rep, "unexpected value for mandatory prop <coordinates> [.'$Polygon']", path);
        return false;
    }
    if (json_object_get(val, "bbox") != NULL)
    {
        pval = json_object_get(val, "bbox");
        // .'$Polygon'.bbox
        res = json_is_array(pval);
        if (res)
        {
            size_t arr_10_idx;
            json_t *arr_10_item;
            json_array_foreach(pval, arr_10_idx, arr_10_item)
            {
                jm_path_t arr_10_lpath = (jm_path_t) { NULL, arr_10_idx, path, NULL };
                // .'$Polygon'.bbox.0
                res = json_is_number(arr_10_item);
                if (! res)
                {
                    if (rep) jm_report_add_entry(rep, "not a -1.0 loose float [.'$Polygon'.bbox.0]", (path ? &arr_10_lpath : NULL));
                    break;
                }
            }
        }
        if (! res)
        {
            if (rep) jm_report_add_entry(rep, "not array or unexpected array [.'$Polygon'.bbox]", path);
            if (rep) jm_report_add_entry(rep, "unexpected value for optional prop <bbox> [.'$Polygon']", path);
            return false;
        }
    }
    return true;
}

// check $Polygon (.'$Polygon')
static bool json_model_9(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .'$Polygon'
    res = _jm_obj_4(val, path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected element [.'$Polygon']", path);
    }
    return res;
}

// object .'$MultiPolygon'
static INLINE bool _jm_obj_5(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    // check must only props
    if (! json_is_object(val))
    {
        if (rep) jm_report_add_entry(rep, "not an object [.'$MultiPolygon']", path);
        return false;
    }
    json_t * pval;
    bool res;
    if (! (json_object_get(val, "type") != NULL))
    {
        if (rep) jm_report_add_entry(rep, "missing mandatory prop <type> [.'$MultiPolygon']", path);
        return false;
    }
    pval = json_object_get(val, "type");
    // .'$MultiPolygon'.type
    res = json_is_string(pval) && strcmp(json_string_value(pval), "MultiPolygon") == 0;
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected MultiPolygon [.'$MultiPolygon'.type]", path);
        if (rep) jm_report_add_entry(rep, "unexpected value for mandatory prop <type> [.'$MultiPolygon']", path);
        return false;
    }
    if (! (json_object_get(val, "coordinates") != NULL))
    {
        if (rep) jm_report_add_entry(rep, "missing mandatory prop <coordinates> [.'$MultiPolygon']", path);
        return false;
    }
    pval = json_object_get(val, "coordinates");
    // .'$MultiPolygon'.coordinates
    res = json_is_array(pval);
    if (res)
    {
        size_t arr_11_idx;
        json_t *arr_11_item;
        json_array_foreach(pval, arr_11_idx, arr_11_item)
        {
            jm_path_t arr_11_lpath = (jm_path_t) { NULL, arr_11_idx, path, NULL };
            // .'$MultiPolygon'.coordinates.0
            res = json_is_array(arr_11_item);
            if (res)
            {
                size_t arr_12_idx;
                json_t *arr_12_item;
                json_array_foreach(arr_11_item, arr_12_idx, arr_12_item)
                {
                    jm_path_t arr_12_lpath = (jm_path_t) { NULL, arr_12_idx, (path ? &arr_11_lpath : NULL), NULL };
                    // .'$MultiPolygon'.coordinates.0.0
                    res = json_model_4(arr_12_item, ((path ? &arr_11_lpath : NULL) ? &arr_12_lpath : NULL), rep);
                    if (! res)
                    {
                        if (rep) jm_report_add_entry(rep, "unexpected $linear_ring [.'$MultiPolygon'.coordinates.0.0]", ((path ? &arr_11_lpath : NULL) ? &arr_12_lpath : NULL));
                        break;
                    }
                }
            }
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "not array or unexpected array [.'$MultiPolygon'.coordinates.0]", (path ? &arr_11_lpath : NULL));
                break;
            }
        }
    }
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "not array or unexpected array [.'$MultiPolygon'.coordinates]", path);
        if (rep) jm_report_add_entry(rep, "unexpected value for mandatory prop <coordinates> [.'$MultiPolygon']", path);
        return false;
    }
    if (json_object_get(val, "bbox") != NULL)
    {
        pval = json_object_get(val, "bbox");
        // .'$MultiPolygon'.bbox
        res = json_is_array(pval);
        if (res)
        {
            size_t arr_13_idx;
            json_t *arr_13_item;
            json_array_foreach(pval, arr_13_idx, arr_13_item)
            {
                jm_path_t arr_13_lpath = (jm_path_t) { NULL, arr_13_idx, path, NULL };
                // .'$MultiPolygon'.bbox.0
                res = json_is_number(arr_13_item);
                if (! res)
                {
                    if (rep) jm_report_add_entry(rep, "not a -1.0 loose float [.'$MultiPolygon'.bbox.0]", (path ? &arr_13_lpath : NULL));
                    break;
                }
            }
        }
        if (! res)
        {
            if (rep) jm_report_add_entry(rep, "not array or unexpected array [.'$MultiPolygon'.bbox]", path);
            if (rep) jm_report_add_entry(rep, "unexpected value for optional prop <bbox> [.'$MultiPolygon']", path);
            return false;
        }
    }
    return true;
}

// check $MultiPolygon (.'$MultiPolygon')
static bool json_model_10(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .'$MultiPolygon'
    res = _jm_obj_5(val, path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected element [.'$MultiPolygon']", path);
    }
    return res;
}

static INLINE jm_check_fun_t _jm_map_0(json_t *val)
{
    jm_constant_t cst;
    jm_set_cst(&cst, val);
    return jm_search_constmap(&cst, _jm_map_0_tab, 6);
}

// check $geometry (.'$geometry')
static bool json_model_11(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .'$geometry'
    bool iso_0 = json_is_object(val);
    res = iso_0;
    if (res)
    {
        if (json_object_get(val, "type") != NULL)
        {
            json_t * tag_0 = json_object_get(val, "type");
            jm_check_fun_t fun_0 = _jm_map_0(tag_0);
            if (fun_0 != NULL)
            {
                res = fun_0(val, path, rep);
            }
            else
            {
                res = false;
                if (rep) jm_report_add_entry(rep, "tag <type> value not found [.'$geometry'.'|']", path);
            }
        }
        else
        {
            res = false;
            if (rep) jm_report_add_entry(rep, "tag prop <type> is missing [.'$geometry'.'|']", path);
        }
    }
    else
    {
        if (rep) jm_report_add_entry(rep, "value is not an object [.'$geometry'.'|']", path);
    }
    return res;
}

// object .'$GeometryCollection'
static INLINE bool _jm_obj_6(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    // check must only props
    if (! json_is_object(val))
    {
        if (rep) jm_report_add_entry(rep, "not an object [.'$GeometryCollection']", path);
        return false;
    }
    json_t * pval;
    bool res;
    if (! (json_object_get(val, "type") != NULL))
    {
        if (rep) jm_report_add_entry(rep, "missing mandatory prop <type> [.'$GeometryCollection']", path);
        return false;
    }
    pval = json_object_get(val, "type");
    // .'$GeometryCollection'.type
    res = json_is_string(pval) && strcmp(json_string_value(pval), "GeometryCollection") == 0;
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected GeometryCollection [.'$GeometryCollection'.type]", path);
        if (rep) jm_report_add_entry(rep, "unexpected value for mandatory prop <type> [.'$GeometryCollection']", path);
        return false;
    }
    if (! (json_object_get(val, "geometries") != NULL))
    {
        if (rep) jm_report_add_entry(rep, "missing mandatory prop <geometries> [.'$GeometryCollection']", path);
        return false;
    }
    pval = json_object_get(val, "geometries");
    // .'$GeometryCollection'.geometries
    res = json_is_array(pval);
    if (res)
    {
        size_t arr_14_idx;
        json_t *arr_14_item;
        json_array_foreach(pval, arr_14_idx, arr_14_item)
        {
            jm_path_t arr_14_lpath = (jm_path_t) { NULL, arr_14_idx, path, NULL };
            // .'$GeometryCollection'.geometries.0
            res = json_model_11(arr_14_item, (path ? &arr_14_lpath : NULL), rep);
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "unexpected $geometry [.'$GeometryCollection'.geometries.0]", (path ? &arr_14_lpath : NULL));
                break;
            }
        }
    }
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "not array or unexpected array [.'$GeometryCollection'.geometries]", path);
        if (rep) jm_report_add_entry(rep, "unexpected value for mandatory prop <geometries> [.'$GeometryCollection']", path);
        return false;
    }
    if (json_object_get(val, "bbox") != NULL)
    {
        pval = json_object_get(val, "bbox");
        // .'$GeometryCollection'.bbox
        res = json_is_array(pval);
        if (res)
        {
            size_t arr_15_idx;
            json_t *arr_15_item;
            json_array_foreach(pval, arr_15_idx, arr_15_item)
            {
                jm_path_t arr_15_lpath = (jm_path_t) { NULL, arr_15_idx, path, NULL };
                // .'$GeometryCollection'.bbox.0
                res = json_is_number(arr_15_item);
                if (! res)
                {
                    if (rep) jm_report_add_entry(rep, "not a -1.0 loose float [.'$GeometryCollection'.bbox.0]", (path ? &arr_15_lpath : NULL));
                    break;
                }
            }
        }
        if (! res)
        {
            if (rep) jm_report_add_entry(rep, "not array or unexpected array [.'$GeometryCollection'.bbox]", path);
            if (rep) jm_report_add_entry(rep, "unexpected value for optional prop <bbox> [.'$GeometryCollection']", path);
            return false;
        }
    }
    return true;
}

// check $GeometryCollection (.'$GeometryCollection')
static bool json_model_12(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .'$GeometryCollection'
    res = _jm_obj_6(val, path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected element [.'$GeometryCollection']", path);
    }
    return res;
}

// object .'$Feature'.properties.'|'.1
static INLINE bool _jm_obj_8(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    if (! json_is_object(val))
    {
        if (rep) jm_report_add_entry(rep, "not an object [.'$Feature'.properties.'|'.1]", path);
        return false;
    }
    // accept any object
    return true;
}

// object .'$Feature'
static INLINE bool _jm_obj_7(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    // check must only props
    if (! json_is_object(val))
    {
        if (rep) jm_report_add_entry(rep, "not an object [.'$Feature']", path);
        return false;
    }
    json_t * pval;
    bool res;
    if (! (json_object_get(val, "type") != NULL))
    {
        if (rep) jm_report_add_entry(rep, "missing mandatory prop <type> [.'$Feature']", path);
        return false;
    }
    pval = json_object_get(val, "type");
    // .'$Feature'.type
    res = json_is_string(pval) && strcmp(json_string_value(pval), "Feature") == 0;
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected Feature [.'$Feature'.type]", path);
        if (rep) jm_report_add_entry(rep, "unexpected value for mandatory prop <type> [.'$Feature']", path);
        return false;
    }
    if (! (json_object_get(val, "geometry") != NULL))
    {
        if (rep) jm_report_add_entry(rep, "missing mandatory prop <geometry> [.'$Feature']", path);
        return false;
    }
    pval = json_object_get(val, "geometry");
    // .'$Feature'.geometry
    // .'$Feature'.geometry.'|'.0
    res = json_is_null(pval);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "not null [.'$Feature'.geometry.'|'.0]", path);
    }
    if (! res)
    {
        // .'$Feature'.geometry.'|'.1
        res = json_model_11(pval, path, rep);
        if (! res)
        {
            if (rep) jm_report_add_entry(rep, "unexpected $geometry [.'$Feature'.geometry.'|'.1]", path);
        }
        if (! res)
        {
            // .'$Feature'.geometry.'|'.2
            res = json_model_12(pval, path, rep);
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "unexpected $GeometryCollection [.'$Feature'.geometry.'|'.2]", path);
            }
        }
    }
    if (res)
    {
        if (rep) jm_report_free_entries(rep);
    }
    else
    {
        if (rep) jm_report_add_entry(rep, "no model matched [.'$Feature'.geometry.'|']", path);
        if (rep) jm_report_add_entry(rep, "unexpected value for mandatory prop <geometry> [.'$Feature']", path);
        return false;
    }
    if (! (json_object_get(val, "properties") != NULL))
    {
        if (rep) jm_report_add_entry(rep, "missing mandatory prop <properties> [.'$Feature']", path);
        return false;
    }
    pval = json_object_get(val, "properties");
    // .'$Feature'.properties
    // .'$Feature'.properties.'|'.0
    res = json_is_null(pval);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "not null [.'$Feature'.properties.'|'.0]", path);
    }
    if (! res)
    {
        // .'$Feature'.properties.'|'.1
        res = _jm_obj_8(pval, path, rep);
        if (! res)
        {
            if (rep) jm_report_add_entry(rep, "unexpected element [.'$Feature'.properties.'|'.1]", path);
        }
    }
    if (res)
    {
        if (rep) jm_report_free_entries(rep);
    }
    else
    {
        if (rep) jm_report_add_entry(rep, "no model matched [.'$Feature'.properties.'|']", path);
        if (rep) jm_report_add_entry(rep, "unexpected value for mandatory prop <properties> [.'$Feature']", path);
        return false;
    }
    if (json_object_get(val, "id") != NULL)
    {
        pval = json_object_get(val, "id");
        // .'$Feature'.id
        // .'$Feature'.id.'|'.0
        res = json_is_string(pval);
        if (! res)
        {
            if (rep) jm_report_add_entry(rep, "unexpected string [.'$Feature'.id.'|'.0]", path);
        }
        if (! res)
        {
            // .'$Feature'.id.'|'.1
            res = json_is_number(pval);
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "not a -1.0 loose float [.'$Feature'.id.'|'.1]", path);
            }
        }
        if (res)
        {
            if (rep) jm_report_free_entries(rep);
        }
        else
        {
            if (rep) jm_report_add_entry(rep, "no model matched [.'$Feature'.id.'|']", path);
            if (rep) jm_report_add_entry(rep, "unexpected value for optional prop <id> [.'$Feature']", path);
            return false;
        }
    }
    if (json_object_get(val, "bbox") != NULL)
    {
        pval = json_object_get(val, "bbox");
        // .'$Feature'.bbox
        res = json_is_array(pval);
        if (res)
        {
            size_t arr_16_idx;
            json_t *arr_16_item;
            json_array_foreach(pval, arr_16_idx, arr_16_item)
            {
                jm_path_t arr_16_lpath = (jm_path_t) { NULL, arr_16_idx, path, NULL };
                // .'$Feature'.bbox.0
                res = json_is_number(arr_16_item);
                if (! res)
                {
                    if (rep) jm_report_add_entry(rep, "not a -1.0 loose float [.'$Feature'.bbox.0]", (path ? &arr_16_lpath : NULL));
                    break;
                }
            }
        }
        if (! res)
        {
            if (rep) jm_report_add_entry(rep, "not array or unexpected array [.'$Feature'.bbox]", path);
            if (rep) jm_report_add_entry(rep, "unexpected value for optional prop <bbox> [.'$Feature']", path);
            return false;
        }
    }
    return true;
}

// check $Feature (.'$Feature')
static bool json_model_13(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .'$Feature'
    res = _jm_obj_7(val, path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected element [.'$Feature']", path);
    }
    return res;
}

// object .'$FeatureCollection'
static INLINE bool _jm_obj_9(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    // check must only props
    if (! json_is_object(val))
    {
        if (rep) jm_report_add_entry(rep, "not an object [.'$FeatureCollection']", path);
        return false;
    }
    json_t * pval;
    bool res;
    if (! (json_object_get(val, "type") != NULL))
    {
        if (rep) jm_report_add_entry(rep, "missing mandatory prop <type> [.'$FeatureCollection']", path);
        return false;
    }
    pval = json_object_get(val, "type");
    // .'$FeatureCollection'.type
    res = json_is_string(pval) && strcmp(json_string_value(pval), "FeatureCollection") == 0;
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected FeatureCollection [.'$FeatureCollection'.type]", path);
        if (rep) jm_report_add_entry(rep, "unexpected value for mandatory prop <type> [.'$FeatureCollection']", path);
        return false;
    }
    if (! (json_object_get(val, "features") != NULL))
    {
        if (rep) jm_report_add_entry(rep, "missing mandatory prop <features> [.'$FeatureCollection']", path);
        return false;
    }
    pval = json_object_get(val, "features");
    // .'$FeatureCollection'.features
    res = json_is_array(pval);
    if (res)
    {
        size_t arr_17_idx;
        json_t *arr_17_item;
        json_array_foreach(pval, arr_17_idx, arr_17_item)
        {
            jm_path_t arr_17_lpath = (jm_path_t) { NULL, arr_17_idx, path, NULL };
            // .'$FeatureCollection'.features.0
            res = json_model_13(arr_17_item, (path ? &arr_17_lpath : NULL), rep);
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "unexpected $Feature [.'$FeatureCollection'.features.0]", (path ? &arr_17_lpath : NULL));
                break;
            }
        }
    }
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "not array or unexpected array [.'$FeatureCollection'.features]", path);
        if (rep) jm_report_add_entry(rep, "unexpected value for mandatory prop <features> [.'$FeatureCollection']", path);
        return false;
    }
    if (json_object_get(val, "bbox") != NULL)
    {
        pval = json_object_get(val, "bbox");
        // .'$FeatureCollection'.bbox
        res = json_is_array(pval);
        if (res)
        {
            size_t arr_18_idx;
            json_t *arr_18_item;
            json_array_foreach(pval, arr_18_idx, arr_18_item)
            {
                jm_path_t arr_18_lpath = (jm_path_t) { NULL, arr_18_idx, path, NULL };
                // .'$FeatureCollection'.bbox.0
                res = json_is_number(arr_18_item);
                if (! res)
                {
                    if (rep) jm_report_add_entry(rep, "not a -1.0 loose float [.'$FeatureCollection'.bbox.0]", (path ? &arr_18_lpath : NULL));
                    break;
                }
            }
        }
        if (! res)
        {
            if (rep) jm_report_add_entry(rep, "not array or unexpected array [.'$FeatureCollection'.bbox]", path);
            if (rep) jm_report_add_entry(rep, "unexpected value for optional prop <bbox> [.'$FeatureCollection']", path);
            return false;
        }
    }
    return true;
}

// check $FeatureCollection (.'$FeatureCollection')
static bool json_model_14(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .'$FeatureCollection'
    res = _jm_obj_9(val, path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected element [.'$FeatureCollection']", path);
    }
    return res;
}

// check $ (.)
static bool json_model_1(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // Easy Geo JSON Model JSON_MODEL_LOOSE_FLOAT
    // .
    // generic xor list
    int64_t xc_0 = 0;
    bool xr_0;
    // .'^'.0
    xr_0 = json_model_11(val, path, rep);
    if (xr_0)
    {
        xc_0 += 1;
    }
    else
    {
        if (rep) jm_report_add_entry(rep, "unexpected $geometry [.'^'.0]", path);
    }
    // .'^'.1
    xr_0 = json_model_12(val, path, rep);
    if (xr_0)
    {
        xc_0 += 1;
    }
    else
    {
        if (rep) jm_report_add_entry(rep, "unexpected $GeometryCollection [.'^'.1]", path);
    }
    if (xc_0 <= 1)
    {
        // .'^'.2
        xr_0 = json_model_13(val, path, rep);
        if (xr_0)
        {
            xc_0 += 1;
        }
        else
        {
            if (rep) jm_report_add_entry(rep, "unexpected $Feature [.'^'.2]", path);
        }
    }
    if (xc_0 <= 1)
    {
        // .'^'.3
        xr_0 = json_model_14(val, path, rep);
        if (xr_0)
        {
            xc_0 += 1;
        }
        else
        {
            if (rep) jm_report_add_entry(rep, "unexpected $FeatureCollection [.'^'.3]", path);
        }
    }
    res = xc_0 == 1;
    if (res)
    {
        if (rep) jm_report_free_entries(rep);
    }
    else
    {
        if (rep) jm_report_add_entry(rep, "not one model match [.'^']", path);
    }
    return res;
}

jm_check_fun_t check_model_map(const char *pname)
{
    return jm_search_propmap(pname, check_model_map_tab, 14);
}

static bool initialized = false;

const char *check_model_init(void)
{
    if (!initialized)
    {
        initialized = true;
        jm_version_string = JSON_MODEL_VERSION;
        _jm_map_0_tab[0] = (jm_constmap_t) { (jm_constant_t) { cst_is_string, { .s = "Point" } }, json_model_5 };
        _jm_map_0_tab[1] = (jm_constmap_t) { (jm_constant_t) { cst_is_string, { .s = "MultiPoint" } }, json_model_6 };
        _jm_map_0_tab[2] = (jm_constmap_t) { (jm_constant_t) { cst_is_string, { .s = "LineString" } }, json_model_7 };
        _jm_map_0_tab[3] = (jm_constmap_t) { (jm_constant_t) { cst_is_string, { .s = "MultiLineString" } }, json_model_8 };
        _jm_map_0_tab[4] = (jm_constmap_t) { (jm_constant_t) { cst_is_string, { .s = "Polygon" } }, json_model_9 };
        _jm_map_0_tab[5] = (jm_constmap_t) { (jm_constant_t) { cst_is_string, { .s = "MultiPolygon" } }, json_model_10 };
        jm_sort_constmap(_jm_map_0_tab, 6);
        check_model_map_tab[0] = (jm_propmap_t) { "", json_model_1 };
        check_model_map_tab[1] = (jm_propmap_t) { "position", json_model_2 };
        check_model_map_tab[2] = (jm_propmap_t) { "coord_array", json_model_3 };
        check_model_map_tab[3] = (jm_propmap_t) { "linear_ring", json_model_4 };
        check_model_map_tab[4] = (jm_propmap_t) { "Point", json_model_5 };
        check_model_map_tab[5] = (jm_propmap_t) { "MultiPoint", json_model_6 };
        check_model_map_tab[6] = (jm_propmap_t) { "LineString", json_model_7 };
        check_model_map_tab[7] = (jm_propmap_t) { "MultiLineString", json_model_8 };
        check_model_map_tab[8] = (jm_propmap_t) { "Polygon", json_model_9 };
        check_model_map_tab[9] = (jm_propmap_t) { "MultiPolygon", json_model_10 };
        check_model_map_tab[10] = (jm_propmap_t) { "geometry", json_model_11 };
        check_model_map_tab[11] = (jm_propmap_t) { "GeometryCollection", json_model_12 };
        check_model_map_tab[12] = (jm_propmap_t) { "Feature", json_model_13 };
        check_model_map_tab[13] = (jm_propmap_t) { "FeatureCollection", json_model_14 };
        jm_sort_propmap(check_model_map_tab, 14);
    }
    return NULL;
}

void check_model_free(void)
{
    if (initialized)
    {
        initialized = false;

        // cleanup code
    }
}

/*
 * # API
 *
 * ```c
 * bool error;
 * char *message;
 *
 * bool valid = check(json_value, "model-name", &error, &message);
 *
 * if (message)
 *    free(message), message = NULL;
 * ```
 *
 * - `error` is set of there was an error during initialization or if the model does not exists.
 * - `message` is provided if a non NULL pointer is passed, and must be freed by the caller.
 */
bool
check_model(const json_t *val, const char *name, bool *error, char **reasons)
{
    return jm_generic_entry(check_model_init, check_model_map, val, name, error, reasons);
}
