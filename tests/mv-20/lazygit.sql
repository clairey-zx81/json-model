--
-- Generated by JSON Model Compiler version 2.0b0
-- see https://github.com/clairey-zx81/json-model
--
-- JSON_MODEL_VERSION is 2.0b0

CREATE OR REPLACE FUNCTION _jm_cst_0(value JSONB)
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  constants JSONB = JSONB '["black","red","green","yellow","blue","magenta","cyan","white","bold","default","reverse","underline","strikethrough"]';
BEGIN
  RETURN constants @> value;
END;
$$ LANGUAGE plpgsql;

-- regex=^#[0-9a-fA-F]{6}$ opts=n
CREATE OR REPLACE FUNCTION _jm_re_0(val TEXT, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  RETURN regexp_like(val, '^#[0-9a-fA-F]{6}$', 'n');
END;
$$ LANGUAGE plpgsql;

-- check $color (.'$color')
CREATE OR REPLACE FUNCTION json_model_2(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$color'
  res := JSONB_TYPEOF(val) IN ('null', 'boolean', 'number', 'string') AND _jm_cst_0(val);
  IF NOT res THEN
    res := JSONB_TYPEOF(val) = 'string';
    IF res THEN
      -- .'$color'.'|'.0
      -- "/^#[0-9a-fA-F]{6}$/"
      res := _jm_re_0(JSON_VALUE(val, '$' RETURNING TEXT), path, rep);
    END IF;
  END IF;
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check $colorArray (.'$colorArray')
CREATE OR REPLACE FUNCTION json_model_3(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  arr_0_idx INT8;
  arr_0_item JSONB;
  ival_0 int;
BEGIN
  -- .'$colorArray'
  -- .'$colorArray'.'@'
  res := JSONB_TYPEOF(val) = 'array';
  IF res THEN
    FOR arr_0_idx IN 0 .. JSONB_ARRAY_LENGTH(val) - 1 LOOP
      arr_0_item := val -> arr_0_idx;
      -- .'$colorArray'.'@'.0
      res := json_model_2(arr_0_item, NULL, rep);
      IF NOT res THEN
        EXIT;
      END IF;
    END LOOP;
  END IF;
  IF res THEN
    ival_0 := JSONB_ARRAY_LENGTH(val);
    res := jm_array_is_unique(val, path, rep) AND ival_0 >= 1;
  END IF;
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check $keybinding (.'$keybinding')
CREATE OR REPLACE FUNCTION json_model_4(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$keybinding'
  -- .'$keybinding'.'|'.0
  res := JSONB_TYPEOF(val) = 'null';
  IF NOT res THEN
    -- .'$keybinding'.'|'.1
    res := JSONB_TYPEOF(val) = 'string';
  END IF;
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION _jm_cst_1(value JSONB)
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  constants JSONB = JSONB '["input","confirm","menu","menuFromCommand"]';
BEGIN
  RETURN constants @> value;
END;
$$ LANGUAGE plpgsql;

-- check $custom-commands-prompts-type-property (.'$custom-commands-prompts-type-property')
CREATE OR REPLACE FUNCTION json_model_5(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$custom-commands-prompts-type-property'
  res := JSONB_TYPEOF(val) IN ('null', 'boolean', 'number', 'string') AND _jm_cst_1(val);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check $custom-commands-prompts-title-property (.'$custom-commands-prompts-title-property')
CREATE OR REPLACE FUNCTION json_model_6(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$custom-commands-prompts-title-property'
  res := JSONB_TYPEOF(val) = 'string';
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check $custom-commands-prompts-key-property (.'$custom-commands-prompts-key-property')
CREATE OR REPLACE FUNCTION json_model_7(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$custom-commands-prompts-key-property'
  res := JSONB_TYPEOF(val) = 'string';
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check $neString (.'$neString')
CREATE OR REPLACE FUNCTION json_model_8(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  ival_1 int;
BEGIN
  -- .'$neString'
  -- .'$neString'.'@'
  res := JSONB_TYPEOF(val) = 'string';
  IF res THEN
    ival_1 := LENGTH(JSON_VALUE(val, '$' RETURNING TEXT));
    res := ival_1 >= 1;
  END IF;
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check $stringArray (.'$stringArray')
CREATE OR REPLACE FUNCTION json_model_9(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  arr_1_idx INT8;
  arr_1_item JSONB;
BEGIN
  -- .'$stringArray'
  -- .'$stringArray'.'@'
  res := JSONB_TYPEOF(val) = 'array';
  IF res THEN
    FOR arr_1_idx IN 0 .. JSONB_ARRAY_LENGTH(val) - 1 LOOP
      arr_1_item := val -> arr_1_idx;
      -- .'$stringArray'.'@'.0
      res := json_model_8(arr_1_item, NULL, rep);
      IF NOT res THEN
        EXIT;
      END IF;
    END LOOP;
  END IF;
  IF res THEN
    res := jm_array_is_unique(val, path, rep);
  END IF;
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- object .'$Prompts'.'|'.0.suggestions.'|'.1
CREATE OR REPLACE FUNCTION _jm_obj_1(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  must_count int;
  prop TEXT;
  pval JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  must_count := 0;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = 'command' THEN
      -- handle must command property
      must_count := must_count + 1;
      -- .'$Prompts'.'|'.0.suggestions.'|'.1.command
      res := JSONB_TYPEOF(pval) = 'string';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  IF must_count <> 1 THEN
    RETURN FALSE;
  END IF;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION _jm_cst_2(value JSONB)
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  constants JSONB = JSONB '["authors","branches","files","refs","remotes","remoteBranches","tags"]';
BEGIN
  RETURN constants @> value;
END;
$$ LANGUAGE plpgsql;

-- object .'$Prompts'.'|'.0.suggestions.'|'.0
CREATE OR REPLACE FUNCTION _jm_obj_2(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  must_count int;
  prop TEXT;
  pval JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  must_count := 0;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = 'preset' THEN
      -- handle must preset property
      must_count := must_count + 1;
      -- .'$Prompts'.'|'.0.suggestions.'|'.0.preset
      res := JSONB_TYPEOF(pval) IN ('null', 'boolean', 'number', 'string') AND _jm_cst_2(pval);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  IF must_count <> 1 THEN
    RETURN FALSE;
  END IF;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- object .'$Prompts'.'|'.0
CREATE OR REPLACE FUNCTION _jm_obj_0(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  must_count int;
  prop TEXT;
  pval JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  must_count := 0;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = 'type' THEN
      -- handle must type property
      must_count := must_count + 1;
      -- .'$Prompts'.'|'.0.type
      res := JSONB_TYPEOF(pval) = 'string' AND JSON_VALUE(pval, '$' RETURNING TEXT) = 'input';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'title' THEN
      -- handle must title property
      must_count := must_count + 1;
      -- .'$Prompts'.'|'.0.title
      res := json_model_6(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'key' THEN
      -- handle must key property
      must_count := must_count + 1;
      -- .'$Prompts'.'|'.0.key
      res := json_model_7(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'initialValue' THEN
      -- handle may initialValue property
      -- .'$Prompts'.'|'.0.initialValue
      res := JSONB_TYPEOF(pval) = 'string';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'suggestions' THEN
      -- handle may suggestions property
      -- .'$Prompts'.'|'.0.suggestions
      res := JSONB_TYPEOF(pval) = 'object';
      IF res THEN
        -- .'$Prompts'.'|'.0.suggestions.'|'.0
        res := _jm_obj_2(pval, NULL, rep);
        IF NOT res THEN
          -- .'$Prompts'.'|'.0.suggestions.'|'.1
          res := _jm_obj_1(pval, NULL, rep);
        END IF;
      END IF;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  IF must_count <> 3 THEN
    RETURN FALSE;
  END IF;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- object .'$Prompts'.'|'.1
CREATE OR REPLACE FUNCTION _jm_obj_3(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  must_count int;
  prop TEXT;
  pval JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  must_count := 0;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = 'type' THEN
      -- handle must type property
      must_count := must_count + 1;
      -- .'$Prompts'.'|'.1.type
      res := JSONB_TYPEOF(pval) = 'string' AND JSON_VALUE(pval, '$' RETURNING TEXT) = 'confirm';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'title' THEN
      -- handle must title property
      must_count := must_count + 1;
      -- .'$Prompts'.'|'.1.title
      res := json_model_6(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'key' THEN
      -- handle must key property
      must_count := must_count + 1;
      -- .'$Prompts'.'|'.1.key
      res := json_model_7(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'body' THEN
      -- handle may body property
      -- .'$Prompts'.'|'.1.body
      res := JSONB_TYPEOF(pval) = 'string';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  IF must_count <> 3 THEN
    RETURN FALSE;
  END IF;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- object .'$Prompts'.'|'.2.options.'@'.0
CREATE OR REPLACE FUNCTION _jm_obj_5(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  must_count int;
  prop TEXT;
  pval JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  must_count := 0;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = 'value' THEN
      -- handle must value property
      must_count := must_count + 1;
      -- .'$Prompts'.'|'.2.options.'@'.0.value
      res := json_model_8(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'description' THEN
      -- handle may description property
      -- .'$Prompts'.'|'.2.options.'@'.0.description
      res := JSONB_TYPEOF(pval) = 'string';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'name' THEN
      -- handle may name property
      -- .'$Prompts'.'|'.2.options.'@'.0.name
      res := JSONB_TYPEOF(pval) = 'string';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  IF must_count <> 1 THEN
    RETURN FALSE;
  END IF;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- object .'$Prompts'.'|'.2
CREATE OR REPLACE FUNCTION _jm_obj_4(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  must_count int;
  prop TEXT;
  pval JSONB;
  arr_2_idx INT8;
  arr_2_item JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  must_count := 0;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = 'type' THEN
      -- handle must type property
      must_count := must_count + 1;
      -- .'$Prompts'.'|'.2.type
      res := JSONB_TYPEOF(pval) = 'string' AND JSON_VALUE(pval, '$' RETURNING TEXT) = 'menu';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'title' THEN
      -- handle must title property
      must_count := must_count + 1;
      -- .'$Prompts'.'|'.2.title
      res := json_model_6(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'key' THEN
      -- handle must key property
      must_count := must_count + 1;
      -- .'$Prompts'.'|'.2.key
      res := json_model_7(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'options' THEN
      -- handle must options property
      must_count := must_count + 1;
      -- .'$Prompts'.'|'.2.options
      -- .'$Prompts'.'|'.2.options.'@'
      res := JSONB_TYPEOF(pval) = 'array';
      IF res THEN
        FOR arr_2_idx IN 0 .. JSONB_ARRAY_LENGTH(pval) - 1 LOOP
          arr_2_item := pval -> arr_2_idx;
          -- .'$Prompts'.'|'.2.options.'@'.0
          res := _jm_obj_5(arr_2_item, NULL, rep);
          IF NOT res THEN
            EXIT;
          END IF;
        END LOOP;
      END IF;
      IF res THEN
        res := jm_array_is_unique(pval, NULL, rep);
      END IF;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  IF must_count <> 4 THEN
    RETURN FALSE;
  END IF;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- object .'$Prompts'.'|'.3
CREATE OR REPLACE FUNCTION _jm_obj_6(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  must_count int;
  prop TEXT;
  pval JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  must_count := 0;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = 'type' THEN
      -- handle must type property
      must_count := must_count + 1;
      -- .'$Prompts'.'|'.3.type
      res := JSONB_TYPEOF(pval) = 'string' AND JSON_VALUE(pval, '$' RETURNING TEXT) = 'menuFromCommand';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'title' THEN
      -- handle must title property
      must_count := must_count + 1;
      -- .'$Prompts'.'|'.3.title
      res := json_model_6(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'key' THEN
      -- handle must key property
      must_count := must_count + 1;
      -- .'$Prompts'.'|'.3.key
      res := json_model_7(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'command' THEN
      -- handle must command property
      must_count := must_count + 1;
      -- .'$Prompts'.'|'.3.command
      res := JSONB_TYPEOF(pval) = 'string';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'filter' THEN
      -- handle may filter property
      -- .'$Prompts'.'|'.3.filter
      res := JSONB_TYPEOF(pval) = 'string';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'valueFormat' THEN
      -- handle may valueFormat property
      -- .'$Prompts'.'|'.3.valueFormat
      res := JSONB_TYPEOF(pval) = 'string';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'labelFormat' THEN
      -- handle may labelFormat property
      -- .'$Prompts'.'|'.3.labelFormat
      res := JSONB_TYPEOF(pval) = 'string';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  IF must_count <> 4 THEN
    RETURN FALSE;
  END IF;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;


-- check $Prompts (.'$Prompts')
CREATE OR REPLACE FUNCTION json_model_10(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  tag_0 JSONB;
  fun_0 TEXT;
BEGIN
  -- .'$Prompts'
  res := JSONB_TYPEOF(val) = 'object';
  IF res THEN
    tag_0 := val -> 'type';
    IF tag_0 IS NOT NULL THEN
      fun_0 := jm_cmap_get('_jm_map_0', tag_0);
      IF fun_0 IS NOT NULL THEN
        res := jm_call(fun_0, val, path, rep);
      ELSE
        res := FALSE;
      END IF;
    ELSE
      res := FALSE;
    END IF;
  END IF;
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_7_map_confirmOnQuit (.confirmOnQuit)
CREATE OR REPLACE FUNCTION _jm_f_0(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .confirmOnQuit
  res := JSONB_TYPEOF(val) = 'boolean';
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION _jm_cst_3(value JSONB)
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  constants JSONB = JSONB '["status","files","worktrees","localBranches","remotes","remoteBranches","tags","commits","reflogCommits","subCommits","commitFiles","stash","global"]';
BEGIN
  RETURN constants @> value;
END;
$$ LANGUAGE plpgsql;

-- object .customCommands.'@'.0.after
CREATE OR REPLACE FUNCTION _jm_obj_9(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = 'checkForConflicts' THEN
      -- handle may checkForConflicts property
      -- .customCommands.'@'.0.after.checkForConflicts
      res := JSONB_TYPEOF(pval) = 'boolean';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_8_map_after (.customCommands.'@'.0.after)
CREATE OR REPLACE FUNCTION _jm_f_2(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .customCommands.'@'.0.after
  res := _jm_obj_9(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_8_map_description (.customCommands.'@'.0.description)
CREATE OR REPLACE FUNCTION _jm_f_3(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .customCommands.'@'.0.description
  res := JSONB_TYPEOF(val) = 'string';
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_8_map_loadingText (.customCommands.'@'.0.loadingText)
CREATE OR REPLACE FUNCTION _jm_f_4(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .customCommands.'@'.0.loadingText
  res := JSONB_TYPEOF(val) = 'string';
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_8_map_prompts (.customCommands.'@'.0.prompts)
CREATE OR REPLACE FUNCTION _jm_f_5(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  arr_4_idx INT8;
  arr_4_item JSONB;
BEGIN
  -- .customCommands.'@'.0.prompts
  res := JSONB_TYPEOF(val) = 'array';
  IF res THEN
    FOR arr_4_idx IN 0 .. JSONB_ARRAY_LENGTH(val) - 1 LOOP
      arr_4_item := val -> arr_4_idx;
      -- .customCommands.'@'.0.prompts.0
      res := json_model_10(arr_4_item, NULL, rep);
      IF NOT res THEN
        EXIT;
      END IF;
    END LOOP;
  END IF;
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_8_map_showOutput (.customCommands.'@'.0.showOutput)
CREATE OR REPLACE FUNCTION _jm_f_6(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .customCommands.'@'.0.showOutput
  res := JSONB_TYPEOF(val) = 'boolean';
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_8_map_stream (.customCommands.'@'.0.stream)
CREATE OR REPLACE FUNCTION _jm_f_7(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .customCommands.'@'.0.stream
  res := JSONB_TYPEOF(val) = 'boolean';
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_8_map_subprocess (.customCommands.'@'.0.subprocess)
CREATE OR REPLACE FUNCTION _jm_f_8(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .customCommands.'@'.0.subprocess
  res := JSONB_TYPEOF(val) = 'boolean';
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION _jm_obj_8_map(name TEXT)
RETURNS TEXT STRICT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  map JSONB := JSONB '{"after":"_jm_f_2","description":"_jm_f_3","loadingText":"_jm_f_4","prompts":"_jm_f_5","showOutput":"_jm_f_6","stream":"_jm_f_7","subprocess":"_jm_f_8"}';
BEGIN
  RETURN map->>name;
END;
$$ LANGUAGE plpgsql;

-- object .customCommands.'@'.0
CREATE OR REPLACE FUNCTION _jm_obj_8(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  pfun TEXT;
  must_count int;
  prop TEXT;
  pval JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  must_count := 0;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = 'key' THEN
      -- handle must key property
      must_count := must_count + 1;
      -- .customCommands.'@'.0.key
      res := json_model_4(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'command' THEN
      -- handle must command property
      must_count := must_count + 1;
      -- .customCommands.'@'.0.command
      res := JSONB_TYPEOF(pval) = 'string';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'context' THEN
      -- handle must context property
      must_count := must_count + 1;
      -- .customCommands.'@'.0.context
      res := JSONB_TYPEOF(pval) IN ('null', 'boolean', 'number', 'string') AND _jm_cst_3(pval);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF _jm_obj_8_map(prop) IS NOT NULL THEN
      -- handle 7 may props
      pfun := _jm_obj_8_map(prop);
      IF NOT jm_call(pfun, pval, NULL, rep) THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  IF must_count <> 3 THEN
    RETURN FALSE;
  END IF;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_7_map_customCommands (.customCommands)
CREATE OR REPLACE FUNCTION _jm_f_1(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  arr_3_idx INT8;
  arr_3_item JSONB;
BEGIN
  -- .customCommands
  -- .customCommands.'@'
  res := JSONB_TYPEOF(val) = 'array';
  IF res THEN
    FOR arr_3_idx IN 0 .. JSONB_ARRAY_LENGTH(val) - 1 LOOP
      arr_3_item := val -> arr_3_idx;
      -- .customCommands.'@'.0
      res := _jm_obj_8(arr_3_item, NULL, rep);
      IF NOT res THEN
        EXIT;
      END IF;
    END LOOP;
  END IF;
  IF res THEN
    res := jm_array_is_unique(val, path, rep);
  END IF;
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_7_map_disableStartupPopups (.disableStartupPopups)
CREATE OR REPLACE FUNCTION _jm_f_9(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .disableStartupPopups
  res := JSONB_TYPEOF(val) = 'boolean';
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_10_map_allBranchesLogCmd (.git.allBranchesLogCmd)
CREATE OR REPLACE FUNCTION _jm_f_11(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .git.allBranchesLogCmd
  res := JSONB_TYPEOF(val) = 'string';
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_10_map_autoFetch (.git.autoFetch)
CREATE OR REPLACE FUNCTION _jm_f_12(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .git.autoFetch
  res := JSONB_TYPEOF(val) = 'boolean';
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_10_map_autoRefresh (.git.autoRefresh)
CREATE OR REPLACE FUNCTION _jm_f_13(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .git.autoRefresh
  res := JSONB_TYPEOF(val) = 'boolean';
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_10_map_branchLogCmd (.git.branchLogCmd)
CREATE OR REPLACE FUNCTION _jm_f_14(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .git.branchLogCmd
  res := JSONB_TYPEOF(val) = 'string';
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- object .git.commit
CREATE OR REPLACE FUNCTION _jm_obj_11(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = 'signOff' THEN
      -- handle may signOff property
      -- .git.commit.signOff
      res := JSONB_TYPEOF(pval) = 'boolean';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_10_map_commit (.git.commit)
CREATE OR REPLACE FUNCTION _jm_f_15(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .git.commit
  res := _jm_obj_11(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- regex=. opts=n
CREATE OR REPLACE FUNCTION _jm_re_1(val TEXT, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  RETURN regexp_like(val, '.', 'n');
END;
$$ LANGUAGE plpgsql;

-- object .git.commitPrefixes.'/./'
CREATE OR REPLACE FUNCTION _jm_obj_13(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  must_count int;
  prop TEXT;
  pval JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  must_count := 0;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = 'pattern' THEN
      -- handle must pattern property
      must_count := must_count + 1;
      -- .git.commitPrefixes.'/./'.pattern
      res := json_model_8(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'replace' THEN
      -- handle must replace property
      must_count := must_count + 1;
      -- .git.commitPrefixes.'/./'.replace
      res := json_model_8(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  IF must_count <> 2 THEN
    RETURN FALSE;
  END IF;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- object .git.commitPrefixes
CREATE OR REPLACE FUNCTION _jm_obj_12(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF _jm_re_1(prop, path, rep) THEN
      -- handle 1 re props
      -- .git.commitPrefixes.'/./'
      res := _jm_obj_13(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_10_map_commitPrefixes (.git.commitPrefixes)
CREATE OR REPLACE FUNCTION _jm_f_16(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .git.commitPrefixes
  res := _jm_obj_12(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_10_map_diffContextSize (.git.diffContextSize)
CREATE OR REPLACE FUNCTION _jm_f_17(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .git.diffContextSize
  res := JSONB_TYPEOF(val) = 'number' AND (val)::INT8 = (val)::FLOAT8 AND (val)::INT8 >= 0;
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_10_map_disableForcePushing (.git.disableForcePushing)
CREATE OR REPLACE FUNCTION _jm_f_18(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .git.disableForcePushing
  res := JSONB_TYPEOF(val) = 'boolean';
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_10_map_fetchAll (.git.fetchAll)
CREATE OR REPLACE FUNCTION _jm_f_19(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .git.fetchAll
  res := JSONB_TYPEOF(val) = 'boolean';
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION _jm_cst_4(value JSONB)
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  constants JSONB = JSONB '["date-order","author-date-order","topo-order","default"]';
BEGIN
  RETURN constants @> value;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION _jm_cst_5(value JSONB)
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  constants JSONB = JSONB '["always","never","when-maximised"]';
BEGIN
  RETURN constants @> value;
END;
$$ LANGUAGE plpgsql;

-- object .git.log
CREATE OR REPLACE FUNCTION _jm_obj_14(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = 'order' THEN
      -- handle may order property
      -- .git.log.order
      res := JSONB_TYPEOF(pval) IN ('null', 'boolean', 'number', 'string') AND _jm_cst_4(pval);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'showGraph' THEN
      -- handle may showGraph property
      -- .git.log.showGraph
      res := JSONB_TYPEOF(pval) IN ('null', 'boolean', 'number', 'string') AND _jm_cst_5(pval);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'showWholeGraph' THEN
      -- handle may showWholeGraph property
      -- .git.log.showWholeGraph
      res := JSONB_TYPEOF(pval) = 'boolean';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_10_map_log (.git.log)
CREATE OR REPLACE FUNCTION _jm_f_20(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .git.log
  res := _jm_obj_14(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_10_map_mainBranches (.git.mainBranches)
CREATE OR REPLACE FUNCTION _jm_f_21(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .git.mainBranches
  res := json_model_9(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- object .git.merging
CREATE OR REPLACE FUNCTION _jm_obj_15(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = 'manualCommit' THEN
      -- handle may manualCommit property
      -- .git.merging.manualCommit
      res := JSONB_TYPEOF(pval) = 'boolean';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'args' THEN
      -- handle may args property
      -- .git.merging.args
      res := JSONB_TYPEOF(pval) = 'string';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_10_map_merging (.git.merging)
CREATE OR REPLACE FUNCTION _jm_f_22(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .git.merging
  res := _jm_obj_15(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_10_map_overrideGpg (.git.overrideGpg)
CREATE OR REPLACE FUNCTION _jm_f_23(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .git.overrideGpg
  res := JSONB_TYPEOF(val) = 'boolean';
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION _jm_cst_6(value JSONB)
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  constants JSONB = JSONB '["always","never"]';
BEGIN
  RETURN constants @> value;
END;
$$ LANGUAGE plpgsql;

-- object .git.paging
CREATE OR REPLACE FUNCTION _jm_obj_16(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
  ival_2 int;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = 'colorArg' THEN
      -- handle may colorArg property
      -- .git.paging.colorArg
      res := JSONB_TYPEOF(pval) IN ('null', 'boolean', 'number', 'string') AND _jm_cst_6(pval);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'useConfig' THEN
      -- handle may useConfig property
      -- .git.paging.useConfig
      res := JSONB_TYPEOF(pval) = 'boolean';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'pager' THEN
      -- handle may pager property
      -- .git.paging.pager
      -- .git.paging.pager.'@'
      res := JSONB_TYPEOF(pval) = 'string';
      IF res THEN
        ival_2 := LENGTH(JSON_VALUE(pval, '$' RETURNING TEXT));
        res := ival_2 >= 1;
      END IF;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_10_map_paging (.git.paging)
CREATE OR REPLACE FUNCTION _jm_f_24(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .git.paging
  res := _jm_obj_16(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_10_map_parseEmoji (.git.parseEmoji)
CREATE OR REPLACE FUNCTION _jm_f_25(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .git.parseEmoji
  res := JSONB_TYPEOF(val) = 'boolean';
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_10_map_skipHookPrefix (.git.skipHookPrefix)
CREATE OR REPLACE FUNCTION _jm_f_26(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .git.skipHookPrefix
  res := JSONB_TYPEOF(val) = 'string';
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION _jm_obj_10_map(name TEXT)
RETURNS TEXT STRICT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  map JSONB := JSONB '{"allBranchesLogCmd":"_jm_f_11","autoFetch":"_jm_f_12","autoRefresh":"_jm_f_13","branchLogCmd":"_jm_f_14","commit":"_jm_f_15","commitPrefixes":"_jm_f_16","diffContextSize":"_jm_f_17","disableForcePushing":"_jm_f_18","fetchAll":"_jm_f_19","log":"_jm_f_20","mainBranches":"_jm_f_21","merging":"_jm_f_22","overrideGpg":"_jm_f_23","paging":"_jm_f_24","parseEmoji":"_jm_f_25","skipHookPrefix":"_jm_f_26"}';
BEGIN
  RETURN map->>name;
END;
$$ LANGUAGE plpgsql;

-- object .git
CREATE OR REPLACE FUNCTION _jm_obj_10(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  pfun TEXT;
  prop TEXT;
  pval JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF _jm_obj_10_map(prop) IS NOT NULL THEN
      -- handle 16 may props
      pfun := _jm_obj_10_map(prop);
      IF NOT jm_call(pfun, pval, NULL, rep) THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_7_map_git (.git)
CREATE OR REPLACE FUNCTION _jm_f_10(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .git
  res := _jm_obj_10(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_17_map_animateExplosion (.gui.animateExplosion)
CREATE OR REPLACE FUNCTION _jm_f_28(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .gui.animateExplosion
  res := JSONB_TYPEOF(val) = 'boolean';
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- object .gui.authorColors
CREATE OR REPLACE FUNCTION _jm_obj_18(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF _jm_re_1(prop, path, rep) THEN
      -- handle 1 re props
      -- .gui.authorColors.'/./'
      res := json_model_2(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_17_map_authorColors (.gui.authorColors)
CREATE OR REPLACE FUNCTION _jm_f_29(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .gui.authorColors
  res := _jm_obj_18(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION _jm_cst_7(value JSONB)
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  constants JSONB = JSONB '["single","double","rounded","hidden"]';
BEGIN
  RETURN constants @> value;
END;
$$ LANGUAGE plpgsql;

-- check _jm_obj_17_map_border (.gui.border)
CREATE OR REPLACE FUNCTION _jm_f_30(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .gui.border
  res := JSONB_TYPEOF(val) IN ('null', 'boolean', 'number', 'string') AND _jm_cst_7(val);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- object .gui.branchColors
CREATE OR REPLACE FUNCTION _jm_obj_19(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF _jm_re_1(prop, path, rep) THEN
      -- handle 1 re props
      -- .gui.branchColors.'/./'
      res := json_model_2(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_17_map_branchColors (.gui.branchColors)
CREATE OR REPLACE FUNCTION _jm_f_31(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .gui.branchColors
  res := _jm_obj_19(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_17_map_commandLogSize (.gui.commandLogSize)
CREATE OR REPLACE FUNCTION _jm_f_32(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .gui.commandLogSize
  res := JSONB_TYPEOF(val) = 'number' AND (val)::INT8 = (val)::FLOAT8 AND (val)::INT8 >= 0;
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- object .gui.commitLength
CREATE OR REPLACE FUNCTION _jm_obj_20(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = 'show' THEN
      -- handle may show property
      -- .gui.commitLength.show
      res := JSONB_TYPEOF(pval) = 'boolean';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_17_map_commitLength (.gui.commitLength)
CREATE OR REPLACE FUNCTION _jm_f_33(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .gui.commitLength
  res := _jm_obj_20(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_17_map_expandFocusedSidePanel (.gui.expandFocusedSidePanel)
CREATE OR REPLACE FUNCTION _jm_f_34(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .gui.expandFocusedSidePanel
  res := JSONB_TYPEOF(val) = 'boolean';
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION _jm_cst_8(value JSONB)
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  constants JSONB = JSONB '["auto","en","zh-CN","zh-TW","pl","nl","ja","ko","ru"]';
BEGIN
  RETURN constants @> value;
END;
$$ LANGUAGE plpgsql;

-- check _jm_obj_17_map_language (.gui.language)
CREATE OR REPLACE FUNCTION _jm_f_35(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .gui.language
  res := JSONB_TYPEOF(val) IN ('null', 'boolean', 'number', 'string') AND _jm_cst_8(val);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION _jm_cst_9(value JSONB)
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  constants JSONB = JSONB '["horizontal","flexible","vertical"]';
BEGIN
  RETURN constants @> value;
END;
$$ LANGUAGE plpgsql;

-- check _jm_obj_17_map_mainPanelSplitMode (.gui.mainPanelSplitMode)
CREATE OR REPLACE FUNCTION _jm_f_36(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .gui.mainPanelSplitMode
  res := JSONB_TYPEOF(val) IN ('null', 'boolean', 'number', 'string') AND _jm_cst_9(val);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_17_map_mouseEvents (.gui.mouseEvents)
CREATE OR REPLACE FUNCTION _jm_f_37(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .gui.mouseEvents
  res := JSONB_TYPEOF(val) = 'boolean';
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION _jm_cst_10(value JSONB)
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  constants JSONB = JSONB '["2","3"]';
BEGIN
  RETURN constants @> value;
END;
$$ LANGUAGE plpgsql;

-- check _jm_obj_17_map_nerdFontsVersion (.gui.nerdFontsVersion)
CREATE OR REPLACE FUNCTION _jm_f_38(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .gui.nerdFontsVersion
  res := JSONB_TYPEOF(val) IN ('null', 'boolean', 'number', 'string') AND _jm_cst_10(val);
  IF NOT res THEN
    res := JSONB_TYPEOF(val) = 'string';
    IF res THEN
      -- .gui.nerdFontsVersion.'|'.0
      res := TRUE;
    END IF;
  END IF;
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_17_map_scrollHeight (.gui.scrollHeight)
CREATE OR REPLACE FUNCTION _jm_f_39(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .gui.scrollHeight
  res := JSONB_TYPEOF(val) = 'number' AND (val)::INT8 = (val)::FLOAT8 AND (val)::INT8 >= 1;
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_17_map_scrollPastBottom (.gui.scrollPastBottom)
CREATE OR REPLACE FUNCTION _jm_f_40(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .gui.scrollPastBottom
  res := JSONB_TYPEOF(val) = 'boolean';
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_17_map_shortTimeFormat (.gui.shortTimeFormat)
CREATE OR REPLACE FUNCTION _jm_f_41(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .gui.shortTimeFormat
  res := JSONB_TYPEOF(val) = 'string';
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_17_map_showBottomLine (.gui.showBottomLine)
CREATE OR REPLACE FUNCTION _jm_f_42(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .gui.showBottomLine
  res := JSONB_TYPEOF(val) = 'boolean';
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_17_map_showBranchCommitHash (.gui.showBranchCommitHash)
CREATE OR REPLACE FUNCTION _jm_f_43(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .gui.showBranchCommitHash
  res := JSONB_TYPEOF(val) = 'boolean';
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_17_map_showCommandLog (.gui.showCommandLog)
CREATE OR REPLACE FUNCTION _jm_f_44(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .gui.showCommandLog
  res := JSONB_TYPEOF(val) = 'boolean';
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_17_map_showFileTree (.gui.showFileTree)
CREATE OR REPLACE FUNCTION _jm_f_45(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .gui.showFileTree
  res := JSONB_TYPEOF(val) = 'boolean';
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_17_map_showListFooter (.gui.showListFooter)
CREATE OR REPLACE FUNCTION _jm_f_46(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .gui.showListFooter
  res := JSONB_TYPEOF(val) = 'boolean';
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_17_map_showRandomTip (.gui.showRandomTip)
CREATE OR REPLACE FUNCTION _jm_f_47(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .gui.showRandomTip
  res := JSONB_TYPEOF(val) = 'boolean';
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_17_map_sidePanelWidth (.gui.sidePanelWidth)
CREATE OR REPLACE FUNCTION _jm_f_48(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  fval_0 FLOAT8;
BEGIN
  -- .gui.sidePanelWidth
  -- .gui.sidePanelWidth.'@'
  res := JSONB_TYPEOF(val) = 'number' AND (val)::FLOAT8 >= 0.0;
  IF res THEN
    fval_0 := (val)::FLOAT8;
    res := fval_0 <= 1.0;
  END IF;
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_17_map_skipDiscardChangeWarning (.gui.skipDiscardChangeWarning)
CREATE OR REPLACE FUNCTION _jm_f_49(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .gui.skipDiscardChangeWarning
  res := JSONB_TYPEOF(val) = 'boolean';
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_17_map_skipRewordInEditorWarning (.gui.skipRewordInEditorWarning)
CREATE OR REPLACE FUNCTION _jm_f_50(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .gui.skipRewordInEditorWarning
  res := JSONB_TYPEOF(val) = 'boolean';
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_17_map_skipStashWarning (.gui.skipStashWarning)
CREATE OR REPLACE FUNCTION _jm_f_51(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .gui.skipStashWarning
  res := JSONB_TYPEOF(val) = 'boolean';
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION _jm_cst_11(value JSONB)
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  constants JSONB = JSONB '["auto","always"]';
BEGIN
  RETURN constants @> value;
END;
$$ LANGUAGE plpgsql;

-- check _jm_obj_17_map_splitDiff (.gui.splitDiff)
CREATE OR REPLACE FUNCTION _jm_f_52(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .gui.splitDiff
  res := JSONB_TYPEOF(val) IN ('null', 'boolean', 'number', 'string') AND _jm_cst_11(val);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_21_map_activeBorderColor (.gui.theme.activeBorderColor)
CREATE OR REPLACE FUNCTION _jm_f_54(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .gui.theme.activeBorderColor
  res := json_model_3(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_21_map_cherryPickedCommitBgColor (.gui.theme.cherryPickedCommitBgColor)
CREATE OR REPLACE FUNCTION _jm_f_55(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .gui.theme.cherryPickedCommitBgColor
  res := json_model_3(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_21_map_cherryPickedCommitFgColor (.gui.theme.cherryPickedCommitFgColor)
CREATE OR REPLACE FUNCTION _jm_f_56(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .gui.theme.cherryPickedCommitFgColor
  res := json_model_3(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_21_map_defaultFgColor (.gui.theme.defaultFgColor)
CREATE OR REPLACE FUNCTION _jm_f_57(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .gui.theme.defaultFgColor
  res := json_model_3(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_21_map_inactiveBorderColor (.gui.theme.inactiveBorderColor)
CREATE OR REPLACE FUNCTION _jm_f_58(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .gui.theme.inactiveBorderColor
  res := json_model_3(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_21_map_optionsTextColor (.gui.theme.optionsTextColor)
CREATE OR REPLACE FUNCTION _jm_f_59(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .gui.theme.optionsTextColor
  res := json_model_3(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_21_map_searchingActiveBorderColor (.gui.theme.searchingActiveBorderColor)
CREATE OR REPLACE FUNCTION _jm_f_60(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .gui.theme.searchingActiveBorderColor
  res := json_model_3(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_21_map_selectedLineBgColor (.gui.theme.selectedLineBgColor)
CREATE OR REPLACE FUNCTION _jm_f_61(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .gui.theme.selectedLineBgColor
  res := json_model_3(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_21_map_selectedRangeBgColor (.gui.theme.selectedRangeBgColor)
CREATE OR REPLACE FUNCTION _jm_f_62(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .gui.theme.selectedRangeBgColor
  res := json_model_3(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_21_map_unstagedChangesColor (.gui.theme.unstagedChangesColor)
CREATE OR REPLACE FUNCTION _jm_f_63(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .gui.theme.unstagedChangesColor
  res := json_model_3(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION _jm_obj_21_map(name TEXT)
RETURNS TEXT STRICT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  map JSONB := JSONB '{"activeBorderColor":"_jm_f_54","cherryPickedCommitBgColor":"_jm_f_55","cherryPickedCommitFgColor":"_jm_f_56","defaultFgColor":"_jm_f_57","inactiveBorderColor":"_jm_f_58","optionsTextColor":"_jm_f_59","searchingActiveBorderColor":"_jm_f_60","selectedLineBgColor":"_jm_f_61","selectedRangeBgColor":"_jm_f_62","unstagedChangesColor":"_jm_f_63"}';
BEGIN
  RETURN map->>name;
END;
$$ LANGUAGE plpgsql;

-- object .gui.theme
CREATE OR REPLACE FUNCTION _jm_obj_21(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  pfun TEXT;
  prop TEXT;
  pval JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF _jm_obj_21_map(prop) IS NOT NULL THEN
      -- handle 10 may props
      pfun := _jm_obj_21_map(prop);
      IF NOT jm_call(pfun, pval, NULL, rep) THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_17_map_theme (.gui.theme)
CREATE OR REPLACE FUNCTION _jm_f_53(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .gui.theme
  res := _jm_obj_21(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_17_map_timeFormat (.gui.timeFormat)
CREATE OR REPLACE FUNCTION _jm_f_64(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .gui.timeFormat
  res := JSONB_TYPEOF(val) = 'string';
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION _jm_cst_12(value JSONB)
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  constants JSONB = JSONB '["normal","half","full"]';
BEGIN
  RETURN constants @> value;
END;
$$ LANGUAGE plpgsql;

-- check _jm_obj_17_map_windowSize (.gui.windowSize)
CREATE OR REPLACE FUNCTION _jm_f_65(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .gui.windowSize
  res := JSONB_TYPEOF(val) IN ('null', 'boolean', 'number', 'string') AND _jm_cst_12(val);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION _jm_obj_17_map(name TEXT)
RETURNS TEXT STRICT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  map JSONB := JSONB '{"animateExplosion":"_jm_f_28","authorColors":"_jm_f_29","border":"_jm_f_30","branchColors":"_jm_f_31","commandLogSize":"_jm_f_32","commitLength":"_jm_f_33","expandFocusedSidePanel":"_jm_f_34","language":"_jm_f_35","mainPanelSplitMode":"_jm_f_36","mouseEvents":"_jm_f_37","nerdFontsVersion":"_jm_f_38","scrollHeight":"_jm_f_39","scrollPastBottom":"_jm_f_40","shortTimeFormat":"_jm_f_41","showBottomLine":"_jm_f_42","showBranchCommitHash":"_jm_f_43","showCommandLog":"_jm_f_44","showFileTree":"_jm_f_45","showListFooter":"_jm_f_46","showRandomTip":"_jm_f_47","sidePanelWidth":"_jm_f_48","skipDiscardChangeWarning":"_jm_f_49","skipRewordInEditorWarning":"_jm_f_50","skipStashWarning":"_jm_f_51","splitDiff":"_jm_f_52","theme":"_jm_f_53","timeFormat":"_jm_f_64","windowSize":"_jm_f_65"}';
BEGIN
  RETURN map->>name;
END;
$$ LANGUAGE plpgsql;

-- object .gui
CREATE OR REPLACE FUNCTION _jm_obj_17(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  pfun TEXT;
  prop TEXT;
  pval JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF _jm_obj_17_map(prop) IS NOT NULL THEN
      -- handle 28 may props
      pfun := _jm_obj_17_map(prop);
      IF NOT jm_call(pfun, pval, NULL, rep) THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_7_map_gui (.gui)
CREATE OR REPLACE FUNCTION _jm_f_27(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .gui
  res := _jm_obj_17(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_23_map_checkoutBranchByName (.keybinding.branches.checkoutBranchByName)
CREATE OR REPLACE FUNCTION _jm_f_68(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .keybinding.branches.checkoutBranchByName
  res := json_model_4(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_23_map_createPullRequest (.keybinding.branches.createPullRequest)
CREATE OR REPLACE FUNCTION _jm_f_69(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .keybinding.branches.createPullRequest
  res := json_model_4(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_23_map_createTag (.keybinding.branches.createTag)
CREATE OR REPLACE FUNCTION _jm_f_70(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .keybinding.branches.createTag
  res := json_model_4(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_23_map_fastForward (.keybinding.branches.fastForward)
CREATE OR REPLACE FUNCTION _jm_f_71(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .keybinding.branches.fastForward
  res := json_model_4(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_23_map_fetchRemote (.keybinding.branches.fetchRemote)
CREATE OR REPLACE FUNCTION _jm_f_72(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .keybinding.branches.fetchRemote
  res := json_model_4(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_23_map_forceCheckoutBranch (.keybinding.branches.forceCheckoutBranch)
CREATE OR REPLACE FUNCTION _jm_f_73(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .keybinding.branches.forceCheckoutBranch
  res := json_model_4(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_23_map_mergeIntoCurrentBranch (.keybinding.branches.mergeIntoCurrentBranch)
CREATE OR REPLACE FUNCTION _jm_f_74(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .keybinding.branches.mergeIntoCurrentBranch
  res := json_model_4(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_23_map_pushTag (.keybinding.branches.pushTag)
CREATE OR REPLACE FUNCTION _jm_f_75(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .keybinding.branches.pushTag
  res := json_model_4(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_23_map_rebaseBranch (.keybinding.branches.rebaseBranch)
CREATE OR REPLACE FUNCTION _jm_f_76(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .keybinding.branches.rebaseBranch
  res := json_model_4(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_23_map_renameBranch (.keybinding.branches.renameBranch)
CREATE OR REPLACE FUNCTION _jm_f_77(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .keybinding.branches.renameBranch
  res := json_model_4(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_23_map_setUpstream (.keybinding.branches.setUpstream)
CREATE OR REPLACE FUNCTION _jm_f_78(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .keybinding.branches.setUpstream
  res := json_model_4(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_23_map_viewGitFlowOptions (.keybinding.branches.viewGitFlowOptions)
CREATE OR REPLACE FUNCTION _jm_f_79(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .keybinding.branches.viewGitFlowOptions
  res := json_model_4(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_23_map_viewPullRequestOptions (.keybinding.branches.viewPullRequestOptions)
CREATE OR REPLACE FUNCTION _jm_f_80(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .keybinding.branches.viewPullRequestOptions
  res := json_model_4(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION _jm_obj_23_map(name TEXT)
RETURNS TEXT STRICT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  map JSONB := JSONB '{"checkoutBranchByName":"_jm_f_68","createPullRequest":"_jm_f_69","createTag":"_jm_f_70","fastForward":"_jm_f_71","fetchRemote":"_jm_f_72","forceCheckoutBranch":"_jm_f_73","mergeIntoCurrentBranch":"_jm_f_74","pushTag":"_jm_f_75","rebaseBranch":"_jm_f_76","renameBranch":"_jm_f_77","setUpstream":"_jm_f_78","viewGitFlowOptions":"_jm_f_79","viewPullRequestOptions":"_jm_f_80"}';
BEGIN
  RETURN map->>name;
END;
$$ LANGUAGE plpgsql;

-- object .keybinding.branches
CREATE OR REPLACE FUNCTION _jm_obj_23(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  pfun TEXT;
  prop TEXT;
  pval JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF _jm_obj_23_map(prop) IS NOT NULL THEN
      -- handle 13 may props
      pfun := _jm_obj_23_map(prop);
      IF NOT jm_call(pfun, pval, NULL, rep) THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_22_map_branches (.keybinding.branches)
CREATE OR REPLACE FUNCTION _jm_f_67(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .keybinding.branches
  res := _jm_obj_23(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- object .keybinding.commitFiles
CREATE OR REPLACE FUNCTION _jm_obj_24(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = 'checkoutCommitFile' THEN
      -- handle may checkoutCommitFile property
      -- .keybinding.commitFiles.checkoutCommitFile
      res := json_model_4(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_22_map_commitFiles (.keybinding.commitFiles)
CREATE OR REPLACE FUNCTION _jm_f_81(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .keybinding.commitFiles
  res := _jm_obj_24(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_25_map_amendToCommit (.keybinding.commits.amendToCommit)
CREATE OR REPLACE FUNCTION _jm_f_83(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .keybinding.commits.amendToCommit
  res := json_model_4(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_25_map_checkoutCommit (.keybinding.commits.checkoutCommit)
CREATE OR REPLACE FUNCTION _jm_f_84(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .keybinding.commits.checkoutCommit
  res := json_model_4(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_25_map_cherryPickCopy (.keybinding.commits.cherryPickCopy)
CREATE OR REPLACE FUNCTION _jm_f_85(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .keybinding.commits.cherryPickCopy
  res := json_model_4(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_25_map_cherryPickCopyRange (.keybinding.commits.cherryPickCopyRange)
CREATE OR REPLACE FUNCTION _jm_f_86(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .keybinding.commits.cherryPickCopyRange
  res := json_model_4(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_25_map_copyCommitMessageToClipboard (.keybinding.commits.copyCommitMessageToClipboard)
CREATE OR REPLACE FUNCTION _jm_f_87(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .keybinding.commits.copyCommitMessageToClipboard
  res := json_model_4(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_25_map_createFixupCommit (.keybinding.commits.createFixupCommit)
CREATE OR REPLACE FUNCTION _jm_f_88(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .keybinding.commits.createFixupCommit
  res := json_model_4(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_25_map_markCommitAsFixup (.keybinding.commits.markCommitAsFixup)
CREATE OR REPLACE FUNCTION _jm_f_89(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .keybinding.commits.markCommitAsFixup
  res := json_model_4(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_25_map_moveDownCommit (.keybinding.commits.moveDownCommit)
CREATE OR REPLACE FUNCTION _jm_f_90(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .keybinding.commits.moveDownCommit
  res := json_model_4(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_25_map_moveUpCommit (.keybinding.commits.moveUpCommit)
CREATE OR REPLACE FUNCTION _jm_f_91(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .keybinding.commits.moveUpCommit
  res := json_model_4(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_25_map_openLogMenu (.keybinding.commits.openLogMenu)
CREATE OR REPLACE FUNCTION _jm_f_92(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .keybinding.commits.openLogMenu
  res := json_model_4(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_25_map_pasteCommits (.keybinding.commits.pasteCommits)
CREATE OR REPLACE FUNCTION _jm_f_93(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .keybinding.commits.pasteCommits
  res := json_model_4(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_25_map_pickCommit (.keybinding.commits.pickCommit)
CREATE OR REPLACE FUNCTION _jm_f_94(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .keybinding.commits.pickCommit
  res := json_model_4(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_25_map_renameCommit (.keybinding.commits.renameCommit)
CREATE OR REPLACE FUNCTION _jm_f_95(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .keybinding.commits.renameCommit
  res := json_model_4(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_25_map_renameCommitWithEditor (.keybinding.commits.renameCommitWithEditor)
CREATE OR REPLACE FUNCTION _jm_f_96(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .keybinding.commits.renameCommitWithEditor
  res := json_model_4(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_25_map_resetCherryPick (.keybinding.commits.resetCherryPick)
CREATE OR REPLACE FUNCTION _jm_f_97(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .keybinding.commits.resetCherryPick
  res := json_model_4(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_25_map_revertCommit (.keybinding.commits.revertCommit)
CREATE OR REPLACE FUNCTION _jm_f_98(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .keybinding.commits.revertCommit
  res := json_model_4(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_25_map_squashAboveCommits (.keybinding.commits.squashAboveCommits)
CREATE OR REPLACE FUNCTION _jm_f_99(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .keybinding.commits.squashAboveCommits
  res := json_model_4(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_25_map_squashDown (.keybinding.commits.squashDown)
CREATE OR REPLACE FUNCTION _jm_f_100(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .keybinding.commits.squashDown
  res := json_model_4(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_25_map_tagCommit (.keybinding.commits.tagCommit)
CREATE OR REPLACE FUNCTION _jm_f_101(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .keybinding.commits.tagCommit
  res := json_model_4(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_25_map_viewBisectOptions (.keybinding.commits.viewBisectOptions)
CREATE OR REPLACE FUNCTION _jm_f_102(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .keybinding.commits.viewBisectOptions
  res := json_model_4(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_25_map_viewResetOptions (.keybinding.commits.viewResetOptions)
CREATE OR REPLACE FUNCTION _jm_f_103(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .keybinding.commits.viewResetOptions
  res := json_model_4(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION _jm_obj_25_map(name TEXT)
RETURNS TEXT STRICT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  map JSONB := JSONB '{"amendToCommit":"_jm_f_83","checkoutCommit":"_jm_f_84","cherryPickCopy":"_jm_f_85","cherryPickCopyRange":"_jm_f_86","copyCommitMessageToClipboard":"_jm_f_87","createFixupCommit":"_jm_f_88","markCommitAsFixup":"_jm_f_89","moveDownCommit":"_jm_f_90","moveUpCommit":"_jm_f_91","openLogMenu":"_jm_f_92","pasteCommits":"_jm_f_93","pickCommit":"_jm_f_94","renameCommit":"_jm_f_95","renameCommitWithEditor":"_jm_f_96","resetCherryPick":"_jm_f_97","revertCommit":"_jm_f_98","squashAboveCommits":"_jm_f_99","squashDown":"_jm_f_100","tagCommit":"_jm_f_101","viewBisectOptions":"_jm_f_102","viewResetOptions":"_jm_f_103"}';
BEGIN
  RETURN map->>name;
END;
$$ LANGUAGE plpgsql;

-- object .keybinding.commits
CREATE OR REPLACE FUNCTION _jm_obj_25(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  pfun TEXT;
  prop TEXT;
  pval JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF _jm_obj_25_map(prop) IS NOT NULL THEN
      -- handle 21 may props
      pfun := _jm_obj_25_map(prop);
      IF NOT jm_call(pfun, pval, NULL, rep) THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_22_map_commits (.keybinding.commits)
CREATE OR REPLACE FUNCTION _jm_f_82(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .keybinding.commits
  res := _jm_obj_25(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_26_map_amendLastCommit (.keybinding.files.amendLastCommit)
CREATE OR REPLACE FUNCTION _jm_f_105(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .keybinding.files.amendLastCommit
  res := json_model_4(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_26_map_commitChanges (.keybinding.files.commitChanges)
CREATE OR REPLACE FUNCTION _jm_f_106(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .keybinding.files.commitChanges
  res := json_model_4(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_26_map_commitChangesWithEditor (.keybinding.files.commitChangesWithEditor)
CREATE OR REPLACE FUNCTION _jm_f_107(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .keybinding.files.commitChangesWithEditor
  res := json_model_4(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_26_map_commitChangesWithoutHook (.keybinding.files.commitChangesWithoutHook)
CREATE OR REPLACE FUNCTION _jm_f_108(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .keybinding.files.commitChangesWithoutHook
  res := json_model_4(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_26_map_fetch (.keybinding.files.fetch)
CREATE OR REPLACE FUNCTION _jm_f_109(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .keybinding.files.fetch
  res := json_model_4(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_26_map_ignoreFile (.keybinding.files.ignoreFile)
CREATE OR REPLACE FUNCTION _jm_f_110(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .keybinding.files.ignoreFile
  res := json_model_4(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_26_map_openMergeTool (.keybinding.files.openMergeTool)
CREATE OR REPLACE FUNCTION _jm_f_111(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .keybinding.files.openMergeTool
  res := json_model_4(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_26_map_openStatusFilter (.keybinding.files.openStatusFilter)
CREATE OR REPLACE FUNCTION _jm_f_112(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .keybinding.files.openStatusFilter
  res := json_model_4(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_26_map_refreshFiles (.keybinding.files.refreshFiles)
CREATE OR REPLACE FUNCTION _jm_f_113(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .keybinding.files.refreshFiles
  res := json_model_4(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_26_map_stashAllChanges (.keybinding.files.stashAllChanges)
CREATE OR REPLACE FUNCTION _jm_f_114(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .keybinding.files.stashAllChanges
  res := json_model_4(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_26_map_toggleStagedAll (.keybinding.files.toggleStagedAll)
CREATE OR REPLACE FUNCTION _jm_f_115(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .keybinding.files.toggleStagedAll
  res := json_model_4(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_26_map_toggleTreeView (.keybinding.files.toggleTreeView)
CREATE OR REPLACE FUNCTION _jm_f_116(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .keybinding.files.toggleTreeView
  res := json_model_4(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_26_map_viewResetOptions (.keybinding.files.viewResetOptions)
CREATE OR REPLACE FUNCTION _jm_f_117(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .keybinding.files.viewResetOptions
  res := json_model_4(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_26_map_viewStashOptions (.keybinding.files.viewStashOptions)
CREATE OR REPLACE FUNCTION _jm_f_118(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .keybinding.files.viewStashOptions
  res := json_model_4(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION _jm_obj_26_map(name TEXT)
RETURNS TEXT STRICT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  map JSONB := JSONB '{"amendLastCommit":"_jm_f_105","commitChanges":"_jm_f_106","commitChangesWithEditor":"_jm_f_107","commitChangesWithoutHook":"_jm_f_108","fetch":"_jm_f_109","ignoreFile":"_jm_f_110","openMergeTool":"_jm_f_111","openStatusFilter":"_jm_f_112","refreshFiles":"_jm_f_113","stashAllChanges":"_jm_f_114","toggleStagedAll":"_jm_f_115","toggleTreeView":"_jm_f_116","viewResetOptions":"_jm_f_117","viewStashOptions":"_jm_f_118"}';
BEGIN
  RETURN map->>name;
END;
$$ LANGUAGE plpgsql;

-- object .keybinding.files
CREATE OR REPLACE FUNCTION _jm_obj_26(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  pfun TEXT;
  prop TEXT;
  pval JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF _jm_obj_26_map(prop) IS NOT NULL THEN
      -- handle 14 may props
      pfun := _jm_obj_26_map(prop);
      IF NOT jm_call(pfun, pval, NULL, rep) THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_22_map_files (.keybinding.files)
CREATE OR REPLACE FUNCTION _jm_f_104(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .keybinding.files
  res := _jm_obj_26(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- object .keybinding.main
CREATE OR REPLACE FUNCTION _jm_obj_27(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = 'toggleDragSelect' THEN
      -- handle may toggleDragSelect property
      -- .keybinding.main.toggleDragSelect
      res := json_model_4(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'toggleDragSelect-alt' THEN
      -- handle may toggleDragSelect-alt property
      -- .keybinding.main.'toggleDragSelect-alt'
      res := json_model_4(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'toggleSelectHunk' THEN
      -- handle may toggleSelectHunk property
      -- .keybinding.main.toggleSelectHunk
      res := json_model_4(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'pickBothHunks' THEN
      -- handle may pickBothHunks property
      -- .keybinding.main.pickBothHunks
      res := json_model_4(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_22_map_main (.keybinding.main)
CREATE OR REPLACE FUNCTION _jm_f_119(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .keybinding.main
  res := _jm_obj_27(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- object .keybinding.stash
CREATE OR REPLACE FUNCTION _jm_obj_28(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = 'popStash' THEN
      -- handle may popStash property
      -- .keybinding.stash.popStash
      res := json_model_4(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'renameStash' THEN
      -- handle may renameStash property
      -- .keybinding.stash.renameStash
      res := json_model_4(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_22_map_stash (.keybinding.stash)
CREATE OR REPLACE FUNCTION _jm_f_120(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .keybinding.stash
  res := _jm_obj_28(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- object .keybinding.status
CREATE OR REPLACE FUNCTION _jm_obj_29(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = 'checkForUpdate' THEN
      -- handle may checkForUpdate property
      -- .keybinding.status.checkForUpdate
      res := json_model_4(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'recentRepos' THEN
      -- handle may recentRepos property
      -- .keybinding.status.recentRepos
      res := json_model_4(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_22_map_status (.keybinding.status)
CREATE OR REPLACE FUNCTION _jm_f_121(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .keybinding.status
  res := _jm_obj_29(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- object .keybinding.submodules
CREATE OR REPLACE FUNCTION _jm_obj_30(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = 'init' THEN
      -- handle may init property
      -- .keybinding.submodules.init
      res := json_model_4(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'update' THEN
      -- handle may update property
      -- .keybinding.submodules.update
      res := json_model_4(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'bulkMenu' THEN
      -- handle may bulkMenu property
      -- .keybinding.submodules.bulkMenu
      res := json_model_4(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_22_map_submodules (.keybinding.submodules)
CREATE OR REPLACE FUNCTION _jm_f_122(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .keybinding.submodules
  res := _jm_obj_30(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_31_map_confirm (.keybinding.universal.confirm)
CREATE OR REPLACE FUNCTION _jm_f_124(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .keybinding.universal.confirm
  res := json_model_4(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_31_map_copyToClipboard (.keybinding.universal.copyToClipboard)
CREATE OR REPLACE FUNCTION _jm_f_125(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .keybinding.universal.copyToClipboard
  res := json_model_4(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_31_map_createPatchOptionsMenu (.keybinding.universal.createPatchOptionsMenu)
CREATE OR REPLACE FUNCTION _jm_f_126(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .keybinding.universal.createPatchOptionsMenu
  res := json_model_4(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_31_map_createRebaseOptionsMenu (.keybinding.universal.createRebaseOptionsMenu)
CREATE OR REPLACE FUNCTION _jm_f_127(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .keybinding.universal.createRebaseOptionsMenu
  res := json_model_4(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_31_map_decreaseContextInDiffView (.keybinding.universal.decreaseContextInDiffView)
CREATE OR REPLACE FUNCTION _jm_f_128(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .keybinding.universal.decreaseContextInDiffView
  res := json_model_4(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_31_map_diffingMenu (.keybinding.universal.diffingMenu)
CREATE OR REPLACE FUNCTION _jm_f_129(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .keybinding.universal.diffingMenu
  res := json_model_4(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_31_map_diffingMenu-alt (.keybinding.universal.'diffingMenu-alt')
CREATE OR REPLACE FUNCTION _jm_f_130(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .keybinding.universal.'diffingMenu-alt'
  res := json_model_4(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_31_map_edit (.keybinding.universal.edit)
CREATE OR REPLACE FUNCTION _jm_f_131(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .keybinding.universal.edit
  res := json_model_4(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_31_map_executeCustomCommand (.keybinding.universal.executeCustomCommand)
CREATE OR REPLACE FUNCTION _jm_f_132(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .keybinding.universal.executeCustomCommand
  res := json_model_4(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_31_map_extrasMenu (.keybinding.universal.extrasMenu)
CREATE OR REPLACE FUNCTION _jm_f_133(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .keybinding.universal.extrasMenu
  res := json_model_4(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_31_map_filteringMenu (.keybinding.universal.filteringMenu)
CREATE OR REPLACE FUNCTION _jm_f_134(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .keybinding.universal.filteringMenu
  res := json_model_4(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_31_map_goInto (.keybinding.universal.goInto)
CREATE OR REPLACE FUNCTION _jm_f_135(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .keybinding.universal.goInto
  res := json_model_4(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_31_map_gotoBottom (.keybinding.universal.gotoBottom)
CREATE OR REPLACE FUNCTION _jm_f_136(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .keybinding.universal.gotoBottom
  res := json_model_4(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_31_map_gotoTop (.keybinding.universal.gotoTop)
CREATE OR REPLACE FUNCTION _jm_f_137(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .keybinding.universal.gotoTop
  res := json_model_4(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_31_map_increaseContextInDiffView (.keybinding.universal.increaseContextInDiffView)
CREATE OR REPLACE FUNCTION _jm_f_138(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .keybinding.universal.increaseContextInDiffView
  res := json_model_4(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_31_map_jumpToBlock (.keybinding.universal.jumpToBlock)
CREATE OR REPLACE FUNCTION _jm_f_139(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .keybinding.universal.jumpToBlock
  res := JSONB_TYPEOF(val) = 'array';
  IF res THEN
    -- accept any array
    NULL;
  END IF;
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_31_map_new (.keybinding.universal.new)
CREATE OR REPLACE FUNCTION _jm_f_140(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .keybinding.universal.new
  res := json_model_4(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_31_map_nextBlock (.keybinding.universal.nextBlock)
CREATE OR REPLACE FUNCTION _jm_f_141(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .keybinding.universal.nextBlock
  res := json_model_4(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_31_map_nextBlock-alt (.keybinding.universal.'nextBlock-alt')
CREATE OR REPLACE FUNCTION _jm_f_142(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .keybinding.universal.'nextBlock-alt'
  res := json_model_4(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_31_map_nextItem (.keybinding.universal.nextItem)
CREATE OR REPLACE FUNCTION _jm_f_143(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .keybinding.universal.nextItem
  res := json_model_4(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_31_map_nextItem-alt (.keybinding.universal.'nextItem-alt')
CREATE OR REPLACE FUNCTION _jm_f_144(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .keybinding.universal.'nextItem-alt'
  res := json_model_4(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_31_map_nextMatch (.keybinding.universal.nextMatch)
CREATE OR REPLACE FUNCTION _jm_f_145(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .keybinding.universal.nextMatch
  res := json_model_4(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_31_map_nextPage (.keybinding.universal.nextPage)
CREATE OR REPLACE FUNCTION _jm_f_146(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .keybinding.universal.nextPage
  res := json_model_4(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_31_map_nextScreenMode (.keybinding.universal.nextScreenMode)
CREATE OR REPLACE FUNCTION _jm_f_147(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .keybinding.universal.nextScreenMode
  res := json_model_4(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_31_map_nextTab (.keybinding.universal.nextTab)
CREATE OR REPLACE FUNCTION _jm_f_148(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .keybinding.universal.nextTab
  res := json_model_4(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_31_map_openFile (.keybinding.universal.openFile)
CREATE OR REPLACE FUNCTION _jm_f_149(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .keybinding.universal.openFile
  res := json_model_4(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_31_map_openRecentRepos (.keybinding.universal.openRecentRepos)
CREATE OR REPLACE FUNCTION _jm_f_150(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .keybinding.universal.openRecentRepos
  res := json_model_4(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_31_map_optionMenu (.keybinding.universal.optionMenu)
CREATE OR REPLACE FUNCTION _jm_f_151(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .keybinding.universal.optionMenu
  res := JSONB_TYPEOF(val) = 'null';
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_31_map_optionMenu-alt1 (.keybinding.universal.'optionMenu-alt1')
CREATE OR REPLACE FUNCTION _jm_f_152(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .keybinding.universal.'optionMenu-alt1'
  res := json_model_4(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_31_map_prevBlock (.keybinding.universal.prevBlock)
CREATE OR REPLACE FUNCTION _jm_f_153(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .keybinding.universal.prevBlock
  res := json_model_4(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_31_map_prevBlock-alt (.keybinding.universal.'prevBlock-alt')
CREATE OR REPLACE FUNCTION _jm_f_154(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .keybinding.universal.'prevBlock-alt'
  res := json_model_4(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_31_map_prevItem (.keybinding.universal.prevItem)
CREATE OR REPLACE FUNCTION _jm_f_155(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .keybinding.universal.prevItem
  res := json_model_4(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_31_map_prevItem-alt (.keybinding.universal.'prevItem-alt')
CREATE OR REPLACE FUNCTION _jm_f_156(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .keybinding.universal.'prevItem-alt'
  res := json_model_4(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_31_map_prevMatch (.keybinding.universal.prevMatch)
CREATE OR REPLACE FUNCTION _jm_f_157(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .keybinding.universal.prevMatch
  res := json_model_4(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_31_map_prevPage (.keybinding.universal.prevPage)
CREATE OR REPLACE FUNCTION _jm_f_158(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .keybinding.universal.prevPage
  res := json_model_4(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_31_map_prevScreenMode (.keybinding.universal.prevScreenMode)
CREATE OR REPLACE FUNCTION _jm_f_159(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .keybinding.universal.prevScreenMode
  res := json_model_4(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_31_map_prevTab (.keybinding.universal.prevTab)
CREATE OR REPLACE FUNCTION _jm_f_160(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .keybinding.universal.prevTab
  res := json_model_4(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_31_map_pullFiles (.keybinding.universal.pullFiles)
CREATE OR REPLACE FUNCTION _jm_f_161(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .keybinding.universal.pullFiles
  res := json_model_4(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_31_map_pushFiles (.keybinding.universal.pushFiles)
CREATE OR REPLACE FUNCTION _jm_f_162(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .keybinding.universal.pushFiles
  res := json_model_4(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_31_map_quit (.keybinding.universal.quit)
CREATE OR REPLACE FUNCTION _jm_f_163(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .keybinding.universal.quit
  res := json_model_4(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_31_map_quit-alt1 (.keybinding.universal.'quit-alt1')
CREATE OR REPLACE FUNCTION _jm_f_164(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .keybinding.universal.'quit-alt1'
  res := json_model_4(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_31_map_quitWithoutChangingDirectory (.keybinding.universal.quitWithoutChangingDirectory)
CREATE OR REPLACE FUNCTION _jm_f_165(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .keybinding.universal.quitWithoutChangingDirectory
  res := json_model_4(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_31_map_redo (.keybinding.universal.redo)
CREATE OR REPLACE FUNCTION _jm_f_166(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .keybinding.universal.redo
  res := json_model_4(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_31_map_refresh (.keybinding.universal.refresh)
CREATE OR REPLACE FUNCTION _jm_f_167(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .keybinding.universal.refresh
  res := json_model_4(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_31_map_remove (.keybinding.universal.remove)
CREATE OR REPLACE FUNCTION _jm_f_168(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .keybinding.universal.remove
  res := json_model_4(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_31_map_return (.keybinding.universal.return)
CREATE OR REPLACE FUNCTION _jm_f_169(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .keybinding.universal.return
  res := json_model_4(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_31_map_scrollDownMain (.keybinding.universal.scrollDownMain)
CREATE OR REPLACE FUNCTION _jm_f_170(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .keybinding.universal.scrollDownMain
  res := json_model_4(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_31_map_scrollDownMain-alt1 (.keybinding.universal.'scrollDownMain-alt1')
CREATE OR REPLACE FUNCTION _jm_f_171(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .keybinding.universal.'scrollDownMain-alt1'
  res := json_model_4(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_31_map_scrollDownMain-alt2 (.keybinding.universal.'scrollDownMain-alt2')
CREATE OR REPLACE FUNCTION _jm_f_172(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .keybinding.universal.'scrollDownMain-alt2'
  res := json_model_4(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_31_map_scrollLeft (.keybinding.universal.scrollLeft)
CREATE OR REPLACE FUNCTION _jm_f_173(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .keybinding.universal.scrollLeft
  res := json_model_4(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_31_map_scrollRight (.keybinding.universal.scrollRight)
CREATE OR REPLACE FUNCTION _jm_f_174(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .keybinding.universal.scrollRight
  res := json_model_4(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_31_map_scrollUpMain (.keybinding.universal.scrollUpMain)
CREATE OR REPLACE FUNCTION _jm_f_175(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .keybinding.universal.scrollUpMain
  res := json_model_4(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_31_map_scrollUpMain-alt1 (.keybinding.universal.'scrollUpMain-alt1')
CREATE OR REPLACE FUNCTION _jm_f_176(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .keybinding.universal.'scrollUpMain-alt1'
  res := json_model_4(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_31_map_scrollUpMain-alt2 (.keybinding.universal.'scrollUpMain-alt2')
CREATE OR REPLACE FUNCTION _jm_f_177(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .keybinding.universal.'scrollUpMain-alt2'
  res := json_model_4(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_31_map_select (.keybinding.universal.select)
CREATE OR REPLACE FUNCTION _jm_f_178(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .keybinding.universal.select
  res := json_model_4(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_31_map_submitEditorText (.keybinding.universal.submitEditorText)
CREATE OR REPLACE FUNCTION _jm_f_179(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .keybinding.universal.submitEditorText
  res := json_model_4(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_31_map_togglePanel (.keybinding.universal.togglePanel)
CREATE OR REPLACE FUNCTION _jm_f_180(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .keybinding.universal.togglePanel
  res := json_model_4(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_31_map_toggleWhitespaceInDiffView (.keybinding.universal.toggleWhitespaceInDiffView)
CREATE OR REPLACE FUNCTION _jm_f_181(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .keybinding.universal.toggleWhitespaceInDiffView
  res := json_model_4(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_31_map_undo (.keybinding.universal.undo)
CREATE OR REPLACE FUNCTION _jm_f_182(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .keybinding.universal.undo
  res := json_model_4(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION _jm_obj_31_map(name TEXT)
RETURNS TEXT STRICT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  map JSONB := JSONB '{"confirm":"_jm_f_124","copyToClipboard":"_jm_f_125","createPatchOptionsMenu":"_jm_f_126","createRebaseOptionsMenu":"_jm_f_127","decreaseContextInDiffView":"_jm_f_128","diffingMenu":"_jm_f_129","diffingMenu-alt":"_jm_f_130","edit":"_jm_f_131","executeCustomCommand":"_jm_f_132","extrasMenu":"_jm_f_133","filteringMenu":"_jm_f_134","goInto":"_jm_f_135","gotoBottom":"_jm_f_136","gotoTop":"_jm_f_137","increaseContextInDiffView":"_jm_f_138","jumpToBlock":"_jm_f_139","new":"_jm_f_140","nextBlock":"_jm_f_141","nextBlock-alt":"_jm_f_142","nextItem":"_jm_f_143","nextItem-alt":"_jm_f_144","nextMatch":"_jm_f_145","nextPage":"_jm_f_146","nextScreenMode":"_jm_f_147","nextTab":"_jm_f_148","openFile":"_jm_f_149","openRecentRepos":"_jm_f_150","optionMenu":"_jm_f_151","optionMenu-alt1":"_jm_f_152","prevBlock":"_jm_f_153","prevBlock-alt":"_jm_f_154","prevItem":"_jm_f_155","prevItem-alt":"_jm_f_156","prevMatch":"_jm_f_157","prevPage":"_jm_f_158","prevScreenMode":"_jm_f_159","prevTab":"_jm_f_160","pullFiles":"_jm_f_161","pushFiles":"_jm_f_162","quit":"_jm_f_163","quit-alt1":"_jm_f_164","quitWithoutChangingDirectory":"_jm_f_165","redo":"_jm_f_166","refresh":"_jm_f_167","remove":"_jm_f_168","return":"_jm_f_169","scrollDownMain":"_jm_f_170","scrollDownMain-alt1":"_jm_f_171","scrollDownMain-alt2":"_jm_f_172","scrollLeft":"_jm_f_173","scrollRight":"_jm_f_174","scrollUpMain":"_jm_f_175","scrollUpMain-alt1":"_jm_f_176","scrollUpMain-alt2":"_jm_f_177","select":"_jm_f_178","submitEditorText":"_jm_f_179","togglePanel":"_jm_f_180","toggleWhitespaceInDiffView":"_jm_f_181","undo":"_jm_f_182"}';
BEGIN
  RETURN map->>name;
END;
$$ LANGUAGE plpgsql;

-- object .keybinding.universal
CREATE OR REPLACE FUNCTION _jm_obj_31(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  pfun TEXT;
  prop TEXT;
  pval JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF _jm_obj_31_map(prop) IS NOT NULL THEN
      -- handle 59 may props
      pfun := _jm_obj_31_map(prop);
      IF NOT jm_call(pfun, pval, NULL, rep) THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_22_map_universal (.keybinding.universal)
CREATE OR REPLACE FUNCTION _jm_f_123(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .keybinding.universal
  res := _jm_obj_31(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION _jm_obj_22_map(name TEXT)
RETURNS TEXT STRICT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  map JSONB := JSONB '{"branches":"_jm_f_67","commitFiles":"_jm_f_81","commits":"_jm_f_82","files":"_jm_f_104","main":"_jm_f_119","stash":"_jm_f_120","status":"_jm_f_121","submodules":"_jm_f_122","universal":"_jm_f_123"}';
BEGIN
  RETURN map->>name;
END;
$$ LANGUAGE plpgsql;

-- object .keybinding
CREATE OR REPLACE FUNCTION _jm_obj_22(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  pfun TEXT;
  prop TEXT;
  pval JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF _jm_obj_22_map(prop) IS NOT NULL THEN
      -- handle 9 may props
      pfun := _jm_obj_22_map(prop);
      IF NOT jm_call(pfun, pval, NULL, rep) THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_7_map_keybinding (.keybinding)
CREATE OR REPLACE FUNCTION _jm_f_66(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .keybinding
  res := _jm_obj_22(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION _jm_cst_13(value JSONB)
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  constants JSONB = JSONB '["prompt","create","skip","quit"]';
BEGIN
  RETURN constants @> value;
END;
$$ LANGUAGE plpgsql;

-- check _jm_obj_7_map_notARepository (.notARepository)
CREATE OR REPLACE FUNCTION _jm_f_183(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .notARepository
  res := JSONB_TYPEOF(val) IN ('null', 'boolean', 'number', 'string') AND _jm_cst_13(val);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_32_map_copyToClipboardCmd (.os.copyToClipboardCmd)
CREATE OR REPLACE FUNCTION _jm_f_185(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .os.copyToClipboardCmd
  res := JSONB_TYPEOF(val) = 'string';
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_32_map_edit (.os.edit)
CREATE OR REPLACE FUNCTION _jm_f_186(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .os.edit
  res := JSONB_TYPEOF(val) = 'string';
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_32_map_editAtLine (.os.editAtLine)
CREATE OR REPLACE FUNCTION _jm_f_187(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .os.editAtLine
  res := JSONB_TYPEOF(val) = 'string';
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_32_map_editAtLineAndWait (.os.editAtLineAndWait)
CREATE OR REPLACE FUNCTION _jm_f_188(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .os.editAtLineAndWait
  res := JSONB_TYPEOF(val) = 'string';
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION _jm_cst_14(value JSONB)
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  constants JSONB = JSONB '["vim","nvim","emacs","nano","vscode","sublime","bbedit","kakoune","helix","xcode"]';
BEGIN
  RETURN constants @> value;
END;
$$ LANGUAGE plpgsql;

-- check _jm_obj_32_map_editPreset (.os.editPreset)
CREATE OR REPLACE FUNCTION _jm_f_189(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .os.editPreset
  res := JSONB_TYPEOF(val) IN ('null', 'boolean', 'number', 'string') AND _jm_cst_14(val);
  IF NOT res THEN
    res := JSONB_TYPEOF(val) = 'string';
    IF res THEN
      -- .os.editPreset.'|'.0
      res := TRUE;
    END IF;
  END IF;
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_32_map_open (.os.open)
CREATE OR REPLACE FUNCTION _jm_f_190(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .os.open
  res := JSONB_TYPEOF(val) = 'string';
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_32_map_openLink (.os.openLink)
CREATE OR REPLACE FUNCTION _jm_f_191(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .os.openLink
  res := JSONB_TYPEOF(val) = 'string';
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION _jm_obj_32_map(name TEXT)
RETURNS TEXT STRICT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  map JSONB := JSONB '{"copyToClipboardCmd":"_jm_f_185","edit":"_jm_f_186","editAtLine":"_jm_f_187","editAtLineAndWait":"_jm_f_188","editPreset":"_jm_f_189","open":"_jm_f_190","openLink":"_jm_f_191"}';
BEGIN
  RETURN map->>name;
END;
$$ LANGUAGE plpgsql;

-- object .os
CREATE OR REPLACE FUNCTION _jm_obj_32(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  pfun TEXT;
  prop TEXT;
  pval JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF _jm_obj_32_map(prop) IS NOT NULL THEN
      -- handle 7 may props
      pfun := _jm_obj_32_map(prop);
      IF NOT jm_call(pfun, pval, NULL, rep) THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_7_map_os (.os)
CREATE OR REPLACE FUNCTION _jm_f_184(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .os
  res := _jm_obj_32(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_7_map_promptToReturnFromSubprocess (.promptToReturnFromSubprocess)
CREATE OR REPLACE FUNCTION _jm_f_192(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .promptToReturnFromSubprocess
  res := JSONB_TYPEOF(val) = 'boolean';
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_7_map_quitOnTopLevelReturn (.quitOnTopLevelReturn)
CREATE OR REPLACE FUNCTION _jm_f_193(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .quitOnTopLevelReturn
  res := JSONB_TYPEOF(val) = 'boolean';
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- object .refresher
CREATE OR REPLACE FUNCTION _jm_obj_33(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = 'refreshInterval' THEN
      -- handle may refreshInterval property
      -- .refresher.refreshInterval
      res := JSONB_TYPEOF(pval) = 'number' AND (pval)::INT8 = (pval)::FLOAT8 AND (pval)::INT8 >= 0;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'fetchInterval' THEN
      -- handle may fetchInterval property
      -- .refresher.fetchInterval
      res := JSONB_TYPEOF(pval) = 'number' AND (pval)::INT8 = (pval)::FLOAT8 AND (pval)::INT8 >= 0;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_7_map_refresher (.refresher)
CREATE OR REPLACE FUNCTION _jm_f_194(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .refresher
  res := _jm_obj_33(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- regex=^[^:]+:[^:]+$ opts=n
CREATE OR REPLACE FUNCTION _jm_re_2(val TEXT, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  RETURN regexp_like(val, '^[^:]+:[^:]+$', 'n');
END;
$$ LANGUAGE plpgsql;

-- object .services
CREATE OR REPLACE FUNCTION _jm_obj_34(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF _jm_re_1(prop, path, rep) THEN
      -- handle 1 re props
      -- .services.'/./'
      -- "/^[^:]+:[^:]+$/"
      res := JSONB_TYPEOF(pval) = 'string' AND _jm_re_2(JSON_VALUE(pval, '$' RETURNING TEXT), NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_7_map_services (.services)
CREATE OR REPLACE FUNCTION _jm_f_195(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .services
  res := _jm_obj_34(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION _jm_cst_15(value JSONB)
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  constants JSONB = JSONB '["prompt","background","never"]';
BEGIN
  RETURN constants @> value;
END;
$$ LANGUAGE plpgsql;

-- object .update
CREATE OR REPLACE FUNCTION _jm_obj_35(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = 'method' THEN
      -- handle may method property
      -- .update.method
      res := JSONB_TYPEOF(pval) IN ('null', 'boolean', 'number', 'string') AND _jm_cst_15(pval);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'days' THEN
      -- handle may days property
      -- .update.days
      res := JSONB_TYPEOF(pval) = 'number' AND (pval)::INT8 = (pval)::FLOAT8 AND (pval)::INT8 >= 0;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_7_map_update (.update)
CREATE OR REPLACE FUNCTION _jm_f_196(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .update
  res := _jm_obj_35(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION _jm_obj_7_map(name TEXT)
RETURNS TEXT STRICT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  map JSONB := JSONB '{"confirmOnQuit":"_jm_f_0","customCommands":"_jm_f_1","disableStartupPopups":"_jm_f_9","git":"_jm_f_10","gui":"_jm_f_27","keybinding":"_jm_f_66","notARepository":"_jm_f_183","os":"_jm_f_184","promptToReturnFromSubprocess":"_jm_f_192","quitOnTopLevelReturn":"_jm_f_193","refresher":"_jm_f_194","services":"_jm_f_195","update":"_jm_f_196"}';
BEGIN
  RETURN map->>name;
END;
$$ LANGUAGE plpgsql;

-- object .
CREATE OR REPLACE FUNCTION _jm_obj_7(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  pfun TEXT;
  prop TEXT;
  pval JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF _jm_obj_7_map(prop) IS NOT NULL THEN
      -- handle 13 may props
      pfun := _jm_obj_7_map(prop);
      IF NOT jm_call(pfun, pval, NULL, rep) THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check $ (.)
CREATE OR REPLACE FUNCTION json_model_1(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .
  res := _jm_obj_7(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION check_model_map(name TEXT)
RETURNS TEXT STRICT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  map JSONB := JSONB '{"":"json_model_1","color":"json_model_2","colorArray":"json_model_3","keybinding":"json_model_4","custom-commands-prompts-type-property":"json_model_5","custom-commands-prompts-title-property":"json_model_6","custom-commands-prompts-key-property":"json_model_7","neString":"json_model_8","stringArray":"json_model_9","Prompts":"json_model_10"}';
BEGIN
  RETURN map->>name;
END;
$$ LANGUAGE plpgsql;

--
-- constant maps initialization
--
TRUNCATE jm_constant_maps;
INSERT INTO jm_constant_maps(mapname, tagval, value) VALUES
  ('_jm_map_0', JSONB '"input"', '_jm_obj_0'),
  ('_jm_map_0', JSONB '"confirm"', '_jm_obj_3'),
  ('_jm_map_0', JSONB '"menu"', '_jm_obj_4'),
  ('_jm_map_0', JSONB '"menuFromCommand"', '_jm_obj_6')
;


--
-- JSON Model checking entry point
--
-- TODO INOUT rep?
CREATE OR REPLACE FUNCTION check_model(val JSONB, name TEXT, rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  fun TEXT;
BEGIN
  fun := check_model_map(name);
  IF fun IS NULL THEN
    RAISE EXCEPTION 'model for % not found', name;
  END IF;
  RETURN jm_call(fun, val, NULL, rep);
END;
$$ LANGUAGE plpgsql;
