--
-- Generated by JSON Model Compiler version 2
-- see https://github.com/clairey-zx81/json-model
--
-- JSON_MODEL_VERSION is 2
CREATE EXTENSION IF NOT EXISTS json_model;

CREATE OR REPLACE FUNCTION _jm_cst_0(value JSONB)
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  constants JSONB = JSONB '["black","red","green","yellow","blue","magenta","cyan","white","bold","default","reverse","underline","strikethrough"]';
BEGIN
  RETURN constants @> value;
END;
$$ LANGUAGE plpgsql;

-- regex=^#[0-9a-fA-F]{6}$ opts=n
CREATE OR REPLACE FUNCTION _jm_re_0(val TEXT, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  RETURN regexp_like(val, '^#[0-9a-fA-F]{6}$', 'n');
END;
$$ LANGUAGE plpgsql;

-- check $color (.'$color')
CREATE OR REPLACE FUNCTION json_model_2(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .'$color'
  -- .'$color'.'|'.0
  -- "/^#[0-9a-fA-F]{6}$/"
  RETURN JSONB_TYPEOF(val) IN ('null', 'boolean', 'number', 'string') AND _jm_cst_0(val) OR JSONB_TYPEOF(val) = 'string' AND _jm_re_0(JSON_VALUE(val, '$' RETURNING TEXT), NULL, NULL);
END;
$$ LANGUAGE PLpgSQL;

-- check $colorArray (.'$colorArray')
CREATE OR REPLACE FUNCTION json_model_3(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  arr_0_idx INT8;
  arr_0_item JSONB;
  ival_0 int;
BEGIN
  -- .'$colorArray'
  -- .'$colorArray'.'@'
  res := JSONB_TYPEOF(val) = 'array';
  IF res THEN
    FOR arr_0_idx IN 0 .. JSONB_ARRAY_LENGTH(val) - 1 LOOP
      arr_0_item := val -> arr_0_idx;
      -- .'$colorArray'.'@'.0
      res := json_model_2(arr_0_item, NULL, NULL);
      IF NOT res THEN
        EXIT;
      END IF;
    END LOOP;
  END IF;
  IF res THEN
    ival_0 := JSONB_ARRAY_LENGTH(val);
    res := jm_array_is_unique(val, NULL, NULL) AND ival_0 >= 1;
  END IF;
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check $keybinding (.'$keybinding')
CREATE OR REPLACE FUNCTION json_model_4(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .'$keybinding'
  -- .'$keybinding'.'|'.0
  -- .'$keybinding'.'|'.1
  RETURN JSONB_TYPEOF(val) = 'null' OR JSONB_TYPEOF(val) = 'string';
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION _jm_cst_1(value JSONB)
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  constants JSONB = JSONB '["input","confirm","menu","menuFromCommand"]';
BEGIN
  RETURN constants @> value;
END;
$$ LANGUAGE plpgsql;

-- check $custom-commands-prompts-type-property (.'$custom-commands-prompts-type-property')
CREATE OR REPLACE FUNCTION json_model_5(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .'$custom-commands-prompts-type-property'
  RETURN JSONB_TYPEOF(val) IN ('null', 'boolean', 'number', 'string') AND _jm_cst_1(val);
END;
$$ LANGUAGE PLpgSQL;

-- check $custom-commands-prompts-title-property (.'$custom-commands-prompts-title-property')
CREATE OR REPLACE FUNCTION json_model_6(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .'$custom-commands-prompts-title-property'
  RETURN JSONB_TYPEOF(val) = 'string';
END;
$$ LANGUAGE PLpgSQL;

-- check $custom-commands-prompts-key-property (.'$custom-commands-prompts-key-property')
CREATE OR REPLACE FUNCTION json_model_7(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .'$custom-commands-prompts-key-property'
  RETURN JSONB_TYPEOF(val) = 'string';
END;
$$ LANGUAGE PLpgSQL;

-- check $neString (.'$neString')
CREATE OR REPLACE FUNCTION json_model_8(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  sval_0 TEXT;
BEGIN
  -- .'$neString'
  -- .'$neString'.'@'
  res := JSONB_TYPEOF(val) = 'string';
  IF res THEN
    sval_0 := JSON_VALUE(val, '$' RETURNING TEXT);
    res := sval_0 <> '';
  END IF;
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check $stringArray (.'$stringArray')
CREATE OR REPLACE FUNCTION json_model_9(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  arr_1_idx INT8;
  arr_1_item JSONB;
BEGIN
  -- .'$stringArray'
  -- .'$stringArray'.'@'
  res := JSONB_TYPEOF(val) = 'array';
  IF res THEN
    FOR arr_1_idx IN 0 .. JSONB_ARRAY_LENGTH(val) - 1 LOOP
      arr_1_item := val -> arr_1_idx;
      -- .'$stringArray'.'@'.0
      res := json_model_8(arr_1_item, NULL, NULL);
      IF NOT res THEN
        EXIT;
      END IF;
    END LOOP;
  END IF;
  IF res THEN
    res := jm_array_is_unique(val, NULL, NULL);
  END IF;
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- object .'$Prompts'.'|'.0.suggestions.'|'.1
CREATE OR REPLACE FUNCTION _jm_obj_1(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  must_count int;
  prop TEXT;
  pval JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  must_count := 0;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = 'command' THEN
      -- handle must command property
      must_count := must_count + 1;
      -- .'$Prompts'.'|'.0.suggestions.'|'.1.command
      res := JSONB_TYPEOF(pval) = 'string';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN must_count = 1;
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION _jm_cst_2(value JSONB)
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  constants JSONB = JSONB '["authors","branches","files","refs","remotes","remoteBranches","tags"]';
BEGIN
  RETURN constants @> value;
END;
$$ LANGUAGE plpgsql;

-- object .'$Prompts'.'|'.0.suggestions.'|'.0
CREATE OR REPLACE FUNCTION _jm_obj_2(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  must_count int;
  prop TEXT;
  pval JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  must_count := 0;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = 'preset' THEN
      -- handle must preset property
      must_count := must_count + 1;
      -- .'$Prompts'.'|'.0.suggestions.'|'.0.preset
      res := JSONB_TYPEOF(pval) IN ('null', 'boolean', 'number', 'string') AND _jm_cst_2(pval);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN must_count = 1;
END;
$$ LANGUAGE PLpgSQL;

-- object .'$Prompts'.'|'.0
CREATE OR REPLACE FUNCTION _jm_obj_0(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  must_count int;
  prop TEXT;
  pval JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  must_count := 0;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = 'type' THEN
      -- handle must type property
      must_count := must_count + 1;
      -- .'$Prompts'.'|'.0.type
      res := JSONB_TYPEOF(pval) = 'string' AND JSON_VALUE(pval, '$' RETURNING TEXT) = 'input';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'title' THEN
      -- handle must title property
      must_count := must_count + 1;
      -- .'$Prompts'.'|'.0.title
      res := json_model_6(pval, NULL, NULL);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'key' THEN
      -- handle must key property
      must_count := must_count + 1;
      -- .'$Prompts'.'|'.0.key
      res := json_model_7(pval, NULL, NULL);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'initialValue' THEN
      -- handle may initialValue property
      -- .'$Prompts'.'|'.0.initialValue
      res := JSONB_TYPEOF(pval) = 'string';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'suggestions' THEN
      -- handle may suggestions property
      -- .'$Prompts'.'|'.0.suggestions
      -- .'$Prompts'.'|'.0.suggestions.'|'.0
      -- .'$Prompts'.'|'.0.suggestions.'|'.1
      res := JSONB_TYPEOF(pval) = 'object' AND (_jm_obj_2(pval, NULL, NULL) OR _jm_obj_1(pval, NULL, NULL));
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN must_count = 3;
END;
$$ LANGUAGE PLpgSQL;

-- object .'$Prompts'.'|'.1
CREATE OR REPLACE FUNCTION _jm_obj_3(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  must_count int;
  prop TEXT;
  pval JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  must_count := 0;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = 'type' THEN
      -- handle must type property
      must_count := must_count + 1;
      -- .'$Prompts'.'|'.1.type
      res := JSONB_TYPEOF(pval) = 'string' AND JSON_VALUE(pval, '$' RETURNING TEXT) = 'confirm';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'title' THEN
      -- handle must title property
      must_count := must_count + 1;
      -- .'$Prompts'.'|'.1.title
      res := json_model_6(pval, NULL, NULL);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'key' THEN
      -- handle must key property
      must_count := must_count + 1;
      -- .'$Prompts'.'|'.1.key
      res := json_model_7(pval, NULL, NULL);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'body' THEN
      -- handle may body property
      -- .'$Prompts'.'|'.1.body
      res := JSONB_TYPEOF(pval) = 'string';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN must_count = 3;
END;
$$ LANGUAGE PLpgSQL;

-- object .'$Prompts'.'|'.2.options.'@'.0
CREATE OR REPLACE FUNCTION _jm_obj_5(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  must_count int;
  prop TEXT;
  pval JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  must_count := 0;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = 'value' THEN
      -- handle must value property
      must_count := must_count + 1;
      -- .'$Prompts'.'|'.2.options.'@'.0.value
      res := json_model_8(pval, NULL, NULL);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'description' THEN
      -- handle may description property
      -- .'$Prompts'.'|'.2.options.'@'.0.description
      res := JSONB_TYPEOF(pval) = 'string';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'name' THEN
      -- handle may name property
      -- .'$Prompts'.'|'.2.options.'@'.0.name
      res := JSONB_TYPEOF(pval) = 'string';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN must_count = 1;
END;
$$ LANGUAGE PLpgSQL;

-- object .'$Prompts'.'|'.2
CREATE OR REPLACE FUNCTION _jm_obj_4(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  must_count int;
  prop TEXT;
  pval JSONB;
  arr_2_idx INT8;
  arr_2_item JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  must_count := 0;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = 'type' THEN
      -- handle must type property
      must_count := must_count + 1;
      -- .'$Prompts'.'|'.2.type
      res := JSONB_TYPEOF(pval) = 'string' AND JSON_VALUE(pval, '$' RETURNING TEXT) = 'menu';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'title' THEN
      -- handle must title property
      must_count := must_count + 1;
      -- .'$Prompts'.'|'.2.title
      res := json_model_6(pval, NULL, NULL);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'key' THEN
      -- handle must key property
      must_count := must_count + 1;
      -- .'$Prompts'.'|'.2.key
      res := json_model_7(pval, NULL, NULL);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'options' THEN
      -- handle must options property
      must_count := must_count + 1;
      -- .'$Prompts'.'|'.2.options
      -- .'$Prompts'.'|'.2.options.'@'
      res := JSONB_TYPEOF(pval) = 'array';
      IF res THEN
        FOR arr_2_idx IN 0 .. JSONB_ARRAY_LENGTH(pval) - 1 LOOP
          arr_2_item := pval -> arr_2_idx;
          -- .'$Prompts'.'|'.2.options.'@'.0
          res := _jm_obj_5(arr_2_item, NULL, NULL);
          IF NOT res THEN
            EXIT;
          END IF;
        END LOOP;
      END IF;
      IF res THEN
        res := jm_array_is_unique(pval, NULL, NULL);
      END IF;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN must_count = 4;
END;
$$ LANGUAGE PLpgSQL;

-- object .'$Prompts'.'|'.3
CREATE OR REPLACE FUNCTION _jm_obj_6(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  must_count int;
  prop TEXT;
  pval JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  must_count := 0;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = 'type' THEN
      -- handle must type property
      must_count := must_count + 1;
      -- .'$Prompts'.'|'.3.type
      res := JSONB_TYPEOF(pval) = 'string' AND JSON_VALUE(pval, '$' RETURNING TEXT) = 'menuFromCommand';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'title' THEN
      -- handle must title property
      must_count := must_count + 1;
      -- .'$Prompts'.'|'.3.title
      res := json_model_6(pval, NULL, NULL);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'key' THEN
      -- handle must key property
      must_count := must_count + 1;
      -- .'$Prompts'.'|'.3.key
      res := json_model_7(pval, NULL, NULL);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'command' THEN
      -- handle must command property
      must_count := must_count + 1;
      -- .'$Prompts'.'|'.3.command
      res := JSONB_TYPEOF(pval) = 'string';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'filter' THEN
      -- handle may filter property
      -- .'$Prompts'.'|'.3.filter
      res := JSONB_TYPEOF(pval) = 'string';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'valueFormat' THEN
      -- handle may valueFormat property
      -- .'$Prompts'.'|'.3.valueFormat
      res := JSONB_TYPEOF(pval) = 'string';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'labelFormat' THEN
      -- handle may labelFormat property
      -- .'$Prompts'.'|'.3.labelFormat
      res := JSONB_TYPEOF(pval) = 'string';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN must_count = 4;
END;
$$ LANGUAGE PLpgSQL;


-- check $Prompts (.'$Prompts')
CREATE OR REPLACE FUNCTION json_model_10(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  iso_0 bool;
  tag_0 JSONB;
  fun_0 TEXT;
BEGIN
  -- .'$Prompts'
  iso_0 := JSONB_TYPEOF(val) = 'object';
  res := iso_0;
  IF res THEN
    IF val ? 'type' THEN
      tag_0 := val -> 'type';
      fun_0 := jm_cmap_get('_jm_map_0', tag_0);
      res := fun_0 IS NOT NULL AND jm_call(fun_0, val, NULL, NULL);
    ELSE
      res := FALSE;
    END IF;
  ELSE
    NULL;
  END IF;
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_1_map_confirmOnQuit (.confirmOnQuit)
CREATE OR REPLACE FUNCTION _jm_f_0(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .confirmOnQuit
  RETURN JSONB_TYPEOF(val) = 'boolean';
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION _jm_cst_3(value JSONB)
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  constants JSONB = JSONB '["status","files","worktrees","localBranches","remotes","remoteBranches","tags","commits","reflogCommits","subCommits","commitFiles","stash","global"]';
BEGIN
  RETURN constants @> value;
END;
$$ LANGUAGE plpgsql;

-- object .customCommands.'@'.0.after
CREATE OR REPLACE FUNCTION _jm_obj_8(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = 'checkForConflicts' THEN
      -- handle may checkForConflicts property
      -- .customCommands.'@'.0.after.checkForConflicts
      res := JSONB_TYPEOF(pval) = 'boolean';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- object .customCommands.'@'.0
CREATE OR REPLACE FUNCTION _jm_obj_7(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  must_count int;
  prop TEXT;
  pval JSONB;
  arr_4_idx INT8;
  arr_4_item JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  must_count := 0;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = 'key' THEN
      -- handle must key property
      must_count := must_count + 1;
      -- .customCommands.'@'.0.key
      res := json_model_4(pval, NULL, NULL);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'command' THEN
      -- handle must command property
      must_count := must_count + 1;
      -- .customCommands.'@'.0.command
      res := JSONB_TYPEOF(pval) = 'string';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'context' THEN
      -- handle must context property
      must_count := must_count + 1;
      -- .customCommands.'@'.0.context
      res := JSONB_TYPEOF(pval) IN ('null', 'boolean', 'number', 'string') AND _jm_cst_3(pval);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'subprocess' THEN
      -- handle may subprocess property
      -- .customCommands.'@'.0.subprocess
      res := JSONB_TYPEOF(pval) = 'boolean';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'prompts' THEN
      -- handle may prompts property
      -- .customCommands.'@'.0.prompts
      res := JSONB_TYPEOF(pval) = 'array';
      IF res THEN
        FOR arr_4_idx IN 0 .. JSONB_ARRAY_LENGTH(pval) - 1 LOOP
          arr_4_item := pval -> arr_4_idx;
          -- .customCommands.'@'.0.prompts.0
          res := json_model_10(arr_4_item, NULL, NULL);
          IF NOT res THEN
            EXIT;
          END IF;
        END LOOP;
      END IF;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'loadingText' THEN
      -- handle may loadingText property
      -- .customCommands.'@'.0.loadingText
      res := JSONB_TYPEOF(pval) = 'string';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'description' THEN
      -- handle may description property
      -- .customCommands.'@'.0.description
      res := JSONB_TYPEOF(pval) = 'string';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'stream' THEN
      -- handle may stream property
      -- .customCommands.'@'.0.stream
      res := JSONB_TYPEOF(pval) = 'boolean';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'showOutput' THEN
      -- handle may showOutput property
      -- .customCommands.'@'.0.showOutput
      res := JSONB_TYPEOF(pval) = 'boolean';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'after' THEN
      -- handle may after property
      -- .customCommands.'@'.0.after
      res := _jm_obj_8(pval, NULL, NULL);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN must_count = 3;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_1_map_customCommands (.customCommands)
CREATE OR REPLACE FUNCTION _jm_f_1(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  arr_3_idx INT8;
  arr_3_item JSONB;
BEGIN
  -- .customCommands
  -- .customCommands.'@'
  res := JSONB_TYPEOF(val) = 'array';
  IF res THEN
    FOR arr_3_idx IN 0 .. JSONB_ARRAY_LENGTH(val) - 1 LOOP
      arr_3_item := val -> arr_3_idx;
      -- .customCommands.'@'.0
      res := _jm_obj_7(arr_3_item, NULL, NULL);
      IF NOT res THEN
        EXIT;
      END IF;
    END LOOP;
  END IF;
  IF res THEN
    res := jm_array_is_unique(val, NULL, NULL);
  END IF;
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_1_map_disableStartupPopups (.disableStartupPopups)
CREATE OR REPLACE FUNCTION _jm_f_2(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .disableStartupPopups
  RETURN JSONB_TYPEOF(val) = 'boolean';
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_f_3_map_allBranchesLogCmd (.git.allBranchesLogCmd)
CREATE OR REPLACE FUNCTION _jm_f_4(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .git.allBranchesLogCmd
  RETURN JSONB_TYPEOF(val) = 'string';
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_f_3_map_autoFetch (.git.autoFetch)
CREATE OR REPLACE FUNCTION _jm_f_5(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .git.autoFetch
  RETURN JSONB_TYPEOF(val) = 'boolean';
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_f_3_map_autoRefresh (.git.autoRefresh)
CREATE OR REPLACE FUNCTION _jm_f_6(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .git.autoRefresh
  RETURN JSONB_TYPEOF(val) = 'boolean';
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_f_3_map_branchLogCmd (.git.branchLogCmd)
CREATE OR REPLACE FUNCTION _jm_f_7(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .git.branchLogCmd
  RETURN JSONB_TYPEOF(val) = 'string';
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_f_3_map_commit (.git.commit)
CREATE OR REPLACE FUNCTION _jm_f_8(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
BEGIN
  -- .git.commit
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = 'signOff' THEN
      -- handle may signOff property
      -- .git.commit.signOff
      res := JSONB_TYPEOF(pval) = 'boolean';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- regex=. opts=n
CREATE OR REPLACE FUNCTION _jm_re_1(val TEXT, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  RETURN regexp_like(val, '.', 'n');
END;
$$ LANGUAGE plpgsql;

-- object .git.commitPrefixes.'/./'
CREATE OR REPLACE FUNCTION _jm_obj_9(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  must_count int;
  prop TEXT;
  pval JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  must_count := 0;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = 'pattern' THEN
      -- handle must pattern property
      must_count := must_count + 1;
      -- .git.commitPrefixes.'/./'.pattern
      res := json_model_8(pval, NULL, NULL);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'replace' THEN
      -- handle must replace property
      must_count := must_count + 1;
      -- .git.commitPrefixes.'/./'.replace
      res := json_model_8(pval, NULL, NULL);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN must_count = 2;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_f_3_map_commitPrefixes (.git.commitPrefixes)
CREATE OR REPLACE FUNCTION _jm_f_9(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
BEGIN
  -- .git.commitPrefixes
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF _jm_re_1(prop, NULL, NULL) THEN
      -- handle 1 re props
      -- .git.commitPrefixes.'/./'
      res := _jm_obj_9(pval, NULL, NULL);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_f_3_map_diffContextSize (.git.diffContextSize)
CREATE OR REPLACE FUNCTION _jm_f_10(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .git.diffContextSize
  RETURN JSONB_TYPEOF(val) = 'number' AND (val)::INT8 = (val)::FLOAT8 AND (val)::INT8 >= 0;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_f_3_map_disableForcePushing (.git.disableForcePushing)
CREATE OR REPLACE FUNCTION _jm_f_11(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .git.disableForcePushing
  RETURN JSONB_TYPEOF(val) = 'boolean';
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_f_3_map_fetchAll (.git.fetchAll)
CREATE OR REPLACE FUNCTION _jm_f_12(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .git.fetchAll
  RETURN JSONB_TYPEOF(val) = 'boolean';
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION _jm_cst_4(value JSONB)
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  constants JSONB = JSONB '["date-order","author-date-order","topo-order","default"]';
BEGIN
  RETURN constants @> value;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION _jm_cst_5(value JSONB)
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  constants JSONB = JSONB '["always","never","when-maximised"]';
BEGIN
  RETURN constants @> value;
END;
$$ LANGUAGE plpgsql;

-- check _jm_f_3_map_log (.git.log)
CREATE OR REPLACE FUNCTION _jm_f_13(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
BEGIN
  -- .git.log
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = 'order' THEN
      -- handle may order property
      -- .git.log.order
      res := JSONB_TYPEOF(pval) IN ('null', 'boolean', 'number', 'string') AND _jm_cst_4(pval);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'showGraph' THEN
      -- handle may showGraph property
      -- .git.log.showGraph
      res := JSONB_TYPEOF(pval) IN ('null', 'boolean', 'number', 'string') AND _jm_cst_5(pval);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'showWholeGraph' THEN
      -- handle may showWholeGraph property
      -- .git.log.showWholeGraph
      res := JSONB_TYPEOF(pval) = 'boolean';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_f_3_map_merging (.git.merging)
CREATE OR REPLACE FUNCTION _jm_f_14(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
BEGIN
  -- .git.merging
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = 'manualCommit' THEN
      -- handle may manualCommit property
      -- .git.merging.manualCommit
      res := JSONB_TYPEOF(pval) = 'boolean';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'args' THEN
      -- handle may args property
      -- .git.merging.args
      res := JSONB_TYPEOF(pval) = 'string';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_f_3_map_overrideGpg (.git.overrideGpg)
CREATE OR REPLACE FUNCTION _jm_f_15(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .git.overrideGpg
  RETURN JSONB_TYPEOF(val) = 'boolean';
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION _jm_cst_6(value JSONB)
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  constants JSONB = JSONB '["always","never"]';
BEGIN
  RETURN constants @> value;
END;
$$ LANGUAGE plpgsql;

-- check _jm_f_3_map_paging (.git.paging)
CREATE OR REPLACE FUNCTION _jm_f_16(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
  sval_1 TEXT;
BEGIN
  -- .git.paging
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = 'colorArg' THEN
      -- handle may colorArg property
      -- .git.paging.colorArg
      res := JSONB_TYPEOF(pval) IN ('null', 'boolean', 'number', 'string') AND _jm_cst_6(pval);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'useConfig' THEN
      -- handle may useConfig property
      -- .git.paging.useConfig
      res := JSONB_TYPEOF(pval) = 'boolean';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'pager' THEN
      -- handle may pager property
      -- .git.paging.pager
      -- .git.paging.pager.'@'
      res := JSONB_TYPEOF(pval) = 'string';
      IF res THEN
        sval_1 := JSON_VALUE(pval, '$' RETURNING TEXT);
        res := sval_1 <> '';
      END IF;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_f_3_map_parseEmoji (.git.parseEmoji)
CREATE OR REPLACE FUNCTION _jm_f_17(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .git.parseEmoji
  RETURN JSONB_TYPEOF(val) = 'boolean';
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_f_3_map_skipHookPrefix (.git.skipHookPrefix)
CREATE OR REPLACE FUNCTION _jm_f_18(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .git.skipHookPrefix
  RETURN JSONB_TYPEOF(val) = 'string';
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION _jm_f_3_map(name TEXT)
RETURNS TEXT STRICT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  map JSONB := JSONB '{"allBranchesLogCmd":"_jm_f_4","autoFetch":"_jm_f_5","autoRefresh":"_jm_f_6","branchLogCmd":"_jm_f_7","commit":"_jm_f_8","commitPrefixes":"_jm_f_9","diffContextSize":"_jm_f_10","disableForcePushing":"_jm_f_11","fetchAll":"_jm_f_12","log":"_jm_f_13","mainBranches":"json_model_9","merging":"_jm_f_14","overrideGpg":"_jm_f_15","paging":"_jm_f_16","parseEmoji":"_jm_f_17","skipHookPrefix":"_jm_f_18"}';
BEGIN
  RETURN map->>name;
END;
$$ LANGUAGE plpgsql;

-- check json_model_1_map_git (.git)
CREATE OR REPLACE FUNCTION _jm_f_3(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  pfun TEXT;
  prop TEXT;
  pval JSONB;
BEGIN
  -- .git
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF _jm_f_3_map(prop) IS NOT NULL THEN
      -- handle 16 may props
      pfun := _jm_f_3_map(prop);
      IF NOT jm_call(pfun, pval, NULL, NULL) THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_f_19_map_animateExplosion (.gui.animateExplosion)
CREATE OR REPLACE FUNCTION _jm_f_20(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .gui.animateExplosion
  RETURN JSONB_TYPEOF(val) = 'boolean';
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_f_19_map_authorColors (.gui.authorColors)
CREATE OR REPLACE FUNCTION _jm_f_21(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
BEGIN
  -- .gui.authorColors
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF _jm_re_1(prop, NULL, NULL) THEN
      -- handle 1 re props
      -- .gui.authorColors.'/./'
      res := json_model_2(pval, NULL, NULL);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION _jm_cst_7(value JSONB)
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  constants JSONB = JSONB '["single","double","rounded","hidden"]';
BEGIN
  RETURN constants @> value;
END;
$$ LANGUAGE plpgsql;

-- check _jm_f_19_map_border (.gui.border)
CREATE OR REPLACE FUNCTION _jm_f_22(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .gui.border
  RETURN JSONB_TYPEOF(val) IN ('null', 'boolean', 'number', 'string') AND _jm_cst_7(val);
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_f_19_map_branchColors (.gui.branchColors)
CREATE OR REPLACE FUNCTION _jm_f_23(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
BEGIN
  -- .gui.branchColors
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF _jm_re_1(prop, NULL, NULL) THEN
      -- handle 1 re props
      -- .gui.branchColors.'/./'
      res := json_model_2(pval, NULL, NULL);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_f_19_map_commandLogSize (.gui.commandLogSize)
CREATE OR REPLACE FUNCTION _jm_f_24(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .gui.commandLogSize
  RETURN JSONB_TYPEOF(val) = 'number' AND (val)::INT8 = (val)::FLOAT8 AND (val)::INT8 >= 0;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_f_19_map_commitLength (.gui.commitLength)
CREATE OR REPLACE FUNCTION _jm_f_25(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
BEGIN
  -- .gui.commitLength
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = 'show' THEN
      -- handle may show property
      -- .gui.commitLength.show
      res := JSONB_TYPEOF(pval) = 'boolean';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_f_19_map_expandFocusedSidePanel (.gui.expandFocusedSidePanel)
CREATE OR REPLACE FUNCTION _jm_f_26(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .gui.expandFocusedSidePanel
  RETURN JSONB_TYPEOF(val) = 'boolean';
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION _jm_cst_8(value JSONB)
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  constants JSONB = JSONB '["auto","en","zh-CN","zh-TW","pl","nl","ja","ko","ru"]';
BEGIN
  RETURN constants @> value;
END;
$$ LANGUAGE plpgsql;

-- check _jm_f_19_map_language (.gui.language)
CREATE OR REPLACE FUNCTION _jm_f_27(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .gui.language
  RETURN JSONB_TYPEOF(val) IN ('null', 'boolean', 'number', 'string') AND _jm_cst_8(val);
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION _jm_cst_9(value JSONB)
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  constants JSONB = JSONB '["horizontal","flexible","vertical"]';
BEGIN
  RETURN constants @> value;
END;
$$ LANGUAGE plpgsql;

-- check _jm_f_19_map_mainPanelSplitMode (.gui.mainPanelSplitMode)
CREATE OR REPLACE FUNCTION _jm_f_28(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .gui.mainPanelSplitMode
  RETURN JSONB_TYPEOF(val) IN ('null', 'boolean', 'number', 'string') AND _jm_cst_9(val);
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_f_19_map_mouseEvents (.gui.mouseEvents)
CREATE OR REPLACE FUNCTION _jm_f_29(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .gui.mouseEvents
  RETURN JSONB_TYPEOF(val) = 'boolean';
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION _jm_cst_10(value JSONB)
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  constants JSONB = JSONB '["2","3"]';
BEGIN
  RETURN constants @> value;
END;
$$ LANGUAGE plpgsql;

-- check _jm_f_19_map_nerdFontsVersion (.gui.nerdFontsVersion)
CREATE OR REPLACE FUNCTION _jm_f_30(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .gui.nerdFontsVersion
  -- .gui.nerdFontsVersion.'|'.0
  RETURN JSONB_TYPEOF(val) IN ('null', 'boolean', 'number', 'string') AND _jm_cst_10(val) OR JSONB_TYPEOF(val) = 'string';
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_f_19_map_scrollHeight (.gui.scrollHeight)
CREATE OR REPLACE FUNCTION _jm_f_31(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .gui.scrollHeight
  RETURN JSONB_TYPEOF(val) = 'number' AND (val)::INT8 = (val)::FLOAT8 AND (val)::INT8 >= 1;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_f_19_map_scrollPastBottom (.gui.scrollPastBottom)
CREATE OR REPLACE FUNCTION _jm_f_32(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .gui.scrollPastBottom
  RETURN JSONB_TYPEOF(val) = 'boolean';
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_f_19_map_shortTimeFormat (.gui.shortTimeFormat)
CREATE OR REPLACE FUNCTION _jm_f_33(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .gui.shortTimeFormat
  RETURN JSONB_TYPEOF(val) = 'string';
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_f_19_map_showBottomLine (.gui.showBottomLine)
CREATE OR REPLACE FUNCTION _jm_f_34(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .gui.showBottomLine
  RETURN JSONB_TYPEOF(val) = 'boolean';
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_f_19_map_showBranchCommitHash (.gui.showBranchCommitHash)
CREATE OR REPLACE FUNCTION _jm_f_35(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .gui.showBranchCommitHash
  RETURN JSONB_TYPEOF(val) = 'boolean';
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_f_19_map_showCommandLog (.gui.showCommandLog)
CREATE OR REPLACE FUNCTION _jm_f_36(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .gui.showCommandLog
  RETURN JSONB_TYPEOF(val) = 'boolean';
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_f_19_map_showFileTree (.gui.showFileTree)
CREATE OR REPLACE FUNCTION _jm_f_37(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .gui.showFileTree
  RETURN JSONB_TYPEOF(val) = 'boolean';
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_f_19_map_showListFooter (.gui.showListFooter)
CREATE OR REPLACE FUNCTION _jm_f_38(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .gui.showListFooter
  RETURN JSONB_TYPEOF(val) = 'boolean';
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_f_19_map_showRandomTip (.gui.showRandomTip)
CREATE OR REPLACE FUNCTION _jm_f_39(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .gui.showRandomTip
  RETURN JSONB_TYPEOF(val) = 'boolean';
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_f_19_map_sidePanelWidth (.gui.sidePanelWidth)
CREATE OR REPLACE FUNCTION _jm_f_40(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  fval_0 FLOAT8;
BEGIN
  -- .gui.sidePanelWidth
  -- .gui.sidePanelWidth.'@'
  res := JSONB_TYPEOF(val) = 'number' AND (val)::FLOAT8 >= 0.0;
  IF res THEN
    fval_0 := (val)::FLOAT8;
    res := fval_0 <= 1.0;
  END IF;
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_f_19_map_skipDiscardChangeWarning (.gui.skipDiscardChangeWarning)
CREATE OR REPLACE FUNCTION _jm_f_41(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .gui.skipDiscardChangeWarning
  RETURN JSONB_TYPEOF(val) = 'boolean';
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_f_19_map_skipRewordInEditorWarning (.gui.skipRewordInEditorWarning)
CREATE OR REPLACE FUNCTION _jm_f_42(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .gui.skipRewordInEditorWarning
  RETURN JSONB_TYPEOF(val) = 'boolean';
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_f_19_map_skipStashWarning (.gui.skipStashWarning)
CREATE OR REPLACE FUNCTION _jm_f_43(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .gui.skipStashWarning
  RETURN JSONB_TYPEOF(val) = 'boolean';
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION _jm_cst_11(value JSONB)
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  constants JSONB = JSONB '["auto","always"]';
BEGIN
  RETURN constants @> value;
END;
$$ LANGUAGE plpgsql;

-- check _jm_f_19_map_splitDiff (.gui.splitDiff)
CREATE OR REPLACE FUNCTION _jm_f_44(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .gui.splitDiff
  RETURN JSONB_TYPEOF(val) IN ('null', 'boolean', 'number', 'string') AND _jm_cst_11(val);
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION _jm_f_45_map(name TEXT)
RETURNS TEXT STRICT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  map JSONB := JSONB '{"activeBorderColor":"json_model_3","cherryPickedCommitBgColor":"json_model_3","cherryPickedCommitFgColor":"json_model_3","defaultFgColor":"json_model_3","inactiveBorderColor":"json_model_3","optionsTextColor":"json_model_3","searchingActiveBorderColor":"json_model_3","selectedLineBgColor":"json_model_3","selectedRangeBgColor":"json_model_3","unstagedChangesColor":"json_model_3"}';
BEGIN
  RETURN map->>name;
END;
$$ LANGUAGE plpgsql;

-- check _jm_f_19_map_theme (.gui.theme)
CREATE OR REPLACE FUNCTION _jm_f_45(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  pfun TEXT;
  prop TEXT;
  pval JSONB;
BEGIN
  -- .gui.theme
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF _jm_f_45_map(prop) IS NOT NULL THEN
      -- handle 10 may props
      pfun := _jm_f_45_map(prop);
      IF NOT jm_call(pfun, pval, NULL, NULL) THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_f_19_map_timeFormat (.gui.timeFormat)
CREATE OR REPLACE FUNCTION _jm_f_46(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .gui.timeFormat
  RETURN JSONB_TYPEOF(val) = 'string';
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION _jm_cst_12(value JSONB)
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  constants JSONB = JSONB '["normal","half","full"]';
BEGIN
  RETURN constants @> value;
END;
$$ LANGUAGE plpgsql;

-- check _jm_f_19_map_windowSize (.gui.windowSize)
CREATE OR REPLACE FUNCTION _jm_f_47(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .gui.windowSize
  RETURN JSONB_TYPEOF(val) IN ('null', 'boolean', 'number', 'string') AND _jm_cst_12(val);
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION _jm_f_19_map(name TEXT)
RETURNS TEXT STRICT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  map JSONB := JSONB '{"animateExplosion":"_jm_f_20","authorColors":"_jm_f_21","border":"_jm_f_22","branchColors":"_jm_f_23","commandLogSize":"_jm_f_24","commitLength":"_jm_f_25","expandFocusedSidePanel":"_jm_f_26","language":"_jm_f_27","mainPanelSplitMode":"_jm_f_28","mouseEvents":"_jm_f_29","nerdFontsVersion":"_jm_f_30","scrollHeight":"_jm_f_31","scrollPastBottom":"_jm_f_32","shortTimeFormat":"_jm_f_33","showBottomLine":"_jm_f_34","showBranchCommitHash":"_jm_f_35","showCommandLog":"_jm_f_36","showFileTree":"_jm_f_37","showListFooter":"_jm_f_38","showRandomTip":"_jm_f_39","sidePanelWidth":"_jm_f_40","skipDiscardChangeWarning":"_jm_f_41","skipRewordInEditorWarning":"_jm_f_42","skipStashWarning":"_jm_f_43","splitDiff":"_jm_f_44","theme":"_jm_f_45","timeFormat":"_jm_f_46","windowSize":"_jm_f_47"}';
BEGIN
  RETURN map->>name;
END;
$$ LANGUAGE plpgsql;

-- check json_model_1_map_gui (.gui)
CREATE OR REPLACE FUNCTION _jm_f_19(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  pfun TEXT;
  prop TEXT;
  pval JSONB;
BEGIN
  -- .gui
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF _jm_f_19_map(prop) IS NOT NULL THEN
      -- handle 28 may props
      pfun := _jm_f_19_map(prop);
      IF NOT jm_call(pfun, pval, NULL, NULL) THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION _jm_f_49_map(name TEXT)
RETURNS TEXT STRICT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  map JSONB := JSONB '{"checkoutBranchByName":"json_model_4","createPullRequest":"json_model_4","createTag":"json_model_4","fastForward":"json_model_4","fetchRemote":"json_model_4","forceCheckoutBranch":"json_model_4","mergeIntoCurrentBranch":"json_model_4","pushTag":"json_model_4","rebaseBranch":"json_model_4","renameBranch":"json_model_4","setUpstream":"json_model_4","viewGitFlowOptions":"json_model_4","viewPullRequestOptions":"json_model_4"}';
BEGIN
  RETURN map->>name;
END;
$$ LANGUAGE plpgsql;

-- check _jm_f_48_map_branches (.keybinding.branches)
CREATE OR REPLACE FUNCTION _jm_f_49(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  pfun TEXT;
  prop TEXT;
  pval JSONB;
BEGIN
  -- .keybinding.branches
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF _jm_f_49_map(prop) IS NOT NULL THEN
      -- handle 13 may props
      pfun := _jm_f_49_map(prop);
      IF NOT jm_call(pfun, pval, NULL, NULL) THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_f_48_map_commitFiles (.keybinding.commitFiles)
CREATE OR REPLACE FUNCTION _jm_f_50(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
BEGIN
  -- .keybinding.commitFiles
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = 'checkoutCommitFile' THEN
      -- handle may checkoutCommitFile property
      -- .keybinding.commitFiles.checkoutCommitFile
      res := json_model_4(pval, NULL, NULL);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION _jm_f_51_map(name TEXT)
RETURNS TEXT STRICT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  map JSONB := JSONB '{"amendToCommit":"json_model_4","checkoutCommit":"json_model_4","cherryPickCopy":"json_model_4","cherryPickCopyRange":"json_model_4","copyCommitMessageToClipboard":"json_model_4","createFixupCommit":"json_model_4","markCommitAsFixup":"json_model_4","moveDownCommit":"json_model_4","moveUpCommit":"json_model_4","openLogMenu":"json_model_4","pasteCommits":"json_model_4","pickCommit":"json_model_4","renameCommit":"json_model_4","renameCommitWithEditor":"json_model_4","resetCherryPick":"json_model_4","revertCommit":"json_model_4","squashAboveCommits":"json_model_4","squashDown":"json_model_4","tagCommit":"json_model_4","viewBisectOptions":"json_model_4","viewResetOptions":"json_model_4"}';
BEGIN
  RETURN map->>name;
END;
$$ LANGUAGE plpgsql;

-- check _jm_f_48_map_commits (.keybinding.commits)
CREATE OR REPLACE FUNCTION _jm_f_51(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  pfun TEXT;
  prop TEXT;
  pval JSONB;
BEGIN
  -- .keybinding.commits
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF _jm_f_51_map(prop) IS NOT NULL THEN
      -- handle 21 may props
      pfun := _jm_f_51_map(prop);
      IF NOT jm_call(pfun, pval, NULL, NULL) THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION _jm_f_52_map(name TEXT)
RETURNS TEXT STRICT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  map JSONB := JSONB '{"amendLastCommit":"json_model_4","commitChanges":"json_model_4","commitChangesWithEditor":"json_model_4","commitChangesWithoutHook":"json_model_4","fetch":"json_model_4","ignoreFile":"json_model_4","openMergeTool":"json_model_4","openStatusFilter":"json_model_4","refreshFiles":"json_model_4","stashAllChanges":"json_model_4","toggleStagedAll":"json_model_4","toggleTreeView":"json_model_4","viewResetOptions":"json_model_4","viewStashOptions":"json_model_4"}';
BEGIN
  RETURN map->>name;
END;
$$ LANGUAGE plpgsql;

-- check _jm_f_48_map_files (.keybinding.files)
CREATE OR REPLACE FUNCTION _jm_f_52(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  pfun TEXT;
  prop TEXT;
  pval JSONB;
BEGIN
  -- .keybinding.files
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF _jm_f_52_map(prop) IS NOT NULL THEN
      -- handle 14 may props
      pfun := _jm_f_52_map(prop);
      IF NOT jm_call(pfun, pval, NULL, NULL) THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_f_48_map_main (.keybinding.main)
CREATE OR REPLACE FUNCTION _jm_f_53(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
BEGIN
  -- .keybinding.main
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = 'toggleDragSelect' THEN
      -- handle may toggleDragSelect property
      -- .keybinding.main.toggleDragSelect
      res := json_model_4(pval, NULL, NULL);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'toggleDragSelect-alt' THEN
      -- handle may toggleDragSelect-alt property
      -- .keybinding.main.'toggleDragSelect-alt'
      res := json_model_4(pval, NULL, NULL);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'toggleSelectHunk' THEN
      -- handle may toggleSelectHunk property
      -- .keybinding.main.toggleSelectHunk
      res := json_model_4(pval, NULL, NULL);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'pickBothHunks' THEN
      -- handle may pickBothHunks property
      -- .keybinding.main.pickBothHunks
      res := json_model_4(pval, NULL, NULL);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_f_48_map_stash (.keybinding.stash)
CREATE OR REPLACE FUNCTION _jm_f_54(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
BEGIN
  -- .keybinding.stash
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = 'popStash' THEN
      -- handle may popStash property
      -- .keybinding.stash.popStash
      res := json_model_4(pval, NULL, NULL);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'renameStash' THEN
      -- handle may renameStash property
      -- .keybinding.stash.renameStash
      res := json_model_4(pval, NULL, NULL);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_f_48_map_status (.keybinding.status)
CREATE OR REPLACE FUNCTION _jm_f_55(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
BEGIN
  -- .keybinding.status
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = 'checkForUpdate' THEN
      -- handle may checkForUpdate property
      -- .keybinding.status.checkForUpdate
      res := json_model_4(pval, NULL, NULL);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'recentRepos' THEN
      -- handle may recentRepos property
      -- .keybinding.status.recentRepos
      res := json_model_4(pval, NULL, NULL);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_f_48_map_submodules (.keybinding.submodules)
CREATE OR REPLACE FUNCTION _jm_f_56(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
BEGIN
  -- .keybinding.submodules
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = 'init' THEN
      -- handle may init property
      -- .keybinding.submodules.init
      res := json_model_4(pval, NULL, NULL);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'update' THEN
      -- handle may update property
      -- .keybinding.submodules.update
      res := json_model_4(pval, NULL, NULL);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'bulkMenu' THEN
      -- handle may bulkMenu property
      -- .keybinding.submodules.bulkMenu
      res := json_model_4(pval, NULL, NULL);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_f_57_map_jumpToBlock (.keybinding.universal.jumpToBlock)
CREATE OR REPLACE FUNCTION _jm_f_58(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .keybinding.universal.jumpToBlock
  RETURN JSONB_TYPEOF(val) = 'array';
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_f_57_map_optionMenu (.keybinding.universal.optionMenu)
CREATE OR REPLACE FUNCTION _jm_f_59(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .keybinding.universal.optionMenu
  RETURN JSONB_TYPEOF(val) = 'null';
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION _jm_f_57_map(name TEXT)
RETURNS TEXT STRICT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  map JSONB := JSONB '{"confirm":"json_model_4","copyToClipboard":"json_model_4","createPatchOptionsMenu":"json_model_4","createRebaseOptionsMenu":"json_model_4","decreaseContextInDiffView":"json_model_4","diffingMenu":"json_model_4","diffingMenu-alt":"json_model_4","edit":"json_model_4","executeCustomCommand":"json_model_4","extrasMenu":"json_model_4","filteringMenu":"json_model_4","goInto":"json_model_4","gotoBottom":"json_model_4","gotoTop":"json_model_4","increaseContextInDiffView":"json_model_4","jumpToBlock":"_jm_f_58","new":"json_model_4","nextBlock":"json_model_4","nextBlock-alt":"json_model_4","nextItem":"json_model_4","nextItem-alt":"json_model_4","nextMatch":"json_model_4","nextPage":"json_model_4","nextScreenMode":"json_model_4","nextTab":"json_model_4","openFile":"json_model_4","openRecentRepos":"json_model_4","optionMenu":"_jm_f_59","optionMenu-alt1":"json_model_4","prevBlock":"json_model_4","prevBlock-alt":"json_model_4","prevItem":"json_model_4","prevItem-alt":"json_model_4","prevMatch":"json_model_4","prevPage":"json_model_4","prevScreenMode":"json_model_4","prevTab":"json_model_4","pullFiles":"json_model_4","pushFiles":"json_model_4","quit":"json_model_4","quit-alt1":"json_model_4","quitWithoutChangingDirectory":"json_model_4","redo":"json_model_4","refresh":"json_model_4","remove":"json_model_4","return":"json_model_4","scrollDownMain":"json_model_4","scrollDownMain-alt1":"json_model_4","scrollDownMain-alt2":"json_model_4","scrollLeft":"json_model_4","scrollRight":"json_model_4","scrollUpMain":"json_model_4","scrollUpMain-alt1":"json_model_4","scrollUpMain-alt2":"json_model_4","select":"json_model_4","submitEditorText":"json_model_4","togglePanel":"json_model_4","toggleWhitespaceInDiffView":"json_model_4","undo":"json_model_4"}';
BEGIN
  RETURN map->>name;
END;
$$ LANGUAGE plpgsql;

-- check _jm_f_48_map_universal (.keybinding.universal)
CREATE OR REPLACE FUNCTION _jm_f_57(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  pfun TEXT;
  prop TEXT;
  pval JSONB;
BEGIN
  -- .keybinding.universal
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF _jm_f_57_map(prop) IS NOT NULL THEN
      -- handle 59 may props
      pfun := _jm_f_57_map(prop);
      IF NOT jm_call(pfun, pval, NULL, NULL) THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION _jm_f_48_map(name TEXT)
RETURNS TEXT STRICT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  map JSONB := JSONB '{"branches":"_jm_f_49","commitFiles":"_jm_f_50","commits":"_jm_f_51","files":"_jm_f_52","main":"_jm_f_53","stash":"_jm_f_54","status":"_jm_f_55","submodules":"_jm_f_56","universal":"_jm_f_57"}';
BEGIN
  RETURN map->>name;
END;
$$ LANGUAGE plpgsql;

-- check json_model_1_map_keybinding (.keybinding)
CREATE OR REPLACE FUNCTION _jm_f_48(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  pfun TEXT;
  prop TEXT;
  pval JSONB;
BEGIN
  -- .keybinding
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF _jm_f_48_map(prop) IS NOT NULL THEN
      -- handle 9 may props
      pfun := _jm_f_48_map(prop);
      IF NOT jm_call(pfun, pval, NULL, NULL) THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION _jm_cst_13(value JSONB)
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  constants JSONB = JSONB '["prompt","create","skip","quit"]';
BEGIN
  RETURN constants @> value;
END;
$$ LANGUAGE plpgsql;

-- check json_model_1_map_notARepository (.notARepository)
CREATE OR REPLACE FUNCTION _jm_f_60(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .notARepository
  RETURN JSONB_TYPEOF(val) IN ('null', 'boolean', 'number', 'string') AND _jm_cst_13(val);
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION _jm_cst_14(value JSONB)
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  constants JSONB = JSONB '["vim","nvim","emacs","nano","vscode","sublime","bbedit","kakoune","helix","xcode"]';
BEGIN
  RETURN constants @> value;
END;
$$ LANGUAGE plpgsql;

-- check json_model_1_map_os (.os)
CREATE OR REPLACE FUNCTION _jm_f_61(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
BEGIN
  -- .os
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = 'copyToClipboardCmd' THEN
      -- handle may copyToClipboardCmd property
      -- .os.copyToClipboardCmd
      res := JSONB_TYPEOF(pval) = 'string';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'editPreset' THEN
      -- handle may editPreset property
      -- .os.editPreset
      -- .os.editPreset.'|'.0
      res := JSONB_TYPEOF(pval) IN ('null', 'boolean', 'number', 'string') AND _jm_cst_14(pval) OR JSONB_TYPEOF(pval) = 'string';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'edit' THEN
      -- handle may edit property
      -- .os.edit
      res := JSONB_TYPEOF(pval) = 'string';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'editAtLine' THEN
      -- handle may editAtLine property
      -- .os.editAtLine
      res := JSONB_TYPEOF(pval) = 'string';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'editAtLineAndWait' THEN
      -- handle may editAtLineAndWait property
      -- .os.editAtLineAndWait
      res := JSONB_TYPEOF(pval) = 'string';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'open' THEN
      -- handle may open property
      -- .os.open
      res := JSONB_TYPEOF(pval) = 'string';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'openLink' THEN
      -- handle may openLink property
      -- .os.openLink
      res := JSONB_TYPEOF(pval) = 'string';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_1_map_promptToReturnFromSubprocess (.promptToReturnFromSubprocess)
CREATE OR REPLACE FUNCTION _jm_f_62(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .promptToReturnFromSubprocess
  RETURN JSONB_TYPEOF(val) = 'boolean';
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_1_map_quitOnTopLevelReturn (.quitOnTopLevelReturn)
CREATE OR REPLACE FUNCTION _jm_f_63(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .quitOnTopLevelReturn
  RETURN JSONB_TYPEOF(val) = 'boolean';
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_1_map_refresher (.refresher)
CREATE OR REPLACE FUNCTION _jm_f_64(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
BEGIN
  -- .refresher
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = 'refreshInterval' THEN
      -- handle may refreshInterval property
      -- .refresher.refreshInterval
      res := JSONB_TYPEOF(pval) = 'number' AND (pval)::INT8 = (pval)::FLOAT8 AND (pval)::INT8 >= 0;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'fetchInterval' THEN
      -- handle may fetchInterval property
      -- .refresher.fetchInterval
      res := JSONB_TYPEOF(pval) = 'number' AND (pval)::INT8 = (pval)::FLOAT8 AND (pval)::INT8 >= 0;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- regex=^[^:]+:[^:]+$ opts=n
CREATE OR REPLACE FUNCTION _jm_re_2(val TEXT, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  RETURN regexp_like(val, '^[^:]+:[^:]+$', 'n');
END;
$$ LANGUAGE plpgsql;

-- check json_model_1_map_services (.services)
CREATE OR REPLACE FUNCTION _jm_f_65(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
BEGIN
  -- .services
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF _jm_re_1(prop, NULL, NULL) THEN
      -- handle 1 re props
      -- .services.'/./'
      -- "/^[^:]+:[^:]+$/"
      res := JSONB_TYPEOF(pval) = 'string' AND _jm_re_2(JSON_VALUE(pval, '$' RETURNING TEXT), NULL, NULL);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION _jm_cst_15(value JSONB)
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  constants JSONB = JSONB '["prompt","background","never"]';
BEGIN
  RETURN constants @> value;
END;
$$ LANGUAGE plpgsql;

-- check json_model_1_map_update (.update)
CREATE OR REPLACE FUNCTION _jm_f_66(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
BEGIN
  -- .update
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = 'method' THEN
      -- handle may method property
      -- .update.method
      res := JSONB_TYPEOF(pval) IN ('null', 'boolean', 'number', 'string') AND _jm_cst_15(pval);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'days' THEN
      -- handle may days property
      -- .update.days
      res := JSONB_TYPEOF(pval) = 'number' AND (pval)::INT8 = (pval)::FLOAT8 AND (pval)::INT8 >= 0;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION json_model_1_map(name TEXT)
RETURNS TEXT STRICT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  map JSONB := JSONB '{"confirmOnQuit":"_jm_f_0","customCommands":"_jm_f_1","disableStartupPopups":"_jm_f_2","git":"_jm_f_3","gui":"_jm_f_19","keybinding":"_jm_f_48","notARepository":"_jm_f_60","os":"_jm_f_61","promptToReturnFromSubprocess":"_jm_f_62","quitOnTopLevelReturn":"_jm_f_63","refresher":"_jm_f_64","services":"_jm_f_65","update":"_jm_f_66"}';
BEGIN
  RETURN map->>name;
END;
$$ LANGUAGE plpgsql;

-- check $ (.)
CREATE OR REPLACE FUNCTION json_model_1(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  pfun TEXT;
  prop TEXT;
  pval JSONB;
BEGIN
  -- JSON Model for Lazy Git
  -- .
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF json_model_1_map(prop) IS NOT NULL THEN
      -- handle 13 may props
      pfun := json_model_1_map(prop);
      IF NOT jm_call(pfun, pval, NULL, NULL) THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION check_model_map(name TEXT)
RETURNS TEXT STRICT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  map JSONB := JSONB '{"":"json_model_1","color":"json_model_2","colorArray":"json_model_3","keybinding":"json_model_4","custom-commands-prompts-type-property":"json_model_5","custom-commands-prompts-title-property":"json_model_6","custom-commands-prompts-key-property":"json_model_7","neString":"json_model_8","stringArray":"json_model_9","Prompts":"json_model_10"}';
BEGIN
  RETURN map->>name;
END;
$$ LANGUAGE plpgsql;

--
-- constant maps initialization
--
TRUNCATE jm_constant_maps;
INSERT INTO jm_constant_maps(mapname, tagval, value) VALUES
  ('_jm_map_0', JSONB '"input"', '_jm_obj_0'),
  ('_jm_map_0', JSONB '"confirm"', '_jm_obj_3'),
  ('_jm_map_0', JSONB '"menu"', '_jm_obj_4'),
  ('_jm_map_0', JSONB '"menuFromCommand"', '_jm_obj_6')
;

--
-- JSON Model checking entry point
--
-- TODO INOUT rep?
CREATE OR REPLACE FUNCTION check_model(val JSONB, name TEXT, rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  fun TEXT;
BEGIN
  fun := check_model_map(name);
  IF fun IS NULL THEN
    RAISE EXCEPTION 'model for % not found', name;
  END IF;
  RETURN jm_call(fun, val, NULL, rep);
END;
$$ LANGUAGE plpgsql;
