--
-- Generated by JSON Model Compiler version 2
-- see https://github.com/clairey-zx81/json-model
--
-- JSON_MODEL_VERSION is 2
CREATE EXTENSION IF NOT EXISTS json_model;

CREATE OR REPLACE FUNCTION _jm_cst_0(value JSONB)
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  constants JSONB = JSONB '["black","red","green","yellow","blue","magenta","cyan","white","bold","default","reverse","underline","strikethrough"]';
BEGIN
  RETURN constants @> value;
END;
$$ LANGUAGE plpgsql;

-- regex=^#[0-9a-fA-F]{6}$ opts=n
CREATE OR REPLACE FUNCTION _jm_re_0(val TEXT, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  RETURN regexp_like(val, '^#[0-9a-fA-F]{6}$', 'n');
END;
$$ LANGUAGE plpgsql;

-- check $color (.'$color')
CREATE OR REPLACE FUNCTION json_model_2(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$color'
  res := JSONB_TYPEOF(val) IN ('null', 'boolean', 'number', 'string') AND _jm_cst_0(val);
  IF NOT res THEN
    res := JSONB_TYPEOF(val) = 'string';
    IF res THEN
      -- .'$color'.'|'.0
      -- "/^#[0-9a-fA-F]{6}$/"
      res := _jm_re_0(JSON_VALUE(val, '$' RETURNING TEXT), path, rep);
    END IF;
  END IF;
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check $colorArray (.'$colorArray')
CREATE OR REPLACE FUNCTION json_model_3(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  arr_0_idx INT8;
  arr_0_item JSONB;
  ival_0 int;
BEGIN
  -- .'$colorArray'
  -- .'$colorArray'.'@'
  res := JSONB_TYPEOF(val) = 'array';
  IF res THEN
    FOR arr_0_idx IN 0 .. JSONB_ARRAY_LENGTH(val) - 1 LOOP
      arr_0_item := val -> arr_0_idx;
      -- .'$colorArray'.'@'.0
      res := json_model_2(arr_0_item, NULL, rep);
      IF NOT res THEN
        EXIT;
      END IF;
    END LOOP;
  END IF;
  IF res THEN
    ival_0 := JSONB_ARRAY_LENGTH(val);
    res := jm_array_is_unique(val, path, rep) AND ival_0 >= 1;
  END IF;
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check $keybinding (.'$keybinding')
CREATE OR REPLACE FUNCTION json_model_4(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$keybinding'
  -- .'$keybinding'.'|'.0
  res := JSONB_TYPEOF(val) = 'null';
  -- .'$keybinding'.'|'.1
  RETURN res OR JSONB_TYPEOF(val) = 'string';
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION _jm_cst_1(value JSONB)
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  constants JSONB = JSONB '["input","confirm","menu","menuFromCommand"]';
BEGIN
  RETURN constants @> value;
END;
$$ LANGUAGE plpgsql;

-- check $custom-commands-prompts-type-property (.'$custom-commands-prompts-type-property')
CREATE OR REPLACE FUNCTION json_model_5(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .'$custom-commands-prompts-type-property'
  RETURN JSONB_TYPEOF(val) IN ('null', 'boolean', 'number', 'string') AND _jm_cst_1(val);
END;
$$ LANGUAGE PLpgSQL;

-- check $custom-commands-prompts-title-property (.'$custom-commands-prompts-title-property')
CREATE OR REPLACE FUNCTION json_model_6(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .'$custom-commands-prompts-title-property'
  RETURN JSONB_TYPEOF(val) = 'string';
END;
$$ LANGUAGE PLpgSQL;

-- check $custom-commands-prompts-key-property (.'$custom-commands-prompts-key-property')
CREATE OR REPLACE FUNCTION json_model_7(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .'$custom-commands-prompts-key-property'
  RETURN JSONB_TYPEOF(val) = 'string';
END;
$$ LANGUAGE PLpgSQL;

-- check $neString (.'$neString')
CREATE OR REPLACE FUNCTION json_model_8(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  ival_1 int;
BEGIN
  -- .'$neString'
  -- .'$neString'.'@'
  res := JSONB_TYPEOF(val) = 'string';
  IF res THEN
    ival_1 := LENGTH(JSON_VALUE(val, '$' RETURNING TEXT));
    res := ival_1 >= 1;
  END IF;
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check $stringArray (.'$stringArray')
CREATE OR REPLACE FUNCTION json_model_9(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  arr_1_idx INT8;
  arr_1_item JSONB;
BEGIN
  -- .'$stringArray'
  -- .'$stringArray'.'@'
  res := JSONB_TYPEOF(val) = 'array';
  IF res THEN
    FOR arr_1_idx IN 0 .. JSONB_ARRAY_LENGTH(val) - 1 LOOP
      arr_1_item := val -> arr_1_idx;
      -- .'$stringArray'.'@'.0
      res := json_model_8(arr_1_item, NULL, rep);
      IF NOT res THEN
        EXIT;
      END IF;
    END LOOP;
  END IF;
  IF res THEN
    res := jm_array_is_unique(val, path, rep);
  END IF;
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- object .'$Prompts'.'|'.0.suggestions.'|'.1
CREATE OR REPLACE FUNCTION _jm_obj_1(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  pval JSONB;
  res bool;
BEGIN
  -- check close must only props
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  IF jm_object_size(val) <> 1 THEN
    RETURN FALSE;
  END IF;
  IF NOT val ? 'command' THEN
    RETURN FALSE;
  END IF;
  pval := val -> 'command';
  -- .'$Prompts'.'|'.0.suggestions.'|'.1.command
  RETURN JSONB_TYPEOF(pval) = 'string';
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION _jm_cst_2(value JSONB)
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  constants JSONB = JSONB '["authors","branches","files","refs","remotes","remoteBranches","tags"]';
BEGIN
  RETURN constants @> value;
END;
$$ LANGUAGE plpgsql;

-- object .'$Prompts'.'|'.0.suggestions.'|'.0
CREATE OR REPLACE FUNCTION _jm_obj_2(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  pval JSONB;
  res bool;
BEGIN
  -- check close must only props
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  IF jm_object_size(val) <> 1 THEN
    RETURN FALSE;
  END IF;
  IF NOT val ? 'preset' THEN
    RETURN FALSE;
  END IF;
  pval := val -> 'preset';
  -- .'$Prompts'.'|'.0.suggestions.'|'.0.preset
  RETURN JSONB_TYPEOF(pval) IN ('null', 'boolean', 'number', 'string') AND _jm_cst_2(pval);
END;
$$ LANGUAGE PLpgSQL;

-- object .'$Prompts'.'|'.0
CREATE OR REPLACE FUNCTION _jm_obj_0(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  must_count int;
  prop TEXT;
  pval JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  must_count := 0;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = 'type' THEN
      -- handle must type property
      must_count := must_count + 1;
      -- .'$Prompts'.'|'.0.type
      res := JSONB_TYPEOF(pval) = 'string' AND JSON_VALUE(pval, '$' RETURNING TEXT) = 'input';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'title' THEN
      -- handle must title property
      must_count := must_count + 1;
      -- .'$Prompts'.'|'.0.title
      res := json_model_6(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'key' THEN
      -- handle must key property
      must_count := must_count + 1;
      -- .'$Prompts'.'|'.0.key
      res := json_model_7(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'initialValue' THEN
      -- handle may initialValue property
      -- .'$Prompts'.'|'.0.initialValue
      res := JSONB_TYPEOF(pval) = 'string';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'suggestions' THEN
      -- handle may suggestions property
      -- .'$Prompts'.'|'.0.suggestions
      res := JSONB_TYPEOF(pval) = 'object';
      IF res THEN
        -- .'$Prompts'.'|'.0.suggestions.'|'.0
        res := _jm_obj_2(pval, NULL, rep);
        IF NOT res THEN
          -- .'$Prompts'.'|'.0.suggestions.'|'.1
          res := _jm_obj_1(pval, NULL, rep);
        END IF;
      END IF;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN must_count = 3;
END;
$$ LANGUAGE PLpgSQL;

-- object .'$Prompts'.'|'.1
CREATE OR REPLACE FUNCTION _jm_obj_3(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  must_count int;
  prop TEXT;
  pval JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  must_count := 0;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = 'type' THEN
      -- handle must type property
      must_count := must_count + 1;
      -- .'$Prompts'.'|'.1.type
      res := JSONB_TYPEOF(pval) = 'string' AND JSON_VALUE(pval, '$' RETURNING TEXT) = 'confirm';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'title' THEN
      -- handle must title property
      must_count := must_count + 1;
      -- .'$Prompts'.'|'.1.title
      res := json_model_6(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'key' THEN
      -- handle must key property
      must_count := must_count + 1;
      -- .'$Prompts'.'|'.1.key
      res := json_model_7(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'body' THEN
      -- handle may body property
      -- .'$Prompts'.'|'.1.body
      res := JSONB_TYPEOF(pval) = 'string';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN must_count = 3;
END;
$$ LANGUAGE PLpgSQL;

-- object .'$Prompts'.'|'.2.options.'@'.0
CREATE OR REPLACE FUNCTION _jm_obj_5(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  must_count int;
  prop TEXT;
  pval JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  must_count := 0;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = 'value' THEN
      -- handle must value property
      must_count := must_count + 1;
      -- .'$Prompts'.'|'.2.options.'@'.0.value
      res := json_model_8(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'description' THEN
      -- handle may description property
      -- .'$Prompts'.'|'.2.options.'@'.0.description
      res := JSONB_TYPEOF(pval) = 'string';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'name' THEN
      -- handle may name property
      -- .'$Prompts'.'|'.2.options.'@'.0.name
      res := JSONB_TYPEOF(pval) = 'string';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN must_count = 1;
END;
$$ LANGUAGE PLpgSQL;

-- object .'$Prompts'.'|'.2
CREATE OR REPLACE FUNCTION _jm_obj_4(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  pval JSONB;
  res bool;
  arr_2_idx INT8;
  arr_2_item JSONB;
BEGIN
  -- check close must only props
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  IF jm_object_size(val) <> 4 THEN
    RETURN FALSE;
  END IF;
  IF NOT val ? 'type' THEN
    RETURN FALSE;
  END IF;
  pval := val -> 'type';
  -- .'$Prompts'.'|'.2.type
  res := JSONB_TYPEOF(pval) = 'string' AND JSON_VALUE(pval, '$' RETURNING TEXT) = 'menu';
  IF NOT res THEN
    RETURN FALSE;
  END IF;
  IF NOT val ? 'title' THEN
    RETURN FALSE;
  END IF;
  pval := val -> 'title';
  -- .'$Prompts'.'|'.2.title
  res := json_model_6(pval, NULL, rep);
  IF NOT res THEN
    RETURN FALSE;
  END IF;
  IF NOT val ? 'key' THEN
    RETURN FALSE;
  END IF;
  pval := val -> 'key';
  -- .'$Prompts'.'|'.2.key
  res := json_model_7(pval, NULL, rep);
  IF NOT res THEN
    RETURN FALSE;
  END IF;
  IF NOT val ? 'options' THEN
    RETURN FALSE;
  END IF;
  pval := val -> 'options';
  -- .'$Prompts'.'|'.2.options
  -- .'$Prompts'.'|'.2.options.'@'
  res := JSONB_TYPEOF(pval) = 'array';
  IF res THEN
    FOR arr_2_idx IN 0 .. JSONB_ARRAY_LENGTH(pval) - 1 LOOP
      arr_2_item := pval -> arr_2_idx;
      -- .'$Prompts'.'|'.2.options.'@'.0
      res := _jm_obj_5(arr_2_item, NULL, rep);
      IF NOT res THEN
        EXIT;
      END IF;
    END LOOP;
  END IF;
  IF res THEN
    res := jm_array_is_unique(pval, NULL, rep);
  END IF;
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- object .'$Prompts'.'|'.3
CREATE OR REPLACE FUNCTION _jm_obj_6(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  must_count int;
  prop TEXT;
  pval JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  must_count := 0;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = 'type' THEN
      -- handle must type property
      must_count := must_count + 1;
      -- .'$Prompts'.'|'.3.type
      res := JSONB_TYPEOF(pval) = 'string' AND JSON_VALUE(pval, '$' RETURNING TEXT) = 'menuFromCommand';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'title' THEN
      -- handle must title property
      must_count := must_count + 1;
      -- .'$Prompts'.'|'.3.title
      res := json_model_6(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'key' THEN
      -- handle must key property
      must_count := must_count + 1;
      -- .'$Prompts'.'|'.3.key
      res := json_model_7(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'command' THEN
      -- handle must command property
      must_count := must_count + 1;
      -- .'$Prompts'.'|'.3.command
      res := JSONB_TYPEOF(pval) = 'string';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'filter' THEN
      -- handle may filter property
      -- .'$Prompts'.'|'.3.filter
      res := JSONB_TYPEOF(pval) = 'string';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'valueFormat' THEN
      -- handle may valueFormat property
      -- .'$Prompts'.'|'.3.valueFormat
      res := JSONB_TYPEOF(pval) = 'string';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'labelFormat' THEN
      -- handle may labelFormat property
      -- .'$Prompts'.'|'.3.labelFormat
      res := JSONB_TYPEOF(pval) = 'string';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN must_count = 4;
END;
$$ LANGUAGE PLpgSQL;


-- check $Prompts (.'$Prompts')
CREATE OR REPLACE FUNCTION json_model_10(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  iso_0 bool;
  tag_0 JSONB;
  fun_0 TEXT;
BEGIN
  -- .'$Prompts'
  iso_0 := JSONB_TYPEOF(val) = 'object';
  res := iso_0;
  IF res THEN
    IF val ? 'type' THEN
      tag_0 := val -> 'type';
      fun_0 := jm_cmap_get('_jm_map_0', tag_0);
      res := fun_0 IS NOT NULL AND jm_call(fun_0, val, path, rep);
    ELSE
      res := FALSE;
    END IF;
  ELSE
    NULL;
  END IF;
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_1_map_confirmOnQuit (.confirmOnQuit)
CREATE OR REPLACE FUNCTION _jm_f_0(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .confirmOnQuit
  RETURN JSONB_TYPEOF(val) = 'boolean';
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION _jm_cst_3(value JSONB)
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  constants JSONB = JSONB '["status","files","worktrees","localBranches","remotes","remoteBranches","tags","commits","reflogCommits","subCommits","commitFiles","stash","global"]';
BEGIN
  RETURN constants @> value;
END;
$$ LANGUAGE plpgsql;

-- check _jm_obj_7_map_after (.customCommands.'@'.0.after)
CREATE OR REPLACE FUNCTION _jm_f_2(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
BEGIN
  -- .customCommands.'@'.0.after
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = 'checkForConflicts' THEN
      -- handle may checkForConflicts property
      -- .customCommands.'@'.0.after.checkForConflicts
      res := JSONB_TYPEOF(pval) = 'boolean';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_7_map_description (.customCommands.'@'.0.description)
CREATE OR REPLACE FUNCTION _jm_f_3(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .customCommands.'@'.0.description
  RETURN JSONB_TYPEOF(val) = 'string';
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_7_map_loadingText (.customCommands.'@'.0.loadingText)
CREATE OR REPLACE FUNCTION _jm_f_4(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .customCommands.'@'.0.loadingText
  RETURN JSONB_TYPEOF(val) = 'string';
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_7_map_prompts (.customCommands.'@'.0.prompts)
CREATE OR REPLACE FUNCTION _jm_f_5(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  arr_4_idx INT8;
  arr_4_item JSONB;
BEGIN
  -- .customCommands.'@'.0.prompts
  res := JSONB_TYPEOF(val) = 'array';
  IF res THEN
    FOR arr_4_idx IN 0 .. JSONB_ARRAY_LENGTH(val) - 1 LOOP
      arr_4_item := val -> arr_4_idx;
      -- .customCommands.'@'.0.prompts.0
      res := json_model_10(arr_4_item, NULL, rep);
      IF NOT res THEN
        EXIT;
      END IF;
    END LOOP;
  END IF;
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_7_map_showOutput (.customCommands.'@'.0.showOutput)
CREATE OR REPLACE FUNCTION _jm_f_6(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .customCommands.'@'.0.showOutput
  RETURN JSONB_TYPEOF(val) = 'boolean';
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_7_map_stream (.customCommands.'@'.0.stream)
CREATE OR REPLACE FUNCTION _jm_f_7(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .customCommands.'@'.0.stream
  RETURN JSONB_TYPEOF(val) = 'boolean';
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_7_map_subprocess (.customCommands.'@'.0.subprocess)
CREATE OR REPLACE FUNCTION _jm_f_8(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .customCommands.'@'.0.subprocess
  RETURN JSONB_TYPEOF(val) = 'boolean';
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION _jm_obj_7_map(name TEXT)
RETURNS TEXT STRICT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  map JSONB := JSONB '{"after":"_jm_f_2","description":"_jm_f_3","loadingText":"_jm_f_4","prompts":"_jm_f_5","showOutput":"_jm_f_6","stream":"_jm_f_7","subprocess":"_jm_f_8"}';
BEGIN
  RETURN map->>name;
END;
$$ LANGUAGE plpgsql;

-- object .customCommands.'@'.0
CREATE OR REPLACE FUNCTION _jm_obj_7(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  pfun TEXT;
  must_count int;
  prop TEXT;
  pval JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  must_count := 0;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = 'key' THEN
      -- handle must key property
      must_count := must_count + 1;
      -- .customCommands.'@'.0.key
      res := json_model_4(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'command' THEN
      -- handle must command property
      must_count := must_count + 1;
      -- .customCommands.'@'.0.command
      res := JSONB_TYPEOF(pval) = 'string';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'context' THEN
      -- handle must context property
      must_count := must_count + 1;
      -- .customCommands.'@'.0.context
      res := JSONB_TYPEOF(pval) IN ('null', 'boolean', 'number', 'string') AND _jm_cst_3(pval);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF _jm_obj_7_map(prop) IS NOT NULL THEN
      -- handle 7 may props
      pfun := _jm_obj_7_map(prop);
      IF NOT jm_call(pfun, pval, NULL, rep) THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN must_count = 3;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_1_map_customCommands (.customCommands)
CREATE OR REPLACE FUNCTION _jm_f_1(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  arr_3_idx INT8;
  arr_3_item JSONB;
BEGIN
  -- .customCommands
  -- .customCommands.'@'
  res := JSONB_TYPEOF(val) = 'array';
  IF res THEN
    FOR arr_3_idx IN 0 .. JSONB_ARRAY_LENGTH(val) - 1 LOOP
      arr_3_item := val -> arr_3_idx;
      -- .customCommands.'@'.0
      res := _jm_obj_7(arr_3_item, NULL, rep);
      IF NOT res THEN
        EXIT;
      END IF;
    END LOOP;
  END IF;
  IF res THEN
    res := jm_array_is_unique(val, path, rep);
  END IF;
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_1_map_disableStartupPopups (.disableStartupPopups)
CREATE OR REPLACE FUNCTION _jm_f_9(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .disableStartupPopups
  RETURN JSONB_TYPEOF(val) = 'boolean';
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_f_10_map_allBranchesLogCmd (.git.allBranchesLogCmd)
CREATE OR REPLACE FUNCTION _jm_f_11(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .git.allBranchesLogCmd
  RETURN JSONB_TYPEOF(val) = 'string';
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_f_10_map_autoFetch (.git.autoFetch)
CREATE OR REPLACE FUNCTION _jm_f_12(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .git.autoFetch
  RETURN JSONB_TYPEOF(val) = 'boolean';
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_f_10_map_autoRefresh (.git.autoRefresh)
CREATE OR REPLACE FUNCTION _jm_f_13(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .git.autoRefresh
  RETURN JSONB_TYPEOF(val) = 'boolean';
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_f_10_map_branchLogCmd (.git.branchLogCmd)
CREATE OR REPLACE FUNCTION _jm_f_14(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .git.branchLogCmd
  RETURN JSONB_TYPEOF(val) = 'string';
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_f_10_map_commit (.git.commit)
CREATE OR REPLACE FUNCTION _jm_f_15(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
BEGIN
  -- .git.commit
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = 'signOff' THEN
      -- handle may signOff property
      -- .git.commit.signOff
      res := JSONB_TYPEOF(pval) = 'boolean';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- regex=. opts=n
CREATE OR REPLACE FUNCTION _jm_re_1(val TEXT, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  RETURN regexp_like(val, '.', 'n');
END;
$$ LANGUAGE plpgsql;

-- object .git.commitPrefixes.'/./'
CREATE OR REPLACE FUNCTION _jm_obj_8(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  pval JSONB;
  res bool;
BEGIN
  -- check close must only props
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  IF jm_object_size(val) <> 2 THEN
    RETURN FALSE;
  END IF;
  IF NOT val ? 'pattern' THEN
    RETURN FALSE;
  END IF;
  pval := val -> 'pattern';
  -- .git.commitPrefixes.'/./'.pattern
  res := json_model_8(pval, NULL, rep);
  IF NOT res THEN
    RETURN FALSE;
  END IF;
  IF NOT val ? 'replace' THEN
    RETURN FALSE;
  END IF;
  pval := val -> 'replace';
  -- .git.commitPrefixes.'/./'.replace
  RETURN json_model_8(pval, NULL, rep);
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_f_10_map_commitPrefixes (.git.commitPrefixes)
CREATE OR REPLACE FUNCTION _jm_f_16(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
BEGIN
  -- .git.commitPrefixes
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF _jm_re_1(prop, path, rep) THEN
      -- handle 1 re props
      -- .git.commitPrefixes.'/./'
      res := _jm_obj_8(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_f_10_map_diffContextSize (.git.diffContextSize)
CREATE OR REPLACE FUNCTION _jm_f_17(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .git.diffContextSize
  RETURN JSONB_TYPEOF(val) = 'number' AND (val)::INT8 = (val)::FLOAT8 AND (val)::INT8 >= 0;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_f_10_map_disableForcePushing (.git.disableForcePushing)
CREATE OR REPLACE FUNCTION _jm_f_18(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .git.disableForcePushing
  RETURN JSONB_TYPEOF(val) = 'boolean';
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_f_10_map_fetchAll (.git.fetchAll)
CREATE OR REPLACE FUNCTION _jm_f_19(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .git.fetchAll
  RETURN JSONB_TYPEOF(val) = 'boolean';
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION _jm_cst_4(value JSONB)
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  constants JSONB = JSONB '["date-order","author-date-order","topo-order","default"]';
BEGIN
  RETURN constants @> value;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION _jm_cst_5(value JSONB)
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  constants JSONB = JSONB '["always","never","when-maximised"]';
BEGIN
  RETURN constants @> value;
END;
$$ LANGUAGE plpgsql;

-- check _jm_f_10_map_log (.git.log)
CREATE OR REPLACE FUNCTION _jm_f_20(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
BEGIN
  -- .git.log
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = 'order' THEN
      -- handle may order property
      -- .git.log.order
      res := JSONB_TYPEOF(pval) IN ('null', 'boolean', 'number', 'string') AND _jm_cst_4(pval);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'showGraph' THEN
      -- handle may showGraph property
      -- .git.log.showGraph
      res := JSONB_TYPEOF(pval) IN ('null', 'boolean', 'number', 'string') AND _jm_cst_5(pval);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'showWholeGraph' THEN
      -- handle may showWholeGraph property
      -- .git.log.showWholeGraph
      res := JSONB_TYPEOF(pval) = 'boolean';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_f_10_map_merging (.git.merging)
CREATE OR REPLACE FUNCTION _jm_f_21(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
BEGIN
  -- .git.merging
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = 'manualCommit' THEN
      -- handle may manualCommit property
      -- .git.merging.manualCommit
      res := JSONB_TYPEOF(pval) = 'boolean';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'args' THEN
      -- handle may args property
      -- .git.merging.args
      res := JSONB_TYPEOF(pval) = 'string';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_f_10_map_overrideGpg (.git.overrideGpg)
CREATE OR REPLACE FUNCTION _jm_f_22(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .git.overrideGpg
  RETURN JSONB_TYPEOF(val) = 'boolean';
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION _jm_cst_6(value JSONB)
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  constants JSONB = JSONB '["always","never"]';
BEGIN
  RETURN constants @> value;
END;
$$ LANGUAGE plpgsql;

-- check _jm_f_10_map_paging (.git.paging)
CREATE OR REPLACE FUNCTION _jm_f_23(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
  ival_2 int;
BEGIN
  -- .git.paging
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = 'colorArg' THEN
      -- handle may colorArg property
      -- .git.paging.colorArg
      res := JSONB_TYPEOF(pval) IN ('null', 'boolean', 'number', 'string') AND _jm_cst_6(pval);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'useConfig' THEN
      -- handle may useConfig property
      -- .git.paging.useConfig
      res := JSONB_TYPEOF(pval) = 'boolean';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'pager' THEN
      -- handle may pager property
      -- .git.paging.pager
      -- .git.paging.pager.'@'
      res := JSONB_TYPEOF(pval) = 'string';
      IF res THEN
        ival_2 := LENGTH(JSON_VALUE(pval, '$' RETURNING TEXT));
        res := ival_2 >= 1;
      END IF;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_f_10_map_parseEmoji (.git.parseEmoji)
CREATE OR REPLACE FUNCTION _jm_f_24(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .git.parseEmoji
  RETURN JSONB_TYPEOF(val) = 'boolean';
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_f_10_map_skipHookPrefix (.git.skipHookPrefix)
CREATE OR REPLACE FUNCTION _jm_f_25(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .git.skipHookPrefix
  RETURN JSONB_TYPEOF(val) = 'string';
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION _jm_f_10_map(name TEXT)
RETURNS TEXT STRICT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  map JSONB := JSONB '{"allBranchesLogCmd":"_jm_f_11","autoFetch":"_jm_f_12","autoRefresh":"_jm_f_13","branchLogCmd":"_jm_f_14","commit":"_jm_f_15","commitPrefixes":"_jm_f_16","diffContextSize":"_jm_f_17","disableForcePushing":"_jm_f_18","fetchAll":"_jm_f_19","log":"_jm_f_20","mainBranches":"json_model_9","merging":"_jm_f_21","overrideGpg":"_jm_f_22","paging":"_jm_f_23","parseEmoji":"_jm_f_24","skipHookPrefix":"_jm_f_25"}';
BEGIN
  RETURN map->>name;
END;
$$ LANGUAGE plpgsql;

-- check json_model_1_map_git (.git)
CREATE OR REPLACE FUNCTION _jm_f_10(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  pfun TEXT;
  prop TEXT;
  pval JSONB;
BEGIN
  -- .git
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF _jm_f_10_map(prop) IS NOT NULL THEN
      -- handle 16 may props
      pfun := _jm_f_10_map(prop);
      IF NOT jm_call(pfun, pval, NULL, rep) THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_f_26_map_animateExplosion (.gui.animateExplosion)
CREATE OR REPLACE FUNCTION _jm_f_27(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .gui.animateExplosion
  RETURN JSONB_TYPEOF(val) = 'boolean';
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_f_26_map_authorColors (.gui.authorColors)
CREATE OR REPLACE FUNCTION _jm_f_28(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
BEGIN
  -- .gui.authorColors
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF _jm_re_1(prop, path, rep) THEN
      -- handle 1 re props
      -- .gui.authorColors.'/./'
      res := json_model_2(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION _jm_cst_7(value JSONB)
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  constants JSONB = JSONB '["single","double","rounded","hidden"]';
BEGIN
  RETURN constants @> value;
END;
$$ LANGUAGE plpgsql;

-- check _jm_f_26_map_border (.gui.border)
CREATE OR REPLACE FUNCTION _jm_f_29(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .gui.border
  RETURN JSONB_TYPEOF(val) IN ('null', 'boolean', 'number', 'string') AND _jm_cst_7(val);
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_f_26_map_branchColors (.gui.branchColors)
CREATE OR REPLACE FUNCTION _jm_f_30(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
BEGIN
  -- .gui.branchColors
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF _jm_re_1(prop, path, rep) THEN
      -- handle 1 re props
      -- .gui.branchColors.'/./'
      res := json_model_2(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_f_26_map_commandLogSize (.gui.commandLogSize)
CREATE OR REPLACE FUNCTION _jm_f_31(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .gui.commandLogSize
  RETURN JSONB_TYPEOF(val) = 'number' AND (val)::INT8 = (val)::FLOAT8 AND (val)::INT8 >= 0;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_f_26_map_commitLength (.gui.commitLength)
CREATE OR REPLACE FUNCTION _jm_f_32(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
BEGIN
  -- .gui.commitLength
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = 'show' THEN
      -- handle may show property
      -- .gui.commitLength.show
      res := JSONB_TYPEOF(pval) = 'boolean';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_f_26_map_expandFocusedSidePanel (.gui.expandFocusedSidePanel)
CREATE OR REPLACE FUNCTION _jm_f_33(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .gui.expandFocusedSidePanel
  RETURN JSONB_TYPEOF(val) = 'boolean';
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION _jm_cst_8(value JSONB)
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  constants JSONB = JSONB '["auto","en","zh-CN","zh-TW","pl","nl","ja","ko","ru"]';
BEGIN
  RETURN constants @> value;
END;
$$ LANGUAGE plpgsql;

-- check _jm_f_26_map_language (.gui.language)
CREATE OR REPLACE FUNCTION _jm_f_34(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .gui.language
  RETURN JSONB_TYPEOF(val) IN ('null', 'boolean', 'number', 'string') AND _jm_cst_8(val);
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION _jm_cst_9(value JSONB)
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  constants JSONB = JSONB '["horizontal","flexible","vertical"]';
BEGIN
  RETURN constants @> value;
END;
$$ LANGUAGE plpgsql;

-- check _jm_f_26_map_mainPanelSplitMode (.gui.mainPanelSplitMode)
CREATE OR REPLACE FUNCTION _jm_f_35(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .gui.mainPanelSplitMode
  RETURN JSONB_TYPEOF(val) IN ('null', 'boolean', 'number', 'string') AND _jm_cst_9(val);
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_f_26_map_mouseEvents (.gui.mouseEvents)
CREATE OR REPLACE FUNCTION _jm_f_36(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .gui.mouseEvents
  RETURN JSONB_TYPEOF(val) = 'boolean';
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION _jm_cst_10(value JSONB)
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  constants JSONB = JSONB '["2","3"]';
BEGIN
  RETURN constants @> value;
END;
$$ LANGUAGE plpgsql;

-- check _jm_f_26_map_nerdFontsVersion (.gui.nerdFontsVersion)
CREATE OR REPLACE FUNCTION _jm_f_37(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .gui.nerdFontsVersion
  res := JSONB_TYPEOF(val) IN ('null', 'boolean', 'number', 'string') AND _jm_cst_10(val);
  IF NOT res THEN
    res := JSONB_TYPEOF(val) = 'string';
    IF res THEN
      -- .gui.nerdFontsVersion.'|'.0
      res := TRUE;
    END IF;
  END IF;
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_f_26_map_scrollHeight (.gui.scrollHeight)
CREATE OR REPLACE FUNCTION _jm_f_38(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .gui.scrollHeight
  RETURN JSONB_TYPEOF(val) = 'number' AND (val)::INT8 = (val)::FLOAT8 AND (val)::INT8 >= 1;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_f_26_map_scrollPastBottom (.gui.scrollPastBottom)
CREATE OR REPLACE FUNCTION _jm_f_39(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .gui.scrollPastBottom
  RETURN JSONB_TYPEOF(val) = 'boolean';
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_f_26_map_shortTimeFormat (.gui.shortTimeFormat)
CREATE OR REPLACE FUNCTION _jm_f_40(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .gui.shortTimeFormat
  RETURN JSONB_TYPEOF(val) = 'string';
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_f_26_map_showBottomLine (.gui.showBottomLine)
CREATE OR REPLACE FUNCTION _jm_f_41(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .gui.showBottomLine
  RETURN JSONB_TYPEOF(val) = 'boolean';
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_f_26_map_showBranchCommitHash (.gui.showBranchCommitHash)
CREATE OR REPLACE FUNCTION _jm_f_42(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .gui.showBranchCommitHash
  RETURN JSONB_TYPEOF(val) = 'boolean';
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_f_26_map_showCommandLog (.gui.showCommandLog)
CREATE OR REPLACE FUNCTION _jm_f_43(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .gui.showCommandLog
  RETURN JSONB_TYPEOF(val) = 'boolean';
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_f_26_map_showFileTree (.gui.showFileTree)
CREATE OR REPLACE FUNCTION _jm_f_44(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .gui.showFileTree
  RETURN JSONB_TYPEOF(val) = 'boolean';
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_f_26_map_showListFooter (.gui.showListFooter)
CREATE OR REPLACE FUNCTION _jm_f_45(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .gui.showListFooter
  RETURN JSONB_TYPEOF(val) = 'boolean';
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_f_26_map_showRandomTip (.gui.showRandomTip)
CREATE OR REPLACE FUNCTION _jm_f_46(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .gui.showRandomTip
  RETURN JSONB_TYPEOF(val) = 'boolean';
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_f_26_map_sidePanelWidth (.gui.sidePanelWidth)
CREATE OR REPLACE FUNCTION _jm_f_47(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  fval_0 FLOAT8;
BEGIN
  -- .gui.sidePanelWidth
  -- .gui.sidePanelWidth.'@'
  res := JSONB_TYPEOF(val) = 'number' AND (val)::FLOAT8 >= 0.0;
  IF res THEN
    fval_0 := (val)::FLOAT8;
    res := fval_0 <= 1.0;
  END IF;
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_f_26_map_skipDiscardChangeWarning (.gui.skipDiscardChangeWarning)
CREATE OR REPLACE FUNCTION _jm_f_48(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .gui.skipDiscardChangeWarning
  RETURN JSONB_TYPEOF(val) = 'boolean';
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_f_26_map_skipRewordInEditorWarning (.gui.skipRewordInEditorWarning)
CREATE OR REPLACE FUNCTION _jm_f_49(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .gui.skipRewordInEditorWarning
  RETURN JSONB_TYPEOF(val) = 'boolean';
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_f_26_map_skipStashWarning (.gui.skipStashWarning)
CREATE OR REPLACE FUNCTION _jm_f_50(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .gui.skipStashWarning
  RETURN JSONB_TYPEOF(val) = 'boolean';
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION _jm_cst_11(value JSONB)
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  constants JSONB = JSONB '["auto","always"]';
BEGIN
  RETURN constants @> value;
END;
$$ LANGUAGE plpgsql;

-- check _jm_f_26_map_splitDiff (.gui.splitDiff)
CREATE OR REPLACE FUNCTION _jm_f_51(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .gui.splitDiff
  RETURN JSONB_TYPEOF(val) IN ('null', 'boolean', 'number', 'string') AND _jm_cst_11(val);
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION _jm_f_52_map(name TEXT)
RETURNS TEXT STRICT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  map JSONB := JSONB '{"activeBorderColor":"json_model_3","cherryPickedCommitBgColor":"json_model_3","cherryPickedCommitFgColor":"json_model_3","defaultFgColor":"json_model_3","inactiveBorderColor":"json_model_3","optionsTextColor":"json_model_3","searchingActiveBorderColor":"json_model_3","selectedLineBgColor":"json_model_3","selectedRangeBgColor":"json_model_3","unstagedChangesColor":"json_model_3"}';
BEGIN
  RETURN map->>name;
END;
$$ LANGUAGE plpgsql;

-- check _jm_f_26_map_theme (.gui.theme)
CREATE OR REPLACE FUNCTION _jm_f_52(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  pfun TEXT;
  prop TEXT;
  pval JSONB;
BEGIN
  -- .gui.theme
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF _jm_f_52_map(prop) IS NOT NULL THEN
      -- handle 10 may props
      pfun := _jm_f_52_map(prop);
      IF NOT jm_call(pfun, pval, NULL, rep) THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_f_26_map_timeFormat (.gui.timeFormat)
CREATE OR REPLACE FUNCTION _jm_f_53(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .gui.timeFormat
  RETURN JSONB_TYPEOF(val) = 'string';
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION _jm_cst_12(value JSONB)
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  constants JSONB = JSONB '["normal","half","full"]';
BEGIN
  RETURN constants @> value;
END;
$$ LANGUAGE plpgsql;

-- check _jm_f_26_map_windowSize (.gui.windowSize)
CREATE OR REPLACE FUNCTION _jm_f_54(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .gui.windowSize
  RETURN JSONB_TYPEOF(val) IN ('null', 'boolean', 'number', 'string') AND _jm_cst_12(val);
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION _jm_f_26_map(name TEXT)
RETURNS TEXT STRICT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  map JSONB := JSONB '{"animateExplosion":"_jm_f_27","authorColors":"_jm_f_28","border":"_jm_f_29","branchColors":"_jm_f_30","commandLogSize":"_jm_f_31","commitLength":"_jm_f_32","expandFocusedSidePanel":"_jm_f_33","language":"_jm_f_34","mainPanelSplitMode":"_jm_f_35","mouseEvents":"_jm_f_36","nerdFontsVersion":"_jm_f_37","scrollHeight":"_jm_f_38","scrollPastBottom":"_jm_f_39","shortTimeFormat":"_jm_f_40","showBottomLine":"_jm_f_41","showBranchCommitHash":"_jm_f_42","showCommandLog":"_jm_f_43","showFileTree":"_jm_f_44","showListFooter":"_jm_f_45","showRandomTip":"_jm_f_46","sidePanelWidth":"_jm_f_47","skipDiscardChangeWarning":"_jm_f_48","skipRewordInEditorWarning":"_jm_f_49","skipStashWarning":"_jm_f_50","splitDiff":"_jm_f_51","theme":"_jm_f_52","timeFormat":"_jm_f_53","windowSize":"_jm_f_54"}';
BEGIN
  RETURN map->>name;
END;
$$ LANGUAGE plpgsql;

-- check json_model_1_map_gui (.gui)
CREATE OR REPLACE FUNCTION _jm_f_26(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  pfun TEXT;
  prop TEXT;
  pval JSONB;
BEGIN
  -- .gui
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF _jm_f_26_map(prop) IS NOT NULL THEN
      -- handle 28 may props
      pfun := _jm_f_26_map(prop);
      IF NOT jm_call(pfun, pval, NULL, rep) THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION _jm_f_56_map(name TEXT)
RETURNS TEXT STRICT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  map JSONB := JSONB '{"checkoutBranchByName":"json_model_4","createPullRequest":"json_model_4","createTag":"json_model_4","fastForward":"json_model_4","fetchRemote":"json_model_4","forceCheckoutBranch":"json_model_4","mergeIntoCurrentBranch":"json_model_4","pushTag":"json_model_4","rebaseBranch":"json_model_4","renameBranch":"json_model_4","setUpstream":"json_model_4","viewGitFlowOptions":"json_model_4","viewPullRequestOptions":"json_model_4"}';
BEGIN
  RETURN map->>name;
END;
$$ LANGUAGE plpgsql;

-- check _jm_f_55_map_branches (.keybinding.branches)
CREATE OR REPLACE FUNCTION _jm_f_56(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  pfun TEXT;
  prop TEXT;
  pval JSONB;
BEGIN
  -- .keybinding.branches
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF _jm_f_56_map(prop) IS NOT NULL THEN
      -- handle 13 may props
      pfun := _jm_f_56_map(prop);
      IF NOT jm_call(pfun, pval, NULL, rep) THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_f_55_map_commitFiles (.keybinding.commitFiles)
CREATE OR REPLACE FUNCTION _jm_f_57(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
BEGIN
  -- .keybinding.commitFiles
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = 'checkoutCommitFile' THEN
      -- handle may checkoutCommitFile property
      -- .keybinding.commitFiles.checkoutCommitFile
      res := json_model_4(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION _jm_f_58_map(name TEXT)
RETURNS TEXT STRICT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  map JSONB := JSONB '{"amendToCommit":"json_model_4","checkoutCommit":"json_model_4","cherryPickCopy":"json_model_4","cherryPickCopyRange":"json_model_4","copyCommitMessageToClipboard":"json_model_4","createFixupCommit":"json_model_4","markCommitAsFixup":"json_model_4","moveDownCommit":"json_model_4","moveUpCommit":"json_model_4","openLogMenu":"json_model_4","pasteCommits":"json_model_4","pickCommit":"json_model_4","renameCommit":"json_model_4","renameCommitWithEditor":"json_model_4","resetCherryPick":"json_model_4","revertCommit":"json_model_4","squashAboveCommits":"json_model_4","squashDown":"json_model_4","tagCommit":"json_model_4","viewBisectOptions":"json_model_4","viewResetOptions":"json_model_4"}';
BEGIN
  RETURN map->>name;
END;
$$ LANGUAGE plpgsql;

-- check _jm_f_55_map_commits (.keybinding.commits)
CREATE OR REPLACE FUNCTION _jm_f_58(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  pfun TEXT;
  prop TEXT;
  pval JSONB;
BEGIN
  -- .keybinding.commits
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF _jm_f_58_map(prop) IS NOT NULL THEN
      -- handle 21 may props
      pfun := _jm_f_58_map(prop);
      IF NOT jm_call(pfun, pval, NULL, rep) THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION _jm_f_59_map(name TEXT)
RETURNS TEXT STRICT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  map JSONB := JSONB '{"amendLastCommit":"json_model_4","commitChanges":"json_model_4","commitChangesWithEditor":"json_model_4","commitChangesWithoutHook":"json_model_4","fetch":"json_model_4","ignoreFile":"json_model_4","openMergeTool":"json_model_4","openStatusFilter":"json_model_4","refreshFiles":"json_model_4","stashAllChanges":"json_model_4","toggleStagedAll":"json_model_4","toggleTreeView":"json_model_4","viewResetOptions":"json_model_4","viewStashOptions":"json_model_4"}';
BEGIN
  RETURN map->>name;
END;
$$ LANGUAGE plpgsql;

-- check _jm_f_55_map_files (.keybinding.files)
CREATE OR REPLACE FUNCTION _jm_f_59(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  pfun TEXT;
  prop TEXT;
  pval JSONB;
BEGIN
  -- .keybinding.files
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF _jm_f_59_map(prop) IS NOT NULL THEN
      -- handle 14 may props
      pfun := _jm_f_59_map(prop);
      IF NOT jm_call(pfun, pval, NULL, rep) THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_f_55_map_main (.keybinding.main)
CREATE OR REPLACE FUNCTION _jm_f_60(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
BEGIN
  -- .keybinding.main
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = 'toggleDragSelect' THEN
      -- handle may toggleDragSelect property
      -- .keybinding.main.toggleDragSelect
      res := json_model_4(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'toggleDragSelect-alt' THEN
      -- handle may toggleDragSelect-alt property
      -- .keybinding.main.'toggleDragSelect-alt'
      res := json_model_4(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'toggleSelectHunk' THEN
      -- handle may toggleSelectHunk property
      -- .keybinding.main.toggleSelectHunk
      res := json_model_4(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'pickBothHunks' THEN
      -- handle may pickBothHunks property
      -- .keybinding.main.pickBothHunks
      res := json_model_4(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_f_55_map_stash (.keybinding.stash)
CREATE OR REPLACE FUNCTION _jm_f_61(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
BEGIN
  -- .keybinding.stash
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = 'popStash' THEN
      -- handle may popStash property
      -- .keybinding.stash.popStash
      res := json_model_4(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'renameStash' THEN
      -- handle may renameStash property
      -- .keybinding.stash.renameStash
      res := json_model_4(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_f_55_map_status (.keybinding.status)
CREATE OR REPLACE FUNCTION _jm_f_62(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
BEGIN
  -- .keybinding.status
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = 'checkForUpdate' THEN
      -- handle may checkForUpdate property
      -- .keybinding.status.checkForUpdate
      res := json_model_4(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'recentRepos' THEN
      -- handle may recentRepos property
      -- .keybinding.status.recentRepos
      res := json_model_4(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_f_55_map_submodules (.keybinding.submodules)
CREATE OR REPLACE FUNCTION _jm_f_63(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
BEGIN
  -- .keybinding.submodules
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = 'init' THEN
      -- handle may init property
      -- .keybinding.submodules.init
      res := json_model_4(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'update' THEN
      -- handle may update property
      -- .keybinding.submodules.update
      res := json_model_4(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'bulkMenu' THEN
      -- handle may bulkMenu property
      -- .keybinding.submodules.bulkMenu
      res := json_model_4(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_f_64_map_jumpToBlock (.keybinding.universal.jumpToBlock)
CREATE OR REPLACE FUNCTION _jm_f_65(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .keybinding.universal.jumpToBlock
  RETURN JSONB_TYPEOF(val) = 'array';
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_f_64_map_optionMenu (.keybinding.universal.optionMenu)
CREATE OR REPLACE FUNCTION _jm_f_66(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .keybinding.universal.optionMenu
  RETURN JSONB_TYPEOF(val) = 'null';
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION _jm_f_64_map(name TEXT)
RETURNS TEXT STRICT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  map JSONB := JSONB '{"confirm":"json_model_4","copyToClipboard":"json_model_4","createPatchOptionsMenu":"json_model_4","createRebaseOptionsMenu":"json_model_4","decreaseContextInDiffView":"json_model_4","diffingMenu":"json_model_4","diffingMenu-alt":"json_model_4","edit":"json_model_4","executeCustomCommand":"json_model_4","extrasMenu":"json_model_4","filteringMenu":"json_model_4","goInto":"json_model_4","gotoBottom":"json_model_4","gotoTop":"json_model_4","increaseContextInDiffView":"json_model_4","jumpToBlock":"_jm_f_65","new":"json_model_4","nextBlock":"json_model_4","nextBlock-alt":"json_model_4","nextItem":"json_model_4","nextItem-alt":"json_model_4","nextMatch":"json_model_4","nextPage":"json_model_4","nextScreenMode":"json_model_4","nextTab":"json_model_4","openFile":"json_model_4","openRecentRepos":"json_model_4","optionMenu":"_jm_f_66","optionMenu-alt1":"json_model_4","prevBlock":"json_model_4","prevBlock-alt":"json_model_4","prevItem":"json_model_4","prevItem-alt":"json_model_4","prevMatch":"json_model_4","prevPage":"json_model_4","prevScreenMode":"json_model_4","prevTab":"json_model_4","pullFiles":"json_model_4","pushFiles":"json_model_4","quit":"json_model_4","quit-alt1":"json_model_4","quitWithoutChangingDirectory":"json_model_4","redo":"json_model_4","refresh":"json_model_4","remove":"json_model_4","return":"json_model_4","scrollDownMain":"json_model_4","scrollDownMain-alt1":"json_model_4","scrollDownMain-alt2":"json_model_4","scrollLeft":"json_model_4","scrollRight":"json_model_4","scrollUpMain":"json_model_4","scrollUpMain-alt1":"json_model_4","scrollUpMain-alt2":"json_model_4","select":"json_model_4","submitEditorText":"json_model_4","togglePanel":"json_model_4","toggleWhitespaceInDiffView":"json_model_4","undo":"json_model_4"}';
BEGIN
  RETURN map->>name;
END;
$$ LANGUAGE plpgsql;

-- check _jm_f_55_map_universal (.keybinding.universal)
CREATE OR REPLACE FUNCTION _jm_f_64(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  pfun TEXT;
  prop TEXT;
  pval JSONB;
BEGIN
  -- .keybinding.universal
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF _jm_f_64_map(prop) IS NOT NULL THEN
      -- handle 59 may props
      pfun := _jm_f_64_map(prop);
      IF NOT jm_call(pfun, pval, NULL, rep) THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION _jm_f_55_map(name TEXT)
RETURNS TEXT STRICT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  map JSONB := JSONB '{"branches":"_jm_f_56","commitFiles":"_jm_f_57","commits":"_jm_f_58","files":"_jm_f_59","main":"_jm_f_60","stash":"_jm_f_61","status":"_jm_f_62","submodules":"_jm_f_63","universal":"_jm_f_64"}';
BEGIN
  RETURN map->>name;
END;
$$ LANGUAGE plpgsql;

-- check json_model_1_map_keybinding (.keybinding)
CREATE OR REPLACE FUNCTION _jm_f_55(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  pfun TEXT;
  prop TEXT;
  pval JSONB;
BEGIN
  -- .keybinding
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF _jm_f_55_map(prop) IS NOT NULL THEN
      -- handle 9 may props
      pfun := _jm_f_55_map(prop);
      IF NOT jm_call(pfun, pval, NULL, rep) THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION _jm_cst_13(value JSONB)
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  constants JSONB = JSONB '["prompt","create","skip","quit"]';
BEGIN
  RETURN constants @> value;
END;
$$ LANGUAGE plpgsql;

-- check json_model_1_map_notARepository (.notARepository)
CREATE OR REPLACE FUNCTION _jm_f_67(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .notARepository
  RETURN JSONB_TYPEOF(val) IN ('null', 'boolean', 'number', 'string') AND _jm_cst_13(val);
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_f_68_map_copyToClipboardCmd (.os.copyToClipboardCmd)
CREATE OR REPLACE FUNCTION _jm_f_69(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .os.copyToClipboardCmd
  RETURN JSONB_TYPEOF(val) = 'string';
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_f_68_map_edit (.os.edit)
CREATE OR REPLACE FUNCTION _jm_f_70(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .os.edit
  RETURN JSONB_TYPEOF(val) = 'string';
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_f_68_map_editAtLine (.os.editAtLine)
CREATE OR REPLACE FUNCTION _jm_f_71(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .os.editAtLine
  RETURN JSONB_TYPEOF(val) = 'string';
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_f_68_map_editAtLineAndWait (.os.editAtLineAndWait)
CREATE OR REPLACE FUNCTION _jm_f_72(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .os.editAtLineAndWait
  RETURN JSONB_TYPEOF(val) = 'string';
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION _jm_cst_14(value JSONB)
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  constants JSONB = JSONB '["vim","nvim","emacs","nano","vscode","sublime","bbedit","kakoune","helix","xcode"]';
BEGIN
  RETURN constants @> value;
END;
$$ LANGUAGE plpgsql;

-- check _jm_f_68_map_editPreset (.os.editPreset)
CREATE OR REPLACE FUNCTION _jm_f_73(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .os.editPreset
  res := JSONB_TYPEOF(val) IN ('null', 'boolean', 'number', 'string') AND _jm_cst_14(val);
  IF NOT res THEN
    res := JSONB_TYPEOF(val) = 'string';
    IF res THEN
      -- .os.editPreset.'|'.0
      res := TRUE;
    END IF;
  END IF;
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_f_68_map_open (.os.open)
CREATE OR REPLACE FUNCTION _jm_f_74(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .os.open
  RETURN JSONB_TYPEOF(val) = 'string';
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_f_68_map_openLink (.os.openLink)
CREATE OR REPLACE FUNCTION _jm_f_75(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .os.openLink
  RETURN JSONB_TYPEOF(val) = 'string';
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION _jm_f_68_map(name TEXT)
RETURNS TEXT STRICT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  map JSONB := JSONB '{"copyToClipboardCmd":"_jm_f_69","edit":"_jm_f_70","editAtLine":"_jm_f_71","editAtLineAndWait":"_jm_f_72","editPreset":"_jm_f_73","open":"_jm_f_74","openLink":"_jm_f_75"}';
BEGIN
  RETURN map->>name;
END;
$$ LANGUAGE plpgsql;

-- check json_model_1_map_os (.os)
CREATE OR REPLACE FUNCTION _jm_f_68(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  pfun TEXT;
  prop TEXT;
  pval JSONB;
BEGIN
  -- .os
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF _jm_f_68_map(prop) IS NOT NULL THEN
      -- handle 7 may props
      pfun := _jm_f_68_map(prop);
      IF NOT jm_call(pfun, pval, NULL, rep) THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_1_map_promptToReturnFromSubprocess (.promptToReturnFromSubprocess)
CREATE OR REPLACE FUNCTION _jm_f_76(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .promptToReturnFromSubprocess
  RETURN JSONB_TYPEOF(val) = 'boolean';
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_1_map_quitOnTopLevelReturn (.quitOnTopLevelReturn)
CREATE OR REPLACE FUNCTION _jm_f_77(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .quitOnTopLevelReturn
  RETURN JSONB_TYPEOF(val) = 'boolean';
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_1_map_refresher (.refresher)
CREATE OR REPLACE FUNCTION _jm_f_78(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
BEGIN
  -- .refresher
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = 'refreshInterval' THEN
      -- handle may refreshInterval property
      -- .refresher.refreshInterval
      res := JSONB_TYPEOF(pval) = 'number' AND (pval)::INT8 = (pval)::FLOAT8 AND (pval)::INT8 >= 0;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'fetchInterval' THEN
      -- handle may fetchInterval property
      -- .refresher.fetchInterval
      res := JSONB_TYPEOF(pval) = 'number' AND (pval)::INT8 = (pval)::FLOAT8 AND (pval)::INT8 >= 0;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- regex=^[^:]+:[^:]+$ opts=n
CREATE OR REPLACE FUNCTION _jm_re_2(val TEXT, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  RETURN regexp_like(val, '^[^:]+:[^:]+$', 'n');
END;
$$ LANGUAGE plpgsql;

-- check json_model_1_map_services (.services)
CREATE OR REPLACE FUNCTION _jm_f_79(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
BEGIN
  -- .services
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF _jm_re_1(prop, path, rep) THEN
      -- handle 1 re props
      -- .services.'/./'
      -- "/^[^:]+:[^:]+$/"
      res := JSONB_TYPEOF(pval) = 'string' AND _jm_re_2(JSON_VALUE(pval, '$' RETURNING TEXT), NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION _jm_cst_15(value JSONB)
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  constants JSONB = JSONB '["prompt","background","never"]';
BEGIN
  RETURN constants @> value;
END;
$$ LANGUAGE plpgsql;

-- check json_model_1_map_update (.update)
CREATE OR REPLACE FUNCTION _jm_f_80(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
BEGIN
  -- .update
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = 'method' THEN
      -- handle may method property
      -- .update.method
      res := JSONB_TYPEOF(pval) IN ('null', 'boolean', 'number', 'string') AND _jm_cst_15(pval);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'days' THEN
      -- handle may days property
      -- .update.days
      res := JSONB_TYPEOF(pval) = 'number' AND (pval)::INT8 = (pval)::FLOAT8 AND (pval)::INT8 >= 0;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION json_model_1_map(name TEXT)
RETURNS TEXT STRICT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  map JSONB := JSONB '{"confirmOnQuit":"_jm_f_0","customCommands":"_jm_f_1","disableStartupPopups":"_jm_f_9","git":"_jm_f_10","gui":"_jm_f_26","keybinding":"_jm_f_55","notARepository":"_jm_f_67","os":"_jm_f_68","promptToReturnFromSubprocess":"_jm_f_76","quitOnTopLevelReturn":"_jm_f_77","refresher":"_jm_f_78","services":"_jm_f_79","update":"_jm_f_80"}';
BEGIN
  RETURN map->>name;
END;
$$ LANGUAGE plpgsql;

-- check $ (.)
CREATE OR REPLACE FUNCTION json_model_1(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  pfun TEXT;
  prop TEXT;
  pval JSONB;
BEGIN
  -- JSON Model for Lazy Git
  -- .
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF json_model_1_map(prop) IS NOT NULL THEN
      -- handle 13 may props
      pfun := json_model_1_map(prop);
      IF NOT jm_call(pfun, pval, NULL, rep) THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION check_model_map(name TEXT)
RETURNS TEXT STRICT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  map JSONB := JSONB '{"":"json_model_1","color":"json_model_2","colorArray":"json_model_3","keybinding":"json_model_4","custom-commands-prompts-type-property":"json_model_5","custom-commands-prompts-title-property":"json_model_6","custom-commands-prompts-key-property":"json_model_7","neString":"json_model_8","stringArray":"json_model_9","Prompts":"json_model_10"}';
BEGIN
  RETURN map->>name;
END;
$$ LANGUAGE plpgsql;

--
-- constant maps initialization
--
TRUNCATE jm_constant_maps;
INSERT INTO jm_constant_maps(mapname, tagval, value) VALUES
  ('_jm_map_0', JSONB '"input"', '_jm_obj_0'),
  ('_jm_map_0', JSONB '"confirm"', '_jm_obj_3'),
  ('_jm_map_0', JSONB '"menu"', '_jm_obj_4'),
  ('_jm_map_0', JSONB '"menuFromCommand"', '_jm_obj_6')
;

--
-- JSON Model checking entry point
--
-- TODO INOUT rep?
CREATE OR REPLACE FUNCTION check_model(val JSONB, name TEXT, rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  fun TEXT;
BEGIN
  fun := check_model_map(name);
  IF fun IS NULL THEN
    RAISE EXCEPTION 'model for % not found', name;
  END IF;
  RETURN jm_call(fun, val, NULL, rep);
END;
$$ LANGUAGE plpgsql;
