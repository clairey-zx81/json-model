--
-- Generated by JSON Model Compiler version 2
-- see https://github.com/clairey-zx81/json-model
--
-- JSON_MODEL_VERSION is 2
CREATE EXTENSION IF NOT EXISTS json_model;

CREATE OR REPLACE FUNCTION _jm_cst_0(value JSONB)
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  constants JSONB = JSONB '["6.1","7.1","7.2","all"]';
BEGIN
  RETURN constants @> value;
END;
$$ LANGUAGE plpgsql;

-- check $AIXPlatformModel (.'$AIXPlatformModel')
CREATE OR REPLACE FUNCTION json_model_2(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
  arr_0_idx INT8;
  arr_0_item JSONB;
BEGIN
  -- .'$AIXPlatformModel'
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = 'name' THEN
      -- handle may name property
      -- .'$AIXPlatformModel'.name
      res := JSONB_TYPEOF(pval) = 'string' AND JSON_VALUE(pval, '$' RETURNING TEXT) = 'AIX';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'versions' THEN
      -- handle may versions property
      -- .'$AIXPlatformModel'.versions
      res := JSONB_TYPEOF(pval) = 'array';
      IF res THEN
        FOR arr_0_idx IN 0 .. JSONB_ARRAY_LENGTH(pval) - 1 LOOP
          arr_0_item := pval -> arr_0_idx;
          -- .'$AIXPlatformModel'.versions.0
          res := JSONB_TYPEOF(arr_0_item) IN ('null', 'boolean', 'number', 'string') AND _jm_cst_0(arr_0_item);
          IF NOT res THEN
            EXIT;
          END IF;
        END LOOP;
      END IF;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check $AlpinePlatformModel (.'$AlpinePlatformModel')
CREATE OR REPLACE FUNCTION json_model_3(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
  arr_1_idx INT8;
  arr_1_item JSONB;
BEGIN
  -- .'$AlpinePlatformModel'
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = 'name' THEN
      -- handle may name property
      -- .'$AlpinePlatformModel'.name
      res := JSONB_TYPEOF(pval) = 'string' AND JSON_VALUE(pval, '$' RETURNING TEXT) = 'Alpine';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'versions' THEN
      -- handle may versions property
      -- .'$AlpinePlatformModel'.versions
      res := JSONB_TYPEOF(pval) = 'array';
      IF res THEN
        FOR arr_1_idx IN 0 .. JSONB_ARRAY_LENGTH(pval) - 1 LOOP
          arr_1_item := pval -> arr_1_idx;
          -- .'$AlpinePlatformModel'.versions.0
          res := JSONB_TYPEOF(arr_1_item) = 'string' AND JSON_VALUE(arr_1_item, '$' RETURNING TEXT) = 'all';
          IF NOT res THEN
            EXIT;
          END IF;
        END LOOP;
      END IF;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION _jm_cst_1(value JSONB)
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  constants JSONB = JSONB '["all","1","2","2023"]';
BEGIN
  RETURN constants @> value;
END;
$$ LANGUAGE plpgsql;

-- check $AmazonLinuxPlatformModel (.'$AmazonLinuxPlatformModel')
CREATE OR REPLACE FUNCTION json_model_4(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
  arr_2_idx INT8;
  arr_2_item JSONB;
BEGIN
  -- .'$AmazonLinuxPlatformModel'
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = 'name' THEN
      -- handle may name property
      -- .'$AmazonLinuxPlatformModel'.name
      res := JSONB_TYPEOF(pval) = 'string' AND JSON_VALUE(pval, '$' RETURNING TEXT) = 'Amazon Linux';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'versions' THEN
      -- handle may versions property
      -- .'$AmazonLinuxPlatformModel'.versions
      res := JSONB_TYPEOF(pval) = 'array';
      IF res THEN
        FOR arr_2_idx IN 0 .. JSONB_ARRAY_LENGTH(pval) - 1 LOOP
          arr_2_item := pval -> arr_2_idx;
          -- .'$AmazonLinuxPlatformModel'.versions.0
          res := JSONB_TYPEOF(arr_2_item) IN ('null', 'boolean', 'number', 'string') AND _jm_cst_1(arr_2_item);
          IF NOT res THEN
            EXIT;
          END IF;
        END LOOP;
      END IF;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION _jm_cst_2(value JSONB)
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  constants JSONB = JSONB '["2013.03","2013.09","2014.03","2014.09","2015.03","2015.09","2016.03","2016.09","2017.03","2017.09","2017.12","2018.03","Candidate","all"]';
BEGIN
  RETURN constants @> value;
END;
$$ LANGUAGE plpgsql;

-- check $AmazonPlatformModel (.'$AmazonPlatformModel')
CREATE OR REPLACE FUNCTION json_model_5(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
  arr_3_idx INT8;
  arr_3_item JSONB;
BEGIN
  -- .'$AmazonPlatformModel'
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = 'name' THEN
      -- handle may name property
      -- .'$AmazonPlatformModel'.name
      res := JSONB_TYPEOF(pval) = 'string' AND JSON_VALUE(pval, '$' RETURNING TEXT) = 'Amazon';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'versions' THEN
      -- handle may versions property
      -- .'$AmazonPlatformModel'.versions
      res := JSONB_TYPEOF(pval) = 'array';
      IF res THEN
        FOR arr_3_idx IN 0 .. JSONB_ARRAY_LENGTH(pval) - 1 LOOP
          arr_3_item := pval -> arr_3_idx;
          -- .'$AmazonPlatformModel'.versions.0
          res := JSONB_TYPEOF(arr_3_item) IN ('null', 'boolean', 'number', 'string') AND _jm_cst_2(arr_3_item);
          IF NOT res THEN
            EXIT;
          END IF;
        END LOOP;
      END IF;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check $ArchLinuxPlatformModel (.'$ArchLinuxPlatformModel')
CREATE OR REPLACE FUNCTION json_model_6(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
  arr_4_idx INT8;
  arr_4_item JSONB;
BEGIN
  -- .'$ArchLinuxPlatformModel'
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = 'name' THEN
      -- handle may name property
      -- .'$ArchLinuxPlatformModel'.name
      res := JSONB_TYPEOF(pval) = 'string' AND JSON_VALUE(pval, '$' RETURNING TEXT) = 'ArchLinux';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'versions' THEN
      -- handle may versions property
      -- .'$ArchLinuxPlatformModel'.versions
      res := JSONB_TYPEOF(pval) = 'array';
      IF res THEN
        FOR arr_4_idx IN 0 .. JSONB_ARRAY_LENGTH(pval) - 1 LOOP
          arr_4_item := pval -> arr_4_idx;
          -- .'$ArchLinuxPlatformModel'.versions.0
          res := JSONB_TYPEOF(arr_4_item) = 'string' AND JSON_VALUE(arr_4_item, '$' RETURNING TEXT) = 'all';
          IF NOT res THEN
            EXIT;
          END IF;
        END LOOP;
      END IF;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION _jm_cst_3(value JSONB)
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  constants JSONB = JSONB '["1.8","1.7","1.6","2.12","all"]';
BEGIN
  RETURN constants @> value;
END;
$$ LANGUAGE plpgsql;

-- check $AstraLinuxPlatformModel (.'$AstraLinuxPlatformModel')
CREATE OR REPLACE FUNCTION json_model_7(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
  arr_5_idx INT8;
  arr_5_item JSONB;
BEGIN
  -- .'$AstraLinuxPlatformModel'
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = 'name' THEN
      -- handle may name property
      -- .'$AstraLinuxPlatformModel'.name
      res := JSONB_TYPEOF(pval) = 'string' AND JSON_VALUE(pval, '$' RETURNING TEXT) = 'Astra Linux';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'versions' THEN
      -- handle may versions property
      -- .'$AstraLinuxPlatformModel'.versions
      res := JSONB_TYPEOF(pval) = 'array';
      IF res THEN
        FOR arr_5_idx IN 0 .. JSONB_ARRAY_LENGTH(pval) - 1 LOOP
          arr_5_item := pval -> arr_5_idx;
          -- .'$AstraLinuxPlatformModel'.versions.0
          res := JSONB_TYPEOF(arr_5_item) IN ('null', 'boolean', 'number', 'string') AND _jm_cst_3(arr_5_item);
          IF NOT res THEN
            EXIT;
          END IF;
        END LOOP;
      END IF;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check $ClearLinuxPlatformModel (.'$ClearLinuxPlatformModel')
CREATE OR REPLACE FUNCTION json_model_8(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
  arr_6_idx INT8;
  arr_6_item JSONB;
BEGIN
  -- .'$ClearLinuxPlatformModel'
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = 'name' THEN
      -- handle may name property
      -- .'$ClearLinuxPlatformModel'.name
      res := JSONB_TYPEOF(pval) = 'string' AND JSON_VALUE(pval, '$' RETURNING TEXT) = 'ClearLinux';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'versions' THEN
      -- handle may versions property
      -- .'$ClearLinuxPlatformModel'.versions
      res := JSONB_TYPEOF(pval) = 'array';
      IF res THEN
        FOR arr_6_idx IN 0 .. JSONB_ARRAY_LENGTH(pval) - 1 LOOP
          arr_6_item := pval -> arr_6_idx;
          -- .'$ClearLinuxPlatformModel'.versions.0
          res := JSONB_TYPEOF(arr_6_item) = 'string' AND JSON_VALUE(arr_6_item, '$' RETURNING TEXT) = 'all';
          IF NOT res THEN
            EXIT;
          END IF;
        END LOOP;
      END IF;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION _jm_cst_4(value JSONB)
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  constants JSONB = JSONB '["2.5","3.0","3.1","3.2","3.3","3.4","3.5","all"]';
BEGIN
  RETURN constants @> value;
END;
$$ LANGUAGE plpgsql;

-- check $CumulusPlatformModel (.'$CumulusPlatformModel')
CREATE OR REPLACE FUNCTION json_model_9(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
  arr_7_idx INT8;
  arr_7_item JSONB;
BEGIN
  -- .'$CumulusPlatformModel'
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = 'name' THEN
      -- handle may name property
      -- .'$CumulusPlatformModel'.name
      res := JSONB_TYPEOF(pval) = 'string' AND JSON_VALUE(pval, '$' RETURNING TEXT) = 'Cumulus';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'versions' THEN
      -- handle may versions property
      -- .'$CumulusPlatformModel'.versions
      res := JSONB_TYPEOF(pval) = 'array';
      IF res THEN
        FOR arr_7_idx IN 0 .. JSONB_ARRAY_LENGTH(pval) - 1 LOOP
          arr_7_item := pval -> arr_7_idx;
          -- .'$CumulusPlatformModel'.versions.0
          res := JSONB_TYPEOF(arr_7_item) IN ('null', 'boolean', 'number', 'string') AND _jm_cst_4(arr_7_item);
          IF NOT res THEN
            EXIT;
          END IF;
        END LOOP;
      END IF;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION _jm_cst_5(value JSONB)
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  constants JSONB = JSONB '["bookworm","bullseye","buster","etch","jessie","lenny","sid","squeeze","stretch","trixie","wheezy","all"]';
BEGIN
  RETURN constants @> value;
END;
$$ LANGUAGE plpgsql;

-- check $DebianPlatformModel (.'$DebianPlatformModel')
CREATE OR REPLACE FUNCTION json_model_10(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
  arr_8_idx INT8;
  arr_8_item JSONB;
BEGIN
  -- .'$DebianPlatformModel'
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = 'name' THEN
      -- handle may name property
      -- .'$DebianPlatformModel'.name
      res := JSONB_TYPEOF(pval) = 'string' AND JSON_VALUE(pval, '$' RETURNING TEXT) = 'Debian';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'versions' THEN
      -- handle may versions property
      -- .'$DebianPlatformModel'.versions
      res := JSONB_TYPEOF(pval) = 'array';
      IF res THEN
        FOR arr_8_idx IN 0 .. JSONB_ARRAY_LENGTH(pval) - 1 LOOP
          arr_8_item := pval -> arr_8_idx;
          -- .'$DebianPlatformModel'.versions.0
          res := JSONB_TYPEOF(arr_8_item) IN ('null', 'boolean', 'number', 'string') AND _jm_cst_5(arr_8_item);
          IF NOT res THEN
            EXIT;
          END IF;
        END LOOP;
      END IF;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION _jm_cst_6(value JSONB)
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  constants JSONB = JSONB '["10","6","9","all"]';
BEGIN
  RETURN constants @> value;
END;
$$ LANGUAGE plpgsql;

-- check $DellOSPlatformModel (.'$DellOSPlatformModel')
CREATE OR REPLACE FUNCTION json_model_11(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
  arr_9_idx INT8;
  arr_9_item JSONB;
BEGIN
  -- .'$DellOSPlatformModel'
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = 'name' THEN
      -- handle may name property
      -- .'$DellOSPlatformModel'.name
      res := JSONB_TYPEOF(pval) = 'string' AND JSON_VALUE(pval, '$' RETURNING TEXT) = 'DellOS';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'versions' THEN
      -- handle may versions property
      -- .'$DellOSPlatformModel'.versions
      res := JSONB_TYPEOF(pval) = 'array';
      IF res THEN
        FOR arr_9_idx IN 0 .. JSONB_ARRAY_LENGTH(pval) - 1 LOOP
          arr_9_item := pval -> arr_9_idx;
          -- .'$DellOSPlatformModel'.versions.0
          res := JSONB_TYPEOF(arr_9_item) IN ('null', 'boolean', 'number', 'string') AND _jm_cst_6(arr_9_item);
          IF NOT res THEN
            EXIT;
          END IF;
        END LOOP;
      END IF;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION _jm_cst_7(value JSONB)
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  constants JSONB = JSONB '["ascii","beowulf","chimaera","daedalus","jessie","all"]';
BEGIN
  RETURN constants @> value;
END;
$$ LANGUAGE plpgsql;

-- check $DevuanPlatformModel (.'$DevuanPlatformModel')
CREATE OR REPLACE FUNCTION json_model_12(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
  arr_10_idx INT8;
  arr_10_item JSONB;
BEGIN
  -- .'$DevuanPlatformModel'
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = 'name' THEN
      -- handle may name property
      -- .'$DevuanPlatformModel'.name
      res := JSONB_TYPEOF(pval) = 'string' AND JSON_VALUE(pval, '$' RETURNING TEXT) = 'Devuan';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'versions' THEN
      -- handle may versions property
      -- .'$DevuanPlatformModel'.versions
      res := JSONB_TYPEOF(pval) = 'array';
      IF res THEN
        FOR arr_10_idx IN 0 .. JSONB_ARRAY_LENGTH(pval) - 1 LOOP
          arr_10_item := pval -> arr_10_idx;
          -- .'$DevuanPlatformModel'.versions.0
          res := JSONB_TYPEOF(arr_10_item) IN ('null', 'boolean', 'number', 'string') AND _jm_cst_7(arr_10_item);
          IF NOT res THEN
            EXIT;
          END IF;
        END LOOP;
      END IF;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION _jm_cst_8(value JSONB)
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  constants JSONB = JSONB '["5.2","5.4","5.6","5.8","6.0","6.2","6.4","all"]';
BEGIN
  RETURN constants @> value;
END;
$$ LANGUAGE plpgsql;

-- check $DragonFlyBSDPlatformModel (.'$DragonFlyBSDPlatformModel')
CREATE OR REPLACE FUNCTION json_model_13(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
  arr_11_idx INT8;
  arr_11_item JSONB;
BEGIN
  -- .'$DragonFlyBSDPlatformModel'
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = 'name' THEN
      -- handle may name property
      -- .'$DragonFlyBSDPlatformModel'.name
      res := JSONB_TYPEOF(pval) = 'string' AND JSON_VALUE(pval, '$' RETURNING TEXT) = 'DragonFlyBSD';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'versions' THEN
      -- handle may versions property
      -- .'$DragonFlyBSDPlatformModel'.versions
      res := JSONB_TYPEOF(pval) = 'array';
      IF res THEN
        FOR arr_11_idx IN 0 .. JSONB_ARRAY_LENGTH(pval) - 1 LOOP
          arr_11_item := pval -> arr_11_idx;
          -- .'$DragonFlyBSDPlatformModel'.versions.0
          res := JSONB_TYPEOF(arr_11_item) IN ('null', 'boolean', 'number', 'string') AND _jm_cst_8(arr_11_item);
          IF NOT res THEN
            EXIT;
          END IF;
        END LOOP;
      END IF;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION _jm_cst_9(value JSONB)
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  constants JSONB = JSONB '["5","6","7","8","9","10","all"]';
BEGIN
  RETURN constants @> value;
END;
$$ LANGUAGE plpgsql;

-- check $ELPlatformModel (.'$ELPlatformModel')
CREATE OR REPLACE FUNCTION json_model_14(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
  arr_12_idx INT8;
  arr_12_item JSONB;
BEGIN
  -- .'$ELPlatformModel'
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = 'name' THEN
      -- handle may name property
      -- .'$ELPlatformModel'.name
      res := JSONB_TYPEOF(pval) = 'string' AND JSON_VALUE(pval, '$' RETURNING TEXT) = 'EL';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'versions' THEN
      -- handle may versions property
      -- .'$ELPlatformModel'.versions
      res := JSONB_TYPEOF(pval) = 'array';
      IF res THEN
        FOR arr_12_idx IN 0 .. JSONB_ARRAY_LENGTH(pval) - 1 LOOP
          arr_12_item := pval -> arr_12_idx;
          -- .'$ELPlatformModel'.versions.0
          res := JSONB_TYPEOF(arr_12_item) IN ('null', 'boolean', 'number', 'string') AND _jm_cst_9(arr_12_item);
          IF NOT res THEN
            EXIT;
          END IF;
        END LOOP;
      END IF;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION _jm_cst_10(value JSONB)
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  constants JSONB = JSONB '["16","17","18","19","20","21","22","23","24","25","26","27","28","29","30","31","32","33","34","35","36","37","38","39","40","41","42","all"]';
BEGIN
  RETURN constants @> value;
END;
$$ LANGUAGE plpgsql;

-- check $FedoraPlatformModel (.'$FedoraPlatformModel')
CREATE OR REPLACE FUNCTION json_model_15(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
  arr_13_idx INT8;
  arr_13_item JSONB;
BEGIN
  -- .'$FedoraPlatformModel'
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = 'name' THEN
      -- handle may name property
      -- .'$FedoraPlatformModel'.name
      res := JSONB_TYPEOF(pval) = 'string' AND JSON_VALUE(pval, '$' RETURNING TEXT) = 'Fedora';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'versions' THEN
      -- handle may versions property
      -- .'$FedoraPlatformModel'.versions
      res := JSONB_TYPEOF(pval) = 'array';
      IF res THEN
        FOR arr_13_idx IN 0 .. JSONB_ARRAY_LENGTH(pval) - 1 LOOP
          arr_13_item := pval -> arr_13_idx;
          -- .'$FedoraPlatformModel'.versions.0
          res := JSONB_TYPEOF(arr_13_item) IN ('null', 'boolean', 'number', 'string') AND _jm_cst_10(arr_13_item);
          IF NOT res THEN
            EXIT;
          END IF;
        END LOOP;
      END IF;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION _jm_cst_11(value JSONB)
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  constants JSONB = JSONB '["8.0","8.1","8.2","8.3","8.4","9.0","9.1","9.2","9.3","10.0","10.1","10.2","10.3","10.4","11.0","11.1","11.2","11.3","11.4","12.0","12.1","12.2","13.0","13.1","13.2","14.0","all"]';
BEGIN
  RETURN constants @> value;
END;
$$ LANGUAGE plpgsql;

-- check $FreeBSDPlatformModel (.'$FreeBSDPlatformModel')
CREATE OR REPLACE FUNCTION json_model_16(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
  arr_14_idx INT8;
  arr_14_item JSONB;
BEGIN
  -- .'$FreeBSDPlatformModel'
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = 'name' THEN
      -- handle may name property
      -- .'$FreeBSDPlatformModel'.name
      res := JSONB_TYPEOF(pval) = 'string' AND JSON_VALUE(pval, '$' RETURNING TEXT) = 'FreeBSD';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'versions' THEN
      -- handle may versions property
      -- .'$FreeBSDPlatformModel'.versions
      res := JSONB_TYPEOF(pval) = 'array';
      IF res THEN
        FOR arr_14_idx IN 0 .. JSONB_ARRAY_LENGTH(pval) - 1 LOOP
          arr_14_item := pval -> arr_14_idx;
          -- .'$FreeBSDPlatformModel'.versions.0
          res := JSONB_TYPEOF(arr_14_item) IN ('null', 'boolean', 'number', 'string') AND _jm_cst_11(arr_14_item);
          IF NOT res THEN
            EXIT;
          END IF;
        END LOOP;
      END IF;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check $GenericBSDPlatformModel (.'$GenericBSDPlatformModel')
CREATE OR REPLACE FUNCTION json_model_17(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
  arr_15_idx INT8;
  arr_15_item JSONB;
BEGIN
  -- .'$GenericBSDPlatformModel'
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = 'name' THEN
      -- handle may name property
      -- .'$GenericBSDPlatformModel'.name
      res := JSONB_TYPEOF(pval) = 'string' AND JSON_VALUE(pval, '$' RETURNING TEXT) = 'GenericBSD';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'versions' THEN
      -- handle may versions property
      -- .'$GenericBSDPlatformModel'.versions
      res := JSONB_TYPEOF(pval) = 'array';
      IF res THEN
        FOR arr_15_idx IN 0 .. JSONB_ARRAY_LENGTH(pval) - 1 LOOP
          arr_15_item := pval -> arr_15_idx;
          -- .'$GenericBSDPlatformModel'.versions.0
          res := JSONB_TYPEOF(arr_15_item) = 'string' AND JSON_VALUE(arr_15_item, '$' RETURNING TEXT) = 'all';
          IF NOT res THEN
            EXIT;
          END IF;
        END LOOP;
      END IF;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check $GenericLinuxPlatformModel (.'$GenericLinuxPlatformModel')
CREATE OR REPLACE FUNCTION json_model_18(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
  arr_16_idx INT8;
  arr_16_item JSONB;
BEGIN
  -- .'$GenericLinuxPlatformModel'
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = 'name' THEN
      -- handle may name property
      -- .'$GenericLinuxPlatformModel'.name
      res := JSONB_TYPEOF(pval) = 'string' AND JSON_VALUE(pval, '$' RETURNING TEXT) = 'GenericLinux';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'versions' THEN
      -- handle may versions property
      -- .'$GenericLinuxPlatformModel'.versions
      res := JSONB_TYPEOF(pval) = 'array';
      IF res THEN
        FOR arr_16_idx IN 0 .. JSONB_ARRAY_LENGTH(pval) - 1 LOOP
          arr_16_item := pval -> arr_16_idx;
          -- .'$GenericLinuxPlatformModel'.versions.0
          res := JSONB_TYPEOF(arr_16_item) = 'string' AND JSON_VALUE(arr_16_item, '$' RETURNING TEXT) = 'all';
          IF NOT res THEN
            EXIT;
          END IF;
        END LOOP;
      END IF;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check $GenericUNIXPlatformModel (.'$GenericUNIXPlatformModel')
CREATE OR REPLACE FUNCTION json_model_19(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
  arr_17_idx INT8;
  arr_17_item JSONB;
BEGIN
  -- .'$GenericUNIXPlatformModel'
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = 'name' THEN
      -- handle may name property
      -- .'$GenericUNIXPlatformModel'.name
      res := JSONB_TYPEOF(pval) = 'string' AND JSON_VALUE(pval, '$' RETURNING TEXT) = 'GenericUNIX';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'versions' THEN
      -- handle may versions property
      -- .'$GenericUNIXPlatformModel'.versions
      res := JSONB_TYPEOF(pval) = 'array';
      IF res THEN
        FOR arr_17_idx IN 0 .. JSONB_ARRAY_LENGTH(pval) - 1 LOOP
          arr_17_item := pval -> arr_17_idx;
          -- .'$GenericUNIXPlatformModel'.versions.0
          res := JSONB_TYPEOF(arr_17_item) = 'string' AND JSON_VALUE(arr_17_item, '$' RETURNING TEXT) = 'all';
          IF NOT res THEN
            EXIT;
          END IF;
        END LOOP;
      END IF;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check $GentooPlatformModel (.'$GentooPlatformModel')
CREATE OR REPLACE FUNCTION json_model_20(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
  arr_18_idx INT8;
  arr_18_item JSONB;
BEGIN
  -- .'$GentooPlatformModel'
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = 'name' THEN
      -- handle may name property
      -- .'$GentooPlatformModel'.name
      res := JSONB_TYPEOF(pval) = 'string' AND JSON_VALUE(pval, '$' RETURNING TEXT) = 'Gentoo';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'versions' THEN
      -- handle may versions property
      -- .'$GentooPlatformModel'.versions
      res := JSONB_TYPEOF(pval) = 'array';
      IF res THEN
        FOR arr_18_idx IN 0 .. JSONB_ARRAY_LENGTH(pval) - 1 LOOP
          arr_18_item := pval -> arr_18_idx;
          -- .'$GentooPlatformModel'.versions.0
          res := JSONB_TYPEOF(arr_18_item) = 'string' AND JSON_VALUE(arr_18_item, '$' RETURNING TEXT) = 'all';
          IF NOT res THEN
            EXIT;
          END IF;
        END LOOP;
      END IF;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION _jm_cst_12(value JSONB)
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  constants JSONB = JSONB '["10","11","all"]';
BEGIN
  RETURN constants @> value;
END;
$$ LANGUAGE plpgsql;

-- check $HardenedBSDPlatformModel (.'$HardenedBSDPlatformModel')
CREATE OR REPLACE FUNCTION json_model_21(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
  arr_19_idx INT8;
  arr_19_item JSONB;
BEGIN
  -- .'$HardenedBSDPlatformModel'
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = 'name' THEN
      -- handle may name property
      -- .'$HardenedBSDPlatformModel'.name
      res := JSONB_TYPEOF(pval) = 'string' AND JSON_VALUE(pval, '$' RETURNING TEXT) = 'HardenedBSD';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'versions' THEN
      -- handle may versions property
      -- .'$HardenedBSDPlatformModel'.versions
      res := JSONB_TYPEOF(pval) = 'array';
      IF res THEN
        FOR arr_19_idx IN 0 .. JSONB_ARRAY_LENGTH(pval) - 1 LOOP
          arr_19_item := pval -> arr_19_idx;
          -- .'$HardenedBSDPlatformModel'.versions.0
          res := JSONB_TYPEOF(arr_19_item) IN ('null', 'boolean', 'number', 'string') AND _jm_cst_12(arr_19_item);
          IF NOT res THEN
            EXIT;
          END IF;
        END LOOP;
      END IF;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check $IOSPlatformModel (.'$IOSPlatformModel')
CREATE OR REPLACE FUNCTION json_model_22(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
  arr_20_idx INT8;
  arr_20_item JSONB;
BEGIN
  -- .'$IOSPlatformModel'
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = 'name' THEN
      -- handle may name property
      -- .'$IOSPlatformModel'.name
      res := JSONB_TYPEOF(pval) = 'string' AND JSON_VALUE(pval, '$' RETURNING TEXT) = 'IOS';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'versions' THEN
      -- handle may versions property
      -- .'$IOSPlatformModel'.versions
      res := JSONB_TYPEOF(pval) = 'array';
      IF res THEN
        FOR arr_20_idx IN 0 .. JSONB_ARRAY_LENGTH(pval) - 1 LOOP
          arr_20_item := pval -> arr_20_idx;
          -- .'$IOSPlatformModel'.versions.0
          res := JSONB_TYPEOF(arr_20_item) = 'string' AND JSON_VALUE(arr_20_item, '$' RETURNING TEXT) = 'all';
          IF NOT res THEN
            EXIT;
          END IF;
        END LOOP;
      END IF;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check $JunosPlatformModel (.'$JunosPlatformModel')
CREATE OR REPLACE FUNCTION json_model_23(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
  arr_21_idx INT8;
  arr_21_item JSONB;
BEGIN
  -- .'$JunosPlatformModel'
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = 'name' THEN
      -- handle may name property
      -- .'$JunosPlatformModel'.name
      res := JSONB_TYPEOF(pval) = 'string' AND JSON_VALUE(pval, '$' RETURNING TEXT) = 'Junos';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'versions' THEN
      -- handle may versions property
      -- .'$JunosPlatformModel'.versions
      res := JSONB_TYPEOF(pval) = 'array';
      IF res THEN
        FOR arr_21_idx IN 0 .. JSONB_ARRAY_LENGTH(pval) - 1 LOOP
          arr_21_item := pval -> arr_21_idx;
          -- .'$JunosPlatformModel'.versions.0
          res := JSONB_TYPEOF(arr_21_item) = 'string' AND JSON_VALUE(arr_21_item, '$' RETURNING TEXT) = 'all';
          IF NOT res THEN
            EXIT;
          END IF;
        END LOOP;
      END IF;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION _jm_cst_13(value JSONB)
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  constants JSONB = JSONB '["2.0","2016","2017","2018","2019","2020","2021","2022","2023","all"]';
BEGIN
  RETURN constants @> value;
END;
$$ LANGUAGE plpgsql;

-- check $KaliPlatformModel (.'$KaliPlatformModel')
CREATE OR REPLACE FUNCTION json_model_24(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
  arr_22_idx INT8;
  arr_22_item JSONB;
BEGIN
  -- .'$KaliPlatformModel'
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = 'name' THEN
      -- handle may name property
      -- .'$KaliPlatformModel'.name
      res := JSONB_TYPEOF(pval) = 'string' AND JSON_VALUE(pval, '$' RETURNING TEXT) = 'Kali';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'versions' THEN
      -- handle may versions property
      -- .'$KaliPlatformModel'.versions
      res := JSONB_TYPEOF(pval) = 'array';
      IF res THEN
        FOR arr_22_idx IN 0 .. JSONB_ARRAY_LENGTH(pval) - 1 LOOP
          arr_22_item := pval -> arr_22_idx;
          -- .'$KaliPlatformModel'.versions.0
          res := JSONB_TYPEOF(arr_22_item) IN ('null', 'boolean', 'number', 'string') AND _jm_cst_13(arr_22_item);
          IF NOT res THEN
            EXIT;
          END IF;
        END LOOP;
      END IF;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION _jm_cst_14(value JSONB)
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  constants JSONB = JSONB '["10.7","10.8","10.9","10.10","10.11","10.12","10.13","10.14","10.15","all"]';
BEGIN
  RETURN constants @> value;
END;
$$ LANGUAGE plpgsql;

-- check $MacOSXPlatformModel (.'$MacOSXPlatformModel')
CREATE OR REPLACE FUNCTION json_model_25(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
  arr_23_idx INT8;
  arr_23_item JSONB;
BEGIN
  -- .'$MacOSXPlatformModel'
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = 'name' THEN
      -- handle may name property
      -- .'$MacOSXPlatformModel'.name
      res := JSONB_TYPEOF(pval) = 'string' AND JSON_VALUE(pval, '$' RETURNING TEXT) = 'Kali';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'versions' THEN
      -- handle may versions property
      -- .'$MacOSXPlatformModel'.versions
      res := JSONB_TYPEOF(pval) = 'array';
      IF res THEN
        FOR arr_23_idx IN 0 .. JSONB_ARRAY_LENGTH(pval) - 1 LOOP
          arr_23_item := pval -> arr_23_idx;
          -- .'$MacOSXPlatformModel'.versions.0
          res := JSONB_TYPEOF(arr_23_item) IN ('null', 'boolean', 'number', 'string') AND _jm_cst_14(arr_23_item);
          IF NOT res THEN
            EXIT;
          END IF;
        END LOOP;
      END IF;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION _jm_cst_15(value JSONB)
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  constants JSONB = JSONB '["7","8","all"]';
BEGIN
  RETURN constants @> value;
END;
$$ LANGUAGE plpgsql;

-- check $MageiaPlatformModel (.'$MageiaPlatformModel')
CREATE OR REPLACE FUNCTION json_model_26(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
  arr_24_idx INT8;
  arr_24_item JSONB;
BEGIN
  -- .'$MageiaPlatformModel'
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = 'name' THEN
      -- handle may name property
      -- .'$MageiaPlatformModel'.name
      res := JSONB_TYPEOF(pval) = 'string' AND JSON_VALUE(pval, '$' RETURNING TEXT) = 'Megeia';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'versions' THEN
      -- handle may versions property
      -- .'$MageiaPlatformModel'.versions
      res := JSONB_TYPEOF(pval) = 'array';
      IF res THEN
        FOR arr_24_idx IN 0 .. JSONB_ARRAY_LENGTH(pval) - 1 LOOP
          arr_24_item := pval -> arr_24_idx;
          -- .'$MageiaPlatformModel'.versions.0
          res := JSONB_TYPEOF(arr_24_item) IN ('null', 'boolean', 'number', 'string') AND _jm_cst_15(arr_24_item);
          IF NOT res THEN
            EXIT;
          END IF;
        END LOOP;
      END IF;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check $NXOSPlatformModel (.'$NXOSPlatformModel')
CREATE OR REPLACE FUNCTION json_model_27(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
  arr_25_idx INT8;
  arr_25_item JSONB;
BEGIN
  -- .'$NXOSPlatformModel'
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = 'name' THEN
      -- handle may name property
      -- .'$NXOSPlatformModel'.name
      res := JSONB_TYPEOF(pval) = 'string' AND JSON_VALUE(pval, '$' RETURNING TEXT) = 'NXOS';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'versions' THEN
      -- handle may versions property
      -- .'$NXOSPlatformModel'.versions
      res := JSONB_TYPEOF(pval) = 'array';
      IF res THEN
        FOR arr_25_idx IN 0 .. JSONB_ARRAY_LENGTH(pval) - 1 LOOP
          arr_25_item := pval -> arr_25_idx;
          -- .'$NXOSPlatformModel'.versions.0
          res := JSONB_TYPEOF(arr_25_item) = 'string' AND JSON_VALUE(arr_25_item, '$' RETURNING TEXT) = 'all';
          IF NOT res THEN
            EXIT;
          END IF;
        END LOOP;
      END IF;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION _jm_cst_16(value JSONB)
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  constants JSONB = JSONB '["8.0","8.1","8.2","9.0","9.1","9.2","9.3","10.0","all"]';
BEGIN
  RETURN constants @> value;
END;
$$ LANGUAGE plpgsql;

-- check $NetBSDPlatformModel (.'$NetBSDPlatformModel')
CREATE OR REPLACE FUNCTION json_model_28(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
  arr_26_idx INT8;
  arr_26_item JSONB;
BEGIN
  -- .'$NetBSDPlatformModel'
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = 'name' THEN
      -- handle may name property
      -- .'$NetBSDPlatformModel'.name
      res := JSONB_TYPEOF(pval) = 'string' AND JSON_VALUE(pval, '$' RETURNING TEXT) = 'NetBSD';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'versions' THEN
      -- handle may versions property
      -- .'$NetBSDPlatformModel'.versions
      res := JSONB_TYPEOF(pval) = 'array';
      IF res THEN
        FOR arr_26_idx IN 0 .. JSONB_ARRAY_LENGTH(pval) - 1 LOOP
          arr_26_item := pval -> arr_26_idx;
          -- .'$NetBSDPlatformModel'.versions.0
          res := JSONB_TYPEOF(arr_26_item) IN ('null', 'boolean', 'number', 'string') AND _jm_cst_16(arr_26_item);
          IF NOT res THEN
            EXIT;
          END IF;
        END LOOP;
      END IF;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION _jm_cst_17(value JSONB)
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  constants JSONB = JSONB '["5.6","5.7","5.8","5.9","6.0","6.1","6.2","6.3","6.4","6.5","6.6","6.7","6.8","6.9","7.0","7.1","7.2","7.3","all"]';
BEGIN
  RETURN constants @> value;
END;
$$ LANGUAGE plpgsql;

-- check $OpenBSDPlatformModel (.'$OpenBSDPlatformModel')
CREATE OR REPLACE FUNCTION json_model_29(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
  arr_27_idx INT8;
  arr_27_item JSONB;
BEGIN
  -- .'$OpenBSDPlatformModel'
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = 'name' THEN
      -- handle may name property
      -- .'$OpenBSDPlatformModel'.name
      res := JSONB_TYPEOF(pval) = 'string' AND JSON_VALUE(pval, '$' RETURNING TEXT) = 'OpenBSD';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'versions' THEN
      -- handle may versions property
      -- .'$OpenBSDPlatformModel'.versions
      res := JSONB_TYPEOF(pval) = 'array';
      IF res THEN
        FOR arr_27_idx IN 0 .. JSONB_ARRAY_LENGTH(pval) - 1 LOOP
          arr_27_item := pval -> arr_27_idx;
          -- .'$OpenBSDPlatformModel'.versions.0
          res := JSONB_TYPEOF(arr_27_item) IN ('null', 'boolean', 'number', 'string') AND _jm_cst_17(arr_27_item);
          IF NOT res THEN
            EXIT;
          END IF;
        END LOOP;
      END IF;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION _jm_cst_18(value JSONB)
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  constants JSONB = JSONB '["17.01","18.06","19.07","21.02","22.03","23.05","24.10","all"]';
BEGIN
  RETURN constants @> value;
END;
$$ LANGUAGE plpgsql;

-- check $OpenWrtPlatformModel (.'$OpenWrtPlatformModel')
CREATE OR REPLACE FUNCTION json_model_30(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
  arr_28_idx INT8;
  arr_28_item JSONB;
BEGIN
  -- .'$OpenWrtPlatformModel'
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = 'name' THEN
      -- handle may name property
      -- .'$OpenWrtPlatformModel'.name
      res := JSONB_TYPEOF(pval) = 'string' AND JSON_VALUE(pval, '$' RETURNING TEXT) = 'OpenWrt';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'versions' THEN
      -- handle may versions property
      -- .'$OpenWrtPlatformModel'.versions
      res := JSONB_TYPEOF(pval) = 'array';
      IF res THEN
        FOR arr_28_idx IN 0 .. JSONB_ARRAY_LENGTH(pval) - 1 LOOP
          arr_28_item := pval -> arr_28_idx;
          -- .'$OpenWrtPlatformModel'.versions.0
          res := JSONB_TYPEOF(arr_28_item) IN ('null', 'boolean', 'number', 'string') AND _jm_cst_18(arr_28_item);
          IF NOT res THEN
            EXIT;
          END IF;
        END LOOP;
      END IF;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION _jm_cst_19(value JSONB)
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  constants JSONB = JSONB '["7.0","7.1","7.2","7.3","7.4","7.5","7.6","7.7","7.8","7.9","8.0","8.1","8.2","8.3","8.4","8.5","8.6","8.7","8.8","8.9","8.10","9.0","9.1","9.2","9.3","9.4","all"]';
BEGIN
  RETURN constants @> value;
END;
$$ LANGUAGE plpgsql;

-- check $OracleLinuxPlatformModel (.'$OracleLinuxPlatformModel')
CREATE OR REPLACE FUNCTION json_model_31(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
  arr_29_idx INT8;
  arr_29_item JSONB;
BEGIN
  -- .'$OracleLinuxPlatformModel'
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = 'name' THEN
      -- handle may name property
      -- .'$OracleLinuxPlatformModel'.name
      res := JSONB_TYPEOF(pval) = 'string' AND JSON_VALUE(pval, '$' RETURNING TEXT) = 'OracleLinux';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'versions' THEN
      -- handle may versions property
      -- .'$OracleLinuxPlatformModel'.versions
      res := JSONB_TYPEOF(pval) = 'array';
      IF res THEN
        FOR arr_29_idx IN 0 .. JSONB_ARRAY_LENGTH(pval) - 1 LOOP
          arr_29_item := pval -> arr_29_idx;
          -- .'$OracleLinuxPlatformModel'.versions.0
          res := JSONB_TYPEOF(arr_29_item) IN ('null', 'boolean', 'number', 'string') AND _jm_cst_19(arr_29_item);
          IF NOT res THEN
            EXIT;
          END IF;
        END LOOP;
      END IF;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION _jm_cst_20(value JSONB)
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  constants JSONB = JSONB '["7.1","8.0","8.1","9.0","all"]';
BEGIN
  RETURN constants @> value;
END;
$$ LANGUAGE plpgsql;

-- check $PAN-OSPlatformModel (.'$PAN-OSPlatformModel')
CREATE OR REPLACE FUNCTION json_model_32(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
  arr_30_idx INT8;
  arr_30_item JSONB;
BEGIN
  -- .'$PAN-OSPlatformModel'
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = 'name' THEN
      -- handle may name property
      -- .'$PAN-OSPlatformModel'.name
      res := JSONB_TYPEOF(pval) = 'string' AND JSON_VALUE(pval, '$' RETURNING TEXT) = 'PAN-OS';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'versions' THEN
      -- handle may versions property
      -- .'$PAN-OSPlatformModel'.versions
      res := JSONB_TYPEOF(pval) = 'array';
      IF res THEN
        FOR arr_30_idx IN 0 .. JSONB_ARRAY_LENGTH(pval) - 1 LOOP
          arr_30_item := pval -> arr_30_idx;
          -- .'$PAN-OSPlatformModel'.versions.0
          res := JSONB_TYPEOF(arr_30_item) IN ('null', 'boolean', 'number', 'string') AND _jm_cst_20(arr_30_item);
          IF NOT res THEN
            EXIT;
          END IF;
        END LOOP;
      END IF;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION _jm_cst_21(value JSONB)
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  constants JSONB = JSONB '["8.0","8.1","8.2","8.3","8.4","8.5","8.6","8.7","8.8","9.0","9.1","9.2","all"]';
BEGIN
  RETURN constants @> value;
END;
$$ LANGUAGE plpgsql;

-- check $RockyLinuxPlatformModel (.'$RockyLinuxPlatformModel')
CREATE OR REPLACE FUNCTION json_model_33(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
  arr_31_idx INT8;
  arr_31_item JSONB;
BEGIN
  -- .'$RockyLinuxPlatformModel'
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = 'name' THEN
      -- handle may name property
      -- .'$RockyLinuxPlatformModel'.name
      res := JSONB_TYPEOF(pval) = 'string' AND JSON_VALUE(pval, '$' RETURNING TEXT) = 'Rocky';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'versions' THEN
      -- handle may versions property
      -- .'$RockyLinuxPlatformModel'.versions
      res := JSONB_TYPEOF(pval) = 'array';
      IF res THEN
        FOR arr_31_idx IN 0 .. JSONB_ARRAY_LENGTH(pval) - 1 LOOP
          arr_31_item := pval -> arr_31_idx;
          -- .'$RockyLinuxPlatformModel'.versions.0
          res := JSONB_TYPEOF(arr_31_item) IN ('null', 'boolean', 'number', 'string') AND _jm_cst_21(arr_31_item);
          IF NOT res THEN
            EXIT;
          END IF;
        END LOOP;
      END IF;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION _jm_cst_22(value JSONB)
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  constants JSONB = JSONB '["10SP3","10SP4","11","11SP1","11SP2","11SP3","11SP4","12","12SP1","12SP2","12SP3","12SP4","12SP5","15","15SP1","15SP2","15SP3","15SP4","15SP5","15SP6","all"]';
BEGIN
  RETURN constants @> value;
END;
$$ LANGUAGE plpgsql;

-- check $SLESPlatformModel (.'$SLESPlatformModel')
CREATE OR REPLACE FUNCTION json_model_34(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
  arr_32_idx INT8;
  arr_32_item JSONB;
BEGIN
  -- .'$SLESPlatformModel'
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = 'name' THEN
      -- handle may name property
      -- .'$SLESPlatformModel'.name
      res := JSONB_TYPEOF(pval) = 'string' AND JSON_VALUE(pval, '$' RETURNING TEXT) = 'SLES';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'versions' THEN
      -- handle may versions property
      -- .'$SLESPlatformModel'.versions
      res := JSONB_TYPEOF(pval) = 'array';
      IF res THEN
        FOR arr_32_idx IN 0 .. JSONB_ARRAY_LENGTH(pval) - 1 LOOP
          arr_32_item := pval -> arr_32_idx;
          -- .'$SLESPlatformModel'.versions.0
          res := JSONB_TYPEOF(arr_32_item) IN ('null', 'boolean', 'number', 'string') AND _jm_cst_22(arr_32_item);
          IF NOT res THEN
            EXIT;
          END IF;
        END LOOP;
      END IF;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check $SmartOSPlatformModel (.'$SmartOSPlatformModel')
CREATE OR REPLACE FUNCTION json_model_35(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
  arr_33_idx INT8;
  arr_33_item JSONB;
BEGIN
  -- .'$SmartOSPlatformModel'
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = 'name' THEN
      -- handle may name property
      -- .'$SmartOSPlatformModel'.name
      res := JSONB_TYPEOF(pval) = 'string' AND JSON_VALUE(pval, '$' RETURNING TEXT) = 'SmartOS';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'versions' THEN
      -- handle may versions property
      -- .'$SmartOSPlatformModel'.versions
      res := JSONB_TYPEOF(pval) = 'array';
      IF res THEN
        FOR arr_33_idx IN 0 .. JSONB_ARRAY_LENGTH(pval) - 1 LOOP
          arr_33_item := pval -> arr_33_idx;
          -- .'$SmartOSPlatformModel'.versions.0
          res := JSONB_TYPEOF(arr_33_item) = 'string' AND JSON_VALUE(arr_33_item, '$' RETURNING TEXT) = 'all';
          IF NOT res THEN
            EXIT;
          END IF;
        END LOOP;
      END IF;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION _jm_cst_23(value JSONB)
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  constants JSONB = JSONB '["10","11.0","11.1","11.2","11.3","11.4","all"]';
BEGIN
  RETURN constants @> value;
END;
$$ LANGUAGE plpgsql;

-- check $SolarisPlatformModel (.'$SolarisPlatformModel')
CREATE OR REPLACE FUNCTION json_model_36(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
  arr_34_idx INT8;
  arr_34_item JSONB;
BEGIN
  -- .'$SolarisPlatformModel'
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = 'name' THEN
      -- handle may name property
      -- .'$SolarisPlatformModel'.name
      res := JSONB_TYPEOF(pval) = 'string' AND JSON_VALUE(pval, '$' RETURNING TEXT) = 'Solaris';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'versions' THEN
      -- handle may versions property
      -- .'$SolarisPlatformModel'.versions
      res := JSONB_TYPEOF(pval) = 'array';
      IF res THEN
        FOR arr_34_idx IN 0 .. JSONB_ARRAY_LENGTH(pval) - 1 LOOP
          arr_34_item := pval -> arr_34_idx;
          -- .'$SolarisPlatformModel'.versions.0
          res := JSONB_TYPEOF(arr_34_item) IN ('null', 'boolean', 'number', 'string') AND _jm_cst_23(arr_34_item);
          IF NOT res THEN
            EXIT;
          END IF;
        END LOOP;
      END IF;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION _jm_cst_24(value JSONB)
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  constants JSONB = JSONB '["6.0","6.1","6.2","7.0","all"]';
BEGIN
  RETURN constants @> value;
END;
$$ LANGUAGE plpgsql;

-- check $SynologyPlatformModel (.'$SynologyPlatformModel')
CREATE OR REPLACE FUNCTION json_model_37(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
  arr_35_idx INT8;
  arr_35_item JSONB;
BEGIN
  -- .'$SynologyPlatformModel'
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = 'name' THEN
      -- handle may name property
      -- .'$SynologyPlatformModel'.name
      res := JSONB_TYPEOF(pval) = 'string' AND JSON_VALUE(pval, '$' RETURNING TEXT) = 'Synology';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'versions' THEN
      -- handle may versions property
      -- .'$SynologyPlatformModel'.versions
      res := JSONB_TYPEOF(pval) = 'array';
      IF res THEN
        FOR arr_35_idx IN 0 .. JSONB_ARRAY_LENGTH(pval) - 1 LOOP
          arr_35_item := pval -> arr_35_idx;
          -- .'$SynologyPlatformModel'.versions.0
          res := JSONB_TYPEOF(arr_35_item) IN ('null', 'boolean', 'number', 'string') AND _jm_cst_24(arr_35_item);
          IF NOT res THEN
            EXIT;
          END IF;
        END LOOP;
      END IF;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION _jm_cst_25(value JSONB)
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  constants JSONB = JSONB '["12.1","13.0","13.1","14.0","all"]';
BEGIN
  RETURN constants @> value;
END;
$$ LANGUAGE plpgsql;

-- check $TMOSPlatformModel (.'$TMOSPlatformModel')
CREATE OR REPLACE FUNCTION json_model_38(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
  arr_36_idx INT8;
  arr_36_item JSONB;
BEGIN
  -- .'$TMOSPlatformModel'
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = 'name' THEN
      -- handle may name property
      -- .'$TMOSPlatformModel'.name
      res := JSONB_TYPEOF(pval) = 'string' AND JSON_VALUE(pval, '$' RETURNING TEXT) = 'TMOS';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'versions' THEN
      -- handle may versions property
      -- .'$TMOSPlatformModel'.versions
      res := JSONB_TYPEOF(pval) = 'array';
      IF res THEN
        FOR arr_36_idx IN 0 .. JSONB_ARRAY_LENGTH(pval) - 1 LOOP
          arr_36_item := pval -> arr_36_idx;
          -- .'$TMOSPlatformModel'.versions.0
          res := JSONB_TYPEOF(arr_36_item) IN ('null', 'boolean', 'number', 'string') AND _jm_cst_25(arr_36_item);
          IF NOT res THEN
            EXIT;
          END IF;
        END LOOP;
      END IF;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION _jm_cst_26(value JSONB)
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  constants JSONB = JSONB '["artful","bionic","cosmic","disco","eoan","focal","groovy","hirsute","impish","jammy","kinetic","lucid","lunar","mantic","noble","maverick","natty","oneiric","oracular","plucky","precise","quantal","raring","saucy","trusty","utopic","vivid","wily","xenial","yakkety","zesty","all"]';
BEGIN
  RETURN constants @> value;
END;
$$ LANGUAGE plpgsql;

-- check $UbuntuPlatformModel (.'$UbuntuPlatformModel')
CREATE OR REPLACE FUNCTION json_model_39(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
  arr_37_idx INT8;
  arr_37_item JSONB;
BEGIN
  -- .'$UbuntuPlatformModel'
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = 'name' THEN
      -- handle may name property
      -- .'$UbuntuPlatformModel'.name
      res := JSONB_TYPEOF(pval) = 'string' AND JSON_VALUE(pval, '$' RETURNING TEXT) = 'Ubuntu';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'versions' THEN
      -- handle may versions property
      -- .'$UbuntuPlatformModel'.versions
      res := JSONB_TYPEOF(pval) = 'array';
      IF res THEN
        FOR arr_37_idx IN 0 .. JSONB_ARRAY_LENGTH(pval) - 1 LOOP
          arr_37_item := pval -> arr_37_idx;
          -- .'$UbuntuPlatformModel'.versions.0
          res := JSONB_TYPEOF(arr_37_item) IN ('null', 'boolean', 'number', 'string') AND _jm_cst_26(arr_37_item);
          IF NOT res THEN
            EXIT;
          END IF;
        END LOOP;
      END IF;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check $Void_LinuxPlatformModel (.'$Void_LinuxPlatformModel')
CREATE OR REPLACE FUNCTION json_model_40(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
  arr_38_idx INT8;
  arr_38_item JSONB;
BEGIN
  -- .'$Void_LinuxPlatformModel'
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = 'name' THEN
      -- handle may name property
      -- .'$Void_LinuxPlatformModel'.name
      res := JSONB_TYPEOF(pval) = 'string' AND JSON_VALUE(pval, '$' RETURNING TEXT) = 'Void Linux';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'versions' THEN
      -- handle may versions property
      -- .'$Void_LinuxPlatformModel'.versions
      res := JSONB_TYPEOF(pval) = 'array';
      IF res THEN
        FOR arr_38_idx IN 0 .. JSONB_ARRAY_LENGTH(pval) - 1 LOOP
          arr_38_item := pval -> arr_38_idx;
          -- .'$Void_LinuxPlatformModel'.versions.0
          res := JSONB_TYPEOF(arr_38_item) = 'string' AND JSON_VALUE(arr_38_item, '$' RETURNING TEXT) = 'all';
          IF NOT res THEN
            EXIT;
          END IF;
        END LOOP;
      END IF;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION _jm_cst_27(value JSONB)
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  constants JSONB = JSONB '["2008R2","2008x64","2008x86","2012","2012R2","2016","2019","2022","2025","all"]';
BEGIN
  RETURN constants @> value;
END;
$$ LANGUAGE plpgsql;

-- check $WindowsPlatformModel (.'$WindowsPlatformModel')
CREATE OR REPLACE FUNCTION json_model_41(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
  arr_39_idx INT8;
  arr_39_item JSONB;
BEGIN
  -- .'$WindowsPlatformModel'
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = 'name' THEN
      -- handle may name property
      -- .'$WindowsPlatformModel'.name
      res := JSONB_TYPEOF(pval) = 'string' AND JSON_VALUE(pval, '$' RETURNING TEXT) = 'Windows';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'versions' THEN
      -- handle may versions property
      -- .'$WindowsPlatformModel'.versions
      res := JSONB_TYPEOF(pval) = 'array';
      IF res THEN
        FOR arr_39_idx IN 0 .. JSONB_ARRAY_LENGTH(pval) - 1 LOOP
          arr_39_item := pval -> arr_39_idx;
          -- .'$WindowsPlatformModel'.versions.0
          res := JSONB_TYPEOF(arr_39_item) IN ('null', 'boolean', 'number', 'string') AND _jm_cst_27(arr_39_item);
          IF NOT res THEN
            EXIT;
          END IF;
        END LOOP;
      END IF;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check $aosPlatformModel (.'$aosPlatformModel')
CREATE OR REPLACE FUNCTION json_model_42(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
  arr_40_idx INT8;
  arr_40_item JSONB;
BEGIN
  -- .'$aosPlatformModel'
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = 'name' THEN
      -- handle may name property
      -- .'$aosPlatformModel'.name
      res := JSONB_TYPEOF(pval) = 'string' AND JSON_VALUE(pval, '$' RETURNING TEXT) = 'aos';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'versions' THEN
      -- handle may versions property
      -- .'$aosPlatformModel'.versions
      res := JSONB_TYPEOF(pval) = 'array';
      IF res THEN
        FOR arr_40_idx IN 0 .. JSONB_ARRAY_LENGTH(pval) - 1 LOOP
          arr_40_item := pval -> arr_40_idx;
          -- .'$aosPlatformModel'.versions.0
          res := JSONB_TYPEOF(arr_40_item) = 'string' AND JSON_VALUE(arr_40_item, '$' RETURNING TEXT) = 'all';
          IF NOT res THEN
            EXIT;
          END IF;
        END LOOP;
      END IF;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check $eosPlatformModel (.'$eosPlatformModel')
CREATE OR REPLACE FUNCTION json_model_43(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
  arr_41_idx INT8;
  arr_41_item JSONB;
BEGIN
  -- .'$eosPlatformModel'
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = 'name' THEN
      -- handle may name property
      -- .'$eosPlatformModel'.name
      res := JSONB_TYPEOF(pval) = 'string' AND JSON_VALUE(pval, '$' RETURNING TEXT) = 'eos';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'versions' THEN
      -- handle may versions property
      -- .'$eosPlatformModel'.versions
      res := JSONB_TYPEOF(pval) = 'array';
      IF res THEN
        FOR arr_41_idx IN 0 .. JSONB_ARRAY_LENGTH(pval) - 1 LOOP
          arr_41_item := pval -> arr_41_idx;
          -- .'$eosPlatformModel'.versions.0
          res := JSONB_TYPEOF(arr_41_item) = 'string' AND JSON_VALUE(arr_41_item, '$' RETURNING TEXT) = 'all';
          IF NOT res THEN
            EXIT;
          END IF;
        END LOOP;
      END IF;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION _jm_cst_28(value JSONB)
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  constants JSONB = JSONB '["Big-Sur","Catalina","High-Sierra","Mojave","Monterey","Sierra","Sonoma","Ventura","all"]';
BEGIN
  RETURN constants @> value;
END;
$$ LANGUAGE plpgsql;

-- check $macOSPlatformModel (.'$macOSPlatformModel')
CREATE OR REPLACE FUNCTION json_model_44(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
  arr_42_idx INT8;
  arr_42_item JSONB;
BEGIN
  -- .'$macOSPlatformModel'
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = 'name' THEN
      -- handle may name property
      -- .'$macOSPlatformModel'.name
      res := JSONB_TYPEOF(pval) = 'string' AND JSON_VALUE(pval, '$' RETURNING TEXT) = 'macOS';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'versions' THEN
      -- handle may versions property
      -- .'$macOSPlatformModel'.versions
      res := JSONB_TYPEOF(pval) = 'array';
      IF res THEN
        FOR arr_42_idx IN 0 .. JSONB_ARRAY_LENGTH(pval) - 1 LOOP
          arr_42_item := pval -> arr_42_idx;
          -- .'$macOSPlatformModel'.versions.0
          res := JSONB_TYPEOF(arr_42_item) IN ('null', 'boolean', 'number', 'string') AND _jm_cst_28(arr_42_item);
          IF NOT res THEN
            EXIT;
          END IF;
        END LOOP;
      END IF;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION _jm_cst_29(value JSONB)
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  constants JSONB = JSONB '["12.1","12.2","12.3","13.1","13.2","15.0","15.1","15.2","15.3","15.4","15.5","42.1","42.2","42.3","all"]';
BEGIN
  RETURN constants @> value;
END;
$$ LANGUAGE plpgsql;

-- check $opensusePlatformModel (.'$opensusePlatformModel')
CREATE OR REPLACE FUNCTION json_model_45(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
  arr_43_idx INT8;
  arr_43_item JSONB;
BEGIN
  -- .'$opensusePlatformModel'
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = 'name' THEN
      -- handle may name property
      -- .'$opensusePlatformModel'.name
      res := JSONB_TYPEOF(pval) = 'string' AND JSON_VALUE(pval, '$' RETURNING TEXT) = 'opensuse';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'versions' THEN
      -- handle may versions property
      -- .'$opensusePlatformModel'.versions
      res := JSONB_TYPEOF(pval) = 'array';
      IF res THEN
        FOR arr_43_idx IN 0 .. JSONB_ARRAY_LENGTH(pval) - 1 LOOP
          arr_43_item := pval -> arr_43_idx;
          -- .'$opensusePlatformModel'.versions.0
          res := JSONB_TYPEOF(arr_43_item) IN ('null', 'boolean', 'number', 'string') AND _jm_cst_29(arr_43_item);
          IF NOT res THEN
            EXIT;
          END IF;
        END LOOP;
      END IF;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check $os10PlatformModel (.'$os10PlatformModel')
CREATE OR REPLACE FUNCTION json_model_46(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
  arr_44_idx INT8;
  arr_44_item JSONB;
BEGIN
  -- .'$os10PlatformModel'
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = 'name' THEN
      -- handle may name property
      -- .'$os10PlatformModel'.name
      res := JSONB_TYPEOF(pval) = 'string' AND JSON_VALUE(pval, '$' RETURNING TEXT) = 'os10';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'versions' THEN
      -- handle may versions property
      -- .'$os10PlatformModel'.versions
      res := JSONB_TYPEOF(pval) = 'array';
      IF res THEN
        FOR arr_44_idx IN 0 .. JSONB_ARRAY_LENGTH(pval) - 1 LOOP
          arr_44_item := pval -> arr_44_idx;
          -- .'$os10PlatformModel'.versions.0
          res := JSONB_TYPEOF(arr_44_item) = 'string' AND JSON_VALUE(arr_44_item, '$' RETURNING TEXT) = 'all';
          IF NOT res THEN
            EXIT;
          END IF;
        END LOOP;
      END IF;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION _jm_cst_30(value JSONB)
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  constants JSONB = JSONB '["5.5","6.0","6.5","6.7","7.0","8.0","all"]';
BEGIN
  RETURN constants @> value;
END;
$$ LANGUAGE plpgsql;

-- check $vCenterPlatformModel (.'$vCenterPlatformModel')
CREATE OR REPLACE FUNCTION json_model_47(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
  arr_45_idx INT8;
  arr_45_item JSONB;
BEGIN
  -- .'$vCenterPlatformModel'
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = 'name' THEN
      -- handle may name property
      -- .'$vCenterPlatformModel'.name
      res := JSONB_TYPEOF(pval) = 'string' AND JSON_VALUE(pval, '$' RETURNING TEXT) = 'vCenter';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'versions' THEN
      -- handle may versions property
      -- .'$vCenterPlatformModel'.versions
      res := JSONB_TYPEOF(pval) = 'array';
      IF res THEN
        FOR arr_45_idx IN 0 .. JSONB_ARRAY_LENGTH(pval) - 1 LOOP
          arr_45_item := pval -> arr_45_idx;
          -- .'$vCenterPlatformModel'.versions.0
          res := JSONB_TYPEOF(arr_45_item) IN ('null', 'boolean', 'number', 'string') AND _jm_cst_30(arr_45_item);
          IF NOT res THEN
            EXIT;
          END IF;
        END LOOP;
      END IF;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION _jm_cst_31(value JSONB)
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  constants JSONB = JSONB '["5.5","6.0","6.5","6.7","7.0","8.0","all"]';
BEGIN
  RETURN constants @> value;
END;
$$ LANGUAGE plpgsql;

-- check $vSpherePlatformModel (.'$vSpherePlatformModel')
CREATE OR REPLACE FUNCTION json_model_48(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
  arr_46_idx INT8;
  arr_46_item JSONB;
BEGIN
  -- .'$vSpherePlatformModel'
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = 'name' THEN
      -- handle may name property
      -- .'$vSpherePlatformModel'.name
      res := JSONB_TYPEOF(pval) = 'string' AND JSON_VALUE(pval, '$' RETURNING TEXT) = 'vSphere';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'versions' THEN
      -- handle may versions property
      -- .'$vSpherePlatformModel'.versions
      res := JSONB_TYPEOF(pval) = 'array';
      IF res THEN
        FOR arr_46_idx IN 0 .. JSONB_ARRAY_LENGTH(pval) - 1 LOOP
          arr_46_item := pval -> arr_46_idx;
          -- .'$vSpherePlatformModel'.versions.0
          res := JSONB_TYPEOF(arr_46_item) IN ('null', 'boolean', 'number', 'string') AND _jm_cst_31(arr_46_item);
          IF NOT res THEN
            EXIT;
          END IF;
        END LOOP;
      END IF;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check $any_platform (.'$any_platform')
CREATE OR REPLACE FUNCTION json_model_49(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- FIXME: name is not mandatory, not sure it makes much sense… versions should be unique?
  -- .'$any_platform'
  -- .'$any_platform'.'|'.0
  res := json_model_2(val, path, rep);
  IF NOT res THEN
    -- .'$any_platform'.'|'.1
    res := json_model_3(val, path, rep);
    IF NOT res THEN
      -- .'$any_platform'.'|'.2
      res := json_model_5(val, path, rep);
      IF NOT res THEN
        -- .'$any_platform'.'|'.3
        res := json_model_4(val, path, rep);
        IF NOT res THEN
          -- .'$any_platform'.'|'.4
          res := json_model_42(val, path, rep);
          IF NOT res THEN
            -- .'$any_platform'.'|'.5
            res := json_model_6(val, path, rep);
            IF NOT res THEN
              -- .'$any_platform'.'|'.6
              res := json_model_7(val, path, rep);
              IF NOT res THEN
                -- .'$any_platform'.'|'.7
                res := json_model_8(val, path, rep);
                IF NOT res THEN
                  -- .'$any_platform'.'|'.8
                  res := json_model_9(val, path, rep);
                  IF NOT res THEN
                    -- .'$any_platform'.'|'.9
                    res := json_model_28(val, path, rep);
                    IF NOT res THEN
                      -- .'$any_platform'.'|'.10
                      res := json_model_10(val, path, rep);
                      IF NOT res THEN
                        -- .'$any_platform'.'|'.11
                        res := json_model_11(val, path, rep);
                        IF NOT res THEN
                          -- .'$any_platform'.'|'.12
                          res := json_model_12(val, path, rep);
                          IF NOT res THEN
                            -- .'$any_platform'.'|'.13
                            res := json_model_13(val, path, rep);
                            IF NOT res THEN
                              -- .'$any_platform'.'|'.14
                              res := json_model_14(val, path, rep);
                              IF NOT res THEN
                                -- .'$any_platform'.'|'.15
                                res := json_model_43(val, path, rep);
                                IF NOT res THEN
                                  -- .'$any_platform'.'|'.16
                                  res := json_model_15(val, path, rep);
                                  IF NOT res THEN
                                    -- .'$any_platform'.'|'.17
                                    res := json_model_16(val, path, rep);
                                    IF NOT res THEN
                                      -- .'$any_platform'.'|'.18
                                      res := json_model_17(val, path, rep);
                                      IF NOT res THEN
                                        -- .'$any_platform'.'|'.19
                                        res := json_model_18(val, path, rep);
                                        IF NOT res THEN
                                          -- .'$any_platform'.'|'.20
                                          res := json_model_19(val, path, rep);
                                          IF NOT res THEN
                                            -- .'$any_platform'.'|'.21
                                            res := json_model_20(val, path, rep);
                                            IF NOT res THEN
                                              -- .'$any_platform'.'|'.22
                                              res := json_model_21(val, path, rep);
                                              IF NOT res THEN
                                                -- .'$any_platform'.'|'.23
                                                res := json_model_22(val, path, rep);
                                                IF NOT res THEN
                                                  -- .'$any_platform'.'|'.24
                                                  res := json_model_23(val, path, rep);
                                                  IF NOT res THEN
                                                    -- .'$any_platform'.'|'.25
                                                    res := json_model_24(val, path, rep);
                                                    IF NOT res THEN
                                                      -- .'$any_platform'.'|'.26
                                                      res := json_model_44(val, path, rep);
                                                      IF NOT res THEN
                                                        -- .'$any_platform'.'|'.27
                                                        res := json_model_25(val, path, rep);
                                                        IF NOT res THEN
                                                          -- .'$any_platform'.'|'.28
                                                          res := json_model_26(val, path, rep);
                                                          IF NOT res THEN
                                                            -- .'$any_platform'.'|'.29
                                                            res := json_model_27(val, path, rep);
                                                            IF NOT res THEN
                                                              -- .'$any_platform'.'|'.30
                                                              res := json_model_29(val, path, rep);
                                                              IF NOT res THEN
                                                                -- .'$any_platform'.'|'.31
                                                                res := json_model_45(val, path, rep);
                                                                IF NOT res THEN
                                                                  -- .'$any_platform'.'|'.32
                                                                  res := json_model_30(val, path, rep);
                                                                  IF NOT res THEN
                                                                    -- .'$any_platform'.'|'.33
                                                                    res := json_model_31(val, path, rep);
                                                                    IF NOT res THEN
                                                                      -- .'$any_platform'.'|'.34
                                                                      res := json_model_46(val, path, rep);
                                                                      IF NOT res THEN
                                                                        -- .'$any_platform'.'|'.35
                                                                        res := json_model_32(val, path, rep);
                                                                        IF NOT res THEN
                                                                          -- .'$any_platform'.'|'.36
                                                                          res := json_model_33(val, path, rep);
                                                                          IF NOT res THEN
                                                                            -- .'$any_platform'.'|'.37
                                                                            res := json_model_34(val, path, rep);
                                                                            IF NOT res THEN
                                                                              -- .'$any_platform'.'|'.38
                                                                              res := json_model_35(val, path, rep);
                                                                              IF NOT res THEN
                                                                                -- .'$any_platform'.'|'.39
                                                                                res := json_model_36(val, path, rep);
                                                                                IF NOT res THEN
                                                                                  -- .'$any_platform'.'|'.40
                                                                                  res := json_model_37(val, path, rep);
                                                                                  IF NOT res THEN
                                                                                    -- .'$any_platform'.'|'.41
                                                                                    res := json_model_38(val, path, rep);
                                                                                    IF NOT res THEN
                                                                                      -- .'$any_platform'.'|'.42
                                                                                      res := json_model_39(val, path, rep);
                                                                                      IF NOT res THEN
                                                                                        -- .'$any_platform'.'|'.43
                                                                                        res := json_model_47(val, path, rep);
                                                                                        IF NOT res THEN
                                                                                          -- .'$any_platform'.'|'.44
                                                                                          res := json_model_40(val, path, rep);
                                                                                          IF NOT res THEN
                                                                                            -- .'$any_platform'.'|'.45
                                                                                            res := json_model_48(val, path, rep);
                                                                                            IF NOT res THEN
                                                                                              -- .'$any_platform'.'|'.46
                                                                                              res := json_model_41(val, path, rep);
                                                                                            END IF;
                                                                                          END IF;
                                                                                        END IF;
                                                                                      END IF;
                                                                                    END IF;
                                                                                  END IF;
                                                                                END IF;
                                                                              END IF;
                                                                            END IF;
                                                                          END IF;
                                                                        END IF;
                                                                      END IF;
                                                                    END IF;
                                                                  END IF;
                                                                END IF;
                                                              END IF;
                                                            END IF;
                                                          END IF;
                                                        END IF;
                                                      END IF;
                                                    END IF;
                                                  END IF;
                                                END IF;
                                              END IF;
                                            END IF;
                                          END IF;
                                        END IF;
                                      END IF;
                                    END IF;
                                  END IF;
                                END IF;
                              END IF;
                            END IF;
                          END IF;
                        END IF;
                      END IF;
                    END IF;
                  END IF;
                END IF;
              END IF;
            END IF;
          END IF;
        END IF;
      END IF;
    END IF;
  END IF;
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION _jm_cst_32(value JSONB)
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  constants JSONB = JSONB '["2008R2","2008x64","2008x86","2012","2012R2","2016","2019","2022","2025","all"]';
BEGIN
  RETURN constants @> value;
END;
$$ LANGUAGE plpgsql;

-- object .'$platforms'.0.'|'.46
CREATE OR REPLACE FUNCTION _jm_obj_0(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  pval JSONB;
  res bool;
  arr_48_idx INT8;
  arr_48_item JSONB;
BEGIN
  -- check open must/may only props
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  IF val ? 'name' THEN
    pval := val -> 'name';
    -- .'$platforms'.0.'|'.46.name
    res := JSONB_TYPEOF(pval) = 'string' AND JSON_VALUE(pval, '$' RETURNING TEXT) = 'Windows';
    IF NOT res THEN
      RETURN FALSE;
    END IF;
  END IF;
  IF val ? 'versions' THEN
    pval := val -> 'versions';
    -- .'$platforms'.0.'|'.46.versions
    res := JSONB_TYPEOF(pval) = 'array';
    IF res THEN
      FOR arr_48_idx IN 0 .. JSONB_ARRAY_LENGTH(pval) - 1 LOOP
        arr_48_item := pval -> arr_48_idx;
        -- .'$platforms'.0.'|'.46.versions.0
        res := JSONB_TYPEOF(arr_48_item) IN ('null', 'boolean', 'number', 'string') AND _jm_cst_32(arr_48_item);
        IF NOT res THEN
          EXIT;
        END IF;
      END LOOP;
    END IF;
    IF NOT res THEN
      RETURN FALSE;
    END IF;
  END IF;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION _jm_cst_33(value JSONB)
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  constants JSONB = JSONB '["5.5","6.0","6.5","6.7","7.0","8.0","all"]';
BEGIN
  RETURN constants @> value;
END;
$$ LANGUAGE plpgsql;

-- object .'$platforms'.0.'|'.45
CREATE OR REPLACE FUNCTION _jm_obj_1(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  pval JSONB;
  res bool;
  arr_49_idx INT8;
  arr_49_item JSONB;
BEGIN
  -- check open must/may only props
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  IF val ? 'name' THEN
    pval := val -> 'name';
    -- .'$platforms'.0.'|'.45.name
    res := JSONB_TYPEOF(pval) = 'string' AND JSON_VALUE(pval, '$' RETURNING TEXT) = 'vSphere';
    IF NOT res THEN
      RETURN FALSE;
    END IF;
  END IF;
  IF val ? 'versions' THEN
    pval := val -> 'versions';
    -- .'$platforms'.0.'|'.45.versions
    res := JSONB_TYPEOF(pval) = 'array';
    IF res THEN
      FOR arr_49_idx IN 0 .. JSONB_ARRAY_LENGTH(pval) - 1 LOOP
        arr_49_item := pval -> arr_49_idx;
        -- .'$platforms'.0.'|'.45.versions.0
        res := JSONB_TYPEOF(arr_49_item) IN ('null', 'boolean', 'number', 'string') AND _jm_cst_33(arr_49_item);
        IF NOT res THEN
          EXIT;
        END IF;
      END LOOP;
    END IF;
    IF NOT res THEN
      RETURN FALSE;
    END IF;
  END IF;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- object .'$platforms'.0.'|'.44
CREATE OR REPLACE FUNCTION _jm_obj_2(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  pval JSONB;
  res bool;
  arr_50_idx INT8;
  arr_50_item JSONB;
BEGIN
  -- check open must/may only props
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  IF val ? 'name' THEN
    pval := val -> 'name';
    -- .'$platforms'.0.'|'.44.name
    res := JSONB_TYPEOF(pval) = 'string' AND JSON_VALUE(pval, '$' RETURNING TEXT) = 'Void Linux';
    IF NOT res THEN
      RETURN FALSE;
    END IF;
  END IF;
  IF val ? 'versions' THEN
    pval := val -> 'versions';
    -- .'$platforms'.0.'|'.44.versions
    res := JSONB_TYPEOF(pval) = 'array';
    IF res THEN
      FOR arr_50_idx IN 0 .. JSONB_ARRAY_LENGTH(pval) - 1 LOOP
        arr_50_item := pval -> arr_50_idx;
        -- .'$platforms'.0.'|'.44.versions.0
        res := JSONB_TYPEOF(arr_50_item) = 'string' AND JSON_VALUE(arr_50_item, '$' RETURNING TEXT) = 'all';
        IF NOT res THEN
          EXIT;
        END IF;
      END LOOP;
    END IF;
    IF NOT res THEN
      RETURN FALSE;
    END IF;
  END IF;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION _jm_cst_34(value JSONB)
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  constants JSONB = JSONB '["5.5","6.0","6.5","6.7","7.0","8.0","all"]';
BEGIN
  RETURN constants @> value;
END;
$$ LANGUAGE plpgsql;

-- object .'$platforms'.0.'|'.43
CREATE OR REPLACE FUNCTION _jm_obj_3(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  pval JSONB;
  res bool;
  arr_51_idx INT8;
  arr_51_item JSONB;
BEGIN
  -- check open must/may only props
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  IF val ? 'name' THEN
    pval := val -> 'name';
    -- .'$platforms'.0.'|'.43.name
    res := JSONB_TYPEOF(pval) = 'string' AND JSON_VALUE(pval, '$' RETURNING TEXT) = 'vCenter';
    IF NOT res THEN
      RETURN FALSE;
    END IF;
  END IF;
  IF val ? 'versions' THEN
    pval := val -> 'versions';
    -- .'$platforms'.0.'|'.43.versions
    res := JSONB_TYPEOF(pval) = 'array';
    IF res THEN
      FOR arr_51_idx IN 0 .. JSONB_ARRAY_LENGTH(pval) - 1 LOOP
        arr_51_item := pval -> arr_51_idx;
        -- .'$platforms'.0.'|'.43.versions.0
        res := JSONB_TYPEOF(arr_51_item) IN ('null', 'boolean', 'number', 'string') AND _jm_cst_34(arr_51_item);
        IF NOT res THEN
          EXIT;
        END IF;
      END LOOP;
    END IF;
    IF NOT res THEN
      RETURN FALSE;
    END IF;
  END IF;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION _jm_cst_35(value JSONB)
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  constants JSONB = JSONB '["artful","bionic","cosmic","disco","eoan","focal","groovy","hirsute","impish","jammy","kinetic","lucid","lunar","mantic","noble","maverick","natty","oneiric","oracular","plucky","precise","quantal","raring","saucy","trusty","utopic","vivid","wily","xenial","yakkety","zesty","all"]';
BEGIN
  RETURN constants @> value;
END;
$$ LANGUAGE plpgsql;

-- object .'$platforms'.0.'|'.42
CREATE OR REPLACE FUNCTION _jm_obj_4(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  pval JSONB;
  res bool;
  arr_52_idx INT8;
  arr_52_item JSONB;
BEGIN
  -- check open must/may only props
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  IF val ? 'name' THEN
    pval := val -> 'name';
    -- .'$platforms'.0.'|'.42.name
    res := JSONB_TYPEOF(pval) = 'string' AND JSON_VALUE(pval, '$' RETURNING TEXT) = 'Ubuntu';
    IF NOT res THEN
      RETURN FALSE;
    END IF;
  END IF;
  IF val ? 'versions' THEN
    pval := val -> 'versions';
    -- .'$platforms'.0.'|'.42.versions
    res := JSONB_TYPEOF(pval) = 'array';
    IF res THEN
      FOR arr_52_idx IN 0 .. JSONB_ARRAY_LENGTH(pval) - 1 LOOP
        arr_52_item := pval -> arr_52_idx;
        -- .'$platforms'.0.'|'.42.versions.0
        res := JSONB_TYPEOF(arr_52_item) IN ('null', 'boolean', 'number', 'string') AND _jm_cst_35(arr_52_item);
        IF NOT res THEN
          EXIT;
        END IF;
      END LOOP;
    END IF;
    IF NOT res THEN
      RETURN FALSE;
    END IF;
  END IF;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION _jm_cst_36(value JSONB)
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  constants JSONB = JSONB '["12.1","13.0","13.1","14.0","all"]';
BEGIN
  RETURN constants @> value;
END;
$$ LANGUAGE plpgsql;

-- object .'$platforms'.0.'|'.41
CREATE OR REPLACE FUNCTION _jm_obj_5(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  pval JSONB;
  res bool;
  arr_53_idx INT8;
  arr_53_item JSONB;
BEGIN
  -- check open must/may only props
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  IF val ? 'name' THEN
    pval := val -> 'name';
    -- .'$platforms'.0.'|'.41.name
    res := JSONB_TYPEOF(pval) = 'string' AND JSON_VALUE(pval, '$' RETURNING TEXT) = 'TMOS';
    IF NOT res THEN
      RETURN FALSE;
    END IF;
  END IF;
  IF val ? 'versions' THEN
    pval := val -> 'versions';
    -- .'$platforms'.0.'|'.41.versions
    res := JSONB_TYPEOF(pval) = 'array';
    IF res THEN
      FOR arr_53_idx IN 0 .. JSONB_ARRAY_LENGTH(pval) - 1 LOOP
        arr_53_item := pval -> arr_53_idx;
        -- .'$platforms'.0.'|'.41.versions.0
        res := JSONB_TYPEOF(arr_53_item) IN ('null', 'boolean', 'number', 'string') AND _jm_cst_36(arr_53_item);
        IF NOT res THEN
          EXIT;
        END IF;
      END LOOP;
    END IF;
    IF NOT res THEN
      RETURN FALSE;
    END IF;
  END IF;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION _jm_cst_37(value JSONB)
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  constants JSONB = JSONB '["6.0","6.1","6.2","7.0","all"]';
BEGIN
  RETURN constants @> value;
END;
$$ LANGUAGE plpgsql;

-- object .'$platforms'.0.'|'.40
CREATE OR REPLACE FUNCTION _jm_obj_6(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  pval JSONB;
  res bool;
  arr_54_idx INT8;
  arr_54_item JSONB;
BEGIN
  -- check open must/may only props
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  IF val ? 'name' THEN
    pval := val -> 'name';
    -- .'$platforms'.0.'|'.40.name
    res := JSONB_TYPEOF(pval) = 'string' AND JSON_VALUE(pval, '$' RETURNING TEXT) = 'Synology';
    IF NOT res THEN
      RETURN FALSE;
    END IF;
  END IF;
  IF val ? 'versions' THEN
    pval := val -> 'versions';
    -- .'$platforms'.0.'|'.40.versions
    res := JSONB_TYPEOF(pval) = 'array';
    IF res THEN
      FOR arr_54_idx IN 0 .. JSONB_ARRAY_LENGTH(pval) - 1 LOOP
        arr_54_item := pval -> arr_54_idx;
        -- .'$platforms'.0.'|'.40.versions.0
        res := JSONB_TYPEOF(arr_54_item) IN ('null', 'boolean', 'number', 'string') AND _jm_cst_37(arr_54_item);
        IF NOT res THEN
          EXIT;
        END IF;
      END LOOP;
    END IF;
    IF NOT res THEN
      RETURN FALSE;
    END IF;
  END IF;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION _jm_cst_38(value JSONB)
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  constants JSONB = JSONB '["10","11.0","11.1","11.2","11.3","11.4","all"]';
BEGIN
  RETURN constants @> value;
END;
$$ LANGUAGE plpgsql;

-- object .'$platforms'.0.'|'.39
CREATE OR REPLACE FUNCTION _jm_obj_7(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  pval JSONB;
  res bool;
  arr_55_idx INT8;
  arr_55_item JSONB;
BEGIN
  -- check open must/may only props
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  IF val ? 'name' THEN
    pval := val -> 'name';
    -- .'$platforms'.0.'|'.39.name
    res := JSONB_TYPEOF(pval) = 'string' AND JSON_VALUE(pval, '$' RETURNING TEXT) = 'Solaris';
    IF NOT res THEN
      RETURN FALSE;
    END IF;
  END IF;
  IF val ? 'versions' THEN
    pval := val -> 'versions';
    -- .'$platforms'.0.'|'.39.versions
    res := JSONB_TYPEOF(pval) = 'array';
    IF res THEN
      FOR arr_55_idx IN 0 .. JSONB_ARRAY_LENGTH(pval) - 1 LOOP
        arr_55_item := pval -> arr_55_idx;
        -- .'$platforms'.0.'|'.39.versions.0
        res := JSONB_TYPEOF(arr_55_item) IN ('null', 'boolean', 'number', 'string') AND _jm_cst_38(arr_55_item);
        IF NOT res THEN
          EXIT;
        END IF;
      END LOOP;
    END IF;
    IF NOT res THEN
      RETURN FALSE;
    END IF;
  END IF;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- object .'$platforms'.0.'|'.38
CREATE OR REPLACE FUNCTION _jm_obj_8(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  pval JSONB;
  res bool;
  arr_56_idx INT8;
  arr_56_item JSONB;
BEGIN
  -- check open must/may only props
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  IF val ? 'name' THEN
    pval := val -> 'name';
    -- .'$platforms'.0.'|'.38.name
    res := JSONB_TYPEOF(pval) = 'string' AND JSON_VALUE(pval, '$' RETURNING TEXT) = 'SmartOS';
    IF NOT res THEN
      RETURN FALSE;
    END IF;
  END IF;
  IF val ? 'versions' THEN
    pval := val -> 'versions';
    -- .'$platforms'.0.'|'.38.versions
    res := JSONB_TYPEOF(pval) = 'array';
    IF res THEN
      FOR arr_56_idx IN 0 .. JSONB_ARRAY_LENGTH(pval) - 1 LOOP
        arr_56_item := pval -> arr_56_idx;
        -- .'$platforms'.0.'|'.38.versions.0
        res := JSONB_TYPEOF(arr_56_item) = 'string' AND JSON_VALUE(arr_56_item, '$' RETURNING TEXT) = 'all';
        IF NOT res THEN
          EXIT;
        END IF;
      END LOOP;
    END IF;
    IF NOT res THEN
      RETURN FALSE;
    END IF;
  END IF;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION _jm_cst_39(value JSONB)
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  constants JSONB = JSONB '["10SP3","10SP4","11","11SP1","11SP2","11SP3","11SP4","12","12SP1","12SP2","12SP3","12SP4","12SP5","15","15SP1","15SP2","15SP3","15SP4","15SP5","15SP6","all"]';
BEGIN
  RETURN constants @> value;
END;
$$ LANGUAGE plpgsql;

-- object .'$platforms'.0.'|'.37
CREATE OR REPLACE FUNCTION _jm_obj_9(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  pval JSONB;
  res bool;
  arr_57_idx INT8;
  arr_57_item JSONB;
BEGIN
  -- check open must/may only props
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  IF val ? 'name' THEN
    pval := val -> 'name';
    -- .'$platforms'.0.'|'.37.name
    res := JSONB_TYPEOF(pval) = 'string' AND JSON_VALUE(pval, '$' RETURNING TEXT) = 'SLES';
    IF NOT res THEN
      RETURN FALSE;
    END IF;
  END IF;
  IF val ? 'versions' THEN
    pval := val -> 'versions';
    -- .'$platforms'.0.'|'.37.versions
    res := JSONB_TYPEOF(pval) = 'array';
    IF res THEN
      FOR arr_57_idx IN 0 .. JSONB_ARRAY_LENGTH(pval) - 1 LOOP
        arr_57_item := pval -> arr_57_idx;
        -- .'$platforms'.0.'|'.37.versions.0
        res := JSONB_TYPEOF(arr_57_item) IN ('null', 'boolean', 'number', 'string') AND _jm_cst_39(arr_57_item);
        IF NOT res THEN
          EXIT;
        END IF;
      END LOOP;
    END IF;
    IF NOT res THEN
      RETURN FALSE;
    END IF;
  END IF;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION _jm_cst_40(value JSONB)
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  constants JSONB = JSONB '["8.0","8.1","8.2","8.3","8.4","8.5","8.6","8.7","8.8","9.0","9.1","9.2","all"]';
BEGIN
  RETURN constants @> value;
END;
$$ LANGUAGE plpgsql;

-- object .'$platforms'.0.'|'.36
CREATE OR REPLACE FUNCTION _jm_obj_10(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  pval JSONB;
  res bool;
  arr_58_idx INT8;
  arr_58_item JSONB;
BEGIN
  -- check open must/may only props
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  IF val ? 'name' THEN
    pval := val -> 'name';
    -- .'$platforms'.0.'|'.36.name
    res := JSONB_TYPEOF(pval) = 'string' AND JSON_VALUE(pval, '$' RETURNING TEXT) = 'Rocky';
    IF NOT res THEN
      RETURN FALSE;
    END IF;
  END IF;
  IF val ? 'versions' THEN
    pval := val -> 'versions';
    -- .'$platforms'.0.'|'.36.versions
    res := JSONB_TYPEOF(pval) = 'array';
    IF res THEN
      FOR arr_58_idx IN 0 .. JSONB_ARRAY_LENGTH(pval) - 1 LOOP
        arr_58_item := pval -> arr_58_idx;
        -- .'$platforms'.0.'|'.36.versions.0
        res := JSONB_TYPEOF(arr_58_item) IN ('null', 'boolean', 'number', 'string') AND _jm_cst_40(arr_58_item);
        IF NOT res THEN
          EXIT;
        END IF;
      END LOOP;
    END IF;
    IF NOT res THEN
      RETURN FALSE;
    END IF;
  END IF;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION _jm_cst_41(value JSONB)
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  constants JSONB = JSONB '["7.1","8.0","8.1","9.0","all"]';
BEGIN
  RETURN constants @> value;
END;
$$ LANGUAGE plpgsql;

-- object .'$platforms'.0.'|'.35
CREATE OR REPLACE FUNCTION _jm_obj_11(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  pval JSONB;
  res bool;
  arr_59_idx INT8;
  arr_59_item JSONB;
BEGIN
  -- check open must/may only props
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  IF val ? 'name' THEN
    pval := val -> 'name';
    -- .'$platforms'.0.'|'.35.name
    res := JSONB_TYPEOF(pval) = 'string' AND JSON_VALUE(pval, '$' RETURNING TEXT) = 'PAN-OS';
    IF NOT res THEN
      RETURN FALSE;
    END IF;
  END IF;
  IF val ? 'versions' THEN
    pval := val -> 'versions';
    -- .'$platforms'.0.'|'.35.versions
    res := JSONB_TYPEOF(pval) = 'array';
    IF res THEN
      FOR arr_59_idx IN 0 .. JSONB_ARRAY_LENGTH(pval) - 1 LOOP
        arr_59_item := pval -> arr_59_idx;
        -- .'$platforms'.0.'|'.35.versions.0
        res := JSONB_TYPEOF(arr_59_item) IN ('null', 'boolean', 'number', 'string') AND _jm_cst_41(arr_59_item);
        IF NOT res THEN
          EXIT;
        END IF;
      END LOOP;
    END IF;
    IF NOT res THEN
      RETURN FALSE;
    END IF;
  END IF;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- object .'$platforms'.0.'|'.34
CREATE OR REPLACE FUNCTION _jm_obj_12(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  pval JSONB;
  res bool;
  arr_60_idx INT8;
  arr_60_item JSONB;
BEGIN
  -- check open must/may only props
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  IF val ? 'name' THEN
    pval := val -> 'name';
    -- .'$platforms'.0.'|'.34.name
    res := JSONB_TYPEOF(pval) = 'string' AND JSON_VALUE(pval, '$' RETURNING TEXT) = 'os10';
    IF NOT res THEN
      RETURN FALSE;
    END IF;
  END IF;
  IF val ? 'versions' THEN
    pval := val -> 'versions';
    -- .'$platforms'.0.'|'.34.versions
    res := JSONB_TYPEOF(pval) = 'array';
    IF res THEN
      FOR arr_60_idx IN 0 .. JSONB_ARRAY_LENGTH(pval) - 1 LOOP
        arr_60_item := pval -> arr_60_idx;
        -- .'$platforms'.0.'|'.34.versions.0
        res := JSONB_TYPEOF(arr_60_item) = 'string' AND JSON_VALUE(arr_60_item, '$' RETURNING TEXT) = 'all';
        IF NOT res THEN
          EXIT;
        END IF;
      END LOOP;
    END IF;
    IF NOT res THEN
      RETURN FALSE;
    END IF;
  END IF;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION _jm_cst_42(value JSONB)
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  constants JSONB = JSONB '["7.0","7.1","7.2","7.3","7.4","7.5","7.6","7.7","7.8","7.9","8.0","8.1","8.2","8.3","8.4","8.5","8.6","8.7","8.8","8.9","8.10","9.0","9.1","9.2","9.3","9.4","all"]';
BEGIN
  RETURN constants @> value;
END;
$$ LANGUAGE plpgsql;

-- object .'$platforms'.0.'|'.33
CREATE OR REPLACE FUNCTION _jm_obj_13(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  pval JSONB;
  res bool;
  arr_61_idx INT8;
  arr_61_item JSONB;
BEGIN
  -- check open must/may only props
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  IF val ? 'name' THEN
    pval := val -> 'name';
    -- .'$platforms'.0.'|'.33.name
    res := JSONB_TYPEOF(pval) = 'string' AND JSON_VALUE(pval, '$' RETURNING TEXT) = 'OracleLinux';
    IF NOT res THEN
      RETURN FALSE;
    END IF;
  END IF;
  IF val ? 'versions' THEN
    pval := val -> 'versions';
    -- .'$platforms'.0.'|'.33.versions
    res := JSONB_TYPEOF(pval) = 'array';
    IF res THEN
      FOR arr_61_idx IN 0 .. JSONB_ARRAY_LENGTH(pval) - 1 LOOP
        arr_61_item := pval -> arr_61_idx;
        -- .'$platforms'.0.'|'.33.versions.0
        res := JSONB_TYPEOF(arr_61_item) IN ('null', 'boolean', 'number', 'string') AND _jm_cst_42(arr_61_item);
        IF NOT res THEN
          EXIT;
        END IF;
      END LOOP;
    END IF;
    IF NOT res THEN
      RETURN FALSE;
    END IF;
  END IF;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION _jm_cst_43(value JSONB)
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  constants JSONB = JSONB '["17.01","18.06","19.07","21.02","22.03","23.05","24.10","all"]';
BEGIN
  RETURN constants @> value;
END;
$$ LANGUAGE plpgsql;

-- object .'$platforms'.0.'|'.32
CREATE OR REPLACE FUNCTION _jm_obj_14(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  pval JSONB;
  res bool;
  arr_62_idx INT8;
  arr_62_item JSONB;
BEGIN
  -- check open must/may only props
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  IF val ? 'name' THEN
    pval := val -> 'name';
    -- .'$platforms'.0.'|'.32.name
    res := JSONB_TYPEOF(pval) = 'string' AND JSON_VALUE(pval, '$' RETURNING TEXT) = 'OpenWrt';
    IF NOT res THEN
      RETURN FALSE;
    END IF;
  END IF;
  IF val ? 'versions' THEN
    pval := val -> 'versions';
    -- .'$platforms'.0.'|'.32.versions
    res := JSONB_TYPEOF(pval) = 'array';
    IF res THEN
      FOR arr_62_idx IN 0 .. JSONB_ARRAY_LENGTH(pval) - 1 LOOP
        arr_62_item := pval -> arr_62_idx;
        -- .'$platforms'.0.'|'.32.versions.0
        res := JSONB_TYPEOF(arr_62_item) IN ('null', 'boolean', 'number', 'string') AND _jm_cst_43(arr_62_item);
        IF NOT res THEN
          EXIT;
        END IF;
      END LOOP;
    END IF;
    IF NOT res THEN
      RETURN FALSE;
    END IF;
  END IF;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION _jm_cst_44(value JSONB)
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  constants JSONB = JSONB '["12.1","12.2","12.3","13.1","13.2","15.0","15.1","15.2","15.3","15.4","15.5","42.1","42.2","42.3","all"]';
BEGIN
  RETURN constants @> value;
END;
$$ LANGUAGE plpgsql;

-- object .'$platforms'.0.'|'.31
CREATE OR REPLACE FUNCTION _jm_obj_15(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  pval JSONB;
  res bool;
  arr_63_idx INT8;
  arr_63_item JSONB;
BEGIN
  -- check open must/may only props
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  IF val ? 'name' THEN
    pval := val -> 'name';
    -- .'$platforms'.0.'|'.31.name
    res := JSONB_TYPEOF(pval) = 'string' AND JSON_VALUE(pval, '$' RETURNING TEXT) = 'opensuse';
    IF NOT res THEN
      RETURN FALSE;
    END IF;
  END IF;
  IF val ? 'versions' THEN
    pval := val -> 'versions';
    -- .'$platforms'.0.'|'.31.versions
    res := JSONB_TYPEOF(pval) = 'array';
    IF res THEN
      FOR arr_63_idx IN 0 .. JSONB_ARRAY_LENGTH(pval) - 1 LOOP
        arr_63_item := pval -> arr_63_idx;
        -- .'$platforms'.0.'|'.31.versions.0
        res := JSONB_TYPEOF(arr_63_item) IN ('null', 'boolean', 'number', 'string') AND _jm_cst_44(arr_63_item);
        IF NOT res THEN
          EXIT;
        END IF;
      END LOOP;
    END IF;
    IF NOT res THEN
      RETURN FALSE;
    END IF;
  END IF;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION _jm_cst_45(value JSONB)
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  constants JSONB = JSONB '["5.6","5.7","5.8","5.9","6.0","6.1","6.2","6.3","6.4","6.5","6.6","6.7","6.8","6.9","7.0","7.1","7.2","7.3","all"]';
BEGIN
  RETURN constants @> value;
END;
$$ LANGUAGE plpgsql;

-- object .'$platforms'.0.'|'.30
CREATE OR REPLACE FUNCTION _jm_obj_16(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  pval JSONB;
  res bool;
  arr_64_idx INT8;
  arr_64_item JSONB;
BEGIN
  -- check open must/may only props
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  IF val ? 'name' THEN
    pval := val -> 'name';
    -- .'$platforms'.0.'|'.30.name
    res := JSONB_TYPEOF(pval) = 'string' AND JSON_VALUE(pval, '$' RETURNING TEXT) = 'OpenBSD';
    IF NOT res THEN
      RETURN FALSE;
    END IF;
  END IF;
  IF val ? 'versions' THEN
    pval := val -> 'versions';
    -- .'$platforms'.0.'|'.30.versions
    res := JSONB_TYPEOF(pval) = 'array';
    IF res THEN
      FOR arr_64_idx IN 0 .. JSONB_ARRAY_LENGTH(pval) - 1 LOOP
        arr_64_item := pval -> arr_64_idx;
        -- .'$platforms'.0.'|'.30.versions.0
        res := JSONB_TYPEOF(arr_64_item) IN ('null', 'boolean', 'number', 'string') AND _jm_cst_45(arr_64_item);
        IF NOT res THEN
          EXIT;
        END IF;
      END LOOP;
    END IF;
    IF NOT res THEN
      RETURN FALSE;
    END IF;
  END IF;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- object .'$platforms'.0.'|'.29
CREATE OR REPLACE FUNCTION _jm_obj_17(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  pval JSONB;
  res bool;
  arr_65_idx INT8;
  arr_65_item JSONB;
BEGIN
  -- check open must/may only props
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  IF val ? 'name' THEN
    pval := val -> 'name';
    -- .'$platforms'.0.'|'.29.name
    res := JSONB_TYPEOF(pval) = 'string' AND JSON_VALUE(pval, '$' RETURNING TEXT) = 'NXOS';
    IF NOT res THEN
      RETURN FALSE;
    END IF;
  END IF;
  IF val ? 'versions' THEN
    pval := val -> 'versions';
    -- .'$platforms'.0.'|'.29.versions
    res := JSONB_TYPEOF(pval) = 'array';
    IF res THEN
      FOR arr_65_idx IN 0 .. JSONB_ARRAY_LENGTH(pval) - 1 LOOP
        arr_65_item := pval -> arr_65_idx;
        -- .'$platforms'.0.'|'.29.versions.0
        res := JSONB_TYPEOF(arr_65_item) = 'string' AND JSON_VALUE(arr_65_item, '$' RETURNING TEXT) = 'all';
        IF NOT res THEN
          EXIT;
        END IF;
      END LOOP;
    END IF;
    IF NOT res THEN
      RETURN FALSE;
    END IF;
  END IF;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION _jm_cst_46(value JSONB)
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  constants JSONB = JSONB '["7","8","all"]';
BEGIN
  RETURN constants @> value;
END;
$$ LANGUAGE plpgsql;

-- object .'$platforms'.0.'|'.28
CREATE OR REPLACE FUNCTION _jm_obj_18(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  pval JSONB;
  res bool;
  arr_66_idx INT8;
  arr_66_item JSONB;
BEGIN
  -- check open must/may only props
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  IF val ? 'name' THEN
    pval := val -> 'name';
    -- .'$platforms'.0.'|'.28.name
    res := JSONB_TYPEOF(pval) = 'string' AND JSON_VALUE(pval, '$' RETURNING TEXT) = 'Megeia';
    IF NOT res THEN
      RETURN FALSE;
    END IF;
  END IF;
  IF val ? 'versions' THEN
    pval := val -> 'versions';
    -- .'$platforms'.0.'|'.28.versions
    res := JSONB_TYPEOF(pval) = 'array';
    IF res THEN
      FOR arr_66_idx IN 0 .. JSONB_ARRAY_LENGTH(pval) - 1 LOOP
        arr_66_item := pval -> arr_66_idx;
        -- .'$platforms'.0.'|'.28.versions.0
        res := JSONB_TYPEOF(arr_66_item) IN ('null', 'boolean', 'number', 'string') AND _jm_cst_46(arr_66_item);
        IF NOT res THEN
          EXIT;
        END IF;
      END LOOP;
    END IF;
    IF NOT res THEN
      RETURN FALSE;
    END IF;
  END IF;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION _jm_cst_47(value JSONB)
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  constants JSONB = JSONB '["10.7","10.8","10.9","10.10","10.11","10.12","10.13","10.14","10.15","all"]';
BEGIN
  RETURN constants @> value;
END;
$$ LANGUAGE plpgsql;

-- object .'$platforms'.0.'|'.27
CREATE OR REPLACE FUNCTION _jm_obj_19(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  pval JSONB;
  res bool;
  arr_67_idx INT8;
  arr_67_item JSONB;
BEGIN
  -- check open must/may only props
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  IF val ? 'name' THEN
    pval := val -> 'name';
    -- .'$platforms'.0.'|'.27.name
    res := JSONB_TYPEOF(pval) = 'string' AND JSON_VALUE(pval, '$' RETURNING TEXT) = 'Kali';
    IF NOT res THEN
      RETURN FALSE;
    END IF;
  END IF;
  IF val ? 'versions' THEN
    pval := val -> 'versions';
    -- .'$platforms'.0.'|'.27.versions
    res := JSONB_TYPEOF(pval) = 'array';
    IF res THEN
      FOR arr_67_idx IN 0 .. JSONB_ARRAY_LENGTH(pval) - 1 LOOP
        arr_67_item := pval -> arr_67_idx;
        -- .'$platforms'.0.'|'.27.versions.0
        res := JSONB_TYPEOF(arr_67_item) IN ('null', 'boolean', 'number', 'string') AND _jm_cst_47(arr_67_item);
        IF NOT res THEN
          EXIT;
        END IF;
      END LOOP;
    END IF;
    IF NOT res THEN
      RETURN FALSE;
    END IF;
  END IF;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION _jm_cst_48(value JSONB)
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  constants JSONB = JSONB '["Big-Sur","Catalina","High-Sierra","Mojave","Monterey","Sierra","Sonoma","Ventura","all"]';
BEGIN
  RETURN constants @> value;
END;
$$ LANGUAGE plpgsql;

-- object .'$platforms'.0.'|'.26
CREATE OR REPLACE FUNCTION _jm_obj_20(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  pval JSONB;
  res bool;
  arr_68_idx INT8;
  arr_68_item JSONB;
BEGIN
  -- check open must/may only props
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  IF val ? 'name' THEN
    pval := val -> 'name';
    -- .'$platforms'.0.'|'.26.name
    res := JSONB_TYPEOF(pval) = 'string' AND JSON_VALUE(pval, '$' RETURNING TEXT) = 'macOS';
    IF NOT res THEN
      RETURN FALSE;
    END IF;
  END IF;
  IF val ? 'versions' THEN
    pval := val -> 'versions';
    -- .'$platforms'.0.'|'.26.versions
    res := JSONB_TYPEOF(pval) = 'array';
    IF res THEN
      FOR arr_68_idx IN 0 .. JSONB_ARRAY_LENGTH(pval) - 1 LOOP
        arr_68_item := pval -> arr_68_idx;
        -- .'$platforms'.0.'|'.26.versions.0
        res := JSONB_TYPEOF(arr_68_item) IN ('null', 'boolean', 'number', 'string') AND _jm_cst_48(arr_68_item);
        IF NOT res THEN
          EXIT;
        END IF;
      END LOOP;
    END IF;
    IF NOT res THEN
      RETURN FALSE;
    END IF;
  END IF;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION _jm_cst_49(value JSONB)
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  constants JSONB = JSONB '["2.0","2016","2017","2018","2019","2020","2021","2022","2023","all"]';
BEGIN
  RETURN constants @> value;
END;
$$ LANGUAGE plpgsql;

-- object .'$platforms'.0.'|'.25
CREATE OR REPLACE FUNCTION _jm_obj_21(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  pval JSONB;
  res bool;
  arr_69_idx INT8;
  arr_69_item JSONB;
BEGIN
  -- check open must/may only props
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  IF val ? 'name' THEN
    pval := val -> 'name';
    -- .'$platforms'.0.'|'.25.name
    res := JSONB_TYPEOF(pval) = 'string' AND JSON_VALUE(pval, '$' RETURNING TEXT) = 'Kali';
    IF NOT res THEN
      RETURN FALSE;
    END IF;
  END IF;
  IF val ? 'versions' THEN
    pval := val -> 'versions';
    -- .'$platforms'.0.'|'.25.versions
    res := JSONB_TYPEOF(pval) = 'array';
    IF res THEN
      FOR arr_69_idx IN 0 .. JSONB_ARRAY_LENGTH(pval) - 1 LOOP
        arr_69_item := pval -> arr_69_idx;
        -- .'$platforms'.0.'|'.25.versions.0
        res := JSONB_TYPEOF(arr_69_item) IN ('null', 'boolean', 'number', 'string') AND _jm_cst_49(arr_69_item);
        IF NOT res THEN
          EXIT;
        END IF;
      END LOOP;
    END IF;
    IF NOT res THEN
      RETURN FALSE;
    END IF;
  END IF;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- object .'$platforms'.0.'|'.24
CREATE OR REPLACE FUNCTION _jm_obj_22(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  pval JSONB;
  res bool;
  arr_70_idx INT8;
  arr_70_item JSONB;
BEGIN
  -- check open must/may only props
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  IF val ? 'name' THEN
    pval := val -> 'name';
    -- .'$platforms'.0.'|'.24.name
    res := JSONB_TYPEOF(pval) = 'string' AND JSON_VALUE(pval, '$' RETURNING TEXT) = 'Junos';
    IF NOT res THEN
      RETURN FALSE;
    END IF;
  END IF;
  IF val ? 'versions' THEN
    pval := val -> 'versions';
    -- .'$platforms'.0.'|'.24.versions
    res := JSONB_TYPEOF(pval) = 'array';
    IF res THEN
      FOR arr_70_idx IN 0 .. JSONB_ARRAY_LENGTH(pval) - 1 LOOP
        arr_70_item := pval -> arr_70_idx;
        -- .'$platforms'.0.'|'.24.versions.0
        res := JSONB_TYPEOF(arr_70_item) = 'string' AND JSON_VALUE(arr_70_item, '$' RETURNING TEXT) = 'all';
        IF NOT res THEN
          EXIT;
        END IF;
      END LOOP;
    END IF;
    IF NOT res THEN
      RETURN FALSE;
    END IF;
  END IF;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- object .'$platforms'.0.'|'.23
CREATE OR REPLACE FUNCTION _jm_obj_23(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  pval JSONB;
  res bool;
  arr_71_idx INT8;
  arr_71_item JSONB;
BEGIN
  -- check open must/may only props
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  IF val ? 'name' THEN
    pval := val -> 'name';
    -- .'$platforms'.0.'|'.23.name
    res := JSONB_TYPEOF(pval) = 'string' AND JSON_VALUE(pval, '$' RETURNING TEXT) = 'IOS';
    IF NOT res THEN
      RETURN FALSE;
    END IF;
  END IF;
  IF val ? 'versions' THEN
    pval := val -> 'versions';
    -- .'$platforms'.0.'|'.23.versions
    res := JSONB_TYPEOF(pval) = 'array';
    IF res THEN
      FOR arr_71_idx IN 0 .. JSONB_ARRAY_LENGTH(pval) - 1 LOOP
        arr_71_item := pval -> arr_71_idx;
        -- .'$platforms'.0.'|'.23.versions.0
        res := JSONB_TYPEOF(arr_71_item) = 'string' AND JSON_VALUE(arr_71_item, '$' RETURNING TEXT) = 'all';
        IF NOT res THEN
          EXIT;
        END IF;
      END LOOP;
    END IF;
    IF NOT res THEN
      RETURN FALSE;
    END IF;
  END IF;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION _jm_cst_50(value JSONB)
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  constants JSONB = JSONB '["10","11","all"]';
BEGIN
  RETURN constants @> value;
END;
$$ LANGUAGE plpgsql;

-- object .'$platforms'.0.'|'.22
CREATE OR REPLACE FUNCTION _jm_obj_24(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  pval JSONB;
  res bool;
  arr_72_idx INT8;
  arr_72_item JSONB;
BEGIN
  -- check open must/may only props
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  IF val ? 'name' THEN
    pval := val -> 'name';
    -- .'$platforms'.0.'|'.22.name
    res := JSONB_TYPEOF(pval) = 'string' AND JSON_VALUE(pval, '$' RETURNING TEXT) = 'HardenedBSD';
    IF NOT res THEN
      RETURN FALSE;
    END IF;
  END IF;
  IF val ? 'versions' THEN
    pval := val -> 'versions';
    -- .'$platforms'.0.'|'.22.versions
    res := JSONB_TYPEOF(pval) = 'array';
    IF res THEN
      FOR arr_72_idx IN 0 .. JSONB_ARRAY_LENGTH(pval) - 1 LOOP
        arr_72_item := pval -> arr_72_idx;
        -- .'$platforms'.0.'|'.22.versions.0
        res := JSONB_TYPEOF(arr_72_item) IN ('null', 'boolean', 'number', 'string') AND _jm_cst_50(arr_72_item);
        IF NOT res THEN
          EXIT;
        END IF;
      END LOOP;
    END IF;
    IF NOT res THEN
      RETURN FALSE;
    END IF;
  END IF;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- object .'$platforms'.0.'|'.21
CREATE OR REPLACE FUNCTION _jm_obj_25(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  pval JSONB;
  res bool;
  arr_73_idx INT8;
  arr_73_item JSONB;
BEGIN
  -- check open must/may only props
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  IF val ? 'name' THEN
    pval := val -> 'name';
    -- .'$platforms'.0.'|'.21.name
    res := JSONB_TYPEOF(pval) = 'string' AND JSON_VALUE(pval, '$' RETURNING TEXT) = 'Gentoo';
    IF NOT res THEN
      RETURN FALSE;
    END IF;
  END IF;
  IF val ? 'versions' THEN
    pval := val -> 'versions';
    -- .'$platforms'.0.'|'.21.versions
    res := JSONB_TYPEOF(pval) = 'array';
    IF res THEN
      FOR arr_73_idx IN 0 .. JSONB_ARRAY_LENGTH(pval) - 1 LOOP
        arr_73_item := pval -> arr_73_idx;
        -- .'$platforms'.0.'|'.21.versions.0
        res := JSONB_TYPEOF(arr_73_item) = 'string' AND JSON_VALUE(arr_73_item, '$' RETURNING TEXT) = 'all';
        IF NOT res THEN
          EXIT;
        END IF;
      END LOOP;
    END IF;
    IF NOT res THEN
      RETURN FALSE;
    END IF;
  END IF;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- object .'$platforms'.0.'|'.20
CREATE OR REPLACE FUNCTION _jm_obj_26(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  pval JSONB;
  res bool;
  arr_74_idx INT8;
  arr_74_item JSONB;
BEGIN
  -- check open must/may only props
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  IF val ? 'name' THEN
    pval := val -> 'name';
    -- .'$platforms'.0.'|'.20.name
    res := JSONB_TYPEOF(pval) = 'string' AND JSON_VALUE(pval, '$' RETURNING TEXT) = 'GenericUNIX';
    IF NOT res THEN
      RETURN FALSE;
    END IF;
  END IF;
  IF val ? 'versions' THEN
    pval := val -> 'versions';
    -- .'$platforms'.0.'|'.20.versions
    res := JSONB_TYPEOF(pval) = 'array';
    IF res THEN
      FOR arr_74_idx IN 0 .. JSONB_ARRAY_LENGTH(pval) - 1 LOOP
        arr_74_item := pval -> arr_74_idx;
        -- .'$platforms'.0.'|'.20.versions.0
        res := JSONB_TYPEOF(arr_74_item) = 'string' AND JSON_VALUE(arr_74_item, '$' RETURNING TEXT) = 'all';
        IF NOT res THEN
          EXIT;
        END IF;
      END LOOP;
    END IF;
    IF NOT res THEN
      RETURN FALSE;
    END IF;
  END IF;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- object .'$platforms'.0.'|'.19
CREATE OR REPLACE FUNCTION _jm_obj_27(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  pval JSONB;
  res bool;
  arr_75_idx INT8;
  arr_75_item JSONB;
BEGIN
  -- check open must/may only props
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  IF val ? 'name' THEN
    pval := val -> 'name';
    -- .'$platforms'.0.'|'.19.name
    res := JSONB_TYPEOF(pval) = 'string' AND JSON_VALUE(pval, '$' RETURNING TEXT) = 'GenericLinux';
    IF NOT res THEN
      RETURN FALSE;
    END IF;
  END IF;
  IF val ? 'versions' THEN
    pval := val -> 'versions';
    -- .'$platforms'.0.'|'.19.versions
    res := JSONB_TYPEOF(pval) = 'array';
    IF res THEN
      FOR arr_75_idx IN 0 .. JSONB_ARRAY_LENGTH(pval) - 1 LOOP
        arr_75_item := pval -> arr_75_idx;
        -- .'$platforms'.0.'|'.19.versions.0
        res := JSONB_TYPEOF(arr_75_item) = 'string' AND JSON_VALUE(arr_75_item, '$' RETURNING TEXT) = 'all';
        IF NOT res THEN
          EXIT;
        END IF;
      END LOOP;
    END IF;
    IF NOT res THEN
      RETURN FALSE;
    END IF;
  END IF;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- object .'$platforms'.0.'|'.18
CREATE OR REPLACE FUNCTION _jm_obj_28(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  pval JSONB;
  res bool;
  arr_76_idx INT8;
  arr_76_item JSONB;
BEGIN
  -- check open must/may only props
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  IF val ? 'name' THEN
    pval := val -> 'name';
    -- .'$platforms'.0.'|'.18.name
    res := JSONB_TYPEOF(pval) = 'string' AND JSON_VALUE(pval, '$' RETURNING TEXT) = 'GenericBSD';
    IF NOT res THEN
      RETURN FALSE;
    END IF;
  END IF;
  IF val ? 'versions' THEN
    pval := val -> 'versions';
    -- .'$platforms'.0.'|'.18.versions
    res := JSONB_TYPEOF(pval) = 'array';
    IF res THEN
      FOR arr_76_idx IN 0 .. JSONB_ARRAY_LENGTH(pval) - 1 LOOP
        arr_76_item := pval -> arr_76_idx;
        -- .'$platforms'.0.'|'.18.versions.0
        res := JSONB_TYPEOF(arr_76_item) = 'string' AND JSON_VALUE(arr_76_item, '$' RETURNING TEXT) = 'all';
        IF NOT res THEN
          EXIT;
        END IF;
      END LOOP;
    END IF;
    IF NOT res THEN
      RETURN FALSE;
    END IF;
  END IF;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION _jm_cst_51(value JSONB)
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  constants JSONB = JSONB '["8.0","8.1","8.2","8.3","8.4","9.0","9.1","9.2","9.3","10.0","10.1","10.2","10.3","10.4","11.0","11.1","11.2","11.3","11.4","12.0","12.1","12.2","13.0","13.1","13.2","14.0","all"]';
BEGIN
  RETURN constants @> value;
END;
$$ LANGUAGE plpgsql;

-- object .'$platforms'.0.'|'.17
CREATE OR REPLACE FUNCTION _jm_obj_29(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  pval JSONB;
  res bool;
  arr_77_idx INT8;
  arr_77_item JSONB;
BEGIN
  -- check open must/may only props
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  IF val ? 'name' THEN
    pval := val -> 'name';
    -- .'$platforms'.0.'|'.17.name
    res := JSONB_TYPEOF(pval) = 'string' AND JSON_VALUE(pval, '$' RETURNING TEXT) = 'FreeBSD';
    IF NOT res THEN
      RETURN FALSE;
    END IF;
  END IF;
  IF val ? 'versions' THEN
    pval := val -> 'versions';
    -- .'$platforms'.0.'|'.17.versions
    res := JSONB_TYPEOF(pval) = 'array';
    IF res THEN
      FOR arr_77_idx IN 0 .. JSONB_ARRAY_LENGTH(pval) - 1 LOOP
        arr_77_item := pval -> arr_77_idx;
        -- .'$platforms'.0.'|'.17.versions.0
        res := JSONB_TYPEOF(arr_77_item) IN ('null', 'boolean', 'number', 'string') AND _jm_cst_51(arr_77_item);
        IF NOT res THEN
          EXIT;
        END IF;
      END LOOP;
    END IF;
    IF NOT res THEN
      RETURN FALSE;
    END IF;
  END IF;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION _jm_cst_52(value JSONB)
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  constants JSONB = JSONB '["16","17","18","19","20","21","22","23","24","25","26","27","28","29","30","31","32","33","34","35","36","37","38","39","40","41","42","all"]';
BEGIN
  RETURN constants @> value;
END;
$$ LANGUAGE plpgsql;

-- object .'$platforms'.0.'|'.16
CREATE OR REPLACE FUNCTION _jm_obj_30(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  pval JSONB;
  res bool;
  arr_78_idx INT8;
  arr_78_item JSONB;
BEGIN
  -- check open must/may only props
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  IF val ? 'name' THEN
    pval := val -> 'name';
    -- .'$platforms'.0.'|'.16.name
    res := JSONB_TYPEOF(pval) = 'string' AND JSON_VALUE(pval, '$' RETURNING TEXT) = 'Fedora';
    IF NOT res THEN
      RETURN FALSE;
    END IF;
  END IF;
  IF val ? 'versions' THEN
    pval := val -> 'versions';
    -- .'$platforms'.0.'|'.16.versions
    res := JSONB_TYPEOF(pval) = 'array';
    IF res THEN
      FOR arr_78_idx IN 0 .. JSONB_ARRAY_LENGTH(pval) - 1 LOOP
        arr_78_item := pval -> arr_78_idx;
        -- .'$platforms'.0.'|'.16.versions.0
        res := JSONB_TYPEOF(arr_78_item) IN ('null', 'boolean', 'number', 'string') AND _jm_cst_52(arr_78_item);
        IF NOT res THEN
          EXIT;
        END IF;
      END LOOP;
    END IF;
    IF NOT res THEN
      RETURN FALSE;
    END IF;
  END IF;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- object .'$platforms'.0.'|'.15
CREATE OR REPLACE FUNCTION _jm_obj_31(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  pval JSONB;
  res bool;
  arr_79_idx INT8;
  arr_79_item JSONB;
BEGIN
  -- check open must/may only props
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  IF val ? 'name' THEN
    pval := val -> 'name';
    -- .'$platforms'.0.'|'.15.name
    res := JSONB_TYPEOF(pval) = 'string' AND JSON_VALUE(pval, '$' RETURNING TEXT) = 'eos';
    IF NOT res THEN
      RETURN FALSE;
    END IF;
  END IF;
  IF val ? 'versions' THEN
    pval := val -> 'versions';
    -- .'$platforms'.0.'|'.15.versions
    res := JSONB_TYPEOF(pval) = 'array';
    IF res THEN
      FOR arr_79_idx IN 0 .. JSONB_ARRAY_LENGTH(pval) - 1 LOOP
        arr_79_item := pval -> arr_79_idx;
        -- .'$platforms'.0.'|'.15.versions.0
        res := JSONB_TYPEOF(arr_79_item) = 'string' AND JSON_VALUE(arr_79_item, '$' RETURNING TEXT) = 'all';
        IF NOT res THEN
          EXIT;
        END IF;
      END LOOP;
    END IF;
    IF NOT res THEN
      RETURN FALSE;
    END IF;
  END IF;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION _jm_cst_53(value JSONB)
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  constants JSONB = JSONB '["5","6","7","8","9","10","all"]';
BEGIN
  RETURN constants @> value;
END;
$$ LANGUAGE plpgsql;

-- object .'$platforms'.0.'|'.14
CREATE OR REPLACE FUNCTION _jm_obj_32(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  pval JSONB;
  res bool;
  arr_80_idx INT8;
  arr_80_item JSONB;
BEGIN
  -- check open must/may only props
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  IF val ? 'name' THEN
    pval := val -> 'name';
    -- .'$platforms'.0.'|'.14.name
    res := JSONB_TYPEOF(pval) = 'string' AND JSON_VALUE(pval, '$' RETURNING TEXT) = 'EL';
    IF NOT res THEN
      RETURN FALSE;
    END IF;
  END IF;
  IF val ? 'versions' THEN
    pval := val -> 'versions';
    -- .'$platforms'.0.'|'.14.versions
    res := JSONB_TYPEOF(pval) = 'array';
    IF res THEN
      FOR arr_80_idx IN 0 .. JSONB_ARRAY_LENGTH(pval) - 1 LOOP
        arr_80_item := pval -> arr_80_idx;
        -- .'$platforms'.0.'|'.14.versions.0
        res := JSONB_TYPEOF(arr_80_item) IN ('null', 'boolean', 'number', 'string') AND _jm_cst_53(arr_80_item);
        IF NOT res THEN
          EXIT;
        END IF;
      END LOOP;
    END IF;
    IF NOT res THEN
      RETURN FALSE;
    END IF;
  END IF;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION _jm_cst_54(value JSONB)
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  constants JSONB = JSONB '["5.2","5.4","5.6","5.8","6.0","6.2","6.4","all"]';
BEGIN
  RETURN constants @> value;
END;
$$ LANGUAGE plpgsql;

-- object .'$platforms'.0.'|'.13
CREATE OR REPLACE FUNCTION _jm_obj_33(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  pval JSONB;
  res bool;
  arr_81_idx INT8;
  arr_81_item JSONB;
BEGIN
  -- check open must/may only props
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  IF val ? 'name' THEN
    pval := val -> 'name';
    -- .'$platforms'.0.'|'.13.name
    res := JSONB_TYPEOF(pval) = 'string' AND JSON_VALUE(pval, '$' RETURNING TEXT) = 'DragonFlyBSD';
    IF NOT res THEN
      RETURN FALSE;
    END IF;
  END IF;
  IF val ? 'versions' THEN
    pval := val -> 'versions';
    -- .'$platforms'.0.'|'.13.versions
    res := JSONB_TYPEOF(pval) = 'array';
    IF res THEN
      FOR arr_81_idx IN 0 .. JSONB_ARRAY_LENGTH(pval) - 1 LOOP
        arr_81_item := pval -> arr_81_idx;
        -- .'$platforms'.0.'|'.13.versions.0
        res := JSONB_TYPEOF(arr_81_item) IN ('null', 'boolean', 'number', 'string') AND _jm_cst_54(arr_81_item);
        IF NOT res THEN
          EXIT;
        END IF;
      END LOOP;
    END IF;
    IF NOT res THEN
      RETURN FALSE;
    END IF;
  END IF;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION _jm_cst_55(value JSONB)
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  constants JSONB = JSONB '["ascii","beowulf","chimaera","daedalus","jessie","all"]';
BEGIN
  RETURN constants @> value;
END;
$$ LANGUAGE plpgsql;

-- object .'$platforms'.0.'|'.12
CREATE OR REPLACE FUNCTION _jm_obj_34(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  pval JSONB;
  res bool;
  arr_82_idx INT8;
  arr_82_item JSONB;
BEGIN
  -- check open must/may only props
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  IF val ? 'name' THEN
    pval := val -> 'name';
    -- .'$platforms'.0.'|'.12.name
    res := JSONB_TYPEOF(pval) = 'string' AND JSON_VALUE(pval, '$' RETURNING TEXT) = 'Devuan';
    IF NOT res THEN
      RETURN FALSE;
    END IF;
  END IF;
  IF val ? 'versions' THEN
    pval := val -> 'versions';
    -- .'$platforms'.0.'|'.12.versions
    res := JSONB_TYPEOF(pval) = 'array';
    IF res THEN
      FOR arr_82_idx IN 0 .. JSONB_ARRAY_LENGTH(pval) - 1 LOOP
        arr_82_item := pval -> arr_82_idx;
        -- .'$platforms'.0.'|'.12.versions.0
        res := JSONB_TYPEOF(arr_82_item) IN ('null', 'boolean', 'number', 'string') AND _jm_cst_55(arr_82_item);
        IF NOT res THEN
          EXIT;
        END IF;
      END LOOP;
    END IF;
    IF NOT res THEN
      RETURN FALSE;
    END IF;
  END IF;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION _jm_cst_56(value JSONB)
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  constants JSONB = JSONB '["10","6","9","all"]';
BEGIN
  RETURN constants @> value;
END;
$$ LANGUAGE plpgsql;

-- object .'$platforms'.0.'|'.11
CREATE OR REPLACE FUNCTION _jm_obj_35(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  pval JSONB;
  res bool;
  arr_83_idx INT8;
  arr_83_item JSONB;
BEGIN
  -- check open must/may only props
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  IF val ? 'name' THEN
    pval := val -> 'name';
    -- .'$platforms'.0.'|'.11.name
    res := JSONB_TYPEOF(pval) = 'string' AND JSON_VALUE(pval, '$' RETURNING TEXT) = 'DellOS';
    IF NOT res THEN
      RETURN FALSE;
    END IF;
  END IF;
  IF val ? 'versions' THEN
    pval := val -> 'versions';
    -- .'$platforms'.0.'|'.11.versions
    res := JSONB_TYPEOF(pval) = 'array';
    IF res THEN
      FOR arr_83_idx IN 0 .. JSONB_ARRAY_LENGTH(pval) - 1 LOOP
        arr_83_item := pval -> arr_83_idx;
        -- .'$platforms'.0.'|'.11.versions.0
        res := JSONB_TYPEOF(arr_83_item) IN ('null', 'boolean', 'number', 'string') AND _jm_cst_56(arr_83_item);
        IF NOT res THEN
          EXIT;
        END IF;
      END LOOP;
    END IF;
    IF NOT res THEN
      RETURN FALSE;
    END IF;
  END IF;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION _jm_cst_57(value JSONB)
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  constants JSONB = JSONB '["bookworm","bullseye","buster","etch","jessie","lenny","sid","squeeze","stretch","trixie","wheezy","all"]';
BEGIN
  RETURN constants @> value;
END;
$$ LANGUAGE plpgsql;

-- object .'$platforms'.0.'|'.10
CREATE OR REPLACE FUNCTION _jm_obj_36(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  pval JSONB;
  res bool;
  arr_84_idx INT8;
  arr_84_item JSONB;
BEGIN
  -- check open must/may only props
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  IF val ? 'name' THEN
    pval := val -> 'name';
    -- .'$platforms'.0.'|'.10.name
    res := JSONB_TYPEOF(pval) = 'string' AND JSON_VALUE(pval, '$' RETURNING TEXT) = 'Debian';
    IF NOT res THEN
      RETURN FALSE;
    END IF;
  END IF;
  IF val ? 'versions' THEN
    pval := val -> 'versions';
    -- .'$platforms'.0.'|'.10.versions
    res := JSONB_TYPEOF(pval) = 'array';
    IF res THEN
      FOR arr_84_idx IN 0 .. JSONB_ARRAY_LENGTH(pval) - 1 LOOP
        arr_84_item := pval -> arr_84_idx;
        -- .'$platforms'.0.'|'.10.versions.0
        res := JSONB_TYPEOF(arr_84_item) IN ('null', 'boolean', 'number', 'string') AND _jm_cst_57(arr_84_item);
        IF NOT res THEN
          EXIT;
        END IF;
      END LOOP;
    END IF;
    IF NOT res THEN
      RETURN FALSE;
    END IF;
  END IF;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION _jm_cst_58(value JSONB)
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  constants JSONB = JSONB '["8.0","8.1","8.2","9.0","9.1","9.2","9.3","10.0","all"]';
BEGIN
  RETURN constants @> value;
END;
$$ LANGUAGE plpgsql;

-- object .'$platforms'.0.'|'.9
CREATE OR REPLACE FUNCTION _jm_obj_37(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  pval JSONB;
  res bool;
  arr_85_idx INT8;
  arr_85_item JSONB;
BEGIN
  -- check open must/may only props
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  IF val ? 'name' THEN
    pval := val -> 'name';
    -- .'$platforms'.0.'|'.9.name
    res := JSONB_TYPEOF(pval) = 'string' AND JSON_VALUE(pval, '$' RETURNING TEXT) = 'NetBSD';
    IF NOT res THEN
      RETURN FALSE;
    END IF;
  END IF;
  IF val ? 'versions' THEN
    pval := val -> 'versions';
    -- .'$platforms'.0.'|'.9.versions
    res := JSONB_TYPEOF(pval) = 'array';
    IF res THEN
      FOR arr_85_idx IN 0 .. JSONB_ARRAY_LENGTH(pval) - 1 LOOP
        arr_85_item := pval -> arr_85_idx;
        -- .'$platforms'.0.'|'.9.versions.0
        res := JSONB_TYPEOF(arr_85_item) IN ('null', 'boolean', 'number', 'string') AND _jm_cst_58(arr_85_item);
        IF NOT res THEN
          EXIT;
        END IF;
      END LOOP;
    END IF;
    IF NOT res THEN
      RETURN FALSE;
    END IF;
  END IF;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION _jm_cst_59(value JSONB)
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  constants JSONB = JSONB '["2.5","3.0","3.1","3.2","3.3","3.4","3.5","all"]';
BEGIN
  RETURN constants @> value;
END;
$$ LANGUAGE plpgsql;

-- object .'$platforms'.0.'|'.8
CREATE OR REPLACE FUNCTION _jm_obj_38(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  pval JSONB;
  res bool;
  arr_86_idx INT8;
  arr_86_item JSONB;
BEGIN
  -- check open must/may only props
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  IF val ? 'name' THEN
    pval := val -> 'name';
    -- .'$platforms'.0.'|'.8.name
    res := JSONB_TYPEOF(pval) = 'string' AND JSON_VALUE(pval, '$' RETURNING TEXT) = 'Cumulus';
    IF NOT res THEN
      RETURN FALSE;
    END IF;
  END IF;
  IF val ? 'versions' THEN
    pval := val -> 'versions';
    -- .'$platforms'.0.'|'.8.versions
    res := JSONB_TYPEOF(pval) = 'array';
    IF res THEN
      FOR arr_86_idx IN 0 .. JSONB_ARRAY_LENGTH(pval) - 1 LOOP
        arr_86_item := pval -> arr_86_idx;
        -- .'$platforms'.0.'|'.8.versions.0
        res := JSONB_TYPEOF(arr_86_item) IN ('null', 'boolean', 'number', 'string') AND _jm_cst_59(arr_86_item);
        IF NOT res THEN
          EXIT;
        END IF;
      END LOOP;
    END IF;
    IF NOT res THEN
      RETURN FALSE;
    END IF;
  END IF;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- object .'$platforms'.0.'|'.7
CREATE OR REPLACE FUNCTION _jm_obj_39(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  pval JSONB;
  res bool;
  arr_87_idx INT8;
  arr_87_item JSONB;
BEGIN
  -- check open must/may only props
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  IF val ? 'name' THEN
    pval := val -> 'name';
    -- .'$platforms'.0.'|'.7.name
    res := JSONB_TYPEOF(pval) = 'string' AND JSON_VALUE(pval, '$' RETURNING TEXT) = 'ClearLinux';
    IF NOT res THEN
      RETURN FALSE;
    END IF;
  END IF;
  IF val ? 'versions' THEN
    pval := val -> 'versions';
    -- .'$platforms'.0.'|'.7.versions
    res := JSONB_TYPEOF(pval) = 'array';
    IF res THEN
      FOR arr_87_idx IN 0 .. JSONB_ARRAY_LENGTH(pval) - 1 LOOP
        arr_87_item := pval -> arr_87_idx;
        -- .'$platforms'.0.'|'.7.versions.0
        res := JSONB_TYPEOF(arr_87_item) = 'string' AND JSON_VALUE(arr_87_item, '$' RETURNING TEXT) = 'all';
        IF NOT res THEN
          EXIT;
        END IF;
      END LOOP;
    END IF;
    IF NOT res THEN
      RETURN FALSE;
    END IF;
  END IF;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION _jm_cst_60(value JSONB)
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  constants JSONB = JSONB '["1.8","1.7","1.6","2.12","all"]';
BEGIN
  RETURN constants @> value;
END;
$$ LANGUAGE plpgsql;

-- object .'$platforms'.0.'|'.6
CREATE OR REPLACE FUNCTION _jm_obj_40(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  pval JSONB;
  res bool;
  arr_88_idx INT8;
  arr_88_item JSONB;
BEGIN
  -- check open must/may only props
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  IF val ? 'name' THEN
    pval := val -> 'name';
    -- .'$platforms'.0.'|'.6.name
    res := JSONB_TYPEOF(pval) = 'string' AND JSON_VALUE(pval, '$' RETURNING TEXT) = 'Astra Linux';
    IF NOT res THEN
      RETURN FALSE;
    END IF;
  END IF;
  IF val ? 'versions' THEN
    pval := val -> 'versions';
    -- .'$platforms'.0.'|'.6.versions
    res := JSONB_TYPEOF(pval) = 'array';
    IF res THEN
      FOR arr_88_idx IN 0 .. JSONB_ARRAY_LENGTH(pval) - 1 LOOP
        arr_88_item := pval -> arr_88_idx;
        -- .'$platforms'.0.'|'.6.versions.0
        res := JSONB_TYPEOF(arr_88_item) IN ('null', 'boolean', 'number', 'string') AND _jm_cst_60(arr_88_item);
        IF NOT res THEN
          EXIT;
        END IF;
      END LOOP;
    END IF;
    IF NOT res THEN
      RETURN FALSE;
    END IF;
  END IF;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- object .'$platforms'.0.'|'.5
CREATE OR REPLACE FUNCTION _jm_obj_41(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  pval JSONB;
  res bool;
  arr_89_idx INT8;
  arr_89_item JSONB;
BEGIN
  -- check open must/may only props
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  IF val ? 'name' THEN
    pval := val -> 'name';
    -- .'$platforms'.0.'|'.5.name
    res := JSONB_TYPEOF(pval) = 'string' AND JSON_VALUE(pval, '$' RETURNING TEXT) = 'ArchLinux';
    IF NOT res THEN
      RETURN FALSE;
    END IF;
  END IF;
  IF val ? 'versions' THEN
    pval := val -> 'versions';
    -- .'$platforms'.0.'|'.5.versions
    res := JSONB_TYPEOF(pval) = 'array';
    IF res THEN
      FOR arr_89_idx IN 0 .. JSONB_ARRAY_LENGTH(pval) - 1 LOOP
        arr_89_item := pval -> arr_89_idx;
        -- .'$platforms'.0.'|'.5.versions.0
        res := JSONB_TYPEOF(arr_89_item) = 'string' AND JSON_VALUE(arr_89_item, '$' RETURNING TEXT) = 'all';
        IF NOT res THEN
          EXIT;
        END IF;
      END LOOP;
    END IF;
    IF NOT res THEN
      RETURN FALSE;
    END IF;
  END IF;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- object .'$platforms'.0.'|'.4
CREATE OR REPLACE FUNCTION _jm_obj_42(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  pval JSONB;
  res bool;
  arr_90_idx INT8;
  arr_90_item JSONB;
BEGIN
  -- check open must/may only props
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  IF val ? 'name' THEN
    pval := val -> 'name';
    -- .'$platforms'.0.'|'.4.name
    res := JSONB_TYPEOF(pval) = 'string' AND JSON_VALUE(pval, '$' RETURNING TEXT) = 'aos';
    IF NOT res THEN
      RETURN FALSE;
    END IF;
  END IF;
  IF val ? 'versions' THEN
    pval := val -> 'versions';
    -- .'$platforms'.0.'|'.4.versions
    res := JSONB_TYPEOF(pval) = 'array';
    IF res THEN
      FOR arr_90_idx IN 0 .. JSONB_ARRAY_LENGTH(pval) - 1 LOOP
        arr_90_item := pval -> arr_90_idx;
        -- .'$platforms'.0.'|'.4.versions.0
        res := JSONB_TYPEOF(arr_90_item) = 'string' AND JSON_VALUE(arr_90_item, '$' RETURNING TEXT) = 'all';
        IF NOT res THEN
          EXIT;
        END IF;
      END LOOP;
    END IF;
    IF NOT res THEN
      RETURN FALSE;
    END IF;
  END IF;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION _jm_cst_61(value JSONB)
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  constants JSONB = JSONB '["all","1","2","2023"]';
BEGIN
  RETURN constants @> value;
END;
$$ LANGUAGE plpgsql;

-- object .'$platforms'.0.'|'.3
CREATE OR REPLACE FUNCTION _jm_obj_43(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  pval JSONB;
  res bool;
  arr_91_idx INT8;
  arr_91_item JSONB;
BEGIN
  -- check open must/may only props
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  IF val ? 'name' THEN
    pval := val -> 'name';
    -- .'$platforms'.0.'|'.3.name
    res := JSONB_TYPEOF(pval) = 'string' AND JSON_VALUE(pval, '$' RETURNING TEXT) = 'Amazon Linux';
    IF NOT res THEN
      RETURN FALSE;
    END IF;
  END IF;
  IF val ? 'versions' THEN
    pval := val -> 'versions';
    -- .'$platforms'.0.'|'.3.versions
    res := JSONB_TYPEOF(pval) = 'array';
    IF res THEN
      FOR arr_91_idx IN 0 .. JSONB_ARRAY_LENGTH(pval) - 1 LOOP
        arr_91_item := pval -> arr_91_idx;
        -- .'$platforms'.0.'|'.3.versions.0
        res := JSONB_TYPEOF(arr_91_item) IN ('null', 'boolean', 'number', 'string') AND _jm_cst_61(arr_91_item);
        IF NOT res THEN
          EXIT;
        END IF;
      END LOOP;
    END IF;
    IF NOT res THEN
      RETURN FALSE;
    END IF;
  END IF;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION _jm_cst_62(value JSONB)
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  constants JSONB = JSONB '["2013.03","2013.09","2014.03","2014.09","2015.03","2015.09","2016.03","2016.09","2017.03","2017.09","2017.12","2018.03","Candidate","all"]';
BEGIN
  RETURN constants @> value;
END;
$$ LANGUAGE plpgsql;

-- object .'$platforms'.0.'|'.2
CREATE OR REPLACE FUNCTION _jm_obj_44(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  pval JSONB;
  res bool;
  arr_92_idx INT8;
  arr_92_item JSONB;
BEGIN
  -- check open must/may only props
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  IF val ? 'name' THEN
    pval := val -> 'name';
    -- .'$platforms'.0.'|'.2.name
    res := JSONB_TYPEOF(pval) = 'string' AND JSON_VALUE(pval, '$' RETURNING TEXT) = 'Amazon';
    IF NOT res THEN
      RETURN FALSE;
    END IF;
  END IF;
  IF val ? 'versions' THEN
    pval := val -> 'versions';
    -- .'$platforms'.0.'|'.2.versions
    res := JSONB_TYPEOF(pval) = 'array';
    IF res THEN
      FOR arr_92_idx IN 0 .. JSONB_ARRAY_LENGTH(pval) - 1 LOOP
        arr_92_item := pval -> arr_92_idx;
        -- .'$platforms'.0.'|'.2.versions.0
        res := JSONB_TYPEOF(arr_92_item) IN ('null', 'boolean', 'number', 'string') AND _jm_cst_62(arr_92_item);
        IF NOT res THEN
          EXIT;
        END IF;
      END LOOP;
    END IF;
    IF NOT res THEN
      RETURN FALSE;
    END IF;
  END IF;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- object .'$platforms'.0.'|'.1
CREATE OR REPLACE FUNCTION _jm_obj_45(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  pval JSONB;
  res bool;
  arr_93_idx INT8;
  arr_93_item JSONB;
BEGIN
  -- check open must/may only props
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  IF val ? 'name' THEN
    pval := val -> 'name';
    -- .'$platforms'.0.'|'.1.name
    res := JSONB_TYPEOF(pval) = 'string' AND JSON_VALUE(pval, '$' RETURNING TEXT) = 'Alpine';
    IF NOT res THEN
      RETURN FALSE;
    END IF;
  END IF;
  IF val ? 'versions' THEN
    pval := val -> 'versions';
    -- .'$platforms'.0.'|'.1.versions
    res := JSONB_TYPEOF(pval) = 'array';
    IF res THEN
      FOR arr_93_idx IN 0 .. JSONB_ARRAY_LENGTH(pval) - 1 LOOP
        arr_93_item := pval -> arr_93_idx;
        -- .'$platforms'.0.'|'.1.versions.0
        res := JSONB_TYPEOF(arr_93_item) = 'string' AND JSON_VALUE(arr_93_item, '$' RETURNING TEXT) = 'all';
        IF NOT res THEN
          EXIT;
        END IF;
      END LOOP;
    END IF;
    IF NOT res THEN
      RETURN FALSE;
    END IF;
  END IF;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION _jm_cst_63(value JSONB)
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  constants JSONB = JSONB '["6.1","7.1","7.2","all"]';
BEGIN
  RETURN constants @> value;
END;
$$ LANGUAGE plpgsql;

-- object .'$platforms'.0.'|'.0
CREATE OR REPLACE FUNCTION _jm_obj_46(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  pval JSONB;
  res bool;
  arr_94_idx INT8;
  arr_94_item JSONB;
BEGIN
  -- check open must/may only props
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  IF val ? 'name' THEN
    pval := val -> 'name';
    -- .'$platforms'.0.'|'.0.name
    res := JSONB_TYPEOF(pval) = 'string' AND JSON_VALUE(pval, '$' RETURNING TEXT) = 'AIX';
    IF NOT res THEN
      RETURN FALSE;
    END IF;
  END IF;
  IF val ? 'versions' THEN
    pval := val -> 'versions';
    -- .'$platforms'.0.'|'.0.versions
    res := JSONB_TYPEOF(pval) = 'array';
    IF res THEN
      FOR arr_94_idx IN 0 .. JSONB_ARRAY_LENGTH(pval) - 1 LOOP
        arr_94_item := pval -> arr_94_idx;
        -- .'$platforms'.0.'|'.0.versions.0
        res := JSONB_TYPEOF(arr_94_item) IN ('null', 'boolean', 'number', 'string') AND _jm_cst_63(arr_94_item);
        IF NOT res THEN
          EXIT;
        END IF;
      END LOOP;
    END IF;
    IF NOT res THEN
      RETURN FALSE;
    END IF;
  END IF;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check $platforms (.'$platforms')
CREATE OR REPLACE FUNCTION json_model_50(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  arr_47_idx INT8;
  arr_47_item JSONB;
BEGIN
  -- .'$platforms'
  res := JSONB_TYPEOF(val) = 'array';
  IF res THEN
    FOR arr_47_idx IN 0 .. JSONB_ARRAY_LENGTH(val) - 1 LOOP
      arr_47_item := val -> arr_47_idx;
      -- .'$platforms'.0
      res := JSONB_TYPEOF(arr_47_item) = 'object';
      IF res THEN
        -- .'$platforms'.0.'|'.0
        res := _jm_obj_46(arr_47_item, NULL, rep);
        IF NOT res THEN
          -- .'$platforms'.0.'|'.1
          res := _jm_obj_45(arr_47_item, NULL, rep);
          IF NOT res THEN
            -- .'$platforms'.0.'|'.2
            res := _jm_obj_44(arr_47_item, NULL, rep);
            IF NOT res THEN
              -- .'$platforms'.0.'|'.3
              res := _jm_obj_43(arr_47_item, NULL, rep);
              IF NOT res THEN
                -- .'$platforms'.0.'|'.4
                res := _jm_obj_42(arr_47_item, NULL, rep);
                IF NOT res THEN
                  -- .'$platforms'.0.'|'.5
                  res := _jm_obj_41(arr_47_item, NULL, rep);
                  IF NOT res THEN
                    -- .'$platforms'.0.'|'.6
                    res := _jm_obj_40(arr_47_item, NULL, rep);
                    IF NOT res THEN
                      -- .'$platforms'.0.'|'.7
                      res := _jm_obj_39(arr_47_item, NULL, rep);
                      IF NOT res THEN
                        -- .'$platforms'.0.'|'.8
                        res := _jm_obj_38(arr_47_item, NULL, rep);
                        IF NOT res THEN
                          -- .'$platforms'.0.'|'.9
                          res := _jm_obj_37(arr_47_item, NULL, rep);
                          IF NOT res THEN
                            -- .'$platforms'.0.'|'.10
                            res := _jm_obj_36(arr_47_item, NULL, rep);
                            IF NOT res THEN
                              -- .'$platforms'.0.'|'.11
                              res := _jm_obj_35(arr_47_item, NULL, rep);
                              IF NOT res THEN
                                -- .'$platforms'.0.'|'.12
                                res := _jm_obj_34(arr_47_item, NULL, rep);
                                IF NOT res THEN
                                  -- .'$platforms'.0.'|'.13
                                  res := _jm_obj_33(arr_47_item, NULL, rep);
                                  IF NOT res THEN
                                    -- .'$platforms'.0.'|'.14
                                    res := _jm_obj_32(arr_47_item, NULL, rep);
                                    IF NOT res THEN
                                      -- .'$platforms'.0.'|'.15
                                      res := _jm_obj_31(arr_47_item, NULL, rep);
                                      IF NOT res THEN
                                        -- .'$platforms'.0.'|'.16
                                        res := _jm_obj_30(arr_47_item, NULL, rep);
                                        IF NOT res THEN
                                          -- .'$platforms'.0.'|'.17
                                          res := _jm_obj_29(arr_47_item, NULL, rep);
                                          IF NOT res THEN
                                            -- .'$platforms'.0.'|'.18
                                            res := _jm_obj_28(arr_47_item, NULL, rep);
                                            IF NOT res THEN
                                              -- .'$platforms'.0.'|'.19
                                              res := _jm_obj_27(arr_47_item, NULL, rep);
                                              IF NOT res THEN
                                                -- .'$platforms'.0.'|'.20
                                                res := _jm_obj_26(arr_47_item, NULL, rep);
                                                IF NOT res THEN
                                                  -- .'$platforms'.0.'|'.21
                                                  res := _jm_obj_25(arr_47_item, NULL, rep);
                                                  IF NOT res THEN
                                                    -- .'$platforms'.0.'|'.22
                                                    res := _jm_obj_24(arr_47_item, NULL, rep);
                                                    IF NOT res THEN
                                                      -- .'$platforms'.0.'|'.23
                                                      res := _jm_obj_23(arr_47_item, NULL, rep);
                                                      IF NOT res THEN
                                                        -- .'$platforms'.0.'|'.24
                                                        res := _jm_obj_22(arr_47_item, NULL, rep);
                                                        IF NOT res THEN
                                                          -- .'$platforms'.0.'|'.25
                                                          res := _jm_obj_21(arr_47_item, NULL, rep);
                                                          IF NOT res THEN
                                                            -- .'$platforms'.0.'|'.26
                                                            res := _jm_obj_20(arr_47_item, NULL, rep);
                                                            IF NOT res THEN
                                                              -- .'$platforms'.0.'|'.27
                                                              res := _jm_obj_19(arr_47_item, NULL, rep);
                                                              IF NOT res THEN
                                                                -- .'$platforms'.0.'|'.28
                                                                res := _jm_obj_18(arr_47_item, NULL, rep);
                                                                IF NOT res THEN
                                                                  -- .'$platforms'.0.'|'.29
                                                                  res := _jm_obj_17(arr_47_item, NULL, rep);
                                                                  IF NOT res THEN
                                                                    -- .'$platforms'.0.'|'.30
                                                                    res := _jm_obj_16(arr_47_item, NULL, rep);
                                                                    IF NOT res THEN
                                                                      -- .'$platforms'.0.'|'.31
                                                                      res := _jm_obj_15(arr_47_item, NULL, rep);
                                                                      IF NOT res THEN
                                                                        -- .'$platforms'.0.'|'.32
                                                                        res := _jm_obj_14(arr_47_item, NULL, rep);
                                                                        IF NOT res THEN
                                                                          -- .'$platforms'.0.'|'.33
                                                                          res := _jm_obj_13(arr_47_item, NULL, rep);
                                                                          IF NOT res THEN
                                                                            -- .'$platforms'.0.'|'.34
                                                                            res := _jm_obj_12(arr_47_item, NULL, rep);
                                                                            IF NOT res THEN
                                                                              -- .'$platforms'.0.'|'.35
                                                                              res := _jm_obj_11(arr_47_item, NULL, rep);
                                                                              IF NOT res THEN
                                                                                -- .'$platforms'.0.'|'.36
                                                                                res := _jm_obj_10(arr_47_item, NULL, rep);
                                                                                IF NOT res THEN
                                                                                  -- .'$platforms'.0.'|'.37
                                                                                  res := _jm_obj_9(arr_47_item, NULL, rep);
                                                                                  IF NOT res THEN
                                                                                    -- .'$platforms'.0.'|'.38
                                                                                    res := _jm_obj_8(arr_47_item, NULL, rep);
                                                                                    IF NOT res THEN
                                                                                      -- .'$platforms'.0.'|'.39
                                                                                      res := _jm_obj_7(arr_47_item, NULL, rep);
                                                                                      IF NOT res THEN
                                                                                        -- .'$platforms'.0.'|'.40
                                                                                        res := _jm_obj_6(arr_47_item, NULL, rep);
                                                                                        IF NOT res THEN
                                                                                          -- .'$platforms'.0.'|'.41
                                                                                          res := _jm_obj_5(arr_47_item, NULL, rep);
                                                                                          IF NOT res THEN
                                                                                            -- .'$platforms'.0.'|'.42
                                                                                            res := _jm_obj_4(arr_47_item, NULL, rep);
                                                                                            IF NOT res THEN
                                                                                              -- .'$platforms'.0.'|'.43
                                                                                              res := _jm_obj_3(arr_47_item, NULL, rep);
                                                                                              IF NOT res THEN
                                                                                                -- .'$platforms'.0.'|'.44
                                                                                                res := _jm_obj_2(arr_47_item, NULL, rep);
                                                                                                IF NOT res THEN
                                                                                                  -- .'$platforms'.0.'|'.45
                                                                                                  res := _jm_obj_1(arr_47_item, NULL, rep);
                                                                                                  IF NOT res THEN
                                                                                                    -- .'$platforms'.0.'|'.46
                                                                                                    res := _jm_obj_0(arr_47_item, NULL, rep);
                                                                                                  END IF;
                                                                                                END IF;
                                                                                              END IF;
                                                                                            END IF;
                                                                                          END IF;
                                                                                        END IF;
                                                                                      END IF;
                                                                                    END IF;
                                                                                  END IF;
                                                                                END IF;
                                                                              END IF;
                                                                            END IF;
                                                                          END IF;
                                                                        END IF;
                                                                      END IF;
                                                                    END IF;
                                                                  END IF;
                                                                END IF;
                                                              END IF;
                                                            END IF;
                                                          END IF;
                                                        END IF;
                                                      END IF;
                                                    END IF;
                                                  END IF;
                                                END IF;
                                              END IF;
                                            END IF;
                                          END IF;
                                        END IF;
                                      END IF;
                                    END IF;
                                  END IF;
                                END IF;
                              END IF;
                            END IF;
                          END IF;
                        END IF;
                      END IF;
                    END IF;
                  END IF;
                END IF;
              END IF;
            END IF;
          END IF;
        END IF;
      END IF;
      IF NOT res THEN
        EXIT;
      END IF;
    END LOOP;
  END IF;
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_51_map_cloud_platforms (.'$GalaxyInfoModelCollection'.cloud_platforms)
CREATE OR REPLACE FUNCTION _jm_f_0(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$GalaxyInfoModelCollection'.cloud_platforms
  res := TRUE;
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_51_map_galaxy_tags (.'$GalaxyInfoModelCollection'.galaxy_tags)
CREATE OR REPLACE FUNCTION _jm_f_1(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  arr_95_idx INT8;
  arr_95_item JSONB;
BEGIN
  -- .'$GalaxyInfoModelCollection'.galaxy_tags
  res := JSONB_TYPEOF(val) = 'array';
  IF res THEN
    FOR arr_95_idx IN 0 .. JSONB_ARRAY_LENGTH(val) - 1 LOOP
      arr_95_item := val -> arr_95_idx;
      -- .'$GalaxyInfoModelCollection'.galaxy_tags.0
      res := JSONB_TYPEOF(arr_95_item) = 'string';
      IF NOT res THEN
        EXIT;
      END IF;
    END LOOP;
  END IF;
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_51_map_min_ansible_version (.'$GalaxyInfoModelCollection'.min_ansible_version)
CREATE OR REPLACE FUNCTION _jm_f_2(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$GalaxyInfoModelCollection'.min_ansible_version
  res := JSONB_TYPEOF(val) = 'string';
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- regex=^[a-z][-a-z0-9_]+$ opts=n
CREATE OR REPLACE FUNCTION _jm_re_0(val TEXT, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  RETURN regexp_like(val, '^[a-z][-a-z0-9_]+$', 'n');
END;
$$ LANGUAGE plpgsql;

-- check json_model_51_map_namespace (.'$GalaxyInfoModelCollection'.namespace)
CREATE OR REPLACE FUNCTION _jm_f_3(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$GalaxyInfoModelCollection'.namespace
  -- "/^[a-z][-a-z0-9_]+$/"
  res := JSONB_TYPEOF(val) = 'string' AND _jm_re_0(JSON_VALUE(val, '$' RETURNING TEXT), path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- regex=^[a-z][a-z0-9_]+$ opts=n
CREATE OR REPLACE FUNCTION _jm_re_1(val TEXT, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  RETURN regexp_like(val, '^[a-z][a-z0-9_]+$', 'n');
END;
$$ LANGUAGE plpgsql;

-- check json_model_51_map_role_name (.'$GalaxyInfoModelCollection'.role_name)
CREATE OR REPLACE FUNCTION _jm_f_4(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$GalaxyInfoModelCollection'.role_name
  -- "/^[a-z][a-z0-9_]+$/"
  res := JSONB_TYPEOF(val) = 'string' AND _jm_re_1(JSON_VALUE(val, '$' RETURNING TEXT), path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_51_map_video_links (.'$GalaxyInfoModelCollection'.video_links)
CREATE OR REPLACE FUNCTION _jm_f_5(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$GalaxyInfoModelCollection'.video_links
  res := JSONB_TYPEOF(val) = 'array';
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION json_model_51_map(name TEXT)
RETURNS TEXT STRICT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  map JSONB := JSONB '{"cloud_platforms":"_jm_f_0","galaxy_tags":"_jm_f_1","min_ansible_version":"_jm_f_2","namespace":"_jm_f_3","platforms":"json_model_50","role_name":"_jm_f_4","video_links":"_jm_f_5"}';
BEGIN
  RETURN map->>name;
END;
$$ LANGUAGE plpgsql;

-- check $GalaxyInfoModelCollection (.'$GalaxyInfoModelCollection')
CREATE OR REPLACE FUNCTION json_model_51(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  pfun TEXT;
  prop TEXT;
  pval JSONB;
BEGIN
  -- .'$GalaxyInfoModelCollection'
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF json_model_51_map(prop) IS NOT NULL THEN
      -- handle 7 may props
      pfun := json_model_51_map(prop);
      IF NOT jm_call(pfun, pval, NULL, rep) THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_52_map_author (.'$GalaxyInfoModelLoose'.author)
CREATE OR REPLACE FUNCTION _jm_f_6(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$GalaxyInfoModelLoose'.author
  res := JSONB_TYPEOF(val) = 'string';
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_52_map_company (.'$GalaxyInfoModelLoose'.company)
CREATE OR REPLACE FUNCTION _jm_f_7(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$GalaxyInfoModelLoose'.company
  res := JSONB_TYPEOF(val) = 'string';
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_52_map_github_branch (.'$GalaxyInfoModelLoose'.github_branch)
CREATE OR REPLACE FUNCTION _jm_f_8(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$GalaxyInfoModelLoose'.github_branch
  res := JSONB_TYPEOF(val) = 'string';
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_52_map_issue_tracker_url (.'$GalaxyInfoModelLoose'.issue_tracker_url)
CREATE OR REPLACE FUNCTION _jm_f_9(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$GalaxyInfoModelLoose'.issue_tracker_url
  res := JSONB_TYPEOF(val) = 'string';
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_52_map_license (.'$GalaxyInfoModelLoose'.license)
CREATE OR REPLACE FUNCTION _jm_f_10(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$GalaxyInfoModelLoose'.license
  res := JSONB_TYPEOF(val) = 'string';
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_52_map_min_ansible_container_version (.'$GalaxyInfoModelLoose'.min_ansible_container_version)
CREATE OR REPLACE FUNCTION _jm_f_11(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$GalaxyInfoModelLoose'.min_ansible_container_version
  res := JSONB_TYPEOF(val) = 'string';
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION json_model_52_map(name TEXT)
RETURNS TEXT STRICT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  map JSONB := JSONB '{"author":"_jm_f_6","company":"_jm_f_7","github_branch":"_jm_f_8","issue_tracker_url":"_jm_f_9","license":"_jm_f_10","min_ansible_container_version":"_jm_f_11"}';
BEGIN
  RETURN map->>name;
END;
$$ LANGUAGE plpgsql;

-- check $GalaxyInfoModelLoose (.'$GalaxyInfoModelLoose')
CREATE OR REPLACE FUNCTION json_model_52(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  pfun TEXT;
  must_count int;
  prop TEXT;
  pval JSONB;
BEGIN
  -- some $URL should be added?
  -- .'$GalaxyInfoModelLoose'
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  must_count := 0;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = 'description' THEN
      -- handle must description property
      must_count := must_count + 1;
      -- .'$GalaxyInfoModelLoose'.description
      res := JSONB_TYPEOF(pval) = 'string';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF json_model_52_map(prop) IS NOT NULL THEN
      -- handle 6 may props
      pfun := json_model_52_map(prop);
      IF NOT jm_call(pfun, pval, NULL, rep) THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN must_count = 1;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_53_map_cloud_platforms (.'$GalaxyInfoModelStandalone'.cloud_platforms)
CREATE OR REPLACE FUNCTION _jm_f_12(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$GalaxyInfoModelStandalone'.cloud_platforms
  res := TRUE;
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_53_map_company (.'$GalaxyInfoModelStandalone'.company)
CREATE OR REPLACE FUNCTION _jm_f_13(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$GalaxyInfoModelStandalone'.company
  res := JSONB_TYPEOF(val) = 'string';
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_53_map_galaxy_tags (.'$GalaxyInfoModelStandalone'.galaxy_tags)
CREATE OR REPLACE FUNCTION _jm_f_14(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  arr_96_idx INT8;
  arr_96_item JSONB;
BEGIN
  -- .'$GalaxyInfoModelStandalone'.galaxy_tags
  res := JSONB_TYPEOF(val) = 'array';
  IF res THEN
    FOR arr_96_idx IN 0 .. JSONB_ARRAY_LENGTH(val) - 1 LOOP
      arr_96_item := val -> arr_96_idx;
      -- .'$GalaxyInfoModelStandalone'.galaxy_tags.0
      res := JSONB_TYPEOF(arr_96_item) = 'string';
      IF NOT res THEN
        EXIT;
      END IF;
    END LOOP;
  END IF;
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_53_map_github_branch (.'$GalaxyInfoModelStandalone'.github_branch)
CREATE OR REPLACE FUNCTION _jm_f_15(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$GalaxyInfoModelStandalone'.github_branch
  res := JSONB_TYPEOF(val) = 'string';
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_53_map_issue_tracker_url (.'$GalaxyInfoModelStandalone'.issue_tracker_url)
CREATE OR REPLACE FUNCTION _jm_f_16(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$GalaxyInfoModelStandalone'.issue_tracker_url
  res := JSONB_TYPEOF(val) = 'string';
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_53_map_min_ansible_container_version (.'$GalaxyInfoModelStandalone'.min_ansible_container_version)
CREATE OR REPLACE FUNCTION _jm_f_17(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$GalaxyInfoModelStandalone'.min_ansible_container_version
  res := JSONB_TYPEOF(val) = 'string';
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_53_map_namespace (.'$GalaxyInfoModelStandalone'.namespace)
CREATE OR REPLACE FUNCTION _jm_f_18(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$GalaxyInfoModelStandalone'.namespace
  -- "/^[a-z][-a-z0-9_]+$/"
  res := JSONB_TYPEOF(val) = 'string' AND _jm_re_0(JSON_VALUE(val, '$' RETURNING TEXT), path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_53_map_role_name (.'$GalaxyInfoModelStandalone'.role_name)
CREATE OR REPLACE FUNCTION _jm_f_19(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$GalaxyInfoModelStandalone'.role_name
  -- "/^[a-z][a-z0-9_]+$/"
  res := JSONB_TYPEOF(val) = 'string' AND _jm_re_1(JSON_VALUE(val, '$' RETURNING TEXT), path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_53_map_video_links (.'$GalaxyInfoModelStandalone'.video_links)
CREATE OR REPLACE FUNCTION _jm_f_20(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$GalaxyInfoModelStandalone'.video_links
  res := JSONB_TYPEOF(val) = 'array';
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION json_model_53_map(name TEXT)
RETURNS TEXT STRICT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  map JSONB := JSONB '{"cloud_platforms":"_jm_f_12","company":"_jm_f_13","galaxy_tags":"_jm_f_14","github_branch":"_jm_f_15","issue_tracker_url":"_jm_f_16","min_ansible_container_version":"_jm_f_17","namespace":"_jm_f_18","platforms":"json_model_50","role_name":"_jm_f_19","video_links":"_jm_f_20"}';
BEGIN
  RETURN map->>name;
END;
$$ LANGUAGE plpgsql;

-- check $GalaxyInfoModelStandalone (.'$GalaxyInfoModelStandalone')
CREATE OR REPLACE FUNCTION json_model_53(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  pfun TEXT;
  must_count int;
  prop TEXT;
  pval JSONB;
BEGIN
  -- .'$GalaxyInfoModelStandalone'
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  must_count := 0;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = 'standalone' THEN
      -- handle must standalone property
      must_count := must_count + 1;
      -- .'$GalaxyInfoModelStandalone'.standalone
      res := JSONB_TYPEOF(pval) = 'boolean' AND (pval)::BOOL = TRUE;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'description' THEN
      -- handle must description property
      must_count := must_count + 1;
      -- .'$GalaxyInfoModelStandalone'.description
      res := JSONB_TYPEOF(pval) = 'string';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'author' THEN
      -- handle must author property
      must_count := must_count + 1;
      -- .'$GalaxyInfoModelStandalone'.author
      res := JSONB_TYPEOF(pval) = 'string';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'license' THEN
      -- handle must license property
      must_count := must_count + 1;
      -- .'$GalaxyInfoModelStandalone'.license
      res := JSONB_TYPEOF(pval) = 'string';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'min_ansible_version' THEN
      -- handle must min_ansible_version property
      must_count := must_count + 1;
      -- .'$GalaxyInfoModelStandalone'.min_ansible_version
      res := JSONB_TYPEOF(pval) = 'string';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF json_model_53_map(prop) IS NOT NULL THEN
      -- handle 10 may props
      pfun := json_model_53_map(prop);
      IF NOT jm_call(pfun, pval, NULL, rep) THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN must_count = 5;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_47_map_author (.'$GalaxyInfoModel'.'|'.1.author)
CREATE OR REPLACE FUNCTION _jm_f_21(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$GalaxyInfoModel'.'|'.1.author
  res := JSONB_TYPEOF(val) = 'string';
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_47_map_cloud_platforms (.'$GalaxyInfoModel'.'|'.1.cloud_platforms)
CREATE OR REPLACE FUNCTION _jm_f_22(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$GalaxyInfoModel'.'|'.1.cloud_platforms
  res := TRUE;
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_47_map_company (.'$GalaxyInfoModel'.'|'.1.company)
CREATE OR REPLACE FUNCTION _jm_f_23(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$GalaxyInfoModel'.'|'.1.company
  res := JSONB_TYPEOF(val) = 'string';
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_47_map_galaxy_tags (.'$GalaxyInfoModel'.'|'.1.galaxy_tags)
CREATE OR REPLACE FUNCTION _jm_f_24(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  arr_97_idx INT8;
  arr_97_item JSONB;
BEGIN
  -- .'$GalaxyInfoModel'.'|'.1.galaxy_tags
  res := JSONB_TYPEOF(val) = 'array';
  IF res THEN
    FOR arr_97_idx IN 0 .. JSONB_ARRAY_LENGTH(val) - 1 LOOP
      arr_97_item := val -> arr_97_idx;
      -- .'$GalaxyInfoModel'.'|'.1.galaxy_tags.0
      res := JSONB_TYPEOF(arr_97_item) = 'string';
      IF NOT res THEN
        EXIT;
      END IF;
    END LOOP;
  END IF;
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_47_map_github_branch (.'$GalaxyInfoModel'.'|'.1.github_branch)
CREATE OR REPLACE FUNCTION _jm_f_25(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$GalaxyInfoModel'.'|'.1.github_branch
  res := JSONB_TYPEOF(val) = 'string';
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_47_map_issue_tracker_url (.'$GalaxyInfoModel'.'|'.1.issue_tracker_url)
CREATE OR REPLACE FUNCTION _jm_f_26(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$GalaxyInfoModel'.'|'.1.issue_tracker_url
  res := JSONB_TYPEOF(val) = 'string';
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_47_map_license (.'$GalaxyInfoModel'.'|'.1.license)
CREATE OR REPLACE FUNCTION _jm_f_27(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$GalaxyInfoModel'.'|'.1.license
  res := JSONB_TYPEOF(val) = 'string';
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_47_map_min_ansible_container_version (.'$GalaxyInfoModel'.'|'.1.min_ansible_container_version)
CREATE OR REPLACE FUNCTION _jm_f_28(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$GalaxyInfoModel'.'|'.1.min_ansible_container_version
  res := JSONB_TYPEOF(val) = 'string';
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_47_map_min_ansible_version (.'$GalaxyInfoModel'.'|'.1.min_ansible_version)
CREATE OR REPLACE FUNCTION _jm_f_29(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$GalaxyInfoModel'.'|'.1.min_ansible_version
  res := JSONB_TYPEOF(val) = 'string';
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_47_map_namespace (.'$GalaxyInfoModel'.'|'.1.namespace)
CREATE OR REPLACE FUNCTION _jm_f_30(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$GalaxyInfoModel'.'|'.1.namespace
  -- "/^[a-z][-a-z0-9_]+$/"
  res := JSONB_TYPEOF(val) = 'string' AND _jm_re_0(JSON_VALUE(val, '$' RETURNING TEXT), path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_47_map_role_name (.'$GalaxyInfoModel'.'|'.1.role_name)
CREATE OR REPLACE FUNCTION _jm_f_31(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$GalaxyInfoModel'.'|'.1.role_name
  -- "/^[a-z][a-z0-9_]+$/"
  res := JSONB_TYPEOF(val) = 'string' AND _jm_re_1(JSON_VALUE(val, '$' RETURNING TEXT), path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_47_map_video_links (.'$GalaxyInfoModel'.'|'.1.video_links)
CREATE OR REPLACE FUNCTION _jm_f_32(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$GalaxyInfoModel'.'|'.1.video_links
  res := JSONB_TYPEOF(val) = 'array';
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION _jm_obj_47_map(name TEXT)
RETURNS TEXT STRICT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  map JSONB := JSONB '{"author":"_jm_f_21","cloud_platforms":"_jm_f_22","company":"_jm_f_23","galaxy_tags":"_jm_f_24","github_branch":"_jm_f_25","issue_tracker_url":"_jm_f_26","license":"_jm_f_27","min_ansible_container_version":"_jm_f_28","min_ansible_version":"_jm_f_29","namespace":"_jm_f_30","platforms":"json_model_50","role_name":"_jm_f_31","video_links":"_jm_f_32"}';
BEGIN
  RETURN map->>name;
END;
$$ LANGUAGE plpgsql;

-- object .'$GalaxyInfoModel'.'|'.1
CREATE OR REPLACE FUNCTION _jm_obj_47(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  pfun TEXT;
  must_count int;
  prop TEXT;
  pval JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  must_count := 0;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = 'standalone' THEN
      -- handle must standalone property
      must_count := must_count + 1;
      -- .'$GalaxyInfoModel'.'|'.1.standalone
      res := JSONB_TYPEOF(pval) = 'boolean' AND (pval)::BOOL = FALSE;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'description' THEN
      -- handle must description property
      must_count := must_count + 1;
      -- .'$GalaxyInfoModel'.'|'.1.description
      res := JSONB_TYPEOF(pval) = 'string';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF _jm_obj_47_map(prop) IS NOT NULL THEN
      -- handle 13 may props
      pfun := _jm_obj_47_map(prop);
      IF NOT jm_call(pfun, pval, NULL, rep) THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN must_count = 2;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_48_map_author (.'$GalaxyInfoModel'.'|'.2.author)
CREATE OR REPLACE FUNCTION _jm_f_33(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$GalaxyInfoModel'.'|'.2.author
  res := JSONB_TYPEOF(val) = 'string';
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_48_map_cloud_platforms (.'$GalaxyInfoModel'.'|'.2.cloud_platforms)
CREATE OR REPLACE FUNCTION _jm_f_34(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$GalaxyInfoModel'.'|'.2.cloud_platforms
  res := TRUE;
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_48_map_company (.'$GalaxyInfoModel'.'|'.2.company)
CREATE OR REPLACE FUNCTION _jm_f_35(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$GalaxyInfoModel'.'|'.2.company
  res := JSONB_TYPEOF(val) = 'string';
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_48_map_galaxy_tags (.'$GalaxyInfoModel'.'|'.2.galaxy_tags)
CREATE OR REPLACE FUNCTION _jm_f_36(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  arr_98_idx INT8;
  arr_98_item JSONB;
BEGIN
  -- .'$GalaxyInfoModel'.'|'.2.galaxy_tags
  res := JSONB_TYPEOF(val) = 'array';
  IF res THEN
    FOR arr_98_idx IN 0 .. JSONB_ARRAY_LENGTH(val) - 1 LOOP
      arr_98_item := val -> arr_98_idx;
      -- .'$GalaxyInfoModel'.'|'.2.galaxy_tags.0
      res := JSONB_TYPEOF(arr_98_item) = 'string';
      IF NOT res THEN
        EXIT;
      END IF;
    END LOOP;
  END IF;
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_48_map_github_branch (.'$GalaxyInfoModel'.'|'.2.github_branch)
CREATE OR REPLACE FUNCTION _jm_f_37(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$GalaxyInfoModel'.'|'.2.github_branch
  res := JSONB_TYPEOF(val) = 'string';
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_48_map_issue_tracker_url (.'$GalaxyInfoModel'.'|'.2.issue_tracker_url)
CREATE OR REPLACE FUNCTION _jm_f_38(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$GalaxyInfoModel'.'|'.2.issue_tracker_url
  res := JSONB_TYPEOF(val) = 'string';
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_48_map_license (.'$GalaxyInfoModel'.'|'.2.license)
CREATE OR REPLACE FUNCTION _jm_f_39(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$GalaxyInfoModel'.'|'.2.license
  res := JSONB_TYPEOF(val) = 'string';
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_48_map_min_ansible_container_version (.'$GalaxyInfoModel'.'|'.2.min_ansible_container_version)
CREATE OR REPLACE FUNCTION _jm_f_40(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$GalaxyInfoModel'.'|'.2.min_ansible_container_version
  res := JSONB_TYPEOF(val) = 'string';
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_48_map_min_ansible_version (.'$GalaxyInfoModel'.'|'.2.min_ansible_version)
CREATE OR REPLACE FUNCTION _jm_f_41(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$GalaxyInfoModel'.'|'.2.min_ansible_version
  res := JSONB_TYPEOF(val) = 'string';
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_48_map_namespace (.'$GalaxyInfoModel'.'|'.2.namespace)
CREATE OR REPLACE FUNCTION _jm_f_42(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$GalaxyInfoModel'.'|'.2.namespace
  -- "/^[a-z][-a-z0-9_]+$/"
  res := JSONB_TYPEOF(val) = 'string' AND _jm_re_0(JSON_VALUE(val, '$' RETURNING TEXT), path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_48_map_role_name (.'$GalaxyInfoModel'.'|'.2.role_name)
CREATE OR REPLACE FUNCTION _jm_f_43(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$GalaxyInfoModel'.'|'.2.role_name
  -- "/^[a-z][a-z0-9_]+$/"
  res := JSONB_TYPEOF(val) = 'string' AND _jm_re_1(JSON_VALUE(val, '$' RETURNING TEXT), path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_48_map_video_links (.'$GalaxyInfoModel'.'|'.2.video_links)
CREATE OR REPLACE FUNCTION _jm_f_44(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$GalaxyInfoModel'.'|'.2.video_links
  res := JSONB_TYPEOF(val) = 'array';
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION _jm_obj_48_map(name TEXT)
RETURNS TEXT STRICT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  map JSONB := JSONB '{"author":"_jm_f_33","cloud_platforms":"_jm_f_34","company":"_jm_f_35","galaxy_tags":"_jm_f_36","github_branch":"_jm_f_37","issue_tracker_url":"_jm_f_38","license":"_jm_f_39","min_ansible_container_version":"_jm_f_40","min_ansible_version":"_jm_f_41","namespace":"_jm_f_42","platforms":"json_model_50","role_name":"_jm_f_43","video_links":"_jm_f_44"}';
BEGIN
  RETURN map->>name;
END;
$$ LANGUAGE plpgsql;

-- object .'$GalaxyInfoModel'.'|'.2
CREATE OR REPLACE FUNCTION _jm_obj_48(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  pfun TEXT;
  must_count int;
  prop TEXT;
  pval JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  must_count := 0;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = 'description' THEN
      -- handle must description property
      must_count := must_count + 1;
      -- .'$GalaxyInfoModel'.'|'.2.description
      res := JSONB_TYPEOF(pval) = 'string';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF _jm_obj_48_map(prop) IS NOT NULL THEN
      -- handle 13 may props
      pfun := _jm_obj_48_map(prop);
      IF NOT jm_call(pfun, pval, NULL, rep) THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN must_count = 1;
END;
$$ LANGUAGE PLpgSQL;


-- check $GalaxyInfoModel (.'$GalaxyInfoModel')
CREATE OR REPLACE FUNCTION json_model_54(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  iso_0 bool;
  tag_0 JSONB;
  fun_0 TEXT;
BEGIN
  -- hmmmm, property standalone should probably be required…
  -- .'$GalaxyInfoModel'
  iso_0 := JSONB_TYPEOF(val) = 'object';
  res := iso_0;
  IF res THEN
    IF val ? 'standalone' THEN
      tag_0 := val -> 'standalone';
      fun_0 := jm_cmap_get('_jm_map_0', tag_0);
      IF fun_0 IS NOT NULL THEN
        res := jm_call(fun_0, val, path, rep);
      ELSE
        res := FALSE;
      END IF;
    ELSE
      res := FALSE;
    END IF;
  END IF;
  IF NOT res THEN
    -- .'$GalaxyInfoModel'.'|'.2
    res := _jm_obj_48(val, path, rep);
  END IF;
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- regex=^[a-z_]+\.[a-z_]+$ opts=n
CREATE OR REPLACE FUNCTION _jm_re_2(val TEXT, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  RETURN regexp_like(val, '^[a-z_]+\.[a-z_]+$', 'n');
END;
$$ LANGUAGE plpgsql;

-- check $collections (.'$collections')
CREATE OR REPLACE FUNCTION json_model_55(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  arr_99_idx INT8;
  arr_99_item JSONB;
BEGIN
  -- .'$collections'
  res := JSONB_TYPEOF(val) = 'array';
  IF res THEN
    FOR arr_99_idx IN 0 .. JSONB_ARRAY_LENGTH(val) - 1 LOOP
      arr_99_item := val -> arr_99_idx;
      -- .'$collections'.0
      -- "/^[a-z_]+\\.[a-z_]+$/"
      res := JSONB_TYPEOF(arr_99_item) = 'string' AND _jm_re_2(JSON_VALUE(arr_99_item, '$' RETURNING TEXT), NULL, rep);
      IF NOT res THEN
        EXIT;
      END IF;
    END LOOP;
  END IF;
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check $complex_conditional (.'$complex_conditional')
CREATE OR REPLACE FUNCTION json_model_56(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  arr_100_idx INT8;
  arr_100_item JSONB;
BEGIN
  -- .'$complex_conditional'
  -- .'$complex_conditional'.'|'.0
  res := JSONB_TYPEOF(val) = 'boolean';
  IF NOT res THEN
    -- .'$complex_conditional'.'|'.1
    res := JSONB_TYPEOF(val) = 'string';
    IF NOT res THEN
      -- .'$complex_conditional'.'|'.2
      res := JSONB_TYPEOF(val) = 'array';
      IF res THEN
        FOR arr_100_idx IN 0 .. JSONB_ARRAY_LENGTH(val) - 1 LOOP
          arr_100_item := val -> arr_100_idx;
          -- .'$complex_conditional'.'|'.2.0
          res := JSONB_TYPEOF(arr_100_item) = 'string';
          IF NOT res THEN
            EXIT;
          END IF;
        END LOOP;
      END IF;
    END IF;
  END IF;
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_57_map_become (.'$DependencyModelLoose'.become)
CREATE OR REPLACE FUNCTION _jm_f_45(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$DependencyModelLoose'.become
  res := JSONB_TYPEOF(val) = 'boolean';
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_57_map_name (.'$DependencyModelLoose'.name)
CREATE OR REPLACE FUNCTION _jm_f_46(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$DependencyModelLoose'.name
  res := JSONB_TYPEOF(val) = 'string';
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_57_map_role (.'$DependencyModelLoose'.role)
CREATE OR REPLACE FUNCTION _jm_f_47(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$DependencyModelLoose'.role
  res := JSONB_TYPEOF(val) = 'string';
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION _jm_cst_64(value JSONB)
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  constants JSONB = JSONB '["hg","git"]';
BEGIN
  RETURN constants @> value;
END;
$$ LANGUAGE plpgsql;

-- check json_model_57_map_scm (.'$DependencyModelLoose'.scm)
CREATE OR REPLACE FUNCTION _jm_f_48(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$DependencyModelLoose'.scm
  res := JSONB_TYPEOF(val) IN ('null', 'boolean', 'number', 'string') AND _jm_cst_64(val);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_57_map_src (.'$DependencyModelLoose'.src)
CREATE OR REPLACE FUNCTION _jm_f_49(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$DependencyModelLoose'.src
  res := JSONB_TYPEOF(val) = 'string';
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_57_map_tags (.'$DependencyModelLoose'.tags)
CREATE OR REPLACE FUNCTION _jm_f_50(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  arr_101_idx INT8;
  arr_101_item JSONB;
BEGIN
  -- .'$DependencyModelLoose'.tags
  -- .'$DependencyModelLoose'.tags.'|'.0
  res := JSONB_TYPEOF(val) = 'string';
  IF NOT res THEN
    -- .'$DependencyModelLoose'.tags.'|'.1
    res := JSONB_TYPEOF(val) = 'array';
    IF res THEN
      FOR arr_101_idx IN 0 .. JSONB_ARRAY_LENGTH(val) - 1 LOOP
        arr_101_item := val -> arr_101_idx;
        -- .'$DependencyModelLoose'.tags.'|'.1.0
        res := JSONB_TYPEOF(arr_101_item) = 'string';
        IF NOT res THEN
          EXIT;
        END IF;
      END LOOP;
    END IF;
  END IF;
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_57_map_vars (.'$DependencyModelLoose'.vars)
CREATE OR REPLACE FUNCTION _jm_f_51(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  -- .'$DependencyModelLoose'.vars
  -- accept any object
  RETURN JSONB_TYPEOF(val) = 'object';
END;
$$ LANGUAGE PLpgSQL;

-- check json_model_57_map_version (.'$DependencyModelLoose'.version)
CREATE OR REPLACE FUNCTION _jm_f_52(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$DependencyModelLoose'.version
  res := JSONB_TYPEOF(val) = 'string';
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION json_model_57_map(name TEXT)
RETURNS TEXT STRICT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  map JSONB := JSONB '{"become":"_jm_f_45","name":"_jm_f_46","role":"_jm_f_47","scm":"_jm_f_48","src":"_jm_f_49","tags":"_jm_f_50","vars":"_jm_f_51","version":"_jm_f_52","when":"json_model_56"}';
BEGIN
  RETURN map->>name;
END;
$$ LANGUAGE plpgsql;

-- check $DependencyModelLoose (.'$DependencyModelLoose')
CREATE OR REPLACE FUNCTION json_model_57(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  pfun TEXT;
  prop TEXT;
  pval JSONB;
BEGIN
  -- See https://docs.ansible.com/ansible/latest/playbook_guide/playbooks_reuse_roles.html#role-dependencies and https://github.com/ansible/ansible/blob/devel/lib/ansible/playbook/role/metadata.py#L79
  -- 
  -- Other keys are treated as role [parameters](https://docs.ansible.com/ansible/latest/user_guide/playbooks_reuse_roles.html#passing-different-parameters).
  -- .'$DependencyModelLoose'
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF json_model_57_map(prop) IS NOT NULL THEN
      -- handle 9 may props
      pfun := json_model_57_map(prop);
      IF NOT jm_call(pfun, pval, NULL, rep) THEN
        RETURN FALSE;
      END IF;
    ELSE
      -- accept any other props
      NULL;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- object .'$DependencyModel'.'&'.1.'|'.2
CREATE OR REPLACE FUNCTION _jm_obj_49(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  pval JSONB;
  res bool;
BEGIN
  -- check open must/may only props
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  IF NOT val ? 'name' THEN
    RETURN FALSE;
  END IF;
  pval := val -> 'name';
  -- .'$DependencyModel'.'&'.1.'|'.2.name
  res := JSONB_TYPEOF(pval) = 'string';
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- object .'$DependencyModel'.'&'.1.'|'.1
CREATE OR REPLACE FUNCTION _jm_obj_50(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  pval JSONB;
  res bool;
BEGIN
  -- check open must/may only props
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  IF NOT val ? 'src' THEN
    RETURN FALSE;
  END IF;
  pval := val -> 'src';
  -- .'$DependencyModel'.'&'.1.'|'.1.src
  res := JSONB_TYPEOF(pval) = 'string';
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- object .'$DependencyModel'.'&'.1.'|'.0
CREATE OR REPLACE FUNCTION _jm_obj_51(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  pval JSONB;
  res bool;
BEGIN
  -- check open must/may only props
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  IF NOT val ? 'role' THEN
    RETURN FALSE;
  END IF;
  pval := val -> 'role';
  -- .'$DependencyModel'.'&'.1.'|'.0.role
  res := JSONB_TYPEOF(pval) = 'string';
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check $DependencyModel (.'$DependencyModel')
CREATE OR REPLACE FUNCTION json_model_58(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- add non-exclusive mandatory role, src or name props
  -- .'$DependencyModel'
  res := TRUE;
  IF res THEN
    -- .'$DependencyModel'.'&'.0
    res := json_model_57(val, path, rep);
    IF res THEN
      -- .'$DependencyModel'.'&'.1
      res := JSONB_TYPEOF(val) = 'object';
      IF res THEN
        -- .'$DependencyModel'.'&'.1.'|'.0
        res := _jm_obj_51(val, path, rep);
        IF NOT res THEN
          -- .'$DependencyModel'.'&'.1.'|'.1
          res := _jm_obj_50(val, path, rep);
          IF NOT res THEN
            -- .'$DependencyModel'.'&'.1.'|'.2
            res := _jm_obj_49(val, path, rep);
          END IF;
        END IF;
      END IF;
    END IF;
  END IF;
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check $AnsibleMetaObj (.'$AnsibleMetaObj')
CREATE OR REPLACE FUNCTION json_model_59(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
  arr_102_idx INT8;
  arr_102_item JSONB;
BEGIN
  -- .'$AnsibleMetaObj'
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = 'allow_duplicates' THEN
      -- handle may allow_duplicates property
      -- .'$AnsibleMetaObj'.allow_duplicates
      res := JSONB_TYPEOF(pval) = 'boolean';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'collections' THEN
      -- handle may collections property
      -- .'$AnsibleMetaObj'.collections
      res := json_model_55(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'dependencies' THEN
      -- handle may dependencies property
      -- .'$AnsibleMetaObj'.dependencies
      res := JSONB_TYPEOF(pval) = 'array';
      IF res THEN
        FOR arr_102_idx IN 0 .. JSONB_ARRAY_LENGTH(pval) - 1 LOOP
          arr_102_item := pval -> arr_102_idx;
          -- .'$AnsibleMetaObj'.dependencies.0
          -- .'$AnsibleMetaObj'.dependencies.0.'|'.0
          res := JSONB_TYPEOF(arr_102_item) = 'string';
          IF NOT res THEN
            -- .'$AnsibleMetaObj'.dependencies.0.'|'.1
            res := json_model_58(arr_102_item, NULL, rep);
          END IF;
          IF NOT res THEN
            EXIT;
          END IF;
        END LOOP;
      END IF;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = 'galaxy_info' THEN
      -- handle may galaxy_info property
      -- .'$AnsibleMetaObj'.galaxy_info
      res := json_model_54(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check $AnsibleMeta (.'$AnsibleMeta')
CREATE OR REPLACE FUNCTION json_model_60(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- why null?
  -- .'$AnsibleMeta'
  -- .'$AnsibleMeta'.'|'.0
  res := JSONB_TYPEOF(val) = 'null';
  IF NOT res THEN
    -- .'$AnsibleMeta'.'|'.1
    res := json_model_59(val, path, rep);
  END IF;
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check $ (.)
CREATE OR REPLACE FUNCTION json_model_1(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .
  res := json_model_60(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION check_model_map(name TEXT)
RETURNS TEXT STRICT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  map JSONB := JSONB '{"":"json_model_60","AIXPlatformModel":"json_model_2","AlpinePlatformModel":"json_model_3","AmazonLinuxPlatformModel":"json_model_4","AmazonPlatformModel":"json_model_5","ArchLinuxPlatformModel":"json_model_6","AstraLinuxPlatformModel":"json_model_7","ClearLinuxPlatformModel":"json_model_8","CumulusPlatformModel":"json_model_9","DebianPlatformModel":"json_model_10","DellOSPlatformModel":"json_model_11","DevuanPlatformModel":"json_model_12","DragonFlyBSDPlatformModel":"json_model_13","ELPlatformModel":"json_model_14","FedoraPlatformModel":"json_model_15","FreeBSDPlatformModel":"json_model_16","GenericBSDPlatformModel":"json_model_17","GenericLinuxPlatformModel":"json_model_18","GenericUNIXPlatformModel":"json_model_19","GentooPlatformModel":"json_model_20","HardenedBSDPlatformModel":"json_model_21","IOSPlatformModel":"json_model_22","JunosPlatformModel":"json_model_23","KaliPlatformModel":"json_model_24","MacOSXPlatformModel":"json_model_25","MageiaPlatformModel":"json_model_26","NXOSPlatformModel":"json_model_27","NetBSDPlatformModel":"json_model_28","OpenBSDPlatformModel":"json_model_29","OpenWrtPlatformModel":"json_model_30","OracleLinuxPlatformModel":"json_model_31","PAN-OSPlatformModel":"json_model_32","RockyLinuxPlatformModel":"json_model_33","SLESPlatformModel":"json_model_34","SmartOSPlatformModel":"json_model_35","SolarisPlatformModel":"json_model_36","SynologyPlatformModel":"json_model_37","TMOSPlatformModel":"json_model_38","UbuntuPlatformModel":"json_model_39","Void_LinuxPlatformModel":"json_model_40","WindowsPlatformModel":"json_model_41","aosPlatformModel":"json_model_42","eosPlatformModel":"json_model_43","macOSPlatformModel":"json_model_44","opensusePlatformModel":"json_model_45","os10PlatformModel":"json_model_46","vCenterPlatformModel":"json_model_47","vSpherePlatformModel":"json_model_48","any_platform":"json_model_49","platforms":"json_model_50","GalaxyInfoModelCollection":"json_model_51","GalaxyInfoModelLoose":"json_model_52","GalaxyInfoModelStandalone":"json_model_53","GalaxyInfoModel":"json_model_54","collections":"json_model_55","complex_conditional":"json_model_56","DependencyModelLoose":"json_model_57","DependencyModel":"json_model_58","AnsibleMetaObj":"json_model_59","AnsibleMeta":"json_model_60"}';
BEGIN
  RETURN map->>name;
END;
$$ LANGUAGE plpgsql;

--
-- constant maps initialization
--
TRUNCATE jm_constant_maps;
INSERT INTO jm_constant_maps(mapname, tagval, value) VALUES
  ('_jm_map_0', JSONB 'true', 'json_model_53'),
  ('_jm_map_0', JSONB 'false', '_jm_obj_47')
;

--
-- JSON Model checking entry point
--
-- TODO INOUT rep?
CREATE OR REPLACE FUNCTION check_model(val JSONB, name TEXT, rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  fun TEXT;
BEGIN
  fun := check_model_map(name);
  IF fun IS NULL THEN
    RAISE EXCEPTION 'model for % not found', name;
  END IF;
  RETURN jm_call(fun, val, NULL, rep);
END;
$$ LANGUAGE plpgsql;
