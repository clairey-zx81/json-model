//
// Generated by JSON Model Compiler version 2.0b1
// see https://github.com/clairey-zx81/json-model
//

// regular expression engine
#include <stddef.h>
#include <cre2.h>

#include <json-model.h>
#define JSON_MODEL_VERSION "2.0b1"

static jm_constant_t _jm_cst_0[13];
static cre2_regexp_t *_jm_re_0_re2 = NULL;
static int _jm_re_0_nn = 0;
static bool _jm_re_0(const char *s, jm_path_t *path, jm_report_t *rep);
static bool json_model_2(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool json_model_3(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool json_model_4(const json_t *val, jm_path_t *path, jm_report_t *rep);
static jm_constant_t _jm_cst_1[4];
static bool json_model_5(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool json_model_6(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool json_model_7(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool json_model_8(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool json_model_9(const json_t *val, jm_path_t *path, jm_report_t *rep);
static jm_constant_t _jm_cst_2[7];
static jm_constmap_t _jm_map_0_tab[4];
static bool json_model_10(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_0(const json_t *val, jm_path_t *path, jm_report_t *rep);
static jm_constant_t _jm_cst_3[13];
static bool _jm_f_2(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_3(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_4(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_5(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_6(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_7(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_8(const json_t *val, jm_path_t *path, jm_report_t *rep);
static jm_propmap_t _jm_obj_8_map_tab[7];
static bool _jm_f_1(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_9(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_11(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_12(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_13(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_14(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_15(const json_t *val, jm_path_t *path, jm_report_t *rep);
static cre2_regexp_t *_jm_re_1_re2 = NULL;
static int _jm_re_1_nn = 0;
static bool _jm_re_1(const char *s, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_16(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_17(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_18(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_19(const json_t *val, jm_path_t *path, jm_report_t *rep);
static jm_constant_t _jm_cst_4[4];
static jm_constant_t _jm_cst_5[3];
static bool _jm_f_20(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_21(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_22(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_23(const json_t *val, jm_path_t *path, jm_report_t *rep);
static jm_constant_t _jm_cst_6[2];
static bool _jm_f_24(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_25(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_26(const json_t *val, jm_path_t *path, jm_report_t *rep);
static jm_propmap_t _jm_obj_10_map_tab[16];
static bool _jm_f_10(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_28(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_29(const json_t *val, jm_path_t *path, jm_report_t *rep);
static jm_constant_t _jm_cst_7[4];
static bool _jm_f_30(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_31(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_32(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_33(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_34(const json_t *val, jm_path_t *path, jm_report_t *rep);
static jm_constant_t _jm_cst_8[9];
static bool _jm_f_35(const json_t *val, jm_path_t *path, jm_report_t *rep);
static jm_constant_t _jm_cst_9[3];
static bool _jm_f_36(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_37(const json_t *val, jm_path_t *path, jm_report_t *rep);
static jm_constant_t _jm_cst_10[2];
static bool _jm_f_38(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_39(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_40(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_41(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_42(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_43(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_44(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_45(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_46(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_47(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_48(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_49(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_50(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_51(const json_t *val, jm_path_t *path, jm_report_t *rep);
static jm_constant_t _jm_cst_11[2];
static bool _jm_f_52(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_54(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_55(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_56(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_57(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_58(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_59(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_60(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_61(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_62(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_63(const json_t *val, jm_path_t *path, jm_report_t *rep);
static jm_propmap_t _jm_obj_21_map_tab[10];
static bool _jm_f_53(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_64(const json_t *val, jm_path_t *path, jm_report_t *rep);
static jm_constant_t _jm_cst_12[3];
static bool _jm_f_65(const json_t *val, jm_path_t *path, jm_report_t *rep);
static jm_propmap_t _jm_obj_17_map_tab[28];
static bool _jm_f_27(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_68(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_69(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_70(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_71(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_72(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_73(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_74(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_75(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_76(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_77(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_78(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_79(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_80(const json_t *val, jm_path_t *path, jm_report_t *rep);
static jm_propmap_t _jm_obj_23_map_tab[13];
static bool _jm_f_67(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_81(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_83(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_84(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_85(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_86(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_87(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_88(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_89(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_90(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_91(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_92(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_93(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_94(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_95(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_96(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_97(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_98(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_99(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_100(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_101(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_102(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_103(const json_t *val, jm_path_t *path, jm_report_t *rep);
static jm_propmap_t _jm_obj_25_map_tab[21];
static bool _jm_f_82(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_105(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_106(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_107(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_108(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_109(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_110(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_111(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_112(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_113(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_114(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_115(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_116(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_117(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_118(const json_t *val, jm_path_t *path, jm_report_t *rep);
static jm_propmap_t _jm_obj_26_map_tab[14];
static bool _jm_f_104(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_119(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_120(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_121(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_122(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_124(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_125(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_126(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_127(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_128(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_129(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_130(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_131(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_132(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_133(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_134(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_135(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_136(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_137(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_138(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_139(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_140(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_141(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_142(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_143(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_144(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_145(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_146(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_147(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_148(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_149(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_150(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_151(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_152(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_153(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_154(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_155(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_156(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_157(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_158(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_159(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_160(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_161(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_162(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_163(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_164(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_165(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_166(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_167(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_168(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_169(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_170(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_171(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_172(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_173(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_174(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_175(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_176(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_177(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_178(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_179(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_180(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_181(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_182(const json_t *val, jm_path_t *path, jm_report_t *rep);
static jm_propmap_t _jm_obj_31_map_tab[59];
static bool _jm_f_123(const json_t *val, jm_path_t *path, jm_report_t *rep);
static jm_propmap_t _jm_obj_22_map_tab[9];
static bool _jm_f_66(const json_t *val, jm_path_t *path, jm_report_t *rep);
static jm_constant_t _jm_cst_13[4];
static bool _jm_f_183(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_185(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_186(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_187(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_188(const json_t *val, jm_path_t *path, jm_report_t *rep);
static jm_constant_t _jm_cst_14[10];
static bool _jm_f_189(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_190(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_191(const json_t *val, jm_path_t *path, jm_report_t *rep);
static jm_propmap_t _jm_obj_32_map_tab[7];
static bool _jm_f_184(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_192(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_193(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_194(const json_t *val, jm_path_t *path, jm_report_t *rep);
static cre2_regexp_t *_jm_re_2_re2 = NULL;
static int _jm_re_2_nn = 0;
static bool _jm_re_2(const char *s, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_195(const json_t *val, jm_path_t *path, jm_report_t *rep);
static jm_constant_t _jm_cst_15[3];
static bool _jm_f_196(const json_t *val, jm_path_t *path, jm_report_t *rep);
static jm_propmap_t _jm_obj_7_map_tab[13];
static bool json_model_1(const json_t *val, jm_path_t *path, jm_report_t *rep);
jm_propmap_t check_model_map_tab[10];
const size_t check_model_map_size = 10;

static bool _jm_re_0(const char *s, jm_path_t *path, jm_report_t *rep)
{
    size_t slen = strlen(s);
    return cre2_match(_jm_re_0_re2, s, slen, 0, slen, CRE2_UNANCHORED, NULL, 0);
}

// check $color (.'$color')
static bool json_model_2(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .'$color'
    res = jm_json_is_scalar(val) && json_is_string(val) && jm_search_cst(&(jm_constant_t) { cst_is_string, { .s = json_string_value(val) } }, _jm_cst_0, 13);;
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "value not in enum [.'$color'.'|']", path);
    }
    if (! res)
    {
        res = json_is_string(val);
        if (! res)
        {
            if (rep) jm_report_add_entry(rep, "unexpected type [.'$color'.'|']", path);
        }
        if (res)
        {
            // .'$color'.'|'.0
            // "/^#[0-9a-fA-F]{6}$/"
            res = _jm_re_0(json_string_value(val), path, rep);
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "unexpected /^#[0-9a-fA-F]{6}$/ [.'$color'.'|'.0]", path);
            }
            if (res)
            {
                if (rep) jm_report_free_entries(rep);
            }
            else
            {
                if (rep) jm_report_add_entry(rep, "no model matched [.'$color'.'|']", path);
            }
        }
    }
    return res;
}

// check $colorArray (.'$colorArray')
static bool json_model_3(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .'$colorArray'
    // .'$colorArray'.'@'
    res = json_is_array(val);
    if (res)
    {
        size_t arr_0_idx;
        json_t *arr_0_item;
        json_array_foreach(val, arr_0_idx, arr_0_item)
        {
            jm_path_t arr_0_lpath = (jm_path_t) { NULL, arr_0_idx, path, NULL };
            // .'$colorArray'.'@'.0
            res = json_model_2(arr_0_item, (path ? &arr_0_lpath : NULL), rep);
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "unexpected $color [.'$colorArray'.'@'.0]", (path ? &arr_0_lpath : NULL));
            }
            if (! res)
            {
                break;
            }
        }
    }
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "not array or unexpected array [.'$colorArray'.'@']", path);
    }
    if (res)
    {
        int64_t ival_0 = json_array_size(val);
        res = jm_array_is_unique(val, path, rep) && ival_0 >= 1;
        if (! res)
        {
            if (rep) jm_report_add_entry(rep, "constraints failed [.'$colorArray']", path);
        }
    }
    return res;
}

// check $keybinding (.'$keybinding')
static bool json_model_4(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .'$keybinding'
    // .'$keybinding'.'|'.0
    res = json_is_null(val);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "not null [.'$keybinding'.'|'.0]", path);
    }
    if (! res)
    {
        // .'$keybinding'.'|'.1
        res = json_is_string(val);
        if (! res)
        {
            if (rep) jm_report_add_entry(rep, "unexpected string [.'$keybinding'.'|'.1]", path);
        }
    }
    if (res)
    {
        if (rep) jm_report_free_entries(rep);
    }
    else
    {
        if (rep) jm_report_add_entry(rep, "no model matched [.'$keybinding'.'|']", path);
    }
    return res;
}


// check $custom-commands-prompts-type-property (.'$custom-commands-prompts-type-property')
static bool json_model_5(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .'$custom-commands-prompts-type-property'
    res = jm_json_is_scalar(val) && json_is_string(val) && jm_search_cst(&(jm_constant_t) { cst_is_string, { .s = json_string_value(val) } }, _jm_cst_1, 4);;
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "value not in enum [.'$custom-commands-prompts-type-property'.'|']", path);
    }
    return res;
}

// check $custom-commands-prompts-title-property (.'$custom-commands-prompts-title-property')
static bool json_model_6(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .'$custom-commands-prompts-title-property'
    res = json_is_string(val);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected string [.'$custom-commands-prompts-title-property']", path);
    }
    return res;
}

// check $custom-commands-prompts-key-property (.'$custom-commands-prompts-key-property')
static bool json_model_7(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .'$custom-commands-prompts-key-property'
    res = json_is_string(val);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected string [.'$custom-commands-prompts-key-property']", path);
    }
    return res;
}

// check $neString (.'$neString')
static bool json_model_8(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .'$neString'
    // .'$neString'.'@'
    res = json_is_string(val);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected string [.'$neString'.'@']", path);
    }
    if (res)
    {
        int64_t ival_1 = mbstowcs(NULL, json_string_value(val), 0);
        res = ival_1 >= 1;
        if (! res)
        {
            if (rep) jm_report_add_entry(rep, "constraints failed [.'$neString']", path);
        }
    }
    return res;
}

// check $stringArray (.'$stringArray')
static bool json_model_9(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .'$stringArray'
    // .'$stringArray'.'@'
    res = json_is_array(val);
    if (res)
    {
        size_t arr_1_idx;
        json_t *arr_1_item;
        json_array_foreach(val, arr_1_idx, arr_1_item)
        {
            jm_path_t arr_1_lpath = (jm_path_t) { NULL, arr_1_idx, path, NULL };
            // .'$stringArray'.'@'.0
            res = json_model_8(arr_1_item, (path ? &arr_1_lpath : NULL), rep);
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "unexpected $neString [.'$stringArray'.'@'.0]", (path ? &arr_1_lpath : NULL));
            }
            if (! res)
            {
                break;
            }
        }
    }
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "not array or unexpected array [.'$stringArray'.'@']", path);
    }
    if (res)
    {
        res = jm_array_is_unique(val, path, rep);
        if (! res)
        {
            if (rep) jm_report_add_entry(rep, "constraints failed [.'$stringArray']", path);
        }
    }
    return res;
}

// object .'$Prompts'.'|'.0.suggestions.'|'.1
static bool _jm_obj_1(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    if (! json_is_object(val))
    {
        if (rep) jm_report_add_entry(rep, "not an object [.'$Prompts'.'|'.0.suggestions.'|'.1]", path);
        return false;
    }
    bool res;
    int64_t must_count = 0;
    const char *prop;
    json_t *pval;
    json_object_foreach((json_t *) val, prop, pval)
    {
        jm_path_t lpath_1 = (jm_path_t) { prop, 0, path, NULL };
        if (strcmp(prop, "command") == 0)
        {
            // handle must command property
            must_count += 1;
            // .'$Prompts'.'|'.0.suggestions.'|'.1.command
            res = json_is_string(pval);
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "unexpected string [.'$Prompts'.'|'.0.suggestions.'|'.1.command]", (path ? &lpath_1 : NULL));
            }
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "invalid mandatory prop value [.'$Prompts'.'|'.0.suggestions.'|'.1.command]", (path ? &lpath_1 : NULL));
                return false;
            }
        }
        else
        {
            if (rep) jm_report_add_entry(rep, "unexpected prop [.'$Prompts'.'|'.0.suggestions.'|'.1]", (path ? &lpath_1 : NULL));
            return false;
        }
    }
    if (must_count != 1)
    {
        if (rep != NULL)
        {
            if (! (json_object_get(val, "command") != NULL))
            {
                if (rep) jm_report_add_entry(rep, "missing mandatory prop <command> [.'$Prompts'.'|'.0.suggestions.'|'.1]", path);
            }
        }
        return false;
    }
    return true;
}


// object .'$Prompts'.'|'.0.suggestions.'|'.0
static bool _jm_obj_2(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    if (! json_is_object(val))
    {
        if (rep) jm_report_add_entry(rep, "not an object [.'$Prompts'.'|'.0.suggestions.'|'.0]", path);
        return false;
    }
    bool res;
    int64_t must_count = 0;
    const char *prop;
    json_t *pval;
    json_object_foreach((json_t *) val, prop, pval)
    {
        jm_path_t lpath_2 = (jm_path_t) { prop, 0, path, NULL };
        if (strcmp(prop, "preset") == 0)
        {
            // handle must preset property
            must_count += 1;
            // .'$Prompts'.'|'.0.suggestions.'|'.0.preset
            res = jm_json_is_scalar(pval) && json_is_string(pval) && jm_search_cst(&(jm_constant_t) { cst_is_string, { .s = json_string_value(pval) } }, _jm_cst_2, 7);;
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "value not in enum [.'$Prompts'.'|'.0.suggestions.'|'.0.preset.'|']", (path ? &lpath_2 : NULL));
            }
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "invalid mandatory prop value [.'$Prompts'.'|'.0.suggestions.'|'.0.preset]", (path ? &lpath_2 : NULL));
                return false;
            }
        }
        else
        {
            if (rep) jm_report_add_entry(rep, "unexpected prop [.'$Prompts'.'|'.0.suggestions.'|'.0]", (path ? &lpath_2 : NULL));
            return false;
        }
    }
    if (must_count != 1)
    {
        if (rep != NULL)
        {
            if (! (json_object_get(val, "preset") != NULL))
            {
                if (rep) jm_report_add_entry(rep, "missing mandatory prop <preset> [.'$Prompts'.'|'.0.suggestions.'|'.0]", path);
            }
        }
        return false;
    }
    return true;
}

// object .'$Prompts'.'|'.0
static bool _jm_obj_0(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    if (! json_is_object(val))
    {
        if (rep) jm_report_add_entry(rep, "not an object [.'$Prompts'.'|'.0]", path);
        return false;
    }
    bool res;
    int64_t must_count = 0;
    const char *prop;
    json_t *pval;
    json_object_foreach((json_t *) val, prop, pval)
    {
        jm_path_t lpath_0 = (jm_path_t) { prop, 0, path, NULL };
        if (strcmp(prop, "type") == 0)
        {
            // handle must type property
            must_count += 1;
            // .'$Prompts'.'|'.0.type
            res = json_is_string(pval) && strcmp(json_string_value(pval), "input") == 0;
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "unexpected input [.'$Prompts'.'|'.0.type]", (path ? &lpath_0 : NULL));
            }
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "invalid mandatory prop value [.'$Prompts'.'|'.0.type]", (path ? &lpath_0 : NULL));
                return false;
            }
        }
        else if (strcmp(prop, "title") == 0)
        {
            // handle must title property
            must_count += 1;
            // .'$Prompts'.'|'.0.title
            res = json_model_6(pval, (path ? &lpath_0 : NULL), rep);
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "unexpected $custom-commands-prompts-title-property [.'$Prompts'.'|'.0.title]", (path ? &lpath_0 : NULL));
            }
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "invalid mandatory prop value [.'$Prompts'.'|'.0.title]", (path ? &lpath_0 : NULL));
                return false;
            }
        }
        else if (strcmp(prop, "key") == 0)
        {
            // handle must key property
            must_count += 1;
            // .'$Prompts'.'|'.0.key
            res = json_model_7(pval, (path ? &lpath_0 : NULL), rep);
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "unexpected $custom-commands-prompts-key-property [.'$Prompts'.'|'.0.key]", (path ? &lpath_0 : NULL));
            }
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "invalid mandatory prop value [.'$Prompts'.'|'.0.key]", (path ? &lpath_0 : NULL));
                return false;
            }
        }
        else if (strcmp(prop, "initialValue") == 0)
        {
            // handle may initialValue property
            // .'$Prompts'.'|'.0.initialValue
            res = json_is_string(pval);
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "unexpected string [.'$Prompts'.'|'.0.initialValue]", (path ? &lpath_0 : NULL));
            }
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "invalid optional prop value [.'$Prompts'.'|'.0.initialValue]", (path ? &lpath_0 : NULL));
                return false;
            }
        }
        else if (strcmp(prop, "suggestions") == 0)
        {
            // handle may suggestions property
            // .'$Prompts'.'|'.0.suggestions
            res = json_is_object(pval);
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "unexpected type [.'$Prompts'.'|'.0.suggestions.'|']", (path ? &lpath_0 : NULL));
            }
            if (res)
            {
                // .'$Prompts'.'|'.0.suggestions.'|'.0
                res = _jm_obj_2(pval, (path ? &lpath_0 : NULL), rep);
                if (! res)
                {
                    if (rep) jm_report_add_entry(rep, "unexpected element [.'$Prompts'.'|'.0.suggestions.'|'.0]", (path ? &lpath_0 : NULL));
                }
                if (! res)
                {
                    // .'$Prompts'.'|'.0.suggestions.'|'.1
                    res = _jm_obj_1(pval, (path ? &lpath_0 : NULL), rep);
                    if (! res)
                    {
                        if (rep) jm_report_add_entry(rep, "unexpected element [.'$Prompts'.'|'.0.suggestions.'|'.1]", (path ? &lpath_0 : NULL));
                    }
                }
                if (res)
                {
                    if (rep) jm_report_free_entries(rep);
                }
                else
                {
                    if (rep) jm_report_add_entry(rep, "no model matched [.'$Prompts'.'|'.0.suggestions.'|']", (path ? &lpath_0 : NULL));
                }
            }
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "invalid optional prop value [.'$Prompts'.'|'.0.suggestions]", (path ? &lpath_0 : NULL));
                return false;
            }
        }
        else
        {
            if (rep) jm_report_add_entry(rep, "unexpected prop [.'$Prompts'.'|'.0]", (path ? &lpath_0 : NULL));
            return false;
        }
    }
    if (must_count != 3)
    {
        if (rep != NULL)
        {
            if (! (json_object_get(val, "key") != NULL))
            {
                if (rep) jm_report_add_entry(rep, "missing mandatory prop <key> [.'$Prompts'.'|'.0]", path);
            }
            if (! (json_object_get(val, "title") != NULL))
            {
                if (rep) jm_report_add_entry(rep, "missing mandatory prop <title> [.'$Prompts'.'|'.0]", path);
            }
            if (! (json_object_get(val, "type") != NULL))
            {
                if (rep) jm_report_add_entry(rep, "missing mandatory prop <type> [.'$Prompts'.'|'.0]", path);
            }
        }
        return false;
    }
    return true;
}

// object .'$Prompts'.'|'.1
static bool _jm_obj_3(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    if (! json_is_object(val))
    {
        if (rep) jm_report_add_entry(rep, "not an object [.'$Prompts'.'|'.1]", path);
        return false;
    }
    bool res;
    int64_t must_count = 0;
    const char *prop;
    json_t *pval;
    json_object_foreach((json_t *) val, prop, pval)
    {
        jm_path_t lpath_3 = (jm_path_t) { prop, 0, path, NULL };
        if (strcmp(prop, "type") == 0)
        {
            // handle must type property
            must_count += 1;
            // .'$Prompts'.'|'.1.type
            res = json_is_string(pval) && strcmp(json_string_value(pval), "confirm") == 0;
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "unexpected confirm [.'$Prompts'.'|'.1.type]", (path ? &lpath_3 : NULL));
            }
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "invalid mandatory prop value [.'$Prompts'.'|'.1.type]", (path ? &lpath_3 : NULL));
                return false;
            }
        }
        else if (strcmp(prop, "title") == 0)
        {
            // handle must title property
            must_count += 1;
            // .'$Prompts'.'|'.1.title
            res = json_model_6(pval, (path ? &lpath_3 : NULL), rep);
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "unexpected $custom-commands-prompts-title-property [.'$Prompts'.'|'.1.title]", (path ? &lpath_3 : NULL));
            }
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "invalid mandatory prop value [.'$Prompts'.'|'.1.title]", (path ? &lpath_3 : NULL));
                return false;
            }
        }
        else if (strcmp(prop, "key") == 0)
        {
            // handle must key property
            must_count += 1;
            // .'$Prompts'.'|'.1.key
            res = json_model_7(pval, (path ? &lpath_3 : NULL), rep);
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "unexpected $custom-commands-prompts-key-property [.'$Prompts'.'|'.1.key]", (path ? &lpath_3 : NULL));
            }
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "invalid mandatory prop value [.'$Prompts'.'|'.1.key]", (path ? &lpath_3 : NULL));
                return false;
            }
        }
        else if (strcmp(prop, "body") == 0)
        {
            // handle may body property
            // .'$Prompts'.'|'.1.body
            res = json_is_string(pval);
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "unexpected string [.'$Prompts'.'|'.1.body]", (path ? &lpath_3 : NULL));
            }
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "invalid optional prop value [.'$Prompts'.'|'.1.body]", (path ? &lpath_3 : NULL));
                return false;
            }
        }
        else
        {
            if (rep) jm_report_add_entry(rep, "unexpected prop [.'$Prompts'.'|'.1]", (path ? &lpath_3 : NULL));
            return false;
        }
    }
    if (must_count != 3)
    {
        if (rep != NULL)
        {
            if (! (json_object_get(val, "key") != NULL))
            {
                if (rep) jm_report_add_entry(rep, "missing mandatory prop <key> [.'$Prompts'.'|'.1]", path);
            }
            if (! (json_object_get(val, "title") != NULL))
            {
                if (rep) jm_report_add_entry(rep, "missing mandatory prop <title> [.'$Prompts'.'|'.1]", path);
            }
            if (! (json_object_get(val, "type") != NULL))
            {
                if (rep) jm_report_add_entry(rep, "missing mandatory prop <type> [.'$Prompts'.'|'.1]", path);
            }
        }
        return false;
    }
    return true;
}

// object .'$Prompts'.'|'.2.options.'@'.0
static bool _jm_obj_5(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    if (! json_is_object(val))
    {
        if (rep) jm_report_add_entry(rep, "not an object [.'$Prompts'.'|'.2.options.'@'.0]", path);
        return false;
    }
    bool res;
    int64_t must_count = 0;
    const char *prop;
    json_t *pval;
    json_object_foreach((json_t *) val, prop, pval)
    {
        jm_path_t lpath_5 = (jm_path_t) { prop, 0, path, NULL };
        if (strcmp(prop, "value") == 0)
        {
            // handle must value property
            must_count += 1;
            // .'$Prompts'.'|'.2.options.'@'.0.value
            res = json_model_8(pval, (path ? &lpath_5 : NULL), rep);
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "unexpected $neString [.'$Prompts'.'|'.2.options.'@'.0.value]", (path ? &lpath_5 : NULL));
            }
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "invalid mandatory prop value [.'$Prompts'.'|'.2.options.'@'.0.value]", (path ? &lpath_5 : NULL));
                return false;
            }
        }
        else if (strcmp(prop, "description") == 0)
        {
            // handle may description property
            // .'$Prompts'.'|'.2.options.'@'.0.description
            res = json_is_string(pval);
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "unexpected string [.'$Prompts'.'|'.2.options.'@'.0.description]", (path ? &lpath_5 : NULL));
            }
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "invalid optional prop value [.'$Prompts'.'|'.2.options.'@'.0.description]", (path ? &lpath_5 : NULL));
                return false;
            }
        }
        else if (strcmp(prop, "name") == 0)
        {
            // handle may name property
            // .'$Prompts'.'|'.2.options.'@'.0.name
            res = json_is_string(pval);
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "unexpected string [.'$Prompts'.'|'.2.options.'@'.0.name]", (path ? &lpath_5 : NULL));
            }
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "invalid optional prop value [.'$Prompts'.'|'.2.options.'@'.0.name]", (path ? &lpath_5 : NULL));
                return false;
            }
        }
        else
        {
            if (rep) jm_report_add_entry(rep, "unexpected prop [.'$Prompts'.'|'.2.options.'@'.0]", (path ? &lpath_5 : NULL));
            return false;
        }
    }
    if (must_count != 1)
    {
        if (rep != NULL)
        {
            if (! (json_object_get(val, "value") != NULL))
            {
                if (rep) jm_report_add_entry(rep, "missing mandatory prop <value> [.'$Prompts'.'|'.2.options.'@'.0]", path);
            }
        }
        return false;
    }
    return true;
}

// object .'$Prompts'.'|'.2
static bool _jm_obj_4(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    if (! json_is_object(val))
    {
        if (rep) jm_report_add_entry(rep, "not an object [.'$Prompts'.'|'.2]", path);
        return false;
    }
    bool res;
    int64_t must_count = 0;
    const char *prop;
    json_t *pval;
    json_object_foreach((json_t *) val, prop, pval)
    {
        jm_path_t lpath_4 = (jm_path_t) { prop, 0, path, NULL };
        if (strcmp(prop, "type") == 0)
        {
            // handle must type property
            must_count += 1;
            // .'$Prompts'.'|'.2.type
            res = json_is_string(pval) && strcmp(json_string_value(pval), "menu") == 0;
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "unexpected menu [.'$Prompts'.'|'.2.type]", (path ? &lpath_4 : NULL));
            }
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "invalid mandatory prop value [.'$Prompts'.'|'.2.type]", (path ? &lpath_4 : NULL));
                return false;
            }
        }
        else if (strcmp(prop, "title") == 0)
        {
            // handle must title property
            must_count += 1;
            // .'$Prompts'.'|'.2.title
            res = json_model_6(pval, (path ? &lpath_4 : NULL), rep);
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "unexpected $custom-commands-prompts-title-property [.'$Prompts'.'|'.2.title]", (path ? &lpath_4 : NULL));
            }
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "invalid mandatory prop value [.'$Prompts'.'|'.2.title]", (path ? &lpath_4 : NULL));
                return false;
            }
        }
        else if (strcmp(prop, "key") == 0)
        {
            // handle must key property
            must_count += 1;
            // .'$Prompts'.'|'.2.key
            res = json_model_7(pval, (path ? &lpath_4 : NULL), rep);
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "unexpected $custom-commands-prompts-key-property [.'$Prompts'.'|'.2.key]", (path ? &lpath_4 : NULL));
            }
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "invalid mandatory prop value [.'$Prompts'.'|'.2.key]", (path ? &lpath_4 : NULL));
                return false;
            }
        }
        else if (strcmp(prop, "options") == 0)
        {
            // handle must options property
            must_count += 1;
            // .'$Prompts'.'|'.2.options
            // .'$Prompts'.'|'.2.options.'@'
            res = json_is_array(pval);
            if (res)
            {
                size_t arr_2_idx;
                json_t *arr_2_item;
                json_array_foreach(pval, arr_2_idx, arr_2_item)
                {
                    jm_path_t arr_2_lpath = (jm_path_t) { NULL, arr_2_idx, (path ? &lpath_4 : NULL), NULL };
                    // .'$Prompts'.'|'.2.options.'@'.0
                    res = _jm_obj_5(arr_2_item, ((path ? &lpath_4 : NULL) ? &arr_2_lpath : NULL), rep);
                    if (! res)
                    {
                        if (rep) jm_report_add_entry(rep, "unexpected element [.'$Prompts'.'|'.2.options.'@'.0]", ((path ? &lpath_4 : NULL) ? &arr_2_lpath : NULL));
                    }
                    if (! res)
                    {
                        break;
                    }
                }
            }
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "not array or unexpected array [.'$Prompts'.'|'.2.options.'@']", (path ? &lpath_4 : NULL));
            }
            if (res)
            {
                res = jm_array_is_unique(pval, (path ? &lpath_4 : NULL), rep);
                if (! res)
                {
                    if (rep) jm_report_add_entry(rep, "constraints failed [.'$Prompts'.'|'.2.options]", (path ? &lpath_4 : NULL));
                }
            }
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "invalid mandatory prop value [.'$Prompts'.'|'.2.options]", (path ? &lpath_4 : NULL));
                return false;
            }
        }
        else
        {
            if (rep) jm_report_add_entry(rep, "unexpected prop [.'$Prompts'.'|'.2]", (path ? &lpath_4 : NULL));
            return false;
        }
    }
    if (must_count != 4)
    {
        if (rep != NULL)
        {
            if (! (json_object_get(val, "key") != NULL))
            {
                if (rep) jm_report_add_entry(rep, "missing mandatory prop <key> [.'$Prompts'.'|'.2]", path);
            }
            if (! (json_object_get(val, "options") != NULL))
            {
                if (rep) jm_report_add_entry(rep, "missing mandatory prop <options> [.'$Prompts'.'|'.2]", path);
            }
            if (! (json_object_get(val, "title") != NULL))
            {
                if (rep) jm_report_add_entry(rep, "missing mandatory prop <title> [.'$Prompts'.'|'.2]", path);
            }
            if (! (json_object_get(val, "type") != NULL))
            {
                if (rep) jm_report_add_entry(rep, "missing mandatory prop <type> [.'$Prompts'.'|'.2]", path);
            }
        }
        return false;
    }
    return true;
}

// object .'$Prompts'.'|'.3
static bool _jm_obj_6(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    if (! json_is_object(val))
    {
        if (rep) jm_report_add_entry(rep, "not an object [.'$Prompts'.'|'.3]", path);
        return false;
    }
    bool res;
    int64_t must_count = 0;
    const char *prop;
    json_t *pval;
    json_object_foreach((json_t *) val, prop, pval)
    {
        jm_path_t lpath_6 = (jm_path_t) { prop, 0, path, NULL };
        if (strcmp(prop, "type") == 0)
        {
            // handle must type property
            must_count += 1;
            // .'$Prompts'.'|'.3.type
            res = json_is_string(pval) && strcmp(json_string_value(pval), "menuFromCommand") == 0;
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "unexpected menuFromCommand [.'$Prompts'.'|'.3.type]", (path ? &lpath_6 : NULL));
            }
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "invalid mandatory prop value [.'$Prompts'.'|'.3.type]", (path ? &lpath_6 : NULL));
                return false;
            }
        }
        else if (strcmp(prop, "title") == 0)
        {
            // handle must title property
            must_count += 1;
            // .'$Prompts'.'|'.3.title
            res = json_model_6(pval, (path ? &lpath_6 : NULL), rep);
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "unexpected $custom-commands-prompts-title-property [.'$Prompts'.'|'.3.title]", (path ? &lpath_6 : NULL));
            }
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "invalid mandatory prop value [.'$Prompts'.'|'.3.title]", (path ? &lpath_6 : NULL));
                return false;
            }
        }
        else if (strcmp(prop, "key") == 0)
        {
            // handle must key property
            must_count += 1;
            // .'$Prompts'.'|'.3.key
            res = json_model_7(pval, (path ? &lpath_6 : NULL), rep);
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "unexpected $custom-commands-prompts-key-property [.'$Prompts'.'|'.3.key]", (path ? &lpath_6 : NULL));
            }
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "invalid mandatory prop value [.'$Prompts'.'|'.3.key]", (path ? &lpath_6 : NULL));
                return false;
            }
        }
        else if (strcmp(prop, "command") == 0)
        {
            // handle must command property
            must_count += 1;
            // .'$Prompts'.'|'.3.command
            res = json_is_string(pval);
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "unexpected string [.'$Prompts'.'|'.3.command]", (path ? &lpath_6 : NULL));
            }
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "invalid mandatory prop value [.'$Prompts'.'|'.3.command]", (path ? &lpath_6 : NULL));
                return false;
            }
        }
        else if (strcmp(prop, "filter") == 0)
        {
            // handle may filter property
            // .'$Prompts'.'|'.3.filter
            res = json_is_string(pval);
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "unexpected string [.'$Prompts'.'|'.3.filter]", (path ? &lpath_6 : NULL));
            }
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "invalid optional prop value [.'$Prompts'.'|'.3.filter]", (path ? &lpath_6 : NULL));
                return false;
            }
        }
        else if (strcmp(prop, "valueFormat") == 0)
        {
            // handle may valueFormat property
            // .'$Prompts'.'|'.3.valueFormat
            res = json_is_string(pval);
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "unexpected string [.'$Prompts'.'|'.3.valueFormat]", (path ? &lpath_6 : NULL));
            }
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "invalid optional prop value [.'$Prompts'.'|'.3.valueFormat]", (path ? &lpath_6 : NULL));
                return false;
            }
        }
        else if (strcmp(prop, "labelFormat") == 0)
        {
            // handle may labelFormat property
            // .'$Prompts'.'|'.3.labelFormat
            res = json_is_string(pval);
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "unexpected string [.'$Prompts'.'|'.3.labelFormat]", (path ? &lpath_6 : NULL));
            }
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "invalid optional prop value [.'$Prompts'.'|'.3.labelFormat]", (path ? &lpath_6 : NULL));
                return false;
            }
        }
        else
        {
            if (rep) jm_report_add_entry(rep, "unexpected prop [.'$Prompts'.'|'.3]", (path ? &lpath_6 : NULL));
            return false;
        }
    }
    if (must_count != 4)
    {
        if (rep != NULL)
        {
            if (! (json_object_get(val, "command") != NULL))
            {
                if (rep) jm_report_add_entry(rep, "missing mandatory prop <command> [.'$Prompts'.'|'.3]", path);
            }
            if (! (json_object_get(val, "key") != NULL))
            {
                if (rep) jm_report_add_entry(rep, "missing mandatory prop <key> [.'$Prompts'.'|'.3]", path);
            }
            if (! (json_object_get(val, "title") != NULL))
            {
                if (rep) jm_report_add_entry(rep, "missing mandatory prop <title> [.'$Prompts'.'|'.3]", path);
            }
            if (! (json_object_get(val, "type") != NULL))
            {
                if (rep) jm_report_add_entry(rep, "missing mandatory prop <type> [.'$Prompts'.'|'.3]", path);
            }
        }
        return false;
    }
    return true;
}

static jm_check_fun_t _jm_map_0(json_t *val)
{
    jm_constant_t cst;
    jm_set_cst(&cst, val);
    return jm_search_constmap(&cst, _jm_map_0_tab, 4);
}

// check $Prompts (.'$Prompts')
static bool json_model_10(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .'$Prompts'
    res = json_is_object(val);
    if (res)
    {
        json_t * tag_0 = json_object_get(val, "type");
        if (tag_0 != NULL)
        {
            jm_check_fun_t fun_0 = _jm_map_0(tag_0);
            if (fun_0 != NULL)
            {
                res = fun_0(val, path, rep);
            }
            else
            {
                res = false;
                if (rep) jm_report_add_entry(rep, "tag <type> value not found [.'$Prompts'.'|']", path);
            }
        }
        else
        {
            res = false;
            if (rep) jm_report_add_entry(rep, "tag prop <type> is missing [.'$Prompts'.'|']", path);
        }
    }
    else
    {
        if (rep) jm_report_add_entry(rep, "value is not an object [.'$Prompts'.'|']", path);
    }
    return res;
}

// check _jm_obj_7_map_confirmOnQuit (.confirmOnQuit)
static bool _jm_f_0(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .confirmOnQuit
    res = json_is_boolean(val);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "not a bool [.confirmOnQuit]", path);
    }
    return res;
}


// object .customCommands.'@'.0.after
static bool _jm_obj_9(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    if (! json_is_object(val))
    {
        if (rep) jm_report_add_entry(rep, "not an object [.customCommands.'@'.0.after]", path);
        return false;
    }
    bool res;
    const char *prop;
    json_t *pval;
    json_object_foreach((json_t *) val, prop, pval)
    {
        jm_path_t lpath_9 = (jm_path_t) { prop, 0, path, NULL };
        if (strcmp(prop, "checkForConflicts") == 0)
        {
            // handle may checkForConflicts property
            // .customCommands.'@'.0.after.checkForConflicts
            res = json_is_boolean(pval);
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "not a bool [.customCommands.'@'.0.after.checkForConflicts]", (path ? &lpath_9 : NULL));
            }
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "invalid optional prop value [.customCommands.'@'.0.after.checkForConflicts]", (path ? &lpath_9 : NULL));
                return false;
            }
        }
        else
        {
            if (rep) jm_report_add_entry(rep, "unexpected prop [.customCommands.'@'.0.after]", (path ? &lpath_9 : NULL));
            return false;
        }
    }
    return true;
}

// check _jm_obj_8_map_after (.customCommands.'@'.0.after)
static bool _jm_f_2(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .customCommands.'@'.0.after
    res = _jm_obj_9(val, path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected element [.customCommands.'@'.0.after]", path);
    }
    return res;
}

// check _jm_obj_8_map_description (.customCommands.'@'.0.description)
static bool _jm_f_3(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .customCommands.'@'.0.description
    res = json_is_string(val);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected string [.customCommands.'@'.0.description]", path);
    }
    return res;
}

// check _jm_obj_8_map_loadingText (.customCommands.'@'.0.loadingText)
static bool _jm_f_4(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .customCommands.'@'.0.loadingText
    res = json_is_string(val);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected string [.customCommands.'@'.0.loadingText]", path);
    }
    return res;
}

// check _jm_obj_8_map_prompts (.customCommands.'@'.0.prompts)
static bool _jm_f_5(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .customCommands.'@'.0.prompts
    res = json_is_array(val);
    if (res)
    {
        size_t arr_4_idx;
        json_t *arr_4_item;
        json_array_foreach(val, arr_4_idx, arr_4_item)
        {
            jm_path_t arr_4_lpath = (jm_path_t) { NULL, arr_4_idx, path, NULL };
            // .customCommands.'@'.0.prompts.0
            res = json_model_10(arr_4_item, (path ? &arr_4_lpath : NULL), rep);
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "unexpected $Prompts [.customCommands.'@'.0.prompts.0]", (path ? &arr_4_lpath : NULL));
            }
            if (! res)
            {
                break;
            }
        }
    }
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "not array or unexpected array [.customCommands.'@'.0.prompts]", path);
    }
    return res;
}

// check _jm_obj_8_map_showOutput (.customCommands.'@'.0.showOutput)
static bool _jm_f_6(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .customCommands.'@'.0.showOutput
    res = json_is_boolean(val);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "not a bool [.customCommands.'@'.0.showOutput]", path);
    }
    return res;
}

// check _jm_obj_8_map_stream (.customCommands.'@'.0.stream)
static bool _jm_f_7(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .customCommands.'@'.0.stream
    res = json_is_boolean(val);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "not a bool [.customCommands.'@'.0.stream]", path);
    }
    return res;
}

// check _jm_obj_8_map_subprocess (.customCommands.'@'.0.subprocess)
static bool _jm_f_8(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .customCommands.'@'.0.subprocess
    res = json_is_boolean(val);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "not a bool [.customCommands.'@'.0.subprocess]", path);
    }
    return res;
}

static jm_check_fun_t _jm_obj_8_map(const char *pname)
{
    return jm_search_propmap(pname, _jm_obj_8_map_tab, 7);
}

// object .customCommands.'@'.0
static bool _jm_obj_8(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    if (! json_is_object(val))
    {
        if (rep) jm_report_add_entry(rep, "not an object [.customCommands.'@'.0]", path);
        return false;
    }
    bool res;
    jm_check_fun_t pfun;
    int64_t must_count = 0;
    const char *prop;
    json_t *pval;
    json_object_foreach((json_t *) val, prop, pval)
    {
        jm_path_t lpath_8 = (jm_path_t) { prop, 0, path, NULL };
        if (strcmp(prop, "key") == 0)
        {
            // handle must key property
            must_count += 1;
            // .customCommands.'@'.0.key
            res = json_model_4(pval, (path ? &lpath_8 : NULL), rep);
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "unexpected $keybinding [.customCommands.'@'.0.key]", (path ? &lpath_8 : NULL));
            }
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "invalid mandatory prop value [.customCommands.'@'.0.key]", (path ? &lpath_8 : NULL));
                return false;
            }
        }
        else if (strcmp(prop, "command") == 0)
        {
            // handle must command property
            must_count += 1;
            // .customCommands.'@'.0.command
            res = json_is_string(pval);
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "unexpected string [.customCommands.'@'.0.command]", (path ? &lpath_8 : NULL));
            }
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "invalid mandatory prop value [.customCommands.'@'.0.command]", (path ? &lpath_8 : NULL));
                return false;
            }
        }
        else if (strcmp(prop, "context") == 0)
        {
            // handle must context property
            must_count += 1;
            // .customCommands.'@'.0.context
            res = jm_json_is_scalar(pval) && json_is_string(pval) && jm_search_cst(&(jm_constant_t) { cst_is_string, { .s = json_string_value(pval) } }, _jm_cst_3, 13);;
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "value not in enum [.customCommands.'@'.0.context.'|']", (path ? &lpath_8 : NULL));
            }
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "invalid mandatory prop value [.customCommands.'@'.0.context]", (path ? &lpath_8 : NULL));
                return false;
            }
        }
        else if ((pfun = _jm_obj_8_map(prop)))
        {
            // handle 7 may props
            if (pfun != NULL && ! pfun(pval, (path ? &lpath_8 : NULL), rep))
            {
                if (rep) jm_report_add_entry(rep, "invalid optional prop value [.customCommands.'@'.0]", (path ? &lpath_8 : NULL));
                return false;
            }
        }
        else
        {
            if (rep) jm_report_add_entry(rep, "unexpected prop [.customCommands.'@'.0]", (path ? &lpath_8 : NULL));
            return false;
        }
    }
    if (must_count != 3)
    {
        if (rep != NULL)
        {
            if (! (json_object_get(val, "command") != NULL))
            {
                if (rep) jm_report_add_entry(rep, "missing mandatory prop <command> [.customCommands.'@'.0]", path);
            }
            if (! (json_object_get(val, "context") != NULL))
            {
                if (rep) jm_report_add_entry(rep, "missing mandatory prop <context> [.customCommands.'@'.0]", path);
            }
            if (! (json_object_get(val, "key") != NULL))
            {
                if (rep) jm_report_add_entry(rep, "missing mandatory prop <key> [.customCommands.'@'.0]", path);
            }
        }
        return false;
    }
    return true;
}

// check _jm_obj_7_map_customCommands (.customCommands)
static bool _jm_f_1(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .customCommands
    // .customCommands.'@'
    res = json_is_array(val);
    if (res)
    {
        size_t arr_3_idx;
        json_t *arr_3_item;
        json_array_foreach(val, arr_3_idx, arr_3_item)
        {
            jm_path_t arr_3_lpath = (jm_path_t) { NULL, arr_3_idx, path, NULL };
            // .customCommands.'@'.0
            res = _jm_obj_8(arr_3_item, (path ? &arr_3_lpath : NULL), rep);
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "unexpected element [.customCommands.'@'.0]", (path ? &arr_3_lpath : NULL));
            }
            if (! res)
            {
                break;
            }
        }
    }
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "not array or unexpected array [.customCommands.'@']", path);
    }
    if (res)
    {
        res = jm_array_is_unique(val, path, rep);
        if (! res)
        {
            if (rep) jm_report_add_entry(rep, "constraints failed [.customCommands]", path);
        }
    }
    return res;
}

// check _jm_obj_7_map_disableStartupPopups (.disableStartupPopups)
static bool _jm_f_9(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .disableStartupPopups
    res = json_is_boolean(val);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "not a bool [.disableStartupPopups]", path);
    }
    return res;
}

// check _jm_obj_10_map_allBranchesLogCmd (.git.allBranchesLogCmd)
static bool _jm_f_11(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .git.allBranchesLogCmd
    res = json_is_string(val);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected string [.git.allBranchesLogCmd]", path);
    }
    return res;
}

// check _jm_obj_10_map_autoFetch (.git.autoFetch)
static bool _jm_f_12(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .git.autoFetch
    res = json_is_boolean(val);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "not a bool [.git.autoFetch]", path);
    }
    return res;
}

// check _jm_obj_10_map_autoRefresh (.git.autoRefresh)
static bool _jm_f_13(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .git.autoRefresh
    res = json_is_boolean(val);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "not a bool [.git.autoRefresh]", path);
    }
    return res;
}

// check _jm_obj_10_map_branchLogCmd (.git.branchLogCmd)
static bool _jm_f_14(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .git.branchLogCmd
    res = json_is_string(val);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected string [.git.branchLogCmd]", path);
    }
    return res;
}

// object .git.commit
static bool _jm_obj_11(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    if (! json_is_object(val))
    {
        if (rep) jm_report_add_entry(rep, "not an object [.git.commit]", path);
        return false;
    }
    bool res;
    const char *prop;
    json_t *pval;
    json_object_foreach((json_t *) val, prop, pval)
    {
        jm_path_t lpath_11 = (jm_path_t) { prop, 0, path, NULL };
        if (strcmp(prop, "signOff") == 0)
        {
            // handle may signOff property
            // .git.commit.signOff
            res = json_is_boolean(pval);
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "not a bool [.git.commit.signOff]", (path ? &lpath_11 : NULL));
            }
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "invalid optional prop value [.git.commit.signOff]", (path ? &lpath_11 : NULL));
                return false;
            }
        }
        else
        {
            if (rep) jm_report_add_entry(rep, "unexpected prop [.git.commit]", (path ? &lpath_11 : NULL));
            return false;
        }
    }
    return true;
}

// check _jm_obj_10_map_commit (.git.commit)
static bool _jm_f_15(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .git.commit
    res = _jm_obj_11(val, path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected element [.git.commit]", path);
    }
    return res;
}

static bool _jm_re_1(const char *s, jm_path_t *path, jm_report_t *rep)
{
    size_t slen = strlen(s);
    return cre2_match(_jm_re_1_re2, s, slen, 0, slen, CRE2_UNANCHORED, NULL, 0);
}

// object .git.commitPrefixes.'/./'
static bool _jm_obj_13(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    if (! json_is_object(val))
    {
        if (rep) jm_report_add_entry(rep, "not an object [.git.commitPrefixes.'/./']", path);
        return false;
    }
    bool res;
    int64_t must_count = 0;
    const char *prop;
    json_t *pval;
    json_object_foreach((json_t *) val, prop, pval)
    {
        jm_path_t lpath_13 = (jm_path_t) { prop, 0, path, NULL };
        if (strcmp(prop, "pattern") == 0)
        {
            // handle must pattern property
            must_count += 1;
            // .git.commitPrefixes.'/./'.pattern
            res = json_model_8(pval, (path ? &lpath_13 : NULL), rep);
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "unexpected $neString [.git.commitPrefixes.'/./'.pattern]", (path ? &lpath_13 : NULL));
            }
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "invalid mandatory prop value [.git.commitPrefixes.'/./'.pattern]", (path ? &lpath_13 : NULL));
                return false;
            }
        }
        else if (strcmp(prop, "replace") == 0)
        {
            // handle must replace property
            must_count += 1;
            // .git.commitPrefixes.'/./'.replace
            res = json_model_8(pval, (path ? &lpath_13 : NULL), rep);
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "unexpected $neString [.git.commitPrefixes.'/./'.replace]", (path ? &lpath_13 : NULL));
            }
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "invalid mandatory prop value [.git.commitPrefixes.'/./'.replace]", (path ? &lpath_13 : NULL));
                return false;
            }
        }
        else
        {
            if (rep) jm_report_add_entry(rep, "unexpected prop [.git.commitPrefixes.'/./']", (path ? &lpath_13 : NULL));
            return false;
        }
    }
    if (must_count != 2)
    {
        if (rep != NULL)
        {
            if (! (json_object_get(val, "pattern") != NULL))
            {
                if (rep) jm_report_add_entry(rep, "missing mandatory prop <pattern> [.git.commitPrefixes.'/./']", path);
            }
            if (! (json_object_get(val, "replace") != NULL))
            {
                if (rep) jm_report_add_entry(rep, "missing mandatory prop <replace> [.git.commitPrefixes.'/./']", path);
            }
        }
        return false;
    }
    return true;
}

// object .git.commitPrefixes
static bool _jm_obj_12(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    if (! json_is_object(val))
    {
        if (rep) jm_report_add_entry(rep, "not an object [.git.commitPrefixes]", path);
        return false;
    }
    bool res;
    const char *prop;
    json_t *pval;
    json_object_foreach((json_t *) val, prop, pval)
    {
        jm_path_t lpath_12 = (jm_path_t) { prop, 0, path, NULL };
        if (_jm_re_1(prop, path, rep))
        {
            // handle 1 re props
            // .git.commitPrefixes.'/./'
            res = _jm_obj_13(pval, (path ? &lpath_12 : NULL), rep);
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "unexpected element [.git.commitPrefixes.'/./']", (path ? &lpath_12 : NULL));
            }
            if (! res)
            {
                return false;
            }
        }
        else
        {
            if (rep) jm_report_add_entry(rep, "unexpected prop [.git.commitPrefixes]", (path ? &lpath_12 : NULL));
            return false;
        }
    }
    return true;
}

// check _jm_obj_10_map_commitPrefixes (.git.commitPrefixes)
static bool _jm_f_16(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .git.commitPrefixes
    res = _jm_obj_12(val, path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected element [.git.commitPrefixes]", path);
    }
    return res;
}

// check _jm_obj_10_map_diffContextSize (.git.diffContextSize)
static bool _jm_f_17(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .git.diffContextSize
    res = json_is_integer(val) && json_integer_value(val) >= 0;
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "not a 0 strict int [.git.diffContextSize]", path);
    }
    return res;
}

// check _jm_obj_10_map_disableForcePushing (.git.disableForcePushing)
static bool _jm_f_18(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .git.disableForcePushing
    res = json_is_boolean(val);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "not a bool [.git.disableForcePushing]", path);
    }
    return res;
}

// check _jm_obj_10_map_fetchAll (.git.fetchAll)
static bool _jm_f_19(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .git.fetchAll
    res = json_is_boolean(val);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "not a bool [.git.fetchAll]", path);
    }
    return res;
}



// object .git.log
static bool _jm_obj_14(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    if (! json_is_object(val))
    {
        if (rep) jm_report_add_entry(rep, "not an object [.git.log]", path);
        return false;
    }
    bool res;
    const char *prop;
    json_t *pval;
    json_object_foreach((json_t *) val, prop, pval)
    {
        jm_path_t lpath_14 = (jm_path_t) { prop, 0, path, NULL };
        if (strcmp(prop, "order") == 0)
        {
            // handle may order property
            // .git.log.order
            res = jm_json_is_scalar(pval) && json_is_string(pval) && jm_search_cst(&(jm_constant_t) { cst_is_string, { .s = json_string_value(pval) } }, _jm_cst_4, 4);;
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "value not in enum [.git.log.order.'|']", (path ? &lpath_14 : NULL));
            }
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "invalid optional prop value [.git.log.order]", (path ? &lpath_14 : NULL));
                return false;
            }
        }
        else if (strcmp(prop, "showGraph") == 0)
        {
            // handle may showGraph property
            // .git.log.showGraph
            res = jm_json_is_scalar(pval) && json_is_string(pval) && jm_search_cst(&(jm_constant_t) { cst_is_string, { .s = json_string_value(pval) } }, _jm_cst_5, 3);;
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "value not in enum [.git.log.showGraph.'|']", (path ? &lpath_14 : NULL));
            }
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "invalid optional prop value [.git.log.showGraph]", (path ? &lpath_14 : NULL));
                return false;
            }
        }
        else if (strcmp(prop, "showWholeGraph") == 0)
        {
            // handle may showWholeGraph property
            // .git.log.showWholeGraph
            res = json_is_boolean(pval);
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "not a bool [.git.log.showWholeGraph]", (path ? &lpath_14 : NULL));
            }
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "invalid optional prop value [.git.log.showWholeGraph]", (path ? &lpath_14 : NULL));
                return false;
            }
        }
        else
        {
            if (rep) jm_report_add_entry(rep, "unexpected prop [.git.log]", (path ? &lpath_14 : NULL));
            return false;
        }
    }
    return true;
}

// check _jm_obj_10_map_log (.git.log)
static bool _jm_f_20(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .git.log
    res = _jm_obj_14(val, path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected element [.git.log]", path);
    }
    return res;
}

// check _jm_obj_10_map_mainBranches (.git.mainBranches)
static bool _jm_f_21(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .git.mainBranches
    res = json_model_9(val, path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected $stringArray [.git.mainBranches]", path);
    }
    return res;
}

// object .git.merging
static bool _jm_obj_15(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    if (! json_is_object(val))
    {
        if (rep) jm_report_add_entry(rep, "not an object [.git.merging]", path);
        return false;
    }
    bool res;
    const char *prop;
    json_t *pval;
    json_object_foreach((json_t *) val, prop, pval)
    {
        jm_path_t lpath_15 = (jm_path_t) { prop, 0, path, NULL };
        if (strcmp(prop, "manualCommit") == 0)
        {
            // handle may manualCommit property
            // .git.merging.manualCommit
            res = json_is_boolean(pval);
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "not a bool [.git.merging.manualCommit]", (path ? &lpath_15 : NULL));
            }
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "invalid optional prop value [.git.merging.manualCommit]", (path ? &lpath_15 : NULL));
                return false;
            }
        }
        else if (strcmp(prop, "args") == 0)
        {
            // handle may args property
            // .git.merging.args
            res = json_is_string(pval);
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "unexpected string [.git.merging.args]", (path ? &lpath_15 : NULL));
            }
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "invalid optional prop value [.git.merging.args]", (path ? &lpath_15 : NULL));
                return false;
            }
        }
        else
        {
            if (rep) jm_report_add_entry(rep, "unexpected prop [.git.merging]", (path ? &lpath_15 : NULL));
            return false;
        }
    }
    return true;
}

// check _jm_obj_10_map_merging (.git.merging)
static bool _jm_f_22(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .git.merging
    res = _jm_obj_15(val, path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected element [.git.merging]", path);
    }
    return res;
}

// check _jm_obj_10_map_overrideGpg (.git.overrideGpg)
static bool _jm_f_23(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .git.overrideGpg
    res = json_is_boolean(val);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "not a bool [.git.overrideGpg]", path);
    }
    return res;
}


// object .git.paging
static bool _jm_obj_16(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    if (! json_is_object(val))
    {
        if (rep) jm_report_add_entry(rep, "not an object [.git.paging]", path);
        return false;
    }
    bool res;
    const char *prop;
    json_t *pval;
    json_object_foreach((json_t *) val, prop, pval)
    {
        jm_path_t lpath_16 = (jm_path_t) { prop, 0, path, NULL };
        if (strcmp(prop, "colorArg") == 0)
        {
            // handle may colorArg property
            // .git.paging.colorArg
            res = jm_json_is_scalar(pval) && json_is_string(pval) && jm_search_cst(&(jm_constant_t) { cst_is_string, { .s = json_string_value(pval) } }, _jm_cst_6, 2);;
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "value not in enum [.git.paging.colorArg.'|']", (path ? &lpath_16 : NULL));
            }
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "invalid optional prop value [.git.paging.colorArg]", (path ? &lpath_16 : NULL));
                return false;
            }
        }
        else if (strcmp(prop, "useConfig") == 0)
        {
            // handle may useConfig property
            // .git.paging.useConfig
            res = json_is_boolean(pval);
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "not a bool [.git.paging.useConfig]", (path ? &lpath_16 : NULL));
            }
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "invalid optional prop value [.git.paging.useConfig]", (path ? &lpath_16 : NULL));
                return false;
            }
        }
        else if (strcmp(prop, "pager") == 0)
        {
            // handle may pager property
            // .git.paging.pager
            // .git.paging.pager.'@'
            res = json_is_string(pval);
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "unexpected string [.git.paging.pager.'@']", (path ? &lpath_16 : NULL));
            }
            if (res)
            {
                int64_t ival_2 = mbstowcs(NULL, json_string_value(pval), 0);
                res = ival_2 >= 1;
                if (! res)
                {
                    if (rep) jm_report_add_entry(rep, "constraints failed [.git.paging.pager]", (path ? &lpath_16 : NULL));
                }
            }
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "invalid optional prop value [.git.paging.pager]", (path ? &lpath_16 : NULL));
                return false;
            }
        }
        else
        {
            if (rep) jm_report_add_entry(rep, "unexpected prop [.git.paging]", (path ? &lpath_16 : NULL));
            return false;
        }
    }
    return true;
}

// check _jm_obj_10_map_paging (.git.paging)
static bool _jm_f_24(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .git.paging
    res = _jm_obj_16(val, path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected element [.git.paging]", path);
    }
    return res;
}

// check _jm_obj_10_map_parseEmoji (.git.parseEmoji)
static bool _jm_f_25(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .git.parseEmoji
    res = json_is_boolean(val);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "not a bool [.git.parseEmoji]", path);
    }
    return res;
}

// check _jm_obj_10_map_skipHookPrefix (.git.skipHookPrefix)
static bool _jm_f_26(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .git.skipHookPrefix
    res = json_is_string(val);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected string [.git.skipHookPrefix]", path);
    }
    return res;
}

static jm_check_fun_t _jm_obj_10_map(const char *pname)
{
    return jm_search_propmap(pname, _jm_obj_10_map_tab, 16);
}

// object .git
static bool _jm_obj_10(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    if (! json_is_object(val))
    {
        if (rep) jm_report_add_entry(rep, "not an object [.git]", path);
        return false;
    }
    jm_check_fun_t pfun;
    const char *prop;
    json_t *pval;
    json_object_foreach((json_t *) val, prop, pval)
    {
        jm_path_t lpath_10 = (jm_path_t) { prop, 0, path, NULL };
        if ((pfun = _jm_obj_10_map(prop)))
        {
            // handle 16 may props
            if (pfun != NULL && ! pfun(pval, (path ? &lpath_10 : NULL), rep))
            {
                if (rep) jm_report_add_entry(rep, "invalid optional prop value [.git]", (path ? &lpath_10 : NULL));
                return false;
            }
        }
        else
        {
            if (rep) jm_report_add_entry(rep, "unexpected prop [.git]", (path ? &lpath_10 : NULL));
            return false;
        }
    }
    return true;
}

// check _jm_obj_7_map_git (.git)
static bool _jm_f_10(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .git
    res = _jm_obj_10(val, path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected element [.git]", path);
    }
    return res;
}

// check _jm_obj_17_map_animateExplosion (.gui.animateExplosion)
static bool _jm_f_28(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .gui.animateExplosion
    res = json_is_boolean(val);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "not a bool [.gui.animateExplosion]", path);
    }
    return res;
}

// object .gui.authorColors
static bool _jm_obj_18(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    if (! json_is_object(val))
    {
        if (rep) jm_report_add_entry(rep, "not an object [.gui.authorColors]", path);
        return false;
    }
    bool res;
    const char *prop;
    json_t *pval;
    json_object_foreach((json_t *) val, prop, pval)
    {
        jm_path_t lpath_18 = (jm_path_t) { prop, 0, path, NULL };
        if (_jm_re_1(prop, path, rep))
        {
            // handle 1 re props
            // .gui.authorColors.'/./'
            res = json_model_2(pval, (path ? &lpath_18 : NULL), rep);
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "unexpected $color [.gui.authorColors.'/./']", (path ? &lpath_18 : NULL));
            }
            if (! res)
            {
                return false;
            }
        }
        else
        {
            if (rep) jm_report_add_entry(rep, "unexpected prop [.gui.authorColors]", (path ? &lpath_18 : NULL));
            return false;
        }
    }
    return true;
}

// check _jm_obj_17_map_authorColors (.gui.authorColors)
static bool _jm_f_29(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .gui.authorColors
    res = _jm_obj_18(val, path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected element [.gui.authorColors]", path);
    }
    return res;
}


// check _jm_obj_17_map_border (.gui.border)
static bool _jm_f_30(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .gui.border
    res = jm_json_is_scalar(val) && json_is_string(val) && jm_search_cst(&(jm_constant_t) { cst_is_string, { .s = json_string_value(val) } }, _jm_cst_7, 4);;
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "value not in enum [.gui.border.'|']", path);
    }
    return res;
}

// object .gui.branchColors
static bool _jm_obj_19(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    if (! json_is_object(val))
    {
        if (rep) jm_report_add_entry(rep, "not an object [.gui.branchColors]", path);
        return false;
    }
    bool res;
    const char *prop;
    json_t *pval;
    json_object_foreach((json_t *) val, prop, pval)
    {
        jm_path_t lpath_19 = (jm_path_t) { prop, 0, path, NULL };
        if (_jm_re_1(prop, path, rep))
        {
            // handle 1 re props
            // .gui.branchColors.'/./'
            res = json_model_2(pval, (path ? &lpath_19 : NULL), rep);
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "unexpected $color [.gui.branchColors.'/./']", (path ? &lpath_19 : NULL));
            }
            if (! res)
            {
                return false;
            }
        }
        else
        {
            if (rep) jm_report_add_entry(rep, "unexpected prop [.gui.branchColors]", (path ? &lpath_19 : NULL));
            return false;
        }
    }
    return true;
}

// check _jm_obj_17_map_branchColors (.gui.branchColors)
static bool _jm_f_31(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .gui.branchColors
    res = _jm_obj_19(val, path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected element [.gui.branchColors]", path);
    }
    return res;
}

// check _jm_obj_17_map_commandLogSize (.gui.commandLogSize)
static bool _jm_f_32(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .gui.commandLogSize
    res = json_is_integer(val) && json_integer_value(val) >= 0;
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "not a 0 strict int [.gui.commandLogSize]", path);
    }
    return res;
}

// object .gui.commitLength
static bool _jm_obj_20(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    if (! json_is_object(val))
    {
        if (rep) jm_report_add_entry(rep, "not an object [.gui.commitLength]", path);
        return false;
    }
    bool res;
    const char *prop;
    json_t *pval;
    json_object_foreach((json_t *) val, prop, pval)
    {
        jm_path_t lpath_20 = (jm_path_t) { prop, 0, path, NULL };
        if (strcmp(prop, "show") == 0)
        {
            // handle may show property
            // .gui.commitLength.show
            res = json_is_boolean(pval);
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "not a bool [.gui.commitLength.show]", (path ? &lpath_20 : NULL));
            }
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "invalid optional prop value [.gui.commitLength.show]", (path ? &lpath_20 : NULL));
                return false;
            }
        }
        else
        {
            if (rep) jm_report_add_entry(rep, "unexpected prop [.gui.commitLength]", (path ? &lpath_20 : NULL));
            return false;
        }
    }
    return true;
}

// check _jm_obj_17_map_commitLength (.gui.commitLength)
static bool _jm_f_33(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .gui.commitLength
    res = _jm_obj_20(val, path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected element [.gui.commitLength]", path);
    }
    return res;
}

// check _jm_obj_17_map_expandFocusedSidePanel (.gui.expandFocusedSidePanel)
static bool _jm_f_34(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .gui.expandFocusedSidePanel
    res = json_is_boolean(val);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "not a bool [.gui.expandFocusedSidePanel]", path);
    }
    return res;
}


// check _jm_obj_17_map_language (.gui.language)
static bool _jm_f_35(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .gui.language
    res = jm_json_is_scalar(val) && json_is_string(val) && jm_search_cst(&(jm_constant_t) { cst_is_string, { .s = json_string_value(val) } }, _jm_cst_8, 9);;
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "value not in enum [.gui.language.'|']", path);
    }
    return res;
}


// check _jm_obj_17_map_mainPanelSplitMode (.gui.mainPanelSplitMode)
static bool _jm_f_36(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .gui.mainPanelSplitMode
    res = jm_json_is_scalar(val) && json_is_string(val) && jm_search_cst(&(jm_constant_t) { cst_is_string, { .s = json_string_value(val) } }, _jm_cst_9, 3);;
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "value not in enum [.gui.mainPanelSplitMode.'|']", path);
    }
    return res;
}

// check _jm_obj_17_map_mouseEvents (.gui.mouseEvents)
static bool _jm_f_37(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .gui.mouseEvents
    res = json_is_boolean(val);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "not a bool [.gui.mouseEvents]", path);
    }
    return res;
}


// check _jm_obj_17_map_nerdFontsVersion (.gui.nerdFontsVersion)
static bool _jm_f_38(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .gui.nerdFontsVersion
    res = jm_json_is_scalar(val) && json_is_string(val) && jm_search_cst(&(jm_constant_t) { cst_is_string, { .s = json_string_value(val) } }, _jm_cst_10, 2);;
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "value not in enum [.gui.nerdFontsVersion.'|']", path);
    }
    if (! res)
    {
        res = json_is_string(val);
        if (! res)
        {
            if (rep) jm_report_add_entry(rep, "unexpected type [.gui.nerdFontsVersion.'|']", path);
        }
        if (res)
        {
            // .gui.nerdFontsVersion.'|'.0
            res = true;
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "unexpected string [.gui.nerdFontsVersion.'|'.0]", path);
            }
            if (res)
            {
                if (rep) jm_report_free_entries(rep);
            }
            else
            {
                if (rep) jm_report_add_entry(rep, "no model matched [.gui.nerdFontsVersion.'|']", path);
            }
        }
    }
    return res;
}

// check _jm_obj_17_map_scrollHeight (.gui.scrollHeight)
static bool _jm_f_39(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .gui.scrollHeight
    res = json_is_integer(val) && json_integer_value(val) >= 1;
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "not a 1 strict int [.gui.scrollHeight]", path);
    }
    return res;
}

// check _jm_obj_17_map_scrollPastBottom (.gui.scrollPastBottom)
static bool _jm_f_40(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .gui.scrollPastBottom
    res = json_is_boolean(val);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "not a bool [.gui.scrollPastBottom]", path);
    }
    return res;
}

// check _jm_obj_17_map_shortTimeFormat (.gui.shortTimeFormat)
static bool _jm_f_41(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .gui.shortTimeFormat
    res = json_is_string(val);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected string [.gui.shortTimeFormat]", path);
    }
    return res;
}

// check _jm_obj_17_map_showBottomLine (.gui.showBottomLine)
static bool _jm_f_42(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .gui.showBottomLine
    res = json_is_boolean(val);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "not a bool [.gui.showBottomLine]", path);
    }
    return res;
}

// check _jm_obj_17_map_showBranchCommitHash (.gui.showBranchCommitHash)
static bool _jm_f_43(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .gui.showBranchCommitHash
    res = json_is_boolean(val);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "not a bool [.gui.showBranchCommitHash]", path);
    }
    return res;
}

// check _jm_obj_17_map_showCommandLog (.gui.showCommandLog)
static bool _jm_f_44(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .gui.showCommandLog
    res = json_is_boolean(val);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "not a bool [.gui.showCommandLog]", path);
    }
    return res;
}

// check _jm_obj_17_map_showFileTree (.gui.showFileTree)
static bool _jm_f_45(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .gui.showFileTree
    res = json_is_boolean(val);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "not a bool [.gui.showFileTree]", path);
    }
    return res;
}

// check _jm_obj_17_map_showListFooter (.gui.showListFooter)
static bool _jm_f_46(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .gui.showListFooter
    res = json_is_boolean(val);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "not a bool [.gui.showListFooter]", path);
    }
    return res;
}

// check _jm_obj_17_map_showRandomTip (.gui.showRandomTip)
static bool _jm_f_47(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .gui.showRandomTip
    res = json_is_boolean(val);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "not a bool [.gui.showRandomTip]", path);
    }
    return res;
}

// check _jm_obj_17_map_sidePanelWidth (.gui.sidePanelWidth)
static bool _jm_f_48(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .gui.sidePanelWidth
    // .gui.sidePanelWidth.'@'
    res = json_is_real(val) && json_real_value(val) >= 0.0;
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "not a 0.0 strict float [.gui.sidePanelWidth.'@']", path);
    }
    if (res)
    {
        double fval_0 = json_real_value(val);
        res = fval_0 <= 1.0;
        if (! res)
        {
            if (rep) jm_report_add_entry(rep, "constraints failed [.gui.sidePanelWidth]", path);
        }
    }
    return res;
}

// check _jm_obj_17_map_skipDiscardChangeWarning (.gui.skipDiscardChangeWarning)
static bool _jm_f_49(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .gui.skipDiscardChangeWarning
    res = json_is_boolean(val);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "not a bool [.gui.skipDiscardChangeWarning]", path);
    }
    return res;
}

// check _jm_obj_17_map_skipRewordInEditorWarning (.gui.skipRewordInEditorWarning)
static bool _jm_f_50(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .gui.skipRewordInEditorWarning
    res = json_is_boolean(val);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "not a bool [.gui.skipRewordInEditorWarning]", path);
    }
    return res;
}

// check _jm_obj_17_map_skipStashWarning (.gui.skipStashWarning)
static bool _jm_f_51(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .gui.skipStashWarning
    res = json_is_boolean(val);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "not a bool [.gui.skipStashWarning]", path);
    }
    return res;
}


// check _jm_obj_17_map_splitDiff (.gui.splitDiff)
static bool _jm_f_52(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .gui.splitDiff
    res = jm_json_is_scalar(val) && json_is_string(val) && jm_search_cst(&(jm_constant_t) { cst_is_string, { .s = json_string_value(val) } }, _jm_cst_11, 2);;
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "value not in enum [.gui.splitDiff.'|']", path);
    }
    return res;
}

// check _jm_obj_21_map_activeBorderColor (.gui.theme.activeBorderColor)
static bool _jm_f_54(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .gui.theme.activeBorderColor
    res = json_model_3(val, path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected $colorArray [.gui.theme.activeBorderColor]", path);
    }
    return res;
}

// check _jm_obj_21_map_cherryPickedCommitBgColor (.gui.theme.cherryPickedCommitBgColor)
static bool _jm_f_55(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .gui.theme.cherryPickedCommitBgColor
    res = json_model_3(val, path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected $colorArray [.gui.theme.cherryPickedCommitBgColor]", path);
    }
    return res;
}

// check _jm_obj_21_map_cherryPickedCommitFgColor (.gui.theme.cherryPickedCommitFgColor)
static bool _jm_f_56(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .gui.theme.cherryPickedCommitFgColor
    res = json_model_3(val, path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected $colorArray [.gui.theme.cherryPickedCommitFgColor]", path);
    }
    return res;
}

// check _jm_obj_21_map_defaultFgColor (.gui.theme.defaultFgColor)
static bool _jm_f_57(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .gui.theme.defaultFgColor
    res = json_model_3(val, path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected $colorArray [.gui.theme.defaultFgColor]", path);
    }
    return res;
}

// check _jm_obj_21_map_inactiveBorderColor (.gui.theme.inactiveBorderColor)
static bool _jm_f_58(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .gui.theme.inactiveBorderColor
    res = json_model_3(val, path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected $colorArray [.gui.theme.inactiveBorderColor]", path);
    }
    return res;
}

// check _jm_obj_21_map_optionsTextColor (.gui.theme.optionsTextColor)
static bool _jm_f_59(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .gui.theme.optionsTextColor
    res = json_model_3(val, path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected $colorArray [.gui.theme.optionsTextColor]", path);
    }
    return res;
}

// check _jm_obj_21_map_searchingActiveBorderColor (.gui.theme.searchingActiveBorderColor)
static bool _jm_f_60(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .gui.theme.searchingActiveBorderColor
    res = json_model_3(val, path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected $colorArray [.gui.theme.searchingActiveBorderColor]", path);
    }
    return res;
}

// check _jm_obj_21_map_selectedLineBgColor (.gui.theme.selectedLineBgColor)
static bool _jm_f_61(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .gui.theme.selectedLineBgColor
    res = json_model_3(val, path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected $colorArray [.gui.theme.selectedLineBgColor]", path);
    }
    return res;
}

// check _jm_obj_21_map_selectedRangeBgColor (.gui.theme.selectedRangeBgColor)
static bool _jm_f_62(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .gui.theme.selectedRangeBgColor
    res = json_model_3(val, path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected $colorArray [.gui.theme.selectedRangeBgColor]", path);
    }
    return res;
}

// check _jm_obj_21_map_unstagedChangesColor (.gui.theme.unstagedChangesColor)
static bool _jm_f_63(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .gui.theme.unstagedChangesColor
    res = json_model_3(val, path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected $colorArray [.gui.theme.unstagedChangesColor]", path);
    }
    return res;
}

static jm_check_fun_t _jm_obj_21_map(const char *pname)
{
    return jm_search_propmap(pname, _jm_obj_21_map_tab, 10);
}

// object .gui.theme
static bool _jm_obj_21(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    if (! json_is_object(val))
    {
        if (rep) jm_report_add_entry(rep, "not an object [.gui.theme]", path);
        return false;
    }
    jm_check_fun_t pfun;
    const char *prop;
    json_t *pval;
    json_object_foreach((json_t *) val, prop, pval)
    {
        jm_path_t lpath_21 = (jm_path_t) { prop, 0, path, NULL };
        if ((pfun = _jm_obj_21_map(prop)))
        {
            // handle 10 may props
            if (pfun != NULL && ! pfun(pval, (path ? &lpath_21 : NULL), rep))
            {
                if (rep) jm_report_add_entry(rep, "invalid optional prop value [.gui.theme]", (path ? &lpath_21 : NULL));
                return false;
            }
        }
        else
        {
            if (rep) jm_report_add_entry(rep, "unexpected prop [.gui.theme]", (path ? &lpath_21 : NULL));
            return false;
        }
    }
    return true;
}

// check _jm_obj_17_map_theme (.gui.theme)
static bool _jm_f_53(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .gui.theme
    res = _jm_obj_21(val, path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected element [.gui.theme]", path);
    }
    return res;
}

// check _jm_obj_17_map_timeFormat (.gui.timeFormat)
static bool _jm_f_64(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .gui.timeFormat
    res = json_is_string(val);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected string [.gui.timeFormat]", path);
    }
    return res;
}


// check _jm_obj_17_map_windowSize (.gui.windowSize)
static bool _jm_f_65(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .gui.windowSize
    res = jm_json_is_scalar(val) && json_is_string(val) && jm_search_cst(&(jm_constant_t) { cst_is_string, { .s = json_string_value(val) } }, _jm_cst_12, 3);;
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "value not in enum [.gui.windowSize.'|']", path);
    }
    return res;
}

static jm_check_fun_t _jm_obj_17_map(const char *pname)
{
    return jm_search_propmap(pname, _jm_obj_17_map_tab, 28);
}

// object .gui
static bool _jm_obj_17(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    if (! json_is_object(val))
    {
        if (rep) jm_report_add_entry(rep, "not an object [.gui]", path);
        return false;
    }
    jm_check_fun_t pfun;
    const char *prop;
    json_t *pval;
    json_object_foreach((json_t *) val, prop, pval)
    {
        jm_path_t lpath_17 = (jm_path_t) { prop, 0, path, NULL };
        if ((pfun = _jm_obj_17_map(prop)))
        {
            // handle 28 may props
            if (pfun != NULL && ! pfun(pval, (path ? &lpath_17 : NULL), rep))
            {
                if (rep) jm_report_add_entry(rep, "invalid optional prop value [.gui]", (path ? &lpath_17 : NULL));
                return false;
            }
        }
        else
        {
            if (rep) jm_report_add_entry(rep, "unexpected prop [.gui]", (path ? &lpath_17 : NULL));
            return false;
        }
    }
    return true;
}

// check _jm_obj_7_map_gui (.gui)
static bool _jm_f_27(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .gui
    res = _jm_obj_17(val, path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected element [.gui]", path);
    }
    return res;
}

// check _jm_obj_23_map_checkoutBranchByName (.keybinding.branches.checkoutBranchByName)
static bool _jm_f_68(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .keybinding.branches.checkoutBranchByName
    res = json_model_4(val, path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected $keybinding [.keybinding.branches.checkoutBranchByName]", path);
    }
    return res;
}

// check _jm_obj_23_map_createPullRequest (.keybinding.branches.createPullRequest)
static bool _jm_f_69(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .keybinding.branches.createPullRequest
    res = json_model_4(val, path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected $keybinding [.keybinding.branches.createPullRequest]", path);
    }
    return res;
}

// check _jm_obj_23_map_createTag (.keybinding.branches.createTag)
static bool _jm_f_70(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .keybinding.branches.createTag
    res = json_model_4(val, path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected $keybinding [.keybinding.branches.createTag]", path);
    }
    return res;
}

// check _jm_obj_23_map_fastForward (.keybinding.branches.fastForward)
static bool _jm_f_71(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .keybinding.branches.fastForward
    res = json_model_4(val, path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected $keybinding [.keybinding.branches.fastForward]", path);
    }
    return res;
}

// check _jm_obj_23_map_fetchRemote (.keybinding.branches.fetchRemote)
static bool _jm_f_72(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .keybinding.branches.fetchRemote
    res = json_model_4(val, path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected $keybinding [.keybinding.branches.fetchRemote]", path);
    }
    return res;
}

// check _jm_obj_23_map_forceCheckoutBranch (.keybinding.branches.forceCheckoutBranch)
static bool _jm_f_73(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .keybinding.branches.forceCheckoutBranch
    res = json_model_4(val, path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected $keybinding [.keybinding.branches.forceCheckoutBranch]", path);
    }
    return res;
}

// check _jm_obj_23_map_mergeIntoCurrentBranch (.keybinding.branches.mergeIntoCurrentBranch)
static bool _jm_f_74(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .keybinding.branches.mergeIntoCurrentBranch
    res = json_model_4(val, path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected $keybinding [.keybinding.branches.mergeIntoCurrentBranch]", path);
    }
    return res;
}

// check _jm_obj_23_map_pushTag (.keybinding.branches.pushTag)
static bool _jm_f_75(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .keybinding.branches.pushTag
    res = json_model_4(val, path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected $keybinding [.keybinding.branches.pushTag]", path);
    }
    return res;
}

// check _jm_obj_23_map_rebaseBranch (.keybinding.branches.rebaseBranch)
static bool _jm_f_76(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .keybinding.branches.rebaseBranch
    res = json_model_4(val, path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected $keybinding [.keybinding.branches.rebaseBranch]", path);
    }
    return res;
}

// check _jm_obj_23_map_renameBranch (.keybinding.branches.renameBranch)
static bool _jm_f_77(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .keybinding.branches.renameBranch
    res = json_model_4(val, path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected $keybinding [.keybinding.branches.renameBranch]", path);
    }
    return res;
}

// check _jm_obj_23_map_setUpstream (.keybinding.branches.setUpstream)
static bool _jm_f_78(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .keybinding.branches.setUpstream
    res = json_model_4(val, path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected $keybinding [.keybinding.branches.setUpstream]", path);
    }
    return res;
}

// check _jm_obj_23_map_viewGitFlowOptions (.keybinding.branches.viewGitFlowOptions)
static bool _jm_f_79(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .keybinding.branches.viewGitFlowOptions
    res = json_model_4(val, path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected $keybinding [.keybinding.branches.viewGitFlowOptions]", path);
    }
    return res;
}

// check _jm_obj_23_map_viewPullRequestOptions (.keybinding.branches.viewPullRequestOptions)
static bool _jm_f_80(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .keybinding.branches.viewPullRequestOptions
    res = json_model_4(val, path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected $keybinding [.keybinding.branches.viewPullRequestOptions]", path);
    }
    return res;
}

static jm_check_fun_t _jm_obj_23_map(const char *pname)
{
    return jm_search_propmap(pname, _jm_obj_23_map_tab, 13);
}

// object .keybinding.branches
static bool _jm_obj_23(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    if (! json_is_object(val))
    {
        if (rep) jm_report_add_entry(rep, "not an object [.keybinding.branches]", path);
        return false;
    }
    jm_check_fun_t pfun;
    const char *prop;
    json_t *pval;
    json_object_foreach((json_t *) val, prop, pval)
    {
        jm_path_t lpath_23 = (jm_path_t) { prop, 0, path, NULL };
        if ((pfun = _jm_obj_23_map(prop)))
        {
            // handle 13 may props
            if (pfun != NULL && ! pfun(pval, (path ? &lpath_23 : NULL), rep))
            {
                if (rep) jm_report_add_entry(rep, "invalid optional prop value [.keybinding.branches]", (path ? &lpath_23 : NULL));
                return false;
            }
        }
        else
        {
            if (rep) jm_report_add_entry(rep, "unexpected prop [.keybinding.branches]", (path ? &lpath_23 : NULL));
            return false;
        }
    }
    return true;
}

// check _jm_obj_22_map_branches (.keybinding.branches)
static bool _jm_f_67(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .keybinding.branches
    res = _jm_obj_23(val, path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected element [.keybinding.branches]", path);
    }
    return res;
}

// object .keybinding.commitFiles
static bool _jm_obj_24(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    if (! json_is_object(val))
    {
        if (rep) jm_report_add_entry(rep, "not an object [.keybinding.commitFiles]", path);
        return false;
    }
    bool res;
    const char *prop;
    json_t *pval;
    json_object_foreach((json_t *) val, prop, pval)
    {
        jm_path_t lpath_24 = (jm_path_t) { prop, 0, path, NULL };
        if (strcmp(prop, "checkoutCommitFile") == 0)
        {
            // handle may checkoutCommitFile property
            // .keybinding.commitFiles.checkoutCommitFile
            res = json_model_4(pval, (path ? &lpath_24 : NULL), rep);
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "unexpected $keybinding [.keybinding.commitFiles.checkoutCommitFile]", (path ? &lpath_24 : NULL));
            }
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "invalid optional prop value [.keybinding.commitFiles.checkoutCommitFile]", (path ? &lpath_24 : NULL));
                return false;
            }
        }
        else
        {
            if (rep) jm_report_add_entry(rep, "unexpected prop [.keybinding.commitFiles]", (path ? &lpath_24 : NULL));
            return false;
        }
    }
    return true;
}

// check _jm_obj_22_map_commitFiles (.keybinding.commitFiles)
static bool _jm_f_81(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .keybinding.commitFiles
    res = _jm_obj_24(val, path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected element [.keybinding.commitFiles]", path);
    }
    return res;
}

// check _jm_obj_25_map_amendToCommit (.keybinding.commits.amendToCommit)
static bool _jm_f_83(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .keybinding.commits.amendToCommit
    res = json_model_4(val, path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected $keybinding [.keybinding.commits.amendToCommit]", path);
    }
    return res;
}

// check _jm_obj_25_map_checkoutCommit (.keybinding.commits.checkoutCommit)
static bool _jm_f_84(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .keybinding.commits.checkoutCommit
    res = json_model_4(val, path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected $keybinding [.keybinding.commits.checkoutCommit]", path);
    }
    return res;
}

// check _jm_obj_25_map_cherryPickCopy (.keybinding.commits.cherryPickCopy)
static bool _jm_f_85(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .keybinding.commits.cherryPickCopy
    res = json_model_4(val, path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected $keybinding [.keybinding.commits.cherryPickCopy]", path);
    }
    return res;
}

// check _jm_obj_25_map_cherryPickCopyRange (.keybinding.commits.cherryPickCopyRange)
static bool _jm_f_86(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .keybinding.commits.cherryPickCopyRange
    res = json_model_4(val, path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected $keybinding [.keybinding.commits.cherryPickCopyRange]", path);
    }
    return res;
}

// check _jm_obj_25_map_copyCommitMessageToClipboard (.keybinding.commits.copyCommitMessageToClipboard)
static bool _jm_f_87(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .keybinding.commits.copyCommitMessageToClipboard
    res = json_model_4(val, path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected $keybinding [.keybinding.commits.copyCommitMessageToClipboard]", path);
    }
    return res;
}

// check _jm_obj_25_map_createFixupCommit (.keybinding.commits.createFixupCommit)
static bool _jm_f_88(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .keybinding.commits.createFixupCommit
    res = json_model_4(val, path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected $keybinding [.keybinding.commits.createFixupCommit]", path);
    }
    return res;
}

// check _jm_obj_25_map_markCommitAsFixup (.keybinding.commits.markCommitAsFixup)
static bool _jm_f_89(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .keybinding.commits.markCommitAsFixup
    res = json_model_4(val, path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected $keybinding [.keybinding.commits.markCommitAsFixup]", path);
    }
    return res;
}

// check _jm_obj_25_map_moveDownCommit (.keybinding.commits.moveDownCommit)
static bool _jm_f_90(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .keybinding.commits.moveDownCommit
    res = json_model_4(val, path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected $keybinding [.keybinding.commits.moveDownCommit]", path);
    }
    return res;
}

// check _jm_obj_25_map_moveUpCommit (.keybinding.commits.moveUpCommit)
static bool _jm_f_91(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .keybinding.commits.moveUpCommit
    res = json_model_4(val, path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected $keybinding [.keybinding.commits.moveUpCommit]", path);
    }
    return res;
}

// check _jm_obj_25_map_openLogMenu (.keybinding.commits.openLogMenu)
static bool _jm_f_92(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .keybinding.commits.openLogMenu
    res = json_model_4(val, path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected $keybinding [.keybinding.commits.openLogMenu]", path);
    }
    return res;
}

// check _jm_obj_25_map_pasteCommits (.keybinding.commits.pasteCommits)
static bool _jm_f_93(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .keybinding.commits.pasteCommits
    res = json_model_4(val, path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected $keybinding [.keybinding.commits.pasteCommits]", path);
    }
    return res;
}

// check _jm_obj_25_map_pickCommit (.keybinding.commits.pickCommit)
static bool _jm_f_94(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .keybinding.commits.pickCommit
    res = json_model_4(val, path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected $keybinding [.keybinding.commits.pickCommit]", path);
    }
    return res;
}

// check _jm_obj_25_map_renameCommit (.keybinding.commits.renameCommit)
static bool _jm_f_95(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .keybinding.commits.renameCommit
    res = json_model_4(val, path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected $keybinding [.keybinding.commits.renameCommit]", path);
    }
    return res;
}

// check _jm_obj_25_map_renameCommitWithEditor (.keybinding.commits.renameCommitWithEditor)
static bool _jm_f_96(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .keybinding.commits.renameCommitWithEditor
    res = json_model_4(val, path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected $keybinding [.keybinding.commits.renameCommitWithEditor]", path);
    }
    return res;
}

// check _jm_obj_25_map_resetCherryPick (.keybinding.commits.resetCherryPick)
static bool _jm_f_97(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .keybinding.commits.resetCherryPick
    res = json_model_4(val, path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected $keybinding [.keybinding.commits.resetCherryPick]", path);
    }
    return res;
}

// check _jm_obj_25_map_revertCommit (.keybinding.commits.revertCommit)
static bool _jm_f_98(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .keybinding.commits.revertCommit
    res = json_model_4(val, path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected $keybinding [.keybinding.commits.revertCommit]", path);
    }
    return res;
}

// check _jm_obj_25_map_squashAboveCommits (.keybinding.commits.squashAboveCommits)
static bool _jm_f_99(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .keybinding.commits.squashAboveCommits
    res = json_model_4(val, path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected $keybinding [.keybinding.commits.squashAboveCommits]", path);
    }
    return res;
}

// check _jm_obj_25_map_squashDown (.keybinding.commits.squashDown)
static bool _jm_f_100(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .keybinding.commits.squashDown
    res = json_model_4(val, path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected $keybinding [.keybinding.commits.squashDown]", path);
    }
    return res;
}

// check _jm_obj_25_map_tagCommit (.keybinding.commits.tagCommit)
static bool _jm_f_101(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .keybinding.commits.tagCommit
    res = json_model_4(val, path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected $keybinding [.keybinding.commits.tagCommit]", path);
    }
    return res;
}

// check _jm_obj_25_map_viewBisectOptions (.keybinding.commits.viewBisectOptions)
static bool _jm_f_102(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .keybinding.commits.viewBisectOptions
    res = json_model_4(val, path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected $keybinding [.keybinding.commits.viewBisectOptions]", path);
    }
    return res;
}

// check _jm_obj_25_map_viewResetOptions (.keybinding.commits.viewResetOptions)
static bool _jm_f_103(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .keybinding.commits.viewResetOptions
    res = json_model_4(val, path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected $keybinding [.keybinding.commits.viewResetOptions]", path);
    }
    return res;
}

static jm_check_fun_t _jm_obj_25_map(const char *pname)
{
    return jm_search_propmap(pname, _jm_obj_25_map_tab, 21);
}

// object .keybinding.commits
static bool _jm_obj_25(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    if (! json_is_object(val))
    {
        if (rep) jm_report_add_entry(rep, "not an object [.keybinding.commits]", path);
        return false;
    }
    jm_check_fun_t pfun;
    const char *prop;
    json_t *pval;
    json_object_foreach((json_t *) val, prop, pval)
    {
        jm_path_t lpath_25 = (jm_path_t) { prop, 0, path, NULL };
        if ((pfun = _jm_obj_25_map(prop)))
        {
            // handle 21 may props
            if (pfun != NULL && ! pfun(pval, (path ? &lpath_25 : NULL), rep))
            {
                if (rep) jm_report_add_entry(rep, "invalid optional prop value [.keybinding.commits]", (path ? &lpath_25 : NULL));
                return false;
            }
        }
        else
        {
            if (rep) jm_report_add_entry(rep, "unexpected prop [.keybinding.commits]", (path ? &lpath_25 : NULL));
            return false;
        }
    }
    return true;
}

// check _jm_obj_22_map_commits (.keybinding.commits)
static bool _jm_f_82(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .keybinding.commits
    res = _jm_obj_25(val, path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected element [.keybinding.commits]", path);
    }
    return res;
}

// check _jm_obj_26_map_amendLastCommit (.keybinding.files.amendLastCommit)
static bool _jm_f_105(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .keybinding.files.amendLastCommit
    res = json_model_4(val, path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected $keybinding [.keybinding.files.amendLastCommit]", path);
    }
    return res;
}

// check _jm_obj_26_map_commitChanges (.keybinding.files.commitChanges)
static bool _jm_f_106(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .keybinding.files.commitChanges
    res = json_model_4(val, path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected $keybinding [.keybinding.files.commitChanges]", path);
    }
    return res;
}

// check _jm_obj_26_map_commitChangesWithEditor (.keybinding.files.commitChangesWithEditor)
static bool _jm_f_107(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .keybinding.files.commitChangesWithEditor
    res = json_model_4(val, path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected $keybinding [.keybinding.files.commitChangesWithEditor]", path);
    }
    return res;
}

// check _jm_obj_26_map_commitChangesWithoutHook (.keybinding.files.commitChangesWithoutHook)
static bool _jm_f_108(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .keybinding.files.commitChangesWithoutHook
    res = json_model_4(val, path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected $keybinding [.keybinding.files.commitChangesWithoutHook]", path);
    }
    return res;
}

// check _jm_obj_26_map_fetch (.keybinding.files.fetch)
static bool _jm_f_109(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .keybinding.files.fetch
    res = json_model_4(val, path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected $keybinding [.keybinding.files.fetch]", path);
    }
    return res;
}

// check _jm_obj_26_map_ignoreFile (.keybinding.files.ignoreFile)
static bool _jm_f_110(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .keybinding.files.ignoreFile
    res = json_model_4(val, path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected $keybinding [.keybinding.files.ignoreFile]", path);
    }
    return res;
}

// check _jm_obj_26_map_openMergeTool (.keybinding.files.openMergeTool)
static bool _jm_f_111(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .keybinding.files.openMergeTool
    res = json_model_4(val, path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected $keybinding [.keybinding.files.openMergeTool]", path);
    }
    return res;
}

// check _jm_obj_26_map_openStatusFilter (.keybinding.files.openStatusFilter)
static bool _jm_f_112(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .keybinding.files.openStatusFilter
    res = json_model_4(val, path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected $keybinding [.keybinding.files.openStatusFilter]", path);
    }
    return res;
}

// check _jm_obj_26_map_refreshFiles (.keybinding.files.refreshFiles)
static bool _jm_f_113(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .keybinding.files.refreshFiles
    res = json_model_4(val, path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected $keybinding [.keybinding.files.refreshFiles]", path);
    }
    return res;
}

// check _jm_obj_26_map_stashAllChanges (.keybinding.files.stashAllChanges)
static bool _jm_f_114(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .keybinding.files.stashAllChanges
    res = json_model_4(val, path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected $keybinding [.keybinding.files.stashAllChanges]", path);
    }
    return res;
}

// check _jm_obj_26_map_toggleStagedAll (.keybinding.files.toggleStagedAll)
static bool _jm_f_115(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .keybinding.files.toggleStagedAll
    res = json_model_4(val, path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected $keybinding [.keybinding.files.toggleStagedAll]", path);
    }
    return res;
}

// check _jm_obj_26_map_toggleTreeView (.keybinding.files.toggleTreeView)
static bool _jm_f_116(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .keybinding.files.toggleTreeView
    res = json_model_4(val, path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected $keybinding [.keybinding.files.toggleTreeView]", path);
    }
    return res;
}

// check _jm_obj_26_map_viewResetOptions (.keybinding.files.viewResetOptions)
static bool _jm_f_117(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .keybinding.files.viewResetOptions
    res = json_model_4(val, path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected $keybinding [.keybinding.files.viewResetOptions]", path);
    }
    return res;
}

// check _jm_obj_26_map_viewStashOptions (.keybinding.files.viewStashOptions)
static bool _jm_f_118(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .keybinding.files.viewStashOptions
    res = json_model_4(val, path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected $keybinding [.keybinding.files.viewStashOptions]", path);
    }
    return res;
}

static jm_check_fun_t _jm_obj_26_map(const char *pname)
{
    return jm_search_propmap(pname, _jm_obj_26_map_tab, 14);
}

// object .keybinding.files
static bool _jm_obj_26(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    if (! json_is_object(val))
    {
        if (rep) jm_report_add_entry(rep, "not an object [.keybinding.files]", path);
        return false;
    }
    jm_check_fun_t pfun;
    const char *prop;
    json_t *pval;
    json_object_foreach((json_t *) val, prop, pval)
    {
        jm_path_t lpath_26 = (jm_path_t) { prop, 0, path, NULL };
        if ((pfun = _jm_obj_26_map(prop)))
        {
            // handle 14 may props
            if (pfun != NULL && ! pfun(pval, (path ? &lpath_26 : NULL), rep))
            {
                if (rep) jm_report_add_entry(rep, "invalid optional prop value [.keybinding.files]", (path ? &lpath_26 : NULL));
                return false;
            }
        }
        else
        {
            if (rep) jm_report_add_entry(rep, "unexpected prop [.keybinding.files]", (path ? &lpath_26 : NULL));
            return false;
        }
    }
    return true;
}

// check _jm_obj_22_map_files (.keybinding.files)
static bool _jm_f_104(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .keybinding.files
    res = _jm_obj_26(val, path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected element [.keybinding.files]", path);
    }
    return res;
}

// object .keybinding.main
static bool _jm_obj_27(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    if (! json_is_object(val))
    {
        if (rep) jm_report_add_entry(rep, "not an object [.keybinding.main]", path);
        return false;
    }
    bool res;
    const char *prop;
    json_t *pval;
    json_object_foreach((json_t *) val, prop, pval)
    {
        jm_path_t lpath_27 = (jm_path_t) { prop, 0, path, NULL };
        if (strcmp(prop, "toggleDragSelect") == 0)
        {
            // handle may toggleDragSelect property
            // .keybinding.main.toggleDragSelect
            res = json_model_4(pval, (path ? &lpath_27 : NULL), rep);
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "unexpected $keybinding [.keybinding.main.toggleDragSelect]", (path ? &lpath_27 : NULL));
            }
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "invalid optional prop value [.keybinding.main.toggleDragSelect]", (path ? &lpath_27 : NULL));
                return false;
            }
        }
        else if (strcmp(prop, "toggleDragSelect-alt") == 0)
        {
            // handle may toggleDragSelect-alt property
            // .keybinding.main.'toggleDragSelect-alt'
            res = json_model_4(pval, (path ? &lpath_27 : NULL), rep);
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "unexpected $keybinding [.keybinding.main.'toggleDragSelect-alt']", (path ? &lpath_27 : NULL));
            }
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "invalid optional prop value [.keybinding.main.'toggleDragSelect-alt']", (path ? &lpath_27 : NULL));
                return false;
            }
        }
        else if (strcmp(prop, "toggleSelectHunk") == 0)
        {
            // handle may toggleSelectHunk property
            // .keybinding.main.toggleSelectHunk
            res = json_model_4(pval, (path ? &lpath_27 : NULL), rep);
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "unexpected $keybinding [.keybinding.main.toggleSelectHunk]", (path ? &lpath_27 : NULL));
            }
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "invalid optional prop value [.keybinding.main.toggleSelectHunk]", (path ? &lpath_27 : NULL));
                return false;
            }
        }
        else if (strcmp(prop, "pickBothHunks") == 0)
        {
            // handle may pickBothHunks property
            // .keybinding.main.pickBothHunks
            res = json_model_4(pval, (path ? &lpath_27 : NULL), rep);
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "unexpected $keybinding [.keybinding.main.pickBothHunks]", (path ? &lpath_27 : NULL));
            }
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "invalid optional prop value [.keybinding.main.pickBothHunks]", (path ? &lpath_27 : NULL));
                return false;
            }
        }
        else
        {
            if (rep) jm_report_add_entry(rep, "unexpected prop [.keybinding.main]", (path ? &lpath_27 : NULL));
            return false;
        }
    }
    return true;
}

// check _jm_obj_22_map_main (.keybinding.main)
static bool _jm_f_119(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .keybinding.main
    res = _jm_obj_27(val, path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected element [.keybinding.main]", path);
    }
    return res;
}

// object .keybinding.stash
static bool _jm_obj_28(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    if (! json_is_object(val))
    {
        if (rep) jm_report_add_entry(rep, "not an object [.keybinding.stash]", path);
        return false;
    }
    bool res;
    const char *prop;
    json_t *pval;
    json_object_foreach((json_t *) val, prop, pval)
    {
        jm_path_t lpath_28 = (jm_path_t) { prop, 0, path, NULL };
        if (strcmp(prop, "popStash") == 0)
        {
            // handle may popStash property
            // .keybinding.stash.popStash
            res = json_model_4(pval, (path ? &lpath_28 : NULL), rep);
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "unexpected $keybinding [.keybinding.stash.popStash]", (path ? &lpath_28 : NULL));
            }
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "invalid optional prop value [.keybinding.stash.popStash]", (path ? &lpath_28 : NULL));
                return false;
            }
        }
        else if (strcmp(prop, "renameStash") == 0)
        {
            // handle may renameStash property
            // .keybinding.stash.renameStash
            res = json_model_4(pval, (path ? &lpath_28 : NULL), rep);
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "unexpected $keybinding [.keybinding.stash.renameStash]", (path ? &lpath_28 : NULL));
            }
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "invalid optional prop value [.keybinding.stash.renameStash]", (path ? &lpath_28 : NULL));
                return false;
            }
        }
        else
        {
            if (rep) jm_report_add_entry(rep, "unexpected prop [.keybinding.stash]", (path ? &lpath_28 : NULL));
            return false;
        }
    }
    return true;
}

// check _jm_obj_22_map_stash (.keybinding.stash)
static bool _jm_f_120(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .keybinding.stash
    res = _jm_obj_28(val, path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected element [.keybinding.stash]", path);
    }
    return res;
}

// object .keybinding.status
static bool _jm_obj_29(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    if (! json_is_object(val))
    {
        if (rep) jm_report_add_entry(rep, "not an object [.keybinding.status]", path);
        return false;
    }
    bool res;
    const char *prop;
    json_t *pval;
    json_object_foreach((json_t *) val, prop, pval)
    {
        jm_path_t lpath_29 = (jm_path_t) { prop, 0, path, NULL };
        if (strcmp(prop, "checkForUpdate") == 0)
        {
            // handle may checkForUpdate property
            // .keybinding.status.checkForUpdate
            res = json_model_4(pval, (path ? &lpath_29 : NULL), rep);
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "unexpected $keybinding [.keybinding.status.checkForUpdate]", (path ? &lpath_29 : NULL));
            }
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "invalid optional prop value [.keybinding.status.checkForUpdate]", (path ? &lpath_29 : NULL));
                return false;
            }
        }
        else if (strcmp(prop, "recentRepos") == 0)
        {
            // handle may recentRepos property
            // .keybinding.status.recentRepos
            res = json_model_4(pval, (path ? &lpath_29 : NULL), rep);
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "unexpected $keybinding [.keybinding.status.recentRepos]", (path ? &lpath_29 : NULL));
            }
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "invalid optional prop value [.keybinding.status.recentRepos]", (path ? &lpath_29 : NULL));
                return false;
            }
        }
        else
        {
            if (rep) jm_report_add_entry(rep, "unexpected prop [.keybinding.status]", (path ? &lpath_29 : NULL));
            return false;
        }
    }
    return true;
}

// check _jm_obj_22_map_status (.keybinding.status)
static bool _jm_f_121(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .keybinding.status
    res = _jm_obj_29(val, path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected element [.keybinding.status]", path);
    }
    return res;
}

// object .keybinding.submodules
static bool _jm_obj_30(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    if (! json_is_object(val))
    {
        if (rep) jm_report_add_entry(rep, "not an object [.keybinding.submodules]", path);
        return false;
    }
    bool res;
    const char *prop;
    json_t *pval;
    json_object_foreach((json_t *) val, prop, pval)
    {
        jm_path_t lpath_30 = (jm_path_t) { prop, 0, path, NULL };
        if (strcmp(prop, "init") == 0)
        {
            // handle may init property
            // .keybinding.submodules.init
            res = json_model_4(pval, (path ? &lpath_30 : NULL), rep);
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "unexpected $keybinding [.keybinding.submodules.init]", (path ? &lpath_30 : NULL));
            }
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "invalid optional prop value [.keybinding.submodules.init]", (path ? &lpath_30 : NULL));
                return false;
            }
        }
        else if (strcmp(prop, "update") == 0)
        {
            // handle may update property
            // .keybinding.submodules.update
            res = json_model_4(pval, (path ? &lpath_30 : NULL), rep);
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "unexpected $keybinding [.keybinding.submodules.update]", (path ? &lpath_30 : NULL));
            }
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "invalid optional prop value [.keybinding.submodules.update]", (path ? &lpath_30 : NULL));
                return false;
            }
        }
        else if (strcmp(prop, "bulkMenu") == 0)
        {
            // handle may bulkMenu property
            // .keybinding.submodules.bulkMenu
            res = json_model_4(pval, (path ? &lpath_30 : NULL), rep);
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "unexpected $keybinding [.keybinding.submodules.bulkMenu]", (path ? &lpath_30 : NULL));
            }
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "invalid optional prop value [.keybinding.submodules.bulkMenu]", (path ? &lpath_30 : NULL));
                return false;
            }
        }
        else
        {
            if (rep) jm_report_add_entry(rep, "unexpected prop [.keybinding.submodules]", (path ? &lpath_30 : NULL));
            return false;
        }
    }
    return true;
}

// check _jm_obj_22_map_submodules (.keybinding.submodules)
static bool _jm_f_122(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .keybinding.submodules
    res = _jm_obj_30(val, path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected element [.keybinding.submodules]", path);
    }
    return res;
}

// check _jm_obj_31_map_confirm (.keybinding.universal.confirm)
static bool _jm_f_124(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .keybinding.universal.confirm
    res = json_model_4(val, path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected $keybinding [.keybinding.universal.confirm]", path);
    }
    return res;
}

// check _jm_obj_31_map_copyToClipboard (.keybinding.universal.copyToClipboard)
static bool _jm_f_125(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .keybinding.universal.copyToClipboard
    res = json_model_4(val, path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected $keybinding [.keybinding.universal.copyToClipboard]", path);
    }
    return res;
}

// check _jm_obj_31_map_createPatchOptionsMenu (.keybinding.universal.createPatchOptionsMenu)
static bool _jm_f_126(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .keybinding.universal.createPatchOptionsMenu
    res = json_model_4(val, path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected $keybinding [.keybinding.universal.createPatchOptionsMenu]", path);
    }
    return res;
}

// check _jm_obj_31_map_createRebaseOptionsMenu (.keybinding.universal.createRebaseOptionsMenu)
static bool _jm_f_127(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .keybinding.universal.createRebaseOptionsMenu
    res = json_model_4(val, path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected $keybinding [.keybinding.universal.createRebaseOptionsMenu]", path);
    }
    return res;
}

// check _jm_obj_31_map_decreaseContextInDiffView (.keybinding.universal.decreaseContextInDiffView)
static bool _jm_f_128(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .keybinding.universal.decreaseContextInDiffView
    res = json_model_4(val, path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected $keybinding [.keybinding.universal.decreaseContextInDiffView]", path);
    }
    return res;
}

// check _jm_obj_31_map_diffingMenu (.keybinding.universal.diffingMenu)
static bool _jm_f_129(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .keybinding.universal.diffingMenu
    res = json_model_4(val, path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected $keybinding [.keybinding.universal.diffingMenu]", path);
    }
    return res;
}

// check _jm_obj_31_map_diffingMenu-alt (.keybinding.universal.'diffingMenu-alt')
static bool _jm_f_130(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .keybinding.universal.'diffingMenu-alt'
    res = json_model_4(val, path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected $keybinding [.keybinding.universal.'diffingMenu-alt']", path);
    }
    return res;
}

// check _jm_obj_31_map_edit (.keybinding.universal.edit)
static bool _jm_f_131(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .keybinding.universal.edit
    res = json_model_4(val, path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected $keybinding [.keybinding.universal.edit]", path);
    }
    return res;
}

// check _jm_obj_31_map_executeCustomCommand (.keybinding.universal.executeCustomCommand)
static bool _jm_f_132(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .keybinding.universal.executeCustomCommand
    res = json_model_4(val, path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected $keybinding [.keybinding.universal.executeCustomCommand]", path);
    }
    return res;
}

// check _jm_obj_31_map_extrasMenu (.keybinding.universal.extrasMenu)
static bool _jm_f_133(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .keybinding.universal.extrasMenu
    res = json_model_4(val, path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected $keybinding [.keybinding.universal.extrasMenu]", path);
    }
    return res;
}

// check _jm_obj_31_map_filteringMenu (.keybinding.universal.filteringMenu)
static bool _jm_f_134(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .keybinding.universal.filteringMenu
    res = json_model_4(val, path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected $keybinding [.keybinding.universal.filteringMenu]", path);
    }
    return res;
}

// check _jm_obj_31_map_goInto (.keybinding.universal.goInto)
static bool _jm_f_135(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .keybinding.universal.goInto
    res = json_model_4(val, path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected $keybinding [.keybinding.universal.goInto]", path);
    }
    return res;
}

// check _jm_obj_31_map_gotoBottom (.keybinding.universal.gotoBottom)
static bool _jm_f_136(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .keybinding.universal.gotoBottom
    res = json_model_4(val, path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected $keybinding [.keybinding.universal.gotoBottom]", path);
    }
    return res;
}

// check _jm_obj_31_map_gotoTop (.keybinding.universal.gotoTop)
static bool _jm_f_137(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .keybinding.universal.gotoTop
    res = json_model_4(val, path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected $keybinding [.keybinding.universal.gotoTop]", path);
    }
    return res;
}

// check _jm_obj_31_map_increaseContextInDiffView (.keybinding.universal.increaseContextInDiffView)
static bool _jm_f_138(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .keybinding.universal.increaseContextInDiffView
    res = json_model_4(val, path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected $keybinding [.keybinding.universal.increaseContextInDiffView]", path);
    }
    return res;
}

// check _jm_obj_31_map_jumpToBlock (.keybinding.universal.jumpToBlock)
static bool _jm_f_139(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .keybinding.universal.jumpToBlock
    res = json_is_array(val);
    if (res)
    {
        // accept any array
    }
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "not array or unexpected array [.keybinding.universal.jumpToBlock]", path);
    }
    return res;
}

// check _jm_obj_31_map_new (.keybinding.universal.new)
static bool _jm_f_140(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .keybinding.universal.new
    res = json_model_4(val, path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected $keybinding [.keybinding.universal.new]", path);
    }
    return res;
}

// check _jm_obj_31_map_nextBlock (.keybinding.universal.nextBlock)
static bool _jm_f_141(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .keybinding.universal.nextBlock
    res = json_model_4(val, path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected $keybinding [.keybinding.universal.nextBlock]", path);
    }
    return res;
}

// check _jm_obj_31_map_nextBlock-alt (.keybinding.universal.'nextBlock-alt')
static bool _jm_f_142(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .keybinding.universal.'nextBlock-alt'
    res = json_model_4(val, path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected $keybinding [.keybinding.universal.'nextBlock-alt']", path);
    }
    return res;
}

// check _jm_obj_31_map_nextItem (.keybinding.universal.nextItem)
static bool _jm_f_143(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .keybinding.universal.nextItem
    res = json_model_4(val, path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected $keybinding [.keybinding.universal.nextItem]", path);
    }
    return res;
}

// check _jm_obj_31_map_nextItem-alt (.keybinding.universal.'nextItem-alt')
static bool _jm_f_144(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .keybinding.universal.'nextItem-alt'
    res = json_model_4(val, path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected $keybinding [.keybinding.universal.'nextItem-alt']", path);
    }
    return res;
}

// check _jm_obj_31_map_nextMatch (.keybinding.universal.nextMatch)
static bool _jm_f_145(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .keybinding.universal.nextMatch
    res = json_model_4(val, path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected $keybinding [.keybinding.universal.nextMatch]", path);
    }
    return res;
}

// check _jm_obj_31_map_nextPage (.keybinding.universal.nextPage)
static bool _jm_f_146(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .keybinding.universal.nextPage
    res = json_model_4(val, path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected $keybinding [.keybinding.universal.nextPage]", path);
    }
    return res;
}

// check _jm_obj_31_map_nextScreenMode (.keybinding.universal.nextScreenMode)
static bool _jm_f_147(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .keybinding.universal.nextScreenMode
    res = json_model_4(val, path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected $keybinding [.keybinding.universal.nextScreenMode]", path);
    }
    return res;
}

// check _jm_obj_31_map_nextTab (.keybinding.universal.nextTab)
static bool _jm_f_148(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .keybinding.universal.nextTab
    res = json_model_4(val, path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected $keybinding [.keybinding.universal.nextTab]", path);
    }
    return res;
}

// check _jm_obj_31_map_openFile (.keybinding.universal.openFile)
static bool _jm_f_149(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .keybinding.universal.openFile
    res = json_model_4(val, path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected $keybinding [.keybinding.universal.openFile]", path);
    }
    return res;
}

// check _jm_obj_31_map_openRecentRepos (.keybinding.universal.openRecentRepos)
static bool _jm_f_150(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .keybinding.universal.openRecentRepos
    res = json_model_4(val, path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected $keybinding [.keybinding.universal.openRecentRepos]", path);
    }
    return res;
}

// check _jm_obj_31_map_optionMenu (.keybinding.universal.optionMenu)
static bool _jm_f_151(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .keybinding.universal.optionMenu
    res = json_is_null(val);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "not null [.keybinding.universal.optionMenu]", path);
    }
    return res;
}

// check _jm_obj_31_map_optionMenu-alt1 (.keybinding.universal.'optionMenu-alt1')
static bool _jm_f_152(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .keybinding.universal.'optionMenu-alt1'
    res = json_model_4(val, path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected $keybinding [.keybinding.universal.'optionMenu-alt1']", path);
    }
    return res;
}

// check _jm_obj_31_map_prevBlock (.keybinding.universal.prevBlock)
static bool _jm_f_153(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .keybinding.universal.prevBlock
    res = json_model_4(val, path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected $keybinding [.keybinding.universal.prevBlock]", path);
    }
    return res;
}

// check _jm_obj_31_map_prevBlock-alt (.keybinding.universal.'prevBlock-alt')
static bool _jm_f_154(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .keybinding.universal.'prevBlock-alt'
    res = json_model_4(val, path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected $keybinding [.keybinding.universal.'prevBlock-alt']", path);
    }
    return res;
}

// check _jm_obj_31_map_prevItem (.keybinding.universal.prevItem)
static bool _jm_f_155(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .keybinding.universal.prevItem
    res = json_model_4(val, path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected $keybinding [.keybinding.universal.prevItem]", path);
    }
    return res;
}

// check _jm_obj_31_map_prevItem-alt (.keybinding.universal.'prevItem-alt')
static bool _jm_f_156(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .keybinding.universal.'prevItem-alt'
    res = json_model_4(val, path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected $keybinding [.keybinding.universal.'prevItem-alt']", path);
    }
    return res;
}

// check _jm_obj_31_map_prevMatch (.keybinding.universal.prevMatch)
static bool _jm_f_157(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .keybinding.universal.prevMatch
    res = json_model_4(val, path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected $keybinding [.keybinding.universal.prevMatch]", path);
    }
    return res;
}

// check _jm_obj_31_map_prevPage (.keybinding.universal.prevPage)
static bool _jm_f_158(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .keybinding.universal.prevPage
    res = json_model_4(val, path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected $keybinding [.keybinding.universal.prevPage]", path);
    }
    return res;
}

// check _jm_obj_31_map_prevScreenMode (.keybinding.universal.prevScreenMode)
static bool _jm_f_159(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .keybinding.universal.prevScreenMode
    res = json_model_4(val, path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected $keybinding [.keybinding.universal.prevScreenMode]", path);
    }
    return res;
}

// check _jm_obj_31_map_prevTab (.keybinding.universal.prevTab)
static bool _jm_f_160(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .keybinding.universal.prevTab
    res = json_model_4(val, path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected $keybinding [.keybinding.universal.prevTab]", path);
    }
    return res;
}

// check _jm_obj_31_map_pullFiles (.keybinding.universal.pullFiles)
static bool _jm_f_161(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .keybinding.universal.pullFiles
    res = json_model_4(val, path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected $keybinding [.keybinding.universal.pullFiles]", path);
    }
    return res;
}

// check _jm_obj_31_map_pushFiles (.keybinding.universal.pushFiles)
static bool _jm_f_162(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .keybinding.universal.pushFiles
    res = json_model_4(val, path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected $keybinding [.keybinding.universal.pushFiles]", path);
    }
    return res;
}

// check _jm_obj_31_map_quit (.keybinding.universal.quit)
static bool _jm_f_163(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .keybinding.universal.quit
    res = json_model_4(val, path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected $keybinding [.keybinding.universal.quit]", path);
    }
    return res;
}

// check _jm_obj_31_map_quit-alt1 (.keybinding.universal.'quit-alt1')
static bool _jm_f_164(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .keybinding.universal.'quit-alt1'
    res = json_model_4(val, path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected $keybinding [.keybinding.universal.'quit-alt1']", path);
    }
    return res;
}

// check _jm_obj_31_map_quitWithoutChangingDirectory (.keybinding.universal.quitWithoutChangingDirectory)
static bool _jm_f_165(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .keybinding.universal.quitWithoutChangingDirectory
    res = json_model_4(val, path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected $keybinding [.keybinding.universal.quitWithoutChangingDirectory]", path);
    }
    return res;
}

// check _jm_obj_31_map_redo (.keybinding.universal.redo)
static bool _jm_f_166(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .keybinding.universal.redo
    res = json_model_4(val, path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected $keybinding [.keybinding.universal.redo]", path);
    }
    return res;
}

// check _jm_obj_31_map_refresh (.keybinding.universal.refresh)
static bool _jm_f_167(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .keybinding.universal.refresh
    res = json_model_4(val, path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected $keybinding [.keybinding.universal.refresh]", path);
    }
    return res;
}

// check _jm_obj_31_map_remove (.keybinding.universal.remove)
static bool _jm_f_168(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .keybinding.universal.remove
    res = json_model_4(val, path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected $keybinding [.keybinding.universal.remove]", path);
    }
    return res;
}

// check _jm_obj_31_map_return (.keybinding.universal.return)
static bool _jm_f_169(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .keybinding.universal.return
    res = json_model_4(val, path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected $keybinding [.keybinding.universal.return]", path);
    }
    return res;
}

// check _jm_obj_31_map_scrollDownMain (.keybinding.universal.scrollDownMain)
static bool _jm_f_170(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .keybinding.universal.scrollDownMain
    res = json_model_4(val, path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected $keybinding [.keybinding.universal.scrollDownMain]", path);
    }
    return res;
}

// check _jm_obj_31_map_scrollDownMain-alt1 (.keybinding.universal.'scrollDownMain-alt1')
static bool _jm_f_171(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .keybinding.universal.'scrollDownMain-alt1'
    res = json_model_4(val, path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected $keybinding [.keybinding.universal.'scrollDownMain-alt1']", path);
    }
    return res;
}

// check _jm_obj_31_map_scrollDownMain-alt2 (.keybinding.universal.'scrollDownMain-alt2')
static bool _jm_f_172(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .keybinding.universal.'scrollDownMain-alt2'
    res = json_model_4(val, path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected $keybinding [.keybinding.universal.'scrollDownMain-alt2']", path);
    }
    return res;
}

// check _jm_obj_31_map_scrollLeft (.keybinding.universal.scrollLeft)
static bool _jm_f_173(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .keybinding.universal.scrollLeft
    res = json_model_4(val, path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected $keybinding [.keybinding.universal.scrollLeft]", path);
    }
    return res;
}

// check _jm_obj_31_map_scrollRight (.keybinding.universal.scrollRight)
static bool _jm_f_174(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .keybinding.universal.scrollRight
    res = json_model_4(val, path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected $keybinding [.keybinding.universal.scrollRight]", path);
    }
    return res;
}

// check _jm_obj_31_map_scrollUpMain (.keybinding.universal.scrollUpMain)
static bool _jm_f_175(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .keybinding.universal.scrollUpMain
    res = json_model_4(val, path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected $keybinding [.keybinding.universal.scrollUpMain]", path);
    }
    return res;
}

// check _jm_obj_31_map_scrollUpMain-alt1 (.keybinding.universal.'scrollUpMain-alt1')
static bool _jm_f_176(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .keybinding.universal.'scrollUpMain-alt1'
    res = json_model_4(val, path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected $keybinding [.keybinding.universal.'scrollUpMain-alt1']", path);
    }
    return res;
}

// check _jm_obj_31_map_scrollUpMain-alt2 (.keybinding.universal.'scrollUpMain-alt2')
static bool _jm_f_177(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .keybinding.universal.'scrollUpMain-alt2'
    res = json_model_4(val, path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected $keybinding [.keybinding.universal.'scrollUpMain-alt2']", path);
    }
    return res;
}

// check _jm_obj_31_map_select (.keybinding.universal.select)
static bool _jm_f_178(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .keybinding.universal.select
    res = json_model_4(val, path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected $keybinding [.keybinding.universal.select]", path);
    }
    return res;
}

// check _jm_obj_31_map_submitEditorText (.keybinding.universal.submitEditorText)
static bool _jm_f_179(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .keybinding.universal.submitEditorText
    res = json_model_4(val, path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected $keybinding [.keybinding.universal.submitEditorText]", path);
    }
    return res;
}

// check _jm_obj_31_map_togglePanel (.keybinding.universal.togglePanel)
static bool _jm_f_180(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .keybinding.universal.togglePanel
    res = json_model_4(val, path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected $keybinding [.keybinding.universal.togglePanel]", path);
    }
    return res;
}

// check _jm_obj_31_map_toggleWhitespaceInDiffView (.keybinding.universal.toggleWhitespaceInDiffView)
static bool _jm_f_181(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .keybinding.universal.toggleWhitespaceInDiffView
    res = json_model_4(val, path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected $keybinding [.keybinding.universal.toggleWhitespaceInDiffView]", path);
    }
    return res;
}

// check _jm_obj_31_map_undo (.keybinding.universal.undo)
static bool _jm_f_182(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .keybinding.universal.undo
    res = json_model_4(val, path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected $keybinding [.keybinding.universal.undo]", path);
    }
    return res;
}

static jm_check_fun_t _jm_obj_31_map(const char *pname)
{
    return jm_search_propmap(pname, _jm_obj_31_map_tab, 59);
}

// object .keybinding.universal
static bool _jm_obj_31(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    if (! json_is_object(val))
    {
        if (rep) jm_report_add_entry(rep, "not an object [.keybinding.universal]", path);
        return false;
    }
    jm_check_fun_t pfun;
    const char *prop;
    json_t *pval;
    json_object_foreach((json_t *) val, prop, pval)
    {
        jm_path_t lpath_31 = (jm_path_t) { prop, 0, path, NULL };
        if ((pfun = _jm_obj_31_map(prop)))
        {
            // handle 59 may props
            if (pfun != NULL && ! pfun(pval, (path ? &lpath_31 : NULL), rep))
            {
                if (rep) jm_report_add_entry(rep, "invalid optional prop value [.keybinding.universal]", (path ? &lpath_31 : NULL));
                return false;
            }
        }
        else
        {
            if (rep) jm_report_add_entry(rep, "unexpected prop [.keybinding.universal]", (path ? &lpath_31 : NULL));
            return false;
        }
    }
    return true;
}

// check _jm_obj_22_map_universal (.keybinding.universal)
static bool _jm_f_123(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .keybinding.universal
    res = _jm_obj_31(val, path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected element [.keybinding.universal]", path);
    }
    return res;
}

static jm_check_fun_t _jm_obj_22_map(const char *pname)
{
    return jm_search_propmap(pname, _jm_obj_22_map_tab, 9);
}

// object .keybinding
static bool _jm_obj_22(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    if (! json_is_object(val))
    {
        if (rep) jm_report_add_entry(rep, "not an object [.keybinding]", path);
        return false;
    }
    jm_check_fun_t pfun;
    const char *prop;
    json_t *pval;
    json_object_foreach((json_t *) val, prop, pval)
    {
        jm_path_t lpath_22 = (jm_path_t) { prop, 0, path, NULL };
        if ((pfun = _jm_obj_22_map(prop)))
        {
            // handle 9 may props
            if (pfun != NULL && ! pfun(pval, (path ? &lpath_22 : NULL), rep))
            {
                if (rep) jm_report_add_entry(rep, "invalid optional prop value [.keybinding]", (path ? &lpath_22 : NULL));
                return false;
            }
        }
        else
        {
            if (rep) jm_report_add_entry(rep, "unexpected prop [.keybinding]", (path ? &lpath_22 : NULL));
            return false;
        }
    }
    return true;
}

// check _jm_obj_7_map_keybinding (.keybinding)
static bool _jm_f_66(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .keybinding
    res = _jm_obj_22(val, path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected element [.keybinding]", path);
    }
    return res;
}


// check _jm_obj_7_map_notARepository (.notARepository)
static bool _jm_f_183(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .notARepository
    res = jm_json_is_scalar(val) && json_is_string(val) && jm_search_cst(&(jm_constant_t) { cst_is_string, { .s = json_string_value(val) } }, _jm_cst_13, 4);;
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "value not in enum [.notARepository.'|']", path);
    }
    return res;
}

// check _jm_obj_32_map_copyToClipboardCmd (.os.copyToClipboardCmd)
static bool _jm_f_185(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .os.copyToClipboardCmd
    res = json_is_string(val);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected string [.os.copyToClipboardCmd]", path);
    }
    return res;
}

// check _jm_obj_32_map_edit (.os.edit)
static bool _jm_f_186(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .os.edit
    res = json_is_string(val);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected string [.os.edit]", path);
    }
    return res;
}

// check _jm_obj_32_map_editAtLine (.os.editAtLine)
static bool _jm_f_187(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .os.editAtLine
    res = json_is_string(val);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected string [.os.editAtLine]", path);
    }
    return res;
}

// check _jm_obj_32_map_editAtLineAndWait (.os.editAtLineAndWait)
static bool _jm_f_188(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .os.editAtLineAndWait
    res = json_is_string(val);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected string [.os.editAtLineAndWait]", path);
    }
    return res;
}


// check _jm_obj_32_map_editPreset (.os.editPreset)
static bool _jm_f_189(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .os.editPreset
    res = jm_json_is_scalar(val) && json_is_string(val) && jm_search_cst(&(jm_constant_t) { cst_is_string, { .s = json_string_value(val) } }, _jm_cst_14, 10);;
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "value not in enum [.os.editPreset.'|']", path);
    }
    if (! res)
    {
        res = json_is_string(val);
        if (! res)
        {
            if (rep) jm_report_add_entry(rep, "unexpected type [.os.editPreset.'|']", path);
        }
        if (res)
        {
            // .os.editPreset.'|'.0
            res = true;
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "unexpected string [.os.editPreset.'|'.0]", path);
            }
            if (res)
            {
                if (rep) jm_report_free_entries(rep);
            }
            else
            {
                if (rep) jm_report_add_entry(rep, "no model matched [.os.editPreset.'|']", path);
            }
        }
    }
    return res;
}

// check _jm_obj_32_map_open (.os.open)
static bool _jm_f_190(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .os.open
    res = json_is_string(val);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected string [.os.open]", path);
    }
    return res;
}

// check _jm_obj_32_map_openLink (.os.openLink)
static bool _jm_f_191(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .os.openLink
    res = json_is_string(val);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected string [.os.openLink]", path);
    }
    return res;
}

static jm_check_fun_t _jm_obj_32_map(const char *pname)
{
    return jm_search_propmap(pname, _jm_obj_32_map_tab, 7);
}

// object .os
static bool _jm_obj_32(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    if (! json_is_object(val))
    {
        if (rep) jm_report_add_entry(rep, "not an object [.os]", path);
        return false;
    }
    jm_check_fun_t pfun;
    const char *prop;
    json_t *pval;
    json_object_foreach((json_t *) val, prop, pval)
    {
        jm_path_t lpath_32 = (jm_path_t) { prop, 0, path, NULL };
        if ((pfun = _jm_obj_32_map(prop)))
        {
            // handle 7 may props
            if (pfun != NULL && ! pfun(pval, (path ? &lpath_32 : NULL), rep))
            {
                if (rep) jm_report_add_entry(rep, "invalid optional prop value [.os]", (path ? &lpath_32 : NULL));
                return false;
            }
        }
        else
        {
            if (rep) jm_report_add_entry(rep, "unexpected prop [.os]", (path ? &lpath_32 : NULL));
            return false;
        }
    }
    return true;
}

// check _jm_obj_7_map_os (.os)
static bool _jm_f_184(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .os
    res = _jm_obj_32(val, path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected element [.os]", path);
    }
    return res;
}

// check _jm_obj_7_map_promptToReturnFromSubprocess (.promptToReturnFromSubprocess)
static bool _jm_f_192(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .promptToReturnFromSubprocess
    res = json_is_boolean(val);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "not a bool [.promptToReturnFromSubprocess]", path);
    }
    return res;
}

// check _jm_obj_7_map_quitOnTopLevelReturn (.quitOnTopLevelReturn)
static bool _jm_f_193(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .quitOnTopLevelReturn
    res = json_is_boolean(val);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "not a bool [.quitOnTopLevelReturn]", path);
    }
    return res;
}

// object .refresher
static bool _jm_obj_33(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    if (! json_is_object(val))
    {
        if (rep) jm_report_add_entry(rep, "not an object [.refresher]", path);
        return false;
    }
    bool res;
    const char *prop;
    json_t *pval;
    json_object_foreach((json_t *) val, prop, pval)
    {
        jm_path_t lpath_33 = (jm_path_t) { prop, 0, path, NULL };
        if (strcmp(prop, "refreshInterval") == 0)
        {
            // handle may refreshInterval property
            // .refresher.refreshInterval
            res = json_is_integer(pval) && json_integer_value(pval) >= 0;
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "not a 0 strict int [.refresher.refreshInterval]", (path ? &lpath_33 : NULL));
            }
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "invalid optional prop value [.refresher.refreshInterval]", (path ? &lpath_33 : NULL));
                return false;
            }
        }
        else if (strcmp(prop, "fetchInterval") == 0)
        {
            // handle may fetchInterval property
            // .refresher.fetchInterval
            res = json_is_integer(pval) && json_integer_value(pval) >= 0;
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "not a 0 strict int [.refresher.fetchInterval]", (path ? &lpath_33 : NULL));
            }
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "invalid optional prop value [.refresher.fetchInterval]", (path ? &lpath_33 : NULL));
                return false;
            }
        }
        else
        {
            if (rep) jm_report_add_entry(rep, "unexpected prop [.refresher]", (path ? &lpath_33 : NULL));
            return false;
        }
    }
    return true;
}

// check _jm_obj_7_map_refresher (.refresher)
static bool _jm_f_194(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .refresher
    res = _jm_obj_33(val, path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected element [.refresher]", path);
    }
    return res;
}

static bool _jm_re_2(const char *s, jm_path_t *path, jm_report_t *rep)
{
    size_t slen = strlen(s);
    return cre2_match(_jm_re_2_re2, s, slen, 0, slen, CRE2_UNANCHORED, NULL, 0);
}

// object .services
static bool _jm_obj_34(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    if (! json_is_object(val))
    {
        if (rep) jm_report_add_entry(rep, "not an object [.services]", path);
        return false;
    }
    bool res;
    const char *prop;
    json_t *pval;
    json_object_foreach((json_t *) val, prop, pval)
    {
        jm_path_t lpath_34 = (jm_path_t) { prop, 0, path, NULL };
        if (_jm_re_1(prop, path, rep))
        {
            // handle 1 re props
            // .services.'/./'
            // "/^[^:]+:[^:]+$/"
            res = json_is_string(pval) && _jm_re_2(json_string_value(pval), (path ? &lpath_34 : NULL), rep);
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "unexpected /^[^:]+:[^:]+$/ [.services.'/./']", (path ? &lpath_34 : NULL));
            }
            if (! res)
            {
                return false;
            }
        }
        else
        {
            if (rep) jm_report_add_entry(rep, "unexpected prop [.services]", (path ? &lpath_34 : NULL));
            return false;
        }
    }
    return true;
}

// check _jm_obj_7_map_services (.services)
static bool _jm_f_195(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .services
    res = _jm_obj_34(val, path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected element [.services]", path);
    }
    return res;
}


// object .update
static bool _jm_obj_35(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    if (! json_is_object(val))
    {
        if (rep) jm_report_add_entry(rep, "not an object [.update]", path);
        return false;
    }
    bool res;
    const char *prop;
    json_t *pval;
    json_object_foreach((json_t *) val, prop, pval)
    {
        jm_path_t lpath_35 = (jm_path_t) { prop, 0, path, NULL };
        if (strcmp(prop, "method") == 0)
        {
            // handle may method property
            // .update.method
            res = jm_json_is_scalar(pval) && json_is_string(pval) && jm_search_cst(&(jm_constant_t) { cst_is_string, { .s = json_string_value(pval) } }, _jm_cst_15, 3);;
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "value not in enum [.update.method.'|']", (path ? &lpath_35 : NULL));
            }
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "invalid optional prop value [.update.method]", (path ? &lpath_35 : NULL));
                return false;
            }
        }
        else if (strcmp(prop, "days") == 0)
        {
            // handle may days property
            // .update.days
            res = json_is_integer(pval) && json_integer_value(pval) >= 0;
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "not a 0 strict int [.update.days]", (path ? &lpath_35 : NULL));
            }
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "invalid optional prop value [.update.days]", (path ? &lpath_35 : NULL));
                return false;
            }
        }
        else
        {
            if (rep) jm_report_add_entry(rep, "unexpected prop [.update]", (path ? &lpath_35 : NULL));
            return false;
        }
    }
    return true;
}

// check _jm_obj_7_map_update (.update)
static bool _jm_f_196(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .update
    res = _jm_obj_35(val, path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected element [.update]", path);
    }
    return res;
}

static jm_check_fun_t _jm_obj_7_map(const char *pname)
{
    return jm_search_propmap(pname, _jm_obj_7_map_tab, 13);
}

// object .
static bool _jm_obj_7(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    if (! json_is_object(val))
    {
        if (rep) jm_report_add_entry(rep, "not an object [.]", path);
        return false;
    }
    jm_check_fun_t pfun;
    const char *prop;
    json_t *pval;
    json_object_foreach((json_t *) val, prop, pval)
    {
        jm_path_t lpath_7 = (jm_path_t) { prop, 0, path, NULL };
        if ((pfun = _jm_obj_7_map(prop)))
        {
            // handle 13 may props
            if (pfun != NULL && ! pfun(pval, (path ? &lpath_7 : NULL), rep))
            {
                if (rep) jm_report_add_entry(rep, "invalid optional prop value [.]", (path ? &lpath_7 : NULL));
                return false;
            }
        }
        else
        {
            if (rep) jm_report_add_entry(rep, "unexpected prop [.]", (path ? &lpath_7 : NULL));
            return false;
        }
    }
    return true;
}

// check $ (.)
static bool json_model_1(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // JSON Model for Lazy Git
    // .
    res = _jm_obj_7(val, path, rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected element [.]", path);
    }
    return res;
}

jm_check_fun_t check_model_map(const char *pname)
{
    return jm_search_propmap(pname, check_model_map_tab, 10);
}

static bool initialized = false;

const char *check_model_init(void)
{
    if (!initialized)
    {
        initialized = true;
        jm_version_string = JSON_MODEL_VERSION;
        // initialize sorted set _jm_cst_0
        _jm_cst_0[0] = (jm_constant_t) { cst_is_string, { .s = "black" } };
        _jm_cst_0[1] = (jm_constant_t) { cst_is_string, { .s = "red" } };
        _jm_cst_0[2] = (jm_constant_t) { cst_is_string, { .s = "green" } };
        _jm_cst_0[3] = (jm_constant_t) { cst_is_string, { .s = "yellow" } };
        _jm_cst_0[4] = (jm_constant_t) { cst_is_string, { .s = "blue" } };
        _jm_cst_0[5] = (jm_constant_t) { cst_is_string, { .s = "magenta" } };
        _jm_cst_0[6] = (jm_constant_t) { cst_is_string, { .s = "cyan" } };
        _jm_cst_0[7] = (jm_constant_t) { cst_is_string, { .s = "white" } };
        _jm_cst_0[8] = (jm_constant_t) { cst_is_string, { .s = "bold" } };
        _jm_cst_0[9] = (jm_constant_t) { cst_is_string, { .s = "default" } };
        _jm_cst_0[10] = (jm_constant_t) { cst_is_string, { .s = "reverse" } };
        _jm_cst_0[11] = (jm_constant_t) { cst_is_string, { .s = "underline" } };
        _jm_cst_0[12] = (jm_constant_t) { cst_is_string, { .s = "strikethrough" } };
        jm_sort_cst(_jm_cst_0, 13);
        _jm_re_0_re2 = cre2_new("^#[0-9a-fA-F]{6}$", strlen("^#[0-9a-fA-F]{6}$"), NULL);
        if (cre2_error_code(_jm_re_0_re2))
            return cre2_error_string(_jm_re_0_re2);
        _jm_re_0_nn = cre2_num_capturing_groups(_jm_re_0_re2) + 1;
        // initialize sorted set _jm_cst_1
        _jm_cst_1[0] = (jm_constant_t) { cst_is_string, { .s = "input" } };
        _jm_cst_1[1] = (jm_constant_t) { cst_is_string, { .s = "confirm" } };
        _jm_cst_1[2] = (jm_constant_t) { cst_is_string, { .s = "menu" } };
        _jm_cst_1[3] = (jm_constant_t) { cst_is_string, { .s = "menuFromCommand" } };
        jm_sort_cst(_jm_cst_1, 4);
        // initialize sorted set _jm_cst_2
        _jm_cst_2[0] = (jm_constant_t) { cst_is_string, { .s = "authors" } };
        _jm_cst_2[1] = (jm_constant_t) { cst_is_string, { .s = "branches" } };
        _jm_cst_2[2] = (jm_constant_t) { cst_is_string, { .s = "files" } };
        _jm_cst_2[3] = (jm_constant_t) { cst_is_string, { .s = "refs" } };
        _jm_cst_2[4] = (jm_constant_t) { cst_is_string, { .s = "remotes" } };
        _jm_cst_2[5] = (jm_constant_t) { cst_is_string, { .s = "remoteBranches" } };
        _jm_cst_2[6] = (jm_constant_t) { cst_is_string, { .s = "tags" } };
        jm_sort_cst(_jm_cst_2, 7);
        _jm_map_0_tab[0] = (jm_constmap_t) { (jm_constant_t) { cst_is_string, { .s = "input" } }, _jm_obj_0 };
        _jm_map_0_tab[1] = (jm_constmap_t) { (jm_constant_t) { cst_is_string, { .s = "confirm" } }, _jm_obj_3 };
        _jm_map_0_tab[2] = (jm_constmap_t) { (jm_constant_t) { cst_is_string, { .s = "menu" } }, _jm_obj_4 };
        _jm_map_0_tab[3] = (jm_constmap_t) { (jm_constant_t) { cst_is_string, { .s = "menuFromCommand" } }, _jm_obj_6 };
        jm_sort_constmap(_jm_map_0_tab, 4);
        // initialize sorted set _jm_cst_3
        _jm_cst_3[0] = (jm_constant_t) { cst_is_string, { .s = "status" } };
        _jm_cst_3[1] = (jm_constant_t) { cst_is_string, { .s = "files" } };
        _jm_cst_3[2] = (jm_constant_t) { cst_is_string, { .s = "worktrees" } };
        _jm_cst_3[3] = (jm_constant_t) { cst_is_string, { .s = "localBranches" } };
        _jm_cst_3[4] = (jm_constant_t) { cst_is_string, { .s = "remotes" } };
        _jm_cst_3[5] = (jm_constant_t) { cst_is_string, { .s = "remoteBranches" } };
        _jm_cst_3[6] = (jm_constant_t) { cst_is_string, { .s = "tags" } };
        _jm_cst_3[7] = (jm_constant_t) { cst_is_string, { .s = "commits" } };
        _jm_cst_3[8] = (jm_constant_t) { cst_is_string, { .s = "reflogCommits" } };
        _jm_cst_3[9] = (jm_constant_t) { cst_is_string, { .s = "subCommits" } };
        _jm_cst_3[10] = (jm_constant_t) { cst_is_string, { .s = "commitFiles" } };
        _jm_cst_3[11] = (jm_constant_t) { cst_is_string, { .s = "stash" } };
        _jm_cst_3[12] = (jm_constant_t) { cst_is_string, { .s = "global" } };
        jm_sort_cst(_jm_cst_3, 13);
        _jm_obj_8_map_tab[0] = (jm_propmap_t) { "after", _jm_f_2 };
        _jm_obj_8_map_tab[1] = (jm_propmap_t) { "description", _jm_f_3 };
        _jm_obj_8_map_tab[2] = (jm_propmap_t) { "loadingText", _jm_f_4 };
        _jm_obj_8_map_tab[3] = (jm_propmap_t) { "prompts", _jm_f_5 };
        _jm_obj_8_map_tab[4] = (jm_propmap_t) { "showOutput", _jm_f_6 };
        _jm_obj_8_map_tab[5] = (jm_propmap_t) { "stream", _jm_f_7 };
        _jm_obj_8_map_tab[6] = (jm_propmap_t) { "subprocess", _jm_f_8 };
        jm_sort_propmap(_jm_obj_8_map_tab, 7);
        _jm_re_1_re2 = cre2_new(".", strlen("."), NULL);
        if (cre2_error_code(_jm_re_1_re2))
            return cre2_error_string(_jm_re_1_re2);
        _jm_re_1_nn = cre2_num_capturing_groups(_jm_re_1_re2) + 1;
        // initialize sorted set _jm_cst_4
        _jm_cst_4[0] = (jm_constant_t) { cst_is_string, { .s = "date-order" } };
        _jm_cst_4[1] = (jm_constant_t) { cst_is_string, { .s = "author-date-order" } };
        _jm_cst_4[2] = (jm_constant_t) { cst_is_string, { .s = "topo-order" } };
        _jm_cst_4[3] = (jm_constant_t) { cst_is_string, { .s = "default" } };
        jm_sort_cst(_jm_cst_4, 4);
        // initialize sorted set _jm_cst_5
        _jm_cst_5[0] = (jm_constant_t) { cst_is_string, { .s = "always" } };
        _jm_cst_5[1] = (jm_constant_t) { cst_is_string, { .s = "never" } };
        _jm_cst_5[2] = (jm_constant_t) { cst_is_string, { .s = "when-maximised" } };
        jm_sort_cst(_jm_cst_5, 3);
        // initialize sorted set _jm_cst_6
        _jm_cst_6[0] = (jm_constant_t) { cst_is_string, { .s = "always" } };
        _jm_cst_6[1] = (jm_constant_t) { cst_is_string, { .s = "never" } };
        jm_sort_cst(_jm_cst_6, 2);
        _jm_obj_10_map_tab[0] = (jm_propmap_t) { "allBranchesLogCmd", _jm_f_11 };
        _jm_obj_10_map_tab[1] = (jm_propmap_t) { "autoFetch", _jm_f_12 };
        _jm_obj_10_map_tab[2] = (jm_propmap_t) { "autoRefresh", _jm_f_13 };
        _jm_obj_10_map_tab[3] = (jm_propmap_t) { "branchLogCmd", _jm_f_14 };
        _jm_obj_10_map_tab[4] = (jm_propmap_t) { "commit", _jm_f_15 };
        _jm_obj_10_map_tab[5] = (jm_propmap_t) { "commitPrefixes", _jm_f_16 };
        _jm_obj_10_map_tab[6] = (jm_propmap_t) { "diffContextSize", _jm_f_17 };
        _jm_obj_10_map_tab[7] = (jm_propmap_t) { "disableForcePushing", _jm_f_18 };
        _jm_obj_10_map_tab[8] = (jm_propmap_t) { "fetchAll", _jm_f_19 };
        _jm_obj_10_map_tab[9] = (jm_propmap_t) { "log", _jm_f_20 };
        _jm_obj_10_map_tab[10] = (jm_propmap_t) { "mainBranches", _jm_f_21 };
        _jm_obj_10_map_tab[11] = (jm_propmap_t) { "merging", _jm_f_22 };
        _jm_obj_10_map_tab[12] = (jm_propmap_t) { "overrideGpg", _jm_f_23 };
        _jm_obj_10_map_tab[13] = (jm_propmap_t) { "paging", _jm_f_24 };
        _jm_obj_10_map_tab[14] = (jm_propmap_t) { "parseEmoji", _jm_f_25 };
        _jm_obj_10_map_tab[15] = (jm_propmap_t) { "skipHookPrefix", _jm_f_26 };
        jm_sort_propmap(_jm_obj_10_map_tab, 16);
        // initialize sorted set _jm_cst_7
        _jm_cst_7[0] = (jm_constant_t) { cst_is_string, { .s = "single" } };
        _jm_cst_7[1] = (jm_constant_t) { cst_is_string, { .s = "double" } };
        _jm_cst_7[2] = (jm_constant_t) { cst_is_string, { .s = "rounded" } };
        _jm_cst_7[3] = (jm_constant_t) { cst_is_string, { .s = "hidden" } };
        jm_sort_cst(_jm_cst_7, 4);
        // initialize sorted set _jm_cst_8
        _jm_cst_8[0] = (jm_constant_t) { cst_is_string, { .s = "auto" } };
        _jm_cst_8[1] = (jm_constant_t) { cst_is_string, { .s = "en" } };
        _jm_cst_8[2] = (jm_constant_t) { cst_is_string, { .s = "zh-CN" } };
        _jm_cst_8[3] = (jm_constant_t) { cst_is_string, { .s = "zh-TW" } };
        _jm_cst_8[4] = (jm_constant_t) { cst_is_string, { .s = "pl" } };
        _jm_cst_8[5] = (jm_constant_t) { cst_is_string, { .s = "nl" } };
        _jm_cst_8[6] = (jm_constant_t) { cst_is_string, { .s = "ja" } };
        _jm_cst_8[7] = (jm_constant_t) { cst_is_string, { .s = "ko" } };
        _jm_cst_8[8] = (jm_constant_t) { cst_is_string, { .s = "ru" } };
        jm_sort_cst(_jm_cst_8, 9);
        // initialize sorted set _jm_cst_9
        _jm_cst_9[0] = (jm_constant_t) { cst_is_string, { .s = "horizontal" } };
        _jm_cst_9[1] = (jm_constant_t) { cst_is_string, { .s = "flexible" } };
        _jm_cst_9[2] = (jm_constant_t) { cst_is_string, { .s = "vertical" } };
        jm_sort_cst(_jm_cst_9, 3);
        // initialize sorted set _jm_cst_10
        _jm_cst_10[0] = (jm_constant_t) { cst_is_string, { .s = "2" } };
        _jm_cst_10[1] = (jm_constant_t) { cst_is_string, { .s = "3" } };
        jm_sort_cst(_jm_cst_10, 2);
        // initialize sorted set _jm_cst_11
        _jm_cst_11[0] = (jm_constant_t) { cst_is_string, { .s = "auto" } };
        _jm_cst_11[1] = (jm_constant_t) { cst_is_string, { .s = "always" } };
        jm_sort_cst(_jm_cst_11, 2);
        _jm_obj_21_map_tab[0] = (jm_propmap_t) { "activeBorderColor", _jm_f_54 };
        _jm_obj_21_map_tab[1] = (jm_propmap_t) { "cherryPickedCommitBgColor", _jm_f_55 };
        _jm_obj_21_map_tab[2] = (jm_propmap_t) { "cherryPickedCommitFgColor", _jm_f_56 };
        _jm_obj_21_map_tab[3] = (jm_propmap_t) { "defaultFgColor", _jm_f_57 };
        _jm_obj_21_map_tab[4] = (jm_propmap_t) { "inactiveBorderColor", _jm_f_58 };
        _jm_obj_21_map_tab[5] = (jm_propmap_t) { "optionsTextColor", _jm_f_59 };
        _jm_obj_21_map_tab[6] = (jm_propmap_t) { "searchingActiveBorderColor", _jm_f_60 };
        _jm_obj_21_map_tab[7] = (jm_propmap_t) { "selectedLineBgColor", _jm_f_61 };
        _jm_obj_21_map_tab[8] = (jm_propmap_t) { "selectedRangeBgColor", _jm_f_62 };
        _jm_obj_21_map_tab[9] = (jm_propmap_t) { "unstagedChangesColor", _jm_f_63 };
        jm_sort_propmap(_jm_obj_21_map_tab, 10);
        // initialize sorted set _jm_cst_12
        _jm_cst_12[0] = (jm_constant_t) { cst_is_string, { .s = "normal" } };
        _jm_cst_12[1] = (jm_constant_t) { cst_is_string, { .s = "half" } };
        _jm_cst_12[2] = (jm_constant_t) { cst_is_string, { .s = "full" } };
        jm_sort_cst(_jm_cst_12, 3);
        _jm_obj_17_map_tab[0] = (jm_propmap_t) { "animateExplosion", _jm_f_28 };
        _jm_obj_17_map_tab[1] = (jm_propmap_t) { "authorColors", _jm_f_29 };
        _jm_obj_17_map_tab[2] = (jm_propmap_t) { "border", _jm_f_30 };
        _jm_obj_17_map_tab[3] = (jm_propmap_t) { "branchColors", _jm_f_31 };
        _jm_obj_17_map_tab[4] = (jm_propmap_t) { "commandLogSize", _jm_f_32 };
        _jm_obj_17_map_tab[5] = (jm_propmap_t) { "commitLength", _jm_f_33 };
        _jm_obj_17_map_tab[6] = (jm_propmap_t) { "expandFocusedSidePanel", _jm_f_34 };
        _jm_obj_17_map_tab[7] = (jm_propmap_t) { "language", _jm_f_35 };
        _jm_obj_17_map_tab[8] = (jm_propmap_t) { "mainPanelSplitMode", _jm_f_36 };
        _jm_obj_17_map_tab[9] = (jm_propmap_t) { "mouseEvents", _jm_f_37 };
        _jm_obj_17_map_tab[10] = (jm_propmap_t) { "nerdFontsVersion", _jm_f_38 };
        _jm_obj_17_map_tab[11] = (jm_propmap_t) { "scrollHeight", _jm_f_39 };
        _jm_obj_17_map_tab[12] = (jm_propmap_t) { "scrollPastBottom", _jm_f_40 };
        _jm_obj_17_map_tab[13] = (jm_propmap_t) { "shortTimeFormat", _jm_f_41 };
        _jm_obj_17_map_tab[14] = (jm_propmap_t) { "showBottomLine", _jm_f_42 };
        _jm_obj_17_map_tab[15] = (jm_propmap_t) { "showBranchCommitHash", _jm_f_43 };
        _jm_obj_17_map_tab[16] = (jm_propmap_t) { "showCommandLog", _jm_f_44 };
        _jm_obj_17_map_tab[17] = (jm_propmap_t) { "showFileTree", _jm_f_45 };
        _jm_obj_17_map_tab[18] = (jm_propmap_t) { "showListFooter", _jm_f_46 };
        _jm_obj_17_map_tab[19] = (jm_propmap_t) { "showRandomTip", _jm_f_47 };
        _jm_obj_17_map_tab[20] = (jm_propmap_t) { "sidePanelWidth", _jm_f_48 };
        _jm_obj_17_map_tab[21] = (jm_propmap_t) { "skipDiscardChangeWarning", _jm_f_49 };
        _jm_obj_17_map_tab[22] = (jm_propmap_t) { "skipRewordInEditorWarning", _jm_f_50 };
        _jm_obj_17_map_tab[23] = (jm_propmap_t) { "skipStashWarning", _jm_f_51 };
        _jm_obj_17_map_tab[24] = (jm_propmap_t) { "splitDiff", _jm_f_52 };
        _jm_obj_17_map_tab[25] = (jm_propmap_t) { "theme", _jm_f_53 };
        _jm_obj_17_map_tab[26] = (jm_propmap_t) { "timeFormat", _jm_f_64 };
        _jm_obj_17_map_tab[27] = (jm_propmap_t) { "windowSize", _jm_f_65 };
        jm_sort_propmap(_jm_obj_17_map_tab, 28);
        _jm_obj_23_map_tab[0] = (jm_propmap_t) { "checkoutBranchByName", _jm_f_68 };
        _jm_obj_23_map_tab[1] = (jm_propmap_t) { "createPullRequest", _jm_f_69 };
        _jm_obj_23_map_tab[2] = (jm_propmap_t) { "createTag", _jm_f_70 };
        _jm_obj_23_map_tab[3] = (jm_propmap_t) { "fastForward", _jm_f_71 };
        _jm_obj_23_map_tab[4] = (jm_propmap_t) { "fetchRemote", _jm_f_72 };
        _jm_obj_23_map_tab[5] = (jm_propmap_t) { "forceCheckoutBranch", _jm_f_73 };
        _jm_obj_23_map_tab[6] = (jm_propmap_t) { "mergeIntoCurrentBranch", _jm_f_74 };
        _jm_obj_23_map_tab[7] = (jm_propmap_t) { "pushTag", _jm_f_75 };
        _jm_obj_23_map_tab[8] = (jm_propmap_t) { "rebaseBranch", _jm_f_76 };
        _jm_obj_23_map_tab[9] = (jm_propmap_t) { "renameBranch", _jm_f_77 };
        _jm_obj_23_map_tab[10] = (jm_propmap_t) { "setUpstream", _jm_f_78 };
        _jm_obj_23_map_tab[11] = (jm_propmap_t) { "viewGitFlowOptions", _jm_f_79 };
        _jm_obj_23_map_tab[12] = (jm_propmap_t) { "viewPullRequestOptions", _jm_f_80 };
        jm_sort_propmap(_jm_obj_23_map_tab, 13);
        _jm_obj_25_map_tab[0] = (jm_propmap_t) { "amendToCommit", _jm_f_83 };
        _jm_obj_25_map_tab[1] = (jm_propmap_t) { "checkoutCommit", _jm_f_84 };
        _jm_obj_25_map_tab[2] = (jm_propmap_t) { "cherryPickCopy", _jm_f_85 };
        _jm_obj_25_map_tab[3] = (jm_propmap_t) { "cherryPickCopyRange", _jm_f_86 };
        _jm_obj_25_map_tab[4] = (jm_propmap_t) { "copyCommitMessageToClipboard", _jm_f_87 };
        _jm_obj_25_map_tab[5] = (jm_propmap_t) { "createFixupCommit", _jm_f_88 };
        _jm_obj_25_map_tab[6] = (jm_propmap_t) { "markCommitAsFixup", _jm_f_89 };
        _jm_obj_25_map_tab[7] = (jm_propmap_t) { "moveDownCommit", _jm_f_90 };
        _jm_obj_25_map_tab[8] = (jm_propmap_t) { "moveUpCommit", _jm_f_91 };
        _jm_obj_25_map_tab[9] = (jm_propmap_t) { "openLogMenu", _jm_f_92 };
        _jm_obj_25_map_tab[10] = (jm_propmap_t) { "pasteCommits", _jm_f_93 };
        _jm_obj_25_map_tab[11] = (jm_propmap_t) { "pickCommit", _jm_f_94 };
        _jm_obj_25_map_tab[12] = (jm_propmap_t) { "renameCommit", _jm_f_95 };
        _jm_obj_25_map_tab[13] = (jm_propmap_t) { "renameCommitWithEditor", _jm_f_96 };
        _jm_obj_25_map_tab[14] = (jm_propmap_t) { "resetCherryPick", _jm_f_97 };
        _jm_obj_25_map_tab[15] = (jm_propmap_t) { "revertCommit", _jm_f_98 };
        _jm_obj_25_map_tab[16] = (jm_propmap_t) { "squashAboveCommits", _jm_f_99 };
        _jm_obj_25_map_tab[17] = (jm_propmap_t) { "squashDown", _jm_f_100 };
        _jm_obj_25_map_tab[18] = (jm_propmap_t) { "tagCommit", _jm_f_101 };
        _jm_obj_25_map_tab[19] = (jm_propmap_t) { "viewBisectOptions", _jm_f_102 };
        _jm_obj_25_map_tab[20] = (jm_propmap_t) { "viewResetOptions", _jm_f_103 };
        jm_sort_propmap(_jm_obj_25_map_tab, 21);
        _jm_obj_26_map_tab[0] = (jm_propmap_t) { "amendLastCommit", _jm_f_105 };
        _jm_obj_26_map_tab[1] = (jm_propmap_t) { "commitChanges", _jm_f_106 };
        _jm_obj_26_map_tab[2] = (jm_propmap_t) { "commitChangesWithEditor", _jm_f_107 };
        _jm_obj_26_map_tab[3] = (jm_propmap_t) { "commitChangesWithoutHook", _jm_f_108 };
        _jm_obj_26_map_tab[4] = (jm_propmap_t) { "fetch", _jm_f_109 };
        _jm_obj_26_map_tab[5] = (jm_propmap_t) { "ignoreFile", _jm_f_110 };
        _jm_obj_26_map_tab[6] = (jm_propmap_t) { "openMergeTool", _jm_f_111 };
        _jm_obj_26_map_tab[7] = (jm_propmap_t) { "openStatusFilter", _jm_f_112 };
        _jm_obj_26_map_tab[8] = (jm_propmap_t) { "refreshFiles", _jm_f_113 };
        _jm_obj_26_map_tab[9] = (jm_propmap_t) { "stashAllChanges", _jm_f_114 };
        _jm_obj_26_map_tab[10] = (jm_propmap_t) { "toggleStagedAll", _jm_f_115 };
        _jm_obj_26_map_tab[11] = (jm_propmap_t) { "toggleTreeView", _jm_f_116 };
        _jm_obj_26_map_tab[12] = (jm_propmap_t) { "viewResetOptions", _jm_f_117 };
        _jm_obj_26_map_tab[13] = (jm_propmap_t) { "viewStashOptions", _jm_f_118 };
        jm_sort_propmap(_jm_obj_26_map_tab, 14);
        _jm_obj_31_map_tab[0] = (jm_propmap_t) { "confirm", _jm_f_124 };
        _jm_obj_31_map_tab[1] = (jm_propmap_t) { "copyToClipboard", _jm_f_125 };
        _jm_obj_31_map_tab[2] = (jm_propmap_t) { "createPatchOptionsMenu", _jm_f_126 };
        _jm_obj_31_map_tab[3] = (jm_propmap_t) { "createRebaseOptionsMenu", _jm_f_127 };
        _jm_obj_31_map_tab[4] = (jm_propmap_t) { "decreaseContextInDiffView", _jm_f_128 };
        _jm_obj_31_map_tab[5] = (jm_propmap_t) { "diffingMenu", _jm_f_129 };
        _jm_obj_31_map_tab[6] = (jm_propmap_t) { "diffingMenu-alt", _jm_f_130 };
        _jm_obj_31_map_tab[7] = (jm_propmap_t) { "edit", _jm_f_131 };
        _jm_obj_31_map_tab[8] = (jm_propmap_t) { "executeCustomCommand", _jm_f_132 };
        _jm_obj_31_map_tab[9] = (jm_propmap_t) { "extrasMenu", _jm_f_133 };
        _jm_obj_31_map_tab[10] = (jm_propmap_t) { "filteringMenu", _jm_f_134 };
        _jm_obj_31_map_tab[11] = (jm_propmap_t) { "goInto", _jm_f_135 };
        _jm_obj_31_map_tab[12] = (jm_propmap_t) { "gotoBottom", _jm_f_136 };
        _jm_obj_31_map_tab[13] = (jm_propmap_t) { "gotoTop", _jm_f_137 };
        _jm_obj_31_map_tab[14] = (jm_propmap_t) { "increaseContextInDiffView", _jm_f_138 };
        _jm_obj_31_map_tab[15] = (jm_propmap_t) { "jumpToBlock", _jm_f_139 };
        _jm_obj_31_map_tab[16] = (jm_propmap_t) { "new", _jm_f_140 };
        _jm_obj_31_map_tab[17] = (jm_propmap_t) { "nextBlock", _jm_f_141 };
        _jm_obj_31_map_tab[18] = (jm_propmap_t) { "nextBlock-alt", _jm_f_142 };
        _jm_obj_31_map_tab[19] = (jm_propmap_t) { "nextItem", _jm_f_143 };
        _jm_obj_31_map_tab[20] = (jm_propmap_t) { "nextItem-alt", _jm_f_144 };
        _jm_obj_31_map_tab[21] = (jm_propmap_t) { "nextMatch", _jm_f_145 };
        _jm_obj_31_map_tab[22] = (jm_propmap_t) { "nextPage", _jm_f_146 };
        _jm_obj_31_map_tab[23] = (jm_propmap_t) { "nextScreenMode", _jm_f_147 };
        _jm_obj_31_map_tab[24] = (jm_propmap_t) { "nextTab", _jm_f_148 };
        _jm_obj_31_map_tab[25] = (jm_propmap_t) { "openFile", _jm_f_149 };
        _jm_obj_31_map_tab[26] = (jm_propmap_t) { "openRecentRepos", _jm_f_150 };
        _jm_obj_31_map_tab[27] = (jm_propmap_t) { "optionMenu", _jm_f_151 };
        _jm_obj_31_map_tab[28] = (jm_propmap_t) { "optionMenu-alt1", _jm_f_152 };
        _jm_obj_31_map_tab[29] = (jm_propmap_t) { "prevBlock", _jm_f_153 };
        _jm_obj_31_map_tab[30] = (jm_propmap_t) { "prevBlock-alt", _jm_f_154 };
        _jm_obj_31_map_tab[31] = (jm_propmap_t) { "prevItem", _jm_f_155 };
        _jm_obj_31_map_tab[32] = (jm_propmap_t) { "prevItem-alt", _jm_f_156 };
        _jm_obj_31_map_tab[33] = (jm_propmap_t) { "prevMatch", _jm_f_157 };
        _jm_obj_31_map_tab[34] = (jm_propmap_t) { "prevPage", _jm_f_158 };
        _jm_obj_31_map_tab[35] = (jm_propmap_t) { "prevScreenMode", _jm_f_159 };
        _jm_obj_31_map_tab[36] = (jm_propmap_t) { "prevTab", _jm_f_160 };
        _jm_obj_31_map_tab[37] = (jm_propmap_t) { "pullFiles", _jm_f_161 };
        _jm_obj_31_map_tab[38] = (jm_propmap_t) { "pushFiles", _jm_f_162 };
        _jm_obj_31_map_tab[39] = (jm_propmap_t) { "quit", _jm_f_163 };
        _jm_obj_31_map_tab[40] = (jm_propmap_t) { "quit-alt1", _jm_f_164 };
        _jm_obj_31_map_tab[41] = (jm_propmap_t) { "quitWithoutChangingDirectory", _jm_f_165 };
        _jm_obj_31_map_tab[42] = (jm_propmap_t) { "redo", _jm_f_166 };
        _jm_obj_31_map_tab[43] = (jm_propmap_t) { "refresh", _jm_f_167 };
        _jm_obj_31_map_tab[44] = (jm_propmap_t) { "remove", _jm_f_168 };
        _jm_obj_31_map_tab[45] = (jm_propmap_t) { "return", _jm_f_169 };
        _jm_obj_31_map_tab[46] = (jm_propmap_t) { "scrollDownMain", _jm_f_170 };
        _jm_obj_31_map_tab[47] = (jm_propmap_t) { "scrollDownMain-alt1", _jm_f_171 };
        _jm_obj_31_map_tab[48] = (jm_propmap_t) { "scrollDownMain-alt2", _jm_f_172 };
        _jm_obj_31_map_tab[49] = (jm_propmap_t) { "scrollLeft", _jm_f_173 };
        _jm_obj_31_map_tab[50] = (jm_propmap_t) { "scrollRight", _jm_f_174 };
        _jm_obj_31_map_tab[51] = (jm_propmap_t) { "scrollUpMain", _jm_f_175 };
        _jm_obj_31_map_tab[52] = (jm_propmap_t) { "scrollUpMain-alt1", _jm_f_176 };
        _jm_obj_31_map_tab[53] = (jm_propmap_t) { "scrollUpMain-alt2", _jm_f_177 };
        _jm_obj_31_map_tab[54] = (jm_propmap_t) { "select", _jm_f_178 };
        _jm_obj_31_map_tab[55] = (jm_propmap_t) { "submitEditorText", _jm_f_179 };
        _jm_obj_31_map_tab[56] = (jm_propmap_t) { "togglePanel", _jm_f_180 };
        _jm_obj_31_map_tab[57] = (jm_propmap_t) { "toggleWhitespaceInDiffView", _jm_f_181 };
        _jm_obj_31_map_tab[58] = (jm_propmap_t) { "undo", _jm_f_182 };
        jm_sort_propmap(_jm_obj_31_map_tab, 59);
        _jm_obj_22_map_tab[0] = (jm_propmap_t) { "branches", _jm_f_67 };
        _jm_obj_22_map_tab[1] = (jm_propmap_t) { "commitFiles", _jm_f_81 };
        _jm_obj_22_map_tab[2] = (jm_propmap_t) { "commits", _jm_f_82 };
        _jm_obj_22_map_tab[3] = (jm_propmap_t) { "files", _jm_f_104 };
        _jm_obj_22_map_tab[4] = (jm_propmap_t) { "main", _jm_f_119 };
        _jm_obj_22_map_tab[5] = (jm_propmap_t) { "stash", _jm_f_120 };
        _jm_obj_22_map_tab[6] = (jm_propmap_t) { "status", _jm_f_121 };
        _jm_obj_22_map_tab[7] = (jm_propmap_t) { "submodules", _jm_f_122 };
        _jm_obj_22_map_tab[8] = (jm_propmap_t) { "universal", _jm_f_123 };
        jm_sort_propmap(_jm_obj_22_map_tab, 9);
        // initialize sorted set _jm_cst_13
        _jm_cst_13[0] = (jm_constant_t) { cst_is_string, { .s = "prompt" } };
        _jm_cst_13[1] = (jm_constant_t) { cst_is_string, { .s = "create" } };
        _jm_cst_13[2] = (jm_constant_t) { cst_is_string, { .s = "skip" } };
        _jm_cst_13[3] = (jm_constant_t) { cst_is_string, { .s = "quit" } };
        jm_sort_cst(_jm_cst_13, 4);
        // initialize sorted set _jm_cst_14
        _jm_cst_14[0] = (jm_constant_t) { cst_is_string, { .s = "vim" } };
        _jm_cst_14[1] = (jm_constant_t) { cst_is_string, { .s = "nvim" } };
        _jm_cst_14[2] = (jm_constant_t) { cst_is_string, { .s = "emacs" } };
        _jm_cst_14[3] = (jm_constant_t) { cst_is_string, { .s = "nano" } };
        _jm_cst_14[4] = (jm_constant_t) { cst_is_string, { .s = "vscode" } };
        _jm_cst_14[5] = (jm_constant_t) { cst_is_string, { .s = "sublime" } };
        _jm_cst_14[6] = (jm_constant_t) { cst_is_string, { .s = "bbedit" } };
        _jm_cst_14[7] = (jm_constant_t) { cst_is_string, { .s = "kakoune" } };
        _jm_cst_14[8] = (jm_constant_t) { cst_is_string, { .s = "helix" } };
        _jm_cst_14[9] = (jm_constant_t) { cst_is_string, { .s = "xcode" } };
        jm_sort_cst(_jm_cst_14, 10);
        _jm_obj_32_map_tab[0] = (jm_propmap_t) { "copyToClipboardCmd", _jm_f_185 };
        _jm_obj_32_map_tab[1] = (jm_propmap_t) { "edit", _jm_f_186 };
        _jm_obj_32_map_tab[2] = (jm_propmap_t) { "editAtLine", _jm_f_187 };
        _jm_obj_32_map_tab[3] = (jm_propmap_t) { "editAtLineAndWait", _jm_f_188 };
        _jm_obj_32_map_tab[4] = (jm_propmap_t) { "editPreset", _jm_f_189 };
        _jm_obj_32_map_tab[5] = (jm_propmap_t) { "open", _jm_f_190 };
        _jm_obj_32_map_tab[6] = (jm_propmap_t) { "openLink", _jm_f_191 };
        jm_sort_propmap(_jm_obj_32_map_tab, 7);
        _jm_re_2_re2 = cre2_new("^[^:]+:[^:]+$", strlen("^[^:]+:[^:]+$"), NULL);
        if (cre2_error_code(_jm_re_2_re2))
            return cre2_error_string(_jm_re_2_re2);
        _jm_re_2_nn = cre2_num_capturing_groups(_jm_re_2_re2) + 1;
        // initialize sorted set _jm_cst_15
        _jm_cst_15[0] = (jm_constant_t) { cst_is_string, { .s = "prompt" } };
        _jm_cst_15[1] = (jm_constant_t) { cst_is_string, { .s = "background" } };
        _jm_cst_15[2] = (jm_constant_t) { cst_is_string, { .s = "never" } };
        jm_sort_cst(_jm_cst_15, 3);
        _jm_obj_7_map_tab[0] = (jm_propmap_t) { "confirmOnQuit", _jm_f_0 };
        _jm_obj_7_map_tab[1] = (jm_propmap_t) { "customCommands", _jm_f_1 };
        _jm_obj_7_map_tab[2] = (jm_propmap_t) { "disableStartupPopups", _jm_f_9 };
        _jm_obj_7_map_tab[3] = (jm_propmap_t) { "git", _jm_f_10 };
        _jm_obj_7_map_tab[4] = (jm_propmap_t) { "gui", _jm_f_27 };
        _jm_obj_7_map_tab[5] = (jm_propmap_t) { "keybinding", _jm_f_66 };
        _jm_obj_7_map_tab[6] = (jm_propmap_t) { "notARepository", _jm_f_183 };
        _jm_obj_7_map_tab[7] = (jm_propmap_t) { "os", _jm_f_184 };
        _jm_obj_7_map_tab[8] = (jm_propmap_t) { "promptToReturnFromSubprocess", _jm_f_192 };
        _jm_obj_7_map_tab[9] = (jm_propmap_t) { "quitOnTopLevelReturn", _jm_f_193 };
        _jm_obj_7_map_tab[10] = (jm_propmap_t) { "refresher", _jm_f_194 };
        _jm_obj_7_map_tab[11] = (jm_propmap_t) { "services", _jm_f_195 };
        _jm_obj_7_map_tab[12] = (jm_propmap_t) { "update", _jm_f_196 };
        jm_sort_propmap(_jm_obj_7_map_tab, 13);
        check_model_map_tab[0] = (jm_propmap_t) { "", json_model_1 };
        check_model_map_tab[1] = (jm_propmap_t) { "color", json_model_2 };
        check_model_map_tab[2] = (jm_propmap_t) { "colorArray", json_model_3 };
        check_model_map_tab[3] = (jm_propmap_t) { "keybinding", json_model_4 };
        check_model_map_tab[4] = (jm_propmap_t) { "custom-commands-prompts-type-property", json_model_5 };
        check_model_map_tab[5] = (jm_propmap_t) { "custom-commands-prompts-title-property", json_model_6 };
        check_model_map_tab[6] = (jm_propmap_t) { "custom-commands-prompts-key-property", json_model_7 };
        check_model_map_tab[7] = (jm_propmap_t) { "neString", json_model_8 };
        check_model_map_tab[8] = (jm_propmap_t) { "stringArray", json_model_9 };
        check_model_map_tab[9] = (jm_propmap_t) { "Prompts", json_model_10 };
        jm_sort_propmap(check_model_map_tab, 10);
    }
    return NULL;
}

void check_model_free(void)
{
    if (initialized)
    {
        initialized = false;

        // cleanup code
        cre2_delete(_jm_re_0_re2);
        _jm_re_0_re2 = NULL;
        _jm_re_0_nn = 0;
        cre2_delete(_jm_re_1_re2);
        _jm_re_1_re2 = NULL;
        _jm_re_1_nn = 0;
        cre2_delete(_jm_re_2_re2);
        _jm_re_2_re2 = NULL;
        _jm_re_2_nn = 0;
    }
}


/*
 * # API
 *
 * ```c
 * bool error;
 * char *message;
 *
 * bool valid = check(json_value, "model-name", &error, &message);
 *
 * if (message)
 *    free(message), message = NULL;
 * ```
 *
 * - `error` is set of there was an error during initialization or if the model does not exists.
 * - `message` is provided if a non NULL pointer is passed, and must be freed by the caller.
 */
bool
check_model(const json_t *val, const char *name, bool *error, char **reasons)
{
    return jm_generic_entry(check_model_init, check_model_map, val, name, error, reasons);
}
