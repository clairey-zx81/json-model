//
// Generated by JSON Model Compiler version 2
// see https://github.com/clairey-zx81/json-model
//

// regular expression engine
#include <stddef.h>
#include <cre2.h>

#include <json-model.h>
#define JSON_MODEL_VERSION "2"

static jm_constant_t _jm_cst_0[13];
static cre2_regexp_t *_jm_re_0_re2 = NULL;
static int _jm_re_0_nn = 0;
static bool _jm_re_0(const char *s, jm_path_t *path, jm_report_t *rep);
static bool json_model_2(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool json_model_3(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool json_model_4(const json_t *val, jm_path_t *path, jm_report_t *rep);
static jm_constant_t _jm_cst_1[4];
static bool json_model_5(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool json_model_6(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool json_model_7(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool json_model_8(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool json_model_9(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_obj_1(const json_t *val, jm_path_t *path, jm_report_t *rep);
static jm_constant_t _jm_cst_2[7];
static bool _jm_obj_2(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_obj_0(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_obj_3(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_obj_5(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_obj_4(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_obj_6(const json_t *val, jm_path_t *path, jm_report_t *rep);
static jm_constmap_t _jm_map_0_tab[4];
static bool json_model_10(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_0(const json_t *val, jm_path_t *path, jm_report_t *rep);
static jm_constant_t _jm_cst_3[13];
static bool _jm_f_2(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_3(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_4(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_5(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_6(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_7(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_8(const json_t *val, jm_path_t *path, jm_report_t *rep);
static jm_propmap_t _jm_obj_7_map_tab[7];
static bool _jm_obj_7(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_1(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_9(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_11(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_12(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_13(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_14(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_15(const json_t *val, jm_path_t *path, jm_report_t *rep);
static cre2_regexp_t *_jm_re_1_re2 = NULL;
static int _jm_re_1_nn = 0;
static bool _jm_re_1(const char *s, jm_path_t *path, jm_report_t *rep);
static bool _jm_obj_8(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_16(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_17(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_18(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_19(const json_t *val, jm_path_t *path, jm_report_t *rep);
static jm_constant_t _jm_cst_4[4];
static jm_constant_t _jm_cst_5[3];
static bool _jm_f_20(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_21(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_22(const json_t *val, jm_path_t *path, jm_report_t *rep);
static jm_constant_t _jm_cst_6[2];
static bool _jm_f_23(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_24(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_25(const json_t *val, jm_path_t *path, jm_report_t *rep);
static jm_propmap_t _jm_f_10_map_tab[16];
static bool _jm_f_10(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_27(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_28(const json_t *val, jm_path_t *path, jm_report_t *rep);
static jm_constant_t _jm_cst_7[4];
static bool _jm_f_29(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_30(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_31(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_32(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_33(const json_t *val, jm_path_t *path, jm_report_t *rep);
static jm_constant_t _jm_cst_8[9];
static bool _jm_f_34(const json_t *val, jm_path_t *path, jm_report_t *rep);
static jm_constant_t _jm_cst_9[3];
static bool _jm_f_35(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_36(const json_t *val, jm_path_t *path, jm_report_t *rep);
static jm_constant_t _jm_cst_10[2];
static bool _jm_f_37(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_38(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_39(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_40(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_41(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_42(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_43(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_44(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_45(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_46(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_47(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_48(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_49(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_50(const json_t *val, jm_path_t *path, jm_report_t *rep);
static jm_constant_t _jm_cst_11[2];
static bool _jm_f_51(const json_t *val, jm_path_t *path, jm_report_t *rep);
static jm_propmap_t _jm_f_52_map_tab[10];
static bool _jm_f_52(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_53(const json_t *val, jm_path_t *path, jm_report_t *rep);
static jm_constant_t _jm_cst_12[3];
static bool _jm_f_54(const json_t *val, jm_path_t *path, jm_report_t *rep);
static jm_propmap_t _jm_f_26_map_tab[28];
static bool _jm_f_26(const json_t *val, jm_path_t *path, jm_report_t *rep);
static jm_propmap_t _jm_f_56_map_tab[13];
static bool _jm_f_56(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_57(const json_t *val, jm_path_t *path, jm_report_t *rep);
static jm_propmap_t _jm_f_58_map_tab[21];
static bool _jm_f_58(const json_t *val, jm_path_t *path, jm_report_t *rep);
static jm_propmap_t _jm_f_59_map_tab[14];
static bool _jm_f_59(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_60(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_61(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_62(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_63(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_65(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_66(const json_t *val, jm_path_t *path, jm_report_t *rep);
static jm_propmap_t _jm_f_64_map_tab[59];
static bool _jm_f_64(const json_t *val, jm_path_t *path, jm_report_t *rep);
static jm_propmap_t _jm_f_55_map_tab[9];
static bool _jm_f_55(const json_t *val, jm_path_t *path, jm_report_t *rep);
static jm_constant_t _jm_cst_13[4];
static bool _jm_f_67(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_69(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_70(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_71(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_72(const json_t *val, jm_path_t *path, jm_report_t *rep);
static jm_constant_t _jm_cst_14[10];
static bool _jm_f_73(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_74(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_75(const json_t *val, jm_path_t *path, jm_report_t *rep);
static jm_propmap_t _jm_f_68_map_tab[7];
static bool _jm_f_68(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_76(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_77(const json_t *val, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_78(const json_t *val, jm_path_t *path, jm_report_t *rep);
static cre2_regexp_t *_jm_re_2_re2 = NULL;
static int _jm_re_2_nn = 0;
static bool _jm_re_2(const char *s, jm_path_t *path, jm_report_t *rep);
static bool _jm_f_79(const json_t *val, jm_path_t *path, jm_report_t *rep);
static jm_constant_t _jm_cst_15[3];
static bool _jm_f_80(const json_t *val, jm_path_t *path, jm_report_t *rep);
static jm_propmap_t json_model_1_map_tab[13];
static bool json_model_1(const json_t *val, jm_path_t *path, jm_report_t *rep);
jm_propmap_t check_model_map_tab[10];
const size_t check_model_map_size = 10;


static bool _jm_re_0(const char *s, jm_path_t *path, jm_report_t *rep)
{
    size_t slen = strlen(s);
    return cre2_match(_jm_re_0_re2, s, slen, 0, slen, CRE2_UNANCHORED, NULL, 0);
}

// check $color (.'$color')
static bool json_model_2(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .'$color'
    res = json_is_string(val) && jm_search_cst(&(jm_constant_t) { cst_is_string, { .s = json_string_value(val) } }, _jm_cst_0, 13);;
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "value not in enum [.'$color'.'|']", path);
    }
    if (! res)
    {
        res = json_is_string(val);
        if (! res)
        {
            if (rep) jm_report_add_entry(rep, "unexpected type [.'$color'.'|']", path);
        }
        if (res)
        {
            // .'$color'.'|'.0
            // "/^#[0-9a-fA-F]{6}$/"
            res = _jm_re_0(json_string_value(val), path, rep);
            if (res)
            {
                if (rep) jm_report_free_entries(rep);
            }
            else
            {
                if (rep) jm_report_add_entry(rep, "unexpected /^#[0-9a-fA-F]{6}$/ [.'$color'.'|'.0]", path);
                if (rep) jm_report_add_entry(rep, "no model matched [.'$color'.'|']", path);
            }
        }
    }
    return res;
}

// check $colorArray (.'$colorArray')
static bool json_model_3(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .'$colorArray'
    // .'$colorArray'.'@'
    res = json_is_array(val);
    if (res)
    {
        size_t arr_0_idx;
        json_t *arr_0_item;
        json_array_foreach(val, arr_0_idx, arr_0_item)
        {
            jm_path_t arr_0_lpath = (jm_path_t) { NULL, arr_0_idx, path, NULL };
            // .'$colorArray'.'@'.0
            res = json_model_2(arr_0_item, (path ? &arr_0_lpath : NULL), rep);
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "unexpected $color [.'$colorArray'.'@'.0]", (path ? &arr_0_lpath : NULL));
                break;
            }
        }
    }
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "not array or unexpected array [.'$colorArray'.'@']", path);
    }
    if (res)
    {
        int64_t ival_0 = json_array_size(val);
        res = jm_array_is_unique(val, path, rep) && ival_0 >= 1;
        if (! res)
        {
            if (rep) jm_report_add_entry(rep, "constraints failed [.'$colorArray']", path);
        }
    }
    return res;
}

// check $keybinding (.'$keybinding')
static bool json_model_4(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .'$keybinding'
    // .'$keybinding'.'|'.0
    res = json_is_null(val);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "not null [.'$keybinding'.'|'.0]", path);
    }
    if (! res)
    {
        // .'$keybinding'.'|'.1
        res = json_is_string(val);
        if (! res)
        {
            if (rep) jm_report_add_entry(rep, "unexpected string [.'$keybinding'.'|'.1]", path);
        }
    }
    if (res)
    {
        if (rep) jm_report_free_entries(rep);
    }
    else
    {
        if (rep) jm_report_add_entry(rep, "no model matched [.'$keybinding'.'|']", path);
    }
    return res;
}


// check $custom-commands-prompts-type-property (.'$custom-commands-prompts-type-property')
static bool json_model_5(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .'$custom-commands-prompts-type-property'
    res = json_is_string(val) && jm_search_cst(&(jm_constant_t) { cst_is_string, { .s = json_string_value(val) } }, _jm_cst_1, 4);;
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "value not in enum [.'$custom-commands-prompts-type-property'.'|']", path);
    }
    return res;
}

// check $custom-commands-prompts-title-property (.'$custom-commands-prompts-title-property')
static bool json_model_6(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .'$custom-commands-prompts-title-property'
    res = json_is_string(val);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected string [.'$custom-commands-prompts-title-property']", path);
    }
    return res;
}

// check $custom-commands-prompts-key-property (.'$custom-commands-prompts-key-property')
static bool json_model_7(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .'$custom-commands-prompts-key-property'
    res = json_is_string(val);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected string [.'$custom-commands-prompts-key-property']", path);
    }
    return res;
}

// check $neString (.'$neString')
static bool json_model_8(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .'$neString'
    // .'$neString'.'@'
    res = json_is_string(val);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected string [.'$neString'.'@']", path);
    }
    if (res)
    {
        int64_t ival_1 = jm_str_len(json_string_value(val));
        res = ival_1 >= 1;
        if (! res)
        {
            if (rep) jm_report_add_entry(rep, "constraints failed [.'$neString']", path);
        }
    }
    return res;
}

// check $stringArray (.'$stringArray')
static bool json_model_9(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .'$stringArray'
    // .'$stringArray'.'@'
    res = json_is_array(val);
    if (res)
    {
        size_t arr_1_idx;
        json_t *arr_1_item;
        json_array_foreach(val, arr_1_idx, arr_1_item)
        {
            jm_path_t arr_1_lpath = (jm_path_t) { NULL, arr_1_idx, path, NULL };
            // .'$stringArray'.'@'.0
            res = json_model_8(arr_1_item, (path ? &arr_1_lpath : NULL), rep);
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "unexpected $neString [.'$stringArray'.'@'.0]", (path ? &arr_1_lpath : NULL));
                break;
            }
        }
    }
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "not array or unexpected array [.'$stringArray'.'@']", path);
    }
    if (res)
    {
        res = jm_array_is_unique(val, path, rep);
        if (! res)
        {
            if (rep) jm_report_add_entry(rep, "constraints failed [.'$stringArray']", path);
        }
    }
    return res;
}

// object .'$Prompts'.'|'.0.suggestions.'|'.1
static INLINE bool _jm_obj_1(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    // check close must only props
    if (! json_is_object(val))
    {
        if (rep) jm_report_add_entry(rep, "not an object [.'$Prompts'.'|'.0.suggestions.'|'.1]", path);
        return false;
    }
    if (json_object_size(val) != 1)
    {
        if (rep) jm_report_add_entry(rep, "bad property count [.'$Prompts'.'|'.0.suggestions.'|'.1]", path);
        return false;
    }
    jm_path_t lpath;
    json_t * pval;
    bool res;
    if (! ((pval = json_object_get(val, "command")) != NULL))
    {
        if (rep) jm_report_add_entry(rep, "missing mandatory prop <command> [.'$Prompts'.'|'.0.suggestions.'|'.1]", path);
        return false;
    }
    lpath = (jm_path_t) { "command", 0, path, NULL };
    // .'$Prompts'.'|'.0.suggestions.'|'.1.command
    res = json_is_string(pval);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected string [.'$Prompts'.'|'.0.suggestions.'|'.1.command]", (path ? &lpath : NULL));
        if (rep) jm_report_add_entry(rep, "unexpected value for mandatory prop <command> [.'$Prompts'.'|'.0.suggestions.'|'.1]", (path ? &lpath : NULL));
        return false;
    }
    return true;
}


// object .'$Prompts'.'|'.0.suggestions.'|'.0
static INLINE bool _jm_obj_2(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    // check close must only props
    if (! json_is_object(val))
    {
        if (rep) jm_report_add_entry(rep, "not an object [.'$Prompts'.'|'.0.suggestions.'|'.0]", path);
        return false;
    }
    if (json_object_size(val) != 1)
    {
        if (rep) jm_report_add_entry(rep, "bad property count [.'$Prompts'.'|'.0.suggestions.'|'.0]", path);
        return false;
    }
    jm_path_t lpath;
    json_t * pval;
    bool res;
    if (! ((pval = json_object_get(val, "preset")) != NULL))
    {
        if (rep) jm_report_add_entry(rep, "missing mandatory prop <preset> [.'$Prompts'.'|'.0.suggestions.'|'.0]", path);
        return false;
    }
    lpath = (jm_path_t) { "preset", 0, path, NULL };
    // .'$Prompts'.'|'.0.suggestions.'|'.0.preset
    res = json_is_string(pval) && jm_search_cst(&(jm_constant_t) { cst_is_string, { .s = json_string_value(pval) } }, _jm_cst_2, 7);;
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "value not in enum [.'$Prompts'.'|'.0.suggestions.'|'.0.preset.'|']", (path ? &lpath : NULL));
        if (rep) jm_report_add_entry(rep, "unexpected value for mandatory prop <preset> [.'$Prompts'.'|'.0.suggestions.'|'.0]", (path ? &lpath : NULL));
        return false;
    }
    return true;
}

// object .'$Prompts'.'|'.0
static INLINE bool _jm_obj_0(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    if (! json_is_object(val))
    {
        if (rep) jm_report_add_entry(rep, "not an object [.'$Prompts'.'|'.0]", path);
        return false;
    }
    bool res;
    int64_t must_count = 0;
    const char *prop;
    json_t *pval;
    json_object_foreach((json_t *) val, prop, pval)
    {
        jm_path_t lpath_0 = (jm_path_t) { prop, 0, path, NULL };
        if (jm_str_eq_5(prop, 0x0000000065707974LL))
        {
            // handle must type property
            must_count += 1;
            // .'$Prompts'.'|'.0.type
            res = json_is_string(pval) && jm_str_eq_6(json_string_value(pval), 0x0000007475706e69LL);
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "unexpected input [.'$Prompts'.'|'.0.type]", (path ? &lpath_0 : NULL));
                if (rep) jm_report_add_entry(rep, "invalid mandatory prop value [.'$Prompts'.'|'.0.type]", (path ? &lpath_0 : NULL));
                return false;
            }
        }
        else if (jm_str_eq_6(prop, 0x000000656c746974LL))
        {
            // handle must title property
            must_count += 1;
            // .'$Prompts'.'|'.0.title
            res = json_model_6(pval, (path ? &lpath_0 : NULL), rep);
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "unexpected $custom-commands-prompts-title-property [.'$Prompts'.'|'.0.title]", (path ? &lpath_0 : NULL));
                if (rep) jm_report_add_entry(rep, "invalid mandatory prop value [.'$Prompts'.'|'.0.title]", (path ? &lpath_0 : NULL));
                return false;
            }
        }
        else if (jm_str_eq_4(prop, 0x0079656b))
        {
            // handle must key property
            must_count += 1;
            // .'$Prompts'.'|'.0.key
            res = json_model_7(pval, (path ? &lpath_0 : NULL), rep);
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "unexpected $custom-commands-prompts-key-property [.'$Prompts'.'|'.0.key]", (path ? &lpath_0 : NULL));
                if (rep) jm_report_add_entry(rep, "invalid mandatory prop value [.'$Prompts'.'|'.0.key]", (path ? &lpath_0 : NULL));
                return false;
            }
        }
        else if (jm_str_eq_8(prop, 0x566c616974696e69LL) && jm_str_eq_5(prop + 8, 0x0000000065756c61LL))
        {
            // handle may initialValue property
            // .'$Prompts'.'|'.0.initialValue
            res = json_is_string(pval);
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "unexpected string [.'$Prompts'.'|'.0.initialValue]", (path ? &lpath_0 : NULL));
                if (rep) jm_report_add_entry(rep, "invalid optional prop value [.'$Prompts'.'|'.0.initialValue]", (path ? &lpath_0 : NULL));
                return false;
            }
        }
        else if (jm_str_eq_8(prop, 0x6974736567677573LL) && jm_str_eq_4(prop + 8, 0x00736e6f))
        {
            // handle may suggestions property
            // .'$Prompts'.'|'.0.suggestions
            res = json_is_object(pval);
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "unexpected type [.'$Prompts'.'|'.0.suggestions.'|']", (path ? &lpath_0 : NULL));
            }
            if (res)
            {
                // .'$Prompts'.'|'.0.suggestions.'|'.0
                res = _jm_obj_2(pval, (path ? &lpath_0 : NULL), rep);
                if (! res)
                {
                    if (rep) jm_report_add_entry(rep, "unexpected element [.'$Prompts'.'|'.0.suggestions.'|'.0]", (path ? &lpath_0 : NULL));
                }
                if (! res)
                {
                    // .'$Prompts'.'|'.0.suggestions.'|'.1
                    res = _jm_obj_1(pval, (path ? &lpath_0 : NULL), rep);
                    if (! res)
                    {
                        if (rep) jm_report_add_entry(rep, "unexpected element [.'$Prompts'.'|'.0.suggestions.'|'.1]", (path ? &lpath_0 : NULL));
                    }
                }
                if (res)
                {
                    if (rep) jm_report_free_entries(rep);
                }
                else
                {
                    if (rep) jm_report_add_entry(rep, "no model matched [.'$Prompts'.'|'.0.suggestions.'|']", (path ? &lpath_0 : NULL));
                }
            }
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "invalid optional prop value [.'$Prompts'.'|'.0.suggestions]", (path ? &lpath_0 : NULL));
                return false;
            }
        }
        else
        {
            if (rep) jm_report_add_entry(rep, "unexpected prop [.'$Prompts'.'|'.0]", (path ? &lpath_0 : NULL));
            return false;
        }
    }
    if (must_count != 3)
    {
        if (rep != NULL)
        {
            if (! (json_object_get(val, "key") != NULL))
            {
                if (rep) jm_report_add_entry(rep, "missing mandatory prop <key> [.'$Prompts'.'|'.0]", path);
            }
            if (! (json_object_get(val, "title") != NULL))
            {
                if (rep) jm_report_add_entry(rep, "missing mandatory prop <title> [.'$Prompts'.'|'.0]", path);
            }
            if (! (json_object_get(val, "type") != NULL))
            {
                if (rep) jm_report_add_entry(rep, "missing mandatory prop <type> [.'$Prompts'.'|'.0]", path);
            }
        }
        return false;
    }
    return true;
}

// object .'$Prompts'.'|'.1
static INLINE bool _jm_obj_3(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    if (! json_is_object(val))
    {
        if (rep) jm_report_add_entry(rep, "not an object [.'$Prompts'.'|'.1]", path);
        return false;
    }
    bool res;
    int64_t must_count = 0;
    const char *prop;
    json_t *pval;
    json_object_foreach((json_t *) val, prop, pval)
    {
        jm_path_t lpath_1 = (jm_path_t) { prop, 0, path, NULL };
        if (jm_str_eq_5(prop, 0x0000000065707974LL))
        {
            // handle must type property
            must_count += 1;
            // .'$Prompts'.'|'.1.type
            res = json_is_string(pval) && jm_str_eq_8(json_string_value(pval), 0x006d7269666e6f63LL);
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "unexpected confirm [.'$Prompts'.'|'.1.type]", (path ? &lpath_1 : NULL));
                if (rep) jm_report_add_entry(rep, "invalid mandatory prop value [.'$Prompts'.'|'.1.type]", (path ? &lpath_1 : NULL));
                return false;
            }
        }
        else if (jm_str_eq_6(prop, 0x000000656c746974LL))
        {
            // handle must title property
            must_count += 1;
            // .'$Prompts'.'|'.1.title
            res = json_model_6(pval, (path ? &lpath_1 : NULL), rep);
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "unexpected $custom-commands-prompts-title-property [.'$Prompts'.'|'.1.title]", (path ? &lpath_1 : NULL));
                if (rep) jm_report_add_entry(rep, "invalid mandatory prop value [.'$Prompts'.'|'.1.title]", (path ? &lpath_1 : NULL));
                return false;
            }
        }
        else if (jm_str_eq_4(prop, 0x0079656b))
        {
            // handle must key property
            must_count += 1;
            // .'$Prompts'.'|'.1.key
            res = json_model_7(pval, (path ? &lpath_1 : NULL), rep);
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "unexpected $custom-commands-prompts-key-property [.'$Prompts'.'|'.1.key]", (path ? &lpath_1 : NULL));
                if (rep) jm_report_add_entry(rep, "invalid mandatory prop value [.'$Prompts'.'|'.1.key]", (path ? &lpath_1 : NULL));
                return false;
            }
        }
        else if (jm_str_eq_5(prop, 0x0000000079646f62LL))
        {
            // handle may body property
            // .'$Prompts'.'|'.1.body
            res = json_is_string(pval);
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "unexpected string [.'$Prompts'.'|'.1.body]", (path ? &lpath_1 : NULL));
                if (rep) jm_report_add_entry(rep, "invalid optional prop value [.'$Prompts'.'|'.1.body]", (path ? &lpath_1 : NULL));
                return false;
            }
        }
        else
        {
            if (rep) jm_report_add_entry(rep, "unexpected prop [.'$Prompts'.'|'.1]", (path ? &lpath_1 : NULL));
            return false;
        }
    }
    if (must_count != 3)
    {
        if (rep != NULL)
        {
            if (! (json_object_get(val, "key") != NULL))
            {
                if (rep) jm_report_add_entry(rep, "missing mandatory prop <key> [.'$Prompts'.'|'.1]", path);
            }
            if (! (json_object_get(val, "title") != NULL))
            {
                if (rep) jm_report_add_entry(rep, "missing mandatory prop <title> [.'$Prompts'.'|'.1]", path);
            }
            if (! (json_object_get(val, "type") != NULL))
            {
                if (rep) jm_report_add_entry(rep, "missing mandatory prop <type> [.'$Prompts'.'|'.1]", path);
            }
        }
        return false;
    }
    return true;
}

// object .'$Prompts'.'|'.2.options.'@'.0
static INLINE bool _jm_obj_5(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    if (! json_is_object(val))
    {
        if (rep) jm_report_add_entry(rep, "not an object [.'$Prompts'.'|'.2.options.'@'.0]", path);
        return false;
    }
    bool res;
    int64_t must_count = 0;
    const char *prop;
    json_t *pval;
    json_object_foreach((json_t *) val, prop, pval)
    {
        jm_path_t lpath_2 = (jm_path_t) { prop, 0, path, NULL };
        if (jm_str_eq_6(prop, 0x00000065756c6176LL))
        {
            // handle must value property
            must_count += 1;
            // .'$Prompts'.'|'.2.options.'@'.0.value
            res = json_model_8(pval, (path ? &lpath_2 : NULL), rep);
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "unexpected $neString [.'$Prompts'.'|'.2.options.'@'.0.value]", (path ? &lpath_2 : NULL));
                if (rep) jm_report_add_entry(rep, "invalid mandatory prop value [.'$Prompts'.'|'.2.options.'@'.0.value]", (path ? &lpath_2 : NULL));
                return false;
            }
        }
        else if (jm_str_eq_8(prop, 0x7470697263736564LL) && jm_str_eq_4(prop + 8, 0x006e6f69))
        {
            // handle may description property
            // .'$Prompts'.'|'.2.options.'@'.0.description
            res = json_is_string(pval);
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "unexpected string [.'$Prompts'.'|'.2.options.'@'.0.description]", (path ? &lpath_2 : NULL));
                if (rep) jm_report_add_entry(rep, "invalid optional prop value [.'$Prompts'.'|'.2.options.'@'.0.description]", (path ? &lpath_2 : NULL));
                return false;
            }
        }
        else if (jm_str_eq_5(prop, 0x00000000656d616eLL))
        {
            // handle may name property
            // .'$Prompts'.'|'.2.options.'@'.0.name
            res = json_is_string(pval);
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "unexpected string [.'$Prompts'.'|'.2.options.'@'.0.name]", (path ? &lpath_2 : NULL));
                if (rep) jm_report_add_entry(rep, "invalid optional prop value [.'$Prompts'.'|'.2.options.'@'.0.name]", (path ? &lpath_2 : NULL));
                return false;
            }
        }
        else
        {
            if (rep) jm_report_add_entry(rep, "unexpected prop [.'$Prompts'.'|'.2.options.'@'.0]", (path ? &lpath_2 : NULL));
            return false;
        }
    }
    if (must_count != 1)
    {
        if (rep != NULL)
        {
            if (! (json_object_get(val, "value") != NULL))
            {
                if (rep) jm_report_add_entry(rep, "missing mandatory prop <value> [.'$Prompts'.'|'.2.options.'@'.0]", path);
            }
        }
        return false;
    }
    return true;
}

// object .'$Prompts'.'|'.2
static INLINE bool _jm_obj_4(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    // check close must only props
    if (! json_is_object(val))
    {
        if (rep) jm_report_add_entry(rep, "not an object [.'$Prompts'.'|'.2]", path);
        return false;
    }
    if (json_object_size(val) != 4)
    {
        if (rep) jm_report_add_entry(rep, "bad property count [.'$Prompts'.'|'.2]", path);
        return false;
    }
    jm_path_t lpath;
    json_t * pval;
    bool res;
    if (! ((pval = json_object_get(val, "type")) != NULL))
    {
        if (rep) jm_report_add_entry(rep, "missing mandatory prop <type> [.'$Prompts'.'|'.2]", path);
        return false;
    }
    lpath = (jm_path_t) { "type", 0, path, NULL };
    // .'$Prompts'.'|'.2.type
    res = json_is_string(pval) && jm_str_eq_5(json_string_value(pval), 0x00000000756e656dLL);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected menu [.'$Prompts'.'|'.2.type]", (path ? &lpath : NULL));
        if (rep) jm_report_add_entry(rep, "unexpected value for mandatory prop <type> [.'$Prompts'.'|'.2]", (path ? &lpath : NULL));
        return false;
    }
    if (! ((pval = json_object_get(val, "title")) != NULL))
    {
        if (rep) jm_report_add_entry(rep, "missing mandatory prop <title> [.'$Prompts'.'|'.2]", path);
        return false;
    }
    lpath = (jm_path_t) { "title", 0, path, NULL };
    // .'$Prompts'.'|'.2.title
    res = json_model_6(pval, (path ? &lpath : NULL), rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected $custom-commands-prompts-title-property [.'$Prompts'.'|'.2.title]", (path ? &lpath : NULL));
        if (rep) jm_report_add_entry(rep, "unexpected value for mandatory prop <title> [.'$Prompts'.'|'.2]", (path ? &lpath : NULL));
        return false;
    }
    if (! ((pval = json_object_get(val, "key")) != NULL))
    {
        if (rep) jm_report_add_entry(rep, "missing mandatory prop <key> [.'$Prompts'.'|'.2]", path);
        return false;
    }
    lpath = (jm_path_t) { "key", 0, path, NULL };
    // .'$Prompts'.'|'.2.key
    res = json_model_7(pval, (path ? &lpath : NULL), rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected $custom-commands-prompts-key-property [.'$Prompts'.'|'.2.key]", (path ? &lpath : NULL));
        if (rep) jm_report_add_entry(rep, "unexpected value for mandatory prop <key> [.'$Prompts'.'|'.2]", (path ? &lpath : NULL));
        return false;
    }
    if (! ((pval = json_object_get(val, "options")) != NULL))
    {
        if (rep) jm_report_add_entry(rep, "missing mandatory prop <options> [.'$Prompts'.'|'.2]", path);
        return false;
    }
    lpath = (jm_path_t) { "options", 0, path, NULL };
    // .'$Prompts'.'|'.2.options
    // .'$Prompts'.'|'.2.options.'@'
    res = json_is_array(pval);
    if (res)
    {
        size_t arr_2_idx;
        json_t *arr_2_item;
        json_array_foreach(pval, arr_2_idx, arr_2_item)
        {
            jm_path_t arr_2_lpath = (jm_path_t) { NULL, arr_2_idx, (path ? &lpath : NULL), NULL };
            // .'$Prompts'.'|'.2.options.'@'.0
            res = _jm_obj_5(arr_2_item, ((path ? &lpath : NULL) ? &arr_2_lpath : NULL), rep);
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "unexpected element [.'$Prompts'.'|'.2.options.'@'.0]", ((path ? &lpath : NULL) ? &arr_2_lpath : NULL));
                break;
            }
        }
    }
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "not array or unexpected array [.'$Prompts'.'|'.2.options.'@']", (path ? &lpath : NULL));
    }
    if (res)
    {
        res = jm_array_is_unique(pval, (path ? &lpath : NULL), rep);
        if (! res)
        {
            if (rep) jm_report_add_entry(rep, "constraints failed [.'$Prompts'.'|'.2.options]", (path ? &lpath : NULL));
        }
    }
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected value for mandatory prop <options> [.'$Prompts'.'|'.2]", (path ? &lpath : NULL));
        return false;
    }
    return true;
}

// object .'$Prompts'.'|'.3
static INLINE bool _jm_obj_6(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    if (! json_is_object(val))
    {
        if (rep) jm_report_add_entry(rep, "not an object [.'$Prompts'.'|'.3]", path);
        return false;
    }
    bool res;
    int64_t must_count = 0;
    const char *prop;
    json_t *pval;
    json_object_foreach((json_t *) val, prop, pval)
    {
        jm_path_t lpath_3 = (jm_path_t) { prop, 0, path, NULL };
        if (jm_str_eq_5(prop, 0x0000000065707974LL))
        {
            // handle must type property
            must_count += 1;
            // .'$Prompts'.'|'.3.type
            res = json_is_string(pval) && jm_str_eq_8(json_string_value(pval), 0x6d6f7246756e656dLL) && jm_str_eq_8(json_string_value(pval) + 8, 0x00646e616d6d6f43LL);
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "unexpected menuFromCommand [.'$Prompts'.'|'.3.type]", (path ? &lpath_3 : NULL));
                if (rep) jm_report_add_entry(rep, "invalid mandatory prop value [.'$Prompts'.'|'.3.type]", (path ? &lpath_3 : NULL));
                return false;
            }
        }
        else if (jm_str_eq_6(prop, 0x000000656c746974LL))
        {
            // handle must title property
            must_count += 1;
            // .'$Prompts'.'|'.3.title
            res = json_model_6(pval, (path ? &lpath_3 : NULL), rep);
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "unexpected $custom-commands-prompts-title-property [.'$Prompts'.'|'.3.title]", (path ? &lpath_3 : NULL));
                if (rep) jm_report_add_entry(rep, "invalid mandatory prop value [.'$Prompts'.'|'.3.title]", (path ? &lpath_3 : NULL));
                return false;
            }
        }
        else if (jm_str_eq_4(prop, 0x0079656b))
        {
            // handle must key property
            must_count += 1;
            // .'$Prompts'.'|'.3.key
            res = json_model_7(pval, (path ? &lpath_3 : NULL), rep);
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "unexpected $custom-commands-prompts-key-property [.'$Prompts'.'|'.3.key]", (path ? &lpath_3 : NULL));
                if (rep) jm_report_add_entry(rep, "invalid mandatory prop value [.'$Prompts'.'|'.3.key]", (path ? &lpath_3 : NULL));
                return false;
            }
        }
        else if (jm_str_eq_8(prop, 0x00646e616d6d6f63LL))
        {
            // handle must command property
            must_count += 1;
            // .'$Prompts'.'|'.3.command
            res = json_is_string(pval);
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "unexpected string [.'$Prompts'.'|'.3.command]", (path ? &lpath_3 : NULL));
                if (rep) jm_report_add_entry(rep, "invalid mandatory prop value [.'$Prompts'.'|'.3.command]", (path ? &lpath_3 : NULL));
                return false;
            }
        }
        else if (jm_str_eq_7(prop, 0x00007265746c6966LL))
        {
            // handle may filter property
            // .'$Prompts'.'|'.3.filter
            res = json_is_string(pval);
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "unexpected string [.'$Prompts'.'|'.3.filter]", (path ? &lpath_3 : NULL));
                if (rep) jm_report_add_entry(rep, "invalid optional prop value [.'$Prompts'.'|'.3.filter]", (path ? &lpath_3 : NULL));
                return false;
            }
        }
        else if (jm_str_eq_8(prop, 0x726f4665756c6176LL) && jm_str_eq_4(prop + 8, 0x0074616d))
        {
            // handle may valueFormat property
            // .'$Prompts'.'|'.3.valueFormat
            res = json_is_string(pval);
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "unexpected string [.'$Prompts'.'|'.3.valueFormat]", (path ? &lpath_3 : NULL));
                if (rep) jm_report_add_entry(rep, "invalid optional prop value [.'$Prompts'.'|'.3.valueFormat]", (path ? &lpath_3 : NULL));
                return false;
            }
        }
        else if (jm_str_eq_8(prop, 0x726f466c6562616cLL) && jm_str_eq_4(prop + 8, 0x0074616d))
        {
            // handle may labelFormat property
            // .'$Prompts'.'|'.3.labelFormat
            res = json_is_string(pval);
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "unexpected string [.'$Prompts'.'|'.3.labelFormat]", (path ? &lpath_3 : NULL));
                if (rep) jm_report_add_entry(rep, "invalid optional prop value [.'$Prompts'.'|'.3.labelFormat]", (path ? &lpath_3 : NULL));
                return false;
            }
        }
        else
        {
            if (rep) jm_report_add_entry(rep, "unexpected prop [.'$Prompts'.'|'.3]", (path ? &lpath_3 : NULL));
            return false;
        }
    }
    if (must_count != 4)
    {
        if (rep != NULL)
        {
            if (! (json_object_get(val, "command") != NULL))
            {
                if (rep) jm_report_add_entry(rep, "missing mandatory prop <command> [.'$Prompts'.'|'.3]", path);
            }
            if (! (json_object_get(val, "key") != NULL))
            {
                if (rep) jm_report_add_entry(rep, "missing mandatory prop <key> [.'$Prompts'.'|'.3]", path);
            }
            if (! (json_object_get(val, "title") != NULL))
            {
                if (rep) jm_report_add_entry(rep, "missing mandatory prop <title> [.'$Prompts'.'|'.3]", path);
            }
            if (! (json_object_get(val, "type") != NULL))
            {
                if (rep) jm_report_add_entry(rep, "missing mandatory prop <type> [.'$Prompts'.'|'.3]", path);
            }
        }
        return false;
    }
    return true;
}

static INLINE jm_check_fun_t _jm_map_0(json_t *val)
{
    jm_constant_t cst;
    jm_set_cst(&cst, val);
    return jm_search_constmap(&cst, _jm_map_0_tab, 4);
}

// check $Prompts (.'$Prompts')
static bool json_model_10(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .'$Prompts'
    bool iso_0 = json_is_object(val);
    res = iso_0;
    if (res)
    {
        if (json_object_get(val, "type") != NULL)
        {
            json_t * tag_0 = json_object_get(val, "type");
            jm_check_fun_t fun_0 = _jm_map_0(tag_0);
            if (fun_0 != NULL)
                res = fun_0(val, path, rep);
            else
            {
                res = false;
                if (rep) jm_report_add_entry(rep, "tag <type> value not found [.'$Prompts'.'|']", path);
            }
        }
        else
        {
            res = false;
            if (rep) jm_report_add_entry(rep, "tag prop <type> is missing [.'$Prompts'.'|']", path);
        }
    }
    else
    {
        if (rep) jm_report_add_entry(rep, "value is not an object [.'$Prompts'.'|']", path);
    }
    return res;
}

// check json_model_1_map_confirmOnQuit (.confirmOnQuit)
static bool _jm_f_0(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .confirmOnQuit
    res = json_is_boolean(val);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "not a bool [.confirmOnQuit]", path);
    }
    return res;
}


// check _jm_obj_7_map_after (.customCommands.'@'.0.after)
static bool _jm_f_2(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    // .customCommands.'@'.0.after
    if (! json_is_object(val))
    {
        if (rep) jm_report_add_entry(rep, "not an object [.customCommands.'@'.0.after]", path);
        return false;
    }
    bool res;
    const char *prop;
    json_t *pval;
    json_object_foreach((json_t *) val, prop, pval)
    {
        jm_path_t lpath_6 = (jm_path_t) { prop, 0, path, NULL };
        if (jm_str_eq_8(prop, 0x726f466b63656863LL) && jm_str_eq_8(prop + 8, 0x7463696c666e6f43LL) && jm_str_eq_2(prop + 16, 0x00000073))
        {
            // handle may checkForConflicts property
            // .customCommands.'@'.0.after.checkForConflicts
            res = json_is_boolean(pval);
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "not a bool [.customCommands.'@'.0.after.checkForConflicts]", (path ? &lpath_6 : NULL));
                if (rep) jm_report_add_entry(rep, "invalid optional prop value [.customCommands.'@'.0.after.checkForConflicts]", (path ? &lpath_6 : NULL));
                return false;
            }
        }
        else
        {
            if (rep) jm_report_add_entry(rep, "unexpected prop [.customCommands.'@'.0.after]", (path ? &lpath_6 : NULL));
            return false;
        }
    }
    return true;
}

// check _jm_obj_7_map_description (.customCommands.'@'.0.description)
static bool _jm_f_3(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .customCommands.'@'.0.description
    res = json_is_string(val);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected string [.customCommands.'@'.0.description]", path);
    }
    return res;
}

// check _jm_obj_7_map_loadingText (.customCommands.'@'.0.loadingText)
static bool _jm_f_4(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .customCommands.'@'.0.loadingText
    res = json_is_string(val);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected string [.customCommands.'@'.0.loadingText]", path);
    }
    return res;
}

// check _jm_obj_7_map_prompts (.customCommands.'@'.0.prompts)
static bool _jm_f_5(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .customCommands.'@'.0.prompts
    res = json_is_array(val);
    if (res)
    {
        size_t arr_4_idx;
        json_t *arr_4_item;
        json_array_foreach(val, arr_4_idx, arr_4_item)
        {
            jm_path_t arr_4_lpath = (jm_path_t) { NULL, arr_4_idx, path, NULL };
            // .customCommands.'@'.0.prompts.0
            res = json_model_10(arr_4_item, (path ? &arr_4_lpath : NULL), rep);
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "unexpected $Prompts [.customCommands.'@'.0.prompts.0]", (path ? &arr_4_lpath : NULL));
                break;
            }
        }
    }
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "not array or unexpected array [.customCommands.'@'.0.prompts]", path);
    }
    return res;
}

// check _jm_obj_7_map_showOutput (.customCommands.'@'.0.showOutput)
static bool _jm_f_6(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .customCommands.'@'.0.showOutput
    res = json_is_boolean(val);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "not a bool [.customCommands.'@'.0.showOutput]", path);
    }
    return res;
}

// check _jm_obj_7_map_stream (.customCommands.'@'.0.stream)
static bool _jm_f_7(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .customCommands.'@'.0.stream
    res = json_is_boolean(val);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "not a bool [.customCommands.'@'.0.stream]", path);
    }
    return res;
}

// check _jm_obj_7_map_subprocess (.customCommands.'@'.0.subprocess)
static bool _jm_f_8(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .customCommands.'@'.0.subprocess
    res = json_is_boolean(val);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "not a bool [.customCommands.'@'.0.subprocess]", path);
    }
    return res;
}

static INLINE jm_check_fun_t _jm_obj_7_map(const char *pname)
{
    return jm_search_propmap(pname, _jm_obj_7_map_tab, 7);
}

// object .customCommands.'@'.0
static INLINE bool _jm_obj_7(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    if (! json_is_object(val))
    {
        if (rep) jm_report_add_entry(rep, "not an object [.customCommands.'@'.0]", path);
        return false;
    }
    bool res;
    jm_check_fun_t pfun;
    int64_t must_count = 0;
    const char *prop;
    json_t *pval;
    json_object_foreach((json_t *) val, prop, pval)
    {
        jm_path_t lpath_5 = (jm_path_t) { prop, 0, path, NULL };
        if (jm_str_eq_4(prop, 0x0079656b))
        {
            // handle must key property
            must_count += 1;
            // .customCommands.'@'.0.key
            res = json_model_4(pval, (path ? &lpath_5 : NULL), rep);
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "unexpected $keybinding [.customCommands.'@'.0.key]", (path ? &lpath_5 : NULL));
                if (rep) jm_report_add_entry(rep, "invalid mandatory prop value [.customCommands.'@'.0.key]", (path ? &lpath_5 : NULL));
                return false;
            }
        }
        else if (jm_str_eq_8(prop, 0x00646e616d6d6f63LL))
        {
            // handle must command property
            must_count += 1;
            // .customCommands.'@'.0.command
            res = json_is_string(pval);
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "unexpected string [.customCommands.'@'.0.command]", (path ? &lpath_5 : NULL));
                if (rep) jm_report_add_entry(rep, "invalid mandatory prop value [.customCommands.'@'.0.command]", (path ? &lpath_5 : NULL));
                return false;
            }
        }
        else if (jm_str_eq_8(prop, 0x00747865746e6f63LL))
        {
            // handle must context property
            must_count += 1;
            // .customCommands.'@'.0.context
            res = json_is_string(pval) && jm_search_cst(&(jm_constant_t) { cst_is_string, { .s = json_string_value(pval) } }, _jm_cst_3, 13);;
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "value not in enum [.customCommands.'@'.0.context.'|']", (path ? &lpath_5 : NULL));
                if (rep) jm_report_add_entry(rep, "invalid mandatory prop value [.customCommands.'@'.0.context]", (path ? &lpath_5 : NULL));
                return false;
            }
        }
        else if ((pfun = _jm_obj_7_map(prop)))
        {
            // handle 7 may props
            if (pfun != NULL && ! pfun(pval, (path ? &lpath_5 : NULL), rep))
            {
                if (rep) jm_report_add_entry(rep, "invalid optional prop value [.customCommands.'@'.0]", (path ? &lpath_5 : NULL));
                return false;
            }
        }
        else
        {
            if (rep) jm_report_add_entry(rep, "unexpected prop [.customCommands.'@'.0]", (path ? &lpath_5 : NULL));
            return false;
        }
    }
    if (must_count != 3)
    {
        if (rep != NULL)
        {
            if (! (json_object_get(val, "command") != NULL))
            {
                if (rep) jm_report_add_entry(rep, "missing mandatory prop <command> [.customCommands.'@'.0]", path);
            }
            if (! (json_object_get(val, "context") != NULL))
            {
                if (rep) jm_report_add_entry(rep, "missing mandatory prop <context> [.customCommands.'@'.0]", path);
            }
            if (! (json_object_get(val, "key") != NULL))
            {
                if (rep) jm_report_add_entry(rep, "missing mandatory prop <key> [.customCommands.'@'.0]", path);
            }
        }
        return false;
    }
    return true;
}

// check json_model_1_map_customCommands (.customCommands)
static bool _jm_f_1(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .customCommands
    // .customCommands.'@'
    res = json_is_array(val);
    if (res)
    {
        size_t arr_3_idx;
        json_t *arr_3_item;
        json_array_foreach(val, arr_3_idx, arr_3_item)
        {
            jm_path_t arr_3_lpath = (jm_path_t) { NULL, arr_3_idx, path, NULL };
            // .customCommands.'@'.0
            res = _jm_obj_7(arr_3_item, (path ? &arr_3_lpath : NULL), rep);
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "unexpected element [.customCommands.'@'.0]", (path ? &arr_3_lpath : NULL));
                break;
            }
        }
    }
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "not array or unexpected array [.customCommands.'@']", path);
    }
    if (res)
    {
        res = jm_array_is_unique(val, path, rep);
        if (! res)
        {
            if (rep) jm_report_add_entry(rep, "constraints failed [.customCommands]", path);
        }
    }
    return res;
}

// check json_model_1_map_disableStartupPopups (.disableStartupPopups)
static bool _jm_f_9(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .disableStartupPopups
    res = json_is_boolean(val);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "not a bool [.disableStartupPopups]", path);
    }
    return res;
}

// check _jm_f_10_map_allBranchesLogCmd (.git.allBranchesLogCmd)
static bool _jm_f_11(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .git.allBranchesLogCmd
    res = json_is_string(val);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected string [.git.allBranchesLogCmd]", path);
    }
    return res;
}

// check _jm_f_10_map_autoFetch (.git.autoFetch)
static bool _jm_f_12(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .git.autoFetch
    res = json_is_boolean(val);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "not a bool [.git.autoFetch]", path);
    }
    return res;
}

// check _jm_f_10_map_autoRefresh (.git.autoRefresh)
static bool _jm_f_13(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .git.autoRefresh
    res = json_is_boolean(val);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "not a bool [.git.autoRefresh]", path);
    }
    return res;
}

// check _jm_f_10_map_branchLogCmd (.git.branchLogCmd)
static bool _jm_f_14(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .git.branchLogCmd
    res = json_is_string(val);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected string [.git.branchLogCmd]", path);
    }
    return res;
}

// check _jm_f_10_map_commit (.git.commit)
static bool _jm_f_15(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    // .git.commit
    if (! json_is_object(val))
    {
        if (rep) jm_report_add_entry(rep, "not an object [.git.commit]", path);
        return false;
    }
    bool res;
    const char *prop;
    json_t *pval;
    json_object_foreach((json_t *) val, prop, pval)
    {
        jm_path_t lpath_8 = (jm_path_t) { prop, 0, path, NULL };
        if (jm_str_eq_8(prop, 0x0066664f6e676973LL))
        {
            // handle may signOff property
            // .git.commit.signOff
            res = json_is_boolean(pval);
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "not a bool [.git.commit.signOff]", (path ? &lpath_8 : NULL));
                if (rep) jm_report_add_entry(rep, "invalid optional prop value [.git.commit.signOff]", (path ? &lpath_8 : NULL));
                return false;
            }
        }
        else
        {
            if (rep) jm_report_add_entry(rep, "unexpected prop [.git.commit]", (path ? &lpath_8 : NULL));
            return false;
        }
    }
    return true;
}

static bool _jm_re_1(const char *s, jm_path_t *path, jm_report_t *rep)
{
    size_t slen = strlen(s);
    return cre2_match(_jm_re_1_re2, s, slen, 0, slen, CRE2_UNANCHORED, NULL, 0);
}

// object .git.commitPrefixes.'/./'
static INLINE bool _jm_obj_8(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    // check close must only props
    if (! json_is_object(val))
    {
        if (rep) jm_report_add_entry(rep, "not an object [.git.commitPrefixes.'/./']", path);
        return false;
    }
    if (json_object_size(val) != 2)
    {
        if (rep) jm_report_add_entry(rep, "bad property count [.git.commitPrefixes.'/./']", path);
        return false;
    }
    jm_path_t lpath;
    json_t * pval;
    bool res;
    if (! ((pval = json_object_get(val, "pattern")) != NULL))
    {
        if (rep) jm_report_add_entry(rep, "missing mandatory prop <pattern> [.git.commitPrefixes.'/./']", path);
        return false;
    }
    lpath = (jm_path_t) { "pattern", 0, path, NULL };
    // .git.commitPrefixes.'/./'.pattern
    res = json_model_8(pval, (path ? &lpath : NULL), rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected $neString [.git.commitPrefixes.'/./'.pattern]", (path ? &lpath : NULL));
        if (rep) jm_report_add_entry(rep, "unexpected value for mandatory prop <pattern> [.git.commitPrefixes.'/./']", (path ? &lpath : NULL));
        return false;
    }
    if (! ((pval = json_object_get(val, "replace")) != NULL))
    {
        if (rep) jm_report_add_entry(rep, "missing mandatory prop <replace> [.git.commitPrefixes.'/./']", path);
        return false;
    }
    lpath = (jm_path_t) { "replace", 0, path, NULL };
    // .git.commitPrefixes.'/./'.replace
    res = json_model_8(pval, (path ? &lpath : NULL), rep);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected $neString [.git.commitPrefixes.'/./'.replace]", (path ? &lpath : NULL));
        if (rep) jm_report_add_entry(rep, "unexpected value for mandatory prop <replace> [.git.commitPrefixes.'/./']", (path ? &lpath : NULL));
        return false;
    }
    return true;
}

// check _jm_f_10_map_commitPrefixes (.git.commitPrefixes)
static bool _jm_f_16(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    // .git.commitPrefixes
    if (! json_is_object(val))
    {
        if (rep) jm_report_add_entry(rep, "not an object [.git.commitPrefixes]", path);
        return false;
    }
    bool res;
    const char *prop;
    json_t *pval;
    json_object_foreach((json_t *) val, prop, pval)
    {
        jm_path_t lpath_9 = (jm_path_t) { prop, 0, path, NULL };
        if (_jm_re_1(prop, path, rep))
        {
            // handle 1 re props
            // .git.commitPrefixes.'/./'
            res = _jm_obj_8(pval, (path ? &lpath_9 : NULL), rep);
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "unexpected element [.git.commitPrefixes.'/./']", (path ? &lpath_9 : NULL));
                return false;
            }
        }
        else
        {
            if (rep) jm_report_add_entry(rep, "unexpected prop [.git.commitPrefixes]", (path ? &lpath_9 : NULL));
            return false;
        }
    }
    return true;
}

// check _jm_f_10_map_diffContextSize (.git.diffContextSize)
static bool _jm_f_17(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .git.diffContextSize
    res = json_is_integer(val) && json_integer_value(val) >= 0;
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "not a 0 strict int [.git.diffContextSize]", path);
    }
    return res;
}

// check _jm_f_10_map_disableForcePushing (.git.disableForcePushing)
static bool _jm_f_18(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .git.disableForcePushing
    res = json_is_boolean(val);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "not a bool [.git.disableForcePushing]", path);
    }
    return res;
}

// check _jm_f_10_map_fetchAll (.git.fetchAll)
static bool _jm_f_19(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .git.fetchAll
    res = json_is_boolean(val);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "not a bool [.git.fetchAll]", path);
    }
    return res;
}



// check _jm_f_10_map_log (.git.log)
static bool _jm_f_20(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    // .git.log
    if (! json_is_object(val))
    {
        if (rep) jm_report_add_entry(rep, "not an object [.git.log]", path);
        return false;
    }
    bool res;
    const char *prop;
    json_t *pval;
    json_object_foreach((json_t *) val, prop, pval)
    {
        jm_path_t lpath_10 = (jm_path_t) { prop, 0, path, NULL };
        if (jm_str_eq_6(prop, 0x000000726564726fLL))
        {
            // handle may order property
            // .git.log.order
            res = json_is_string(pval) && jm_search_cst(&(jm_constant_t) { cst_is_string, { .s = json_string_value(pval) } }, _jm_cst_4, 4);;
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "value not in enum [.git.log.order.'|']", (path ? &lpath_10 : NULL));
                if (rep) jm_report_add_entry(rep, "invalid optional prop value [.git.log.order]", (path ? &lpath_10 : NULL));
                return false;
            }
        }
        else if (jm_str_eq_8(prop, 0x70617247776f6873LL) && jm_str_eq_2(prop + 8, 0x00000068))
        {
            // handle may showGraph property
            // .git.log.showGraph
            res = json_is_string(pval) && jm_search_cst(&(jm_constant_t) { cst_is_string, { .s = json_string_value(pval) } }, _jm_cst_5, 3);;
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "value not in enum [.git.log.showGraph.'|']", (path ? &lpath_10 : NULL));
                if (rep) jm_report_add_entry(rep, "invalid optional prop value [.git.log.showGraph]", (path ? &lpath_10 : NULL));
                return false;
            }
        }
        else if (jm_str_eq_8(prop, 0x6c6f6857776f6873LL) && jm_str_eq_7(prop + 8, 0x0000687061724765LL))
        {
            // handle may showWholeGraph property
            // .git.log.showWholeGraph
            res = json_is_boolean(pval);
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "not a bool [.git.log.showWholeGraph]", (path ? &lpath_10 : NULL));
                if (rep) jm_report_add_entry(rep, "invalid optional prop value [.git.log.showWholeGraph]", (path ? &lpath_10 : NULL));
                return false;
            }
        }
        else
        {
            if (rep) jm_report_add_entry(rep, "unexpected prop [.git.log]", (path ? &lpath_10 : NULL));
            return false;
        }
    }
    return true;
}

// check _jm_f_10_map_merging (.git.merging)
static bool _jm_f_21(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    // .git.merging
    if (! json_is_object(val))
    {
        if (rep) jm_report_add_entry(rep, "not an object [.git.merging]", path);
        return false;
    }
    bool res;
    const char *prop;
    json_t *pval;
    json_object_foreach((json_t *) val, prop, pval)
    {
        jm_path_t lpath_11 = (jm_path_t) { prop, 0, path, NULL };
        if (jm_str_eq_8(prop, 0x6f436c61756e616dLL) && jm_str_eq_5(prop + 8, 0x0000000074696d6dLL))
        {
            // handle may manualCommit property
            // .git.merging.manualCommit
            res = json_is_boolean(pval);
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "not a bool [.git.merging.manualCommit]", (path ? &lpath_11 : NULL));
                if (rep) jm_report_add_entry(rep, "invalid optional prop value [.git.merging.manualCommit]", (path ? &lpath_11 : NULL));
                return false;
            }
        }
        else if (jm_str_eq_5(prop, 0x0000000073677261LL))
        {
            // handle may args property
            // .git.merging.args
            res = json_is_string(pval);
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "unexpected string [.git.merging.args]", (path ? &lpath_11 : NULL));
                if (rep) jm_report_add_entry(rep, "invalid optional prop value [.git.merging.args]", (path ? &lpath_11 : NULL));
                return false;
            }
        }
        else
        {
            if (rep) jm_report_add_entry(rep, "unexpected prop [.git.merging]", (path ? &lpath_11 : NULL));
            return false;
        }
    }
    return true;
}

// check _jm_f_10_map_overrideGpg (.git.overrideGpg)
static bool _jm_f_22(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .git.overrideGpg
    res = json_is_boolean(val);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "not a bool [.git.overrideGpg]", path);
    }
    return res;
}


// check _jm_f_10_map_paging (.git.paging)
static bool _jm_f_23(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    // .git.paging
    if (! json_is_object(val))
    {
        if (rep) jm_report_add_entry(rep, "not an object [.git.paging]", path);
        return false;
    }
    bool res;
    const char *prop;
    json_t *pval;
    json_object_foreach((json_t *) val, prop, pval)
    {
        jm_path_t lpath_12 = (jm_path_t) { prop, 0, path, NULL };
        if (jm_str_eq_8(prop, 0x677241726f6c6f63LL) && jm_str_eq_1(prop + 8))
        {
            // handle may colorArg property
            // .git.paging.colorArg
            res = json_is_string(pval) && jm_search_cst(&(jm_constant_t) { cst_is_string, { .s = json_string_value(pval) } }, _jm_cst_6, 2);;
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "value not in enum [.git.paging.colorArg.'|']", (path ? &lpath_12 : NULL));
                if (rep) jm_report_add_entry(rep, "invalid optional prop value [.git.paging.colorArg]", (path ? &lpath_12 : NULL));
                return false;
            }
        }
        else if (jm_str_eq_8(prop, 0x69666e6f43657375LL) && jm_str_eq_2(prop + 8, 0x00000067))
        {
            // handle may useConfig property
            // .git.paging.useConfig
            res = json_is_boolean(pval);
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "not a bool [.git.paging.useConfig]", (path ? &lpath_12 : NULL));
                if (rep) jm_report_add_entry(rep, "invalid optional prop value [.git.paging.useConfig]", (path ? &lpath_12 : NULL));
                return false;
            }
        }
        else if (jm_str_eq_6(prop, 0x0000007265676170LL))
        {
            // handle may pager property
            // .git.paging.pager
            // .git.paging.pager.'@'
            res = json_is_string(pval);
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "unexpected string [.git.paging.pager.'@']", (path ? &lpath_12 : NULL));
            }
            if (res)
            {
                int64_t ival_2 = jm_str_len(json_string_value(pval));
                res = ival_2 >= 1;
                if (! res)
                {
                    if (rep) jm_report_add_entry(rep, "constraints failed [.git.paging.pager]", (path ? &lpath_12 : NULL));
                }
            }
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "invalid optional prop value [.git.paging.pager]", (path ? &lpath_12 : NULL));
                return false;
            }
        }
        else
        {
            if (rep) jm_report_add_entry(rep, "unexpected prop [.git.paging]", (path ? &lpath_12 : NULL));
            return false;
        }
    }
    return true;
}

// check _jm_f_10_map_parseEmoji (.git.parseEmoji)
static bool _jm_f_24(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .git.parseEmoji
    res = json_is_boolean(val);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "not a bool [.git.parseEmoji]", path);
    }
    return res;
}

// check _jm_f_10_map_skipHookPrefix (.git.skipHookPrefix)
static bool _jm_f_25(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .git.skipHookPrefix
    res = json_is_string(val);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected string [.git.skipHookPrefix]", path);
    }
    return res;
}

static INLINE jm_check_fun_t _jm_f_10_map(const char *pname)
{
    return jm_search_propmap(pname, _jm_f_10_map_tab, 16);
}

// check json_model_1_map_git (.git)
static bool _jm_f_10(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    // .git
    if (! json_is_object(val))
    {
        if (rep) jm_report_add_entry(rep, "not an object [.git]", path);
        return false;
    }
    jm_check_fun_t pfun;
    const char *prop;
    json_t *pval;
    json_object_foreach((json_t *) val, prop, pval)
    {
        jm_path_t lpath_7 = (jm_path_t) { prop, 0, path, NULL };
        if ((pfun = _jm_f_10_map(prop)))
        {
            // handle 16 may props
            if (pfun != NULL && ! pfun(pval, (path ? &lpath_7 : NULL), rep))
            {
                if (rep) jm_report_add_entry(rep, "invalid optional prop value [.git]", (path ? &lpath_7 : NULL));
                return false;
            }
        }
        else
        {
            if (rep) jm_report_add_entry(rep, "unexpected prop [.git]", (path ? &lpath_7 : NULL));
            return false;
        }
    }
    return true;
}

// check _jm_f_26_map_animateExplosion (.gui.animateExplosion)
static bool _jm_f_27(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .gui.animateExplosion
    res = json_is_boolean(val);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "not a bool [.gui.animateExplosion]", path);
    }
    return res;
}

// check _jm_f_26_map_authorColors (.gui.authorColors)
static bool _jm_f_28(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    // .gui.authorColors
    if (! json_is_object(val))
    {
        if (rep) jm_report_add_entry(rep, "not an object [.gui.authorColors]", path);
        return false;
    }
    bool res;
    const char *prop;
    json_t *pval;
    json_object_foreach((json_t *) val, prop, pval)
    {
        jm_path_t lpath_14 = (jm_path_t) { prop, 0, path, NULL };
        if (_jm_re_1(prop, path, rep))
        {
            // handle 1 re props
            // .gui.authorColors.'/./'
            res = json_model_2(pval, (path ? &lpath_14 : NULL), rep);
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "unexpected $color [.gui.authorColors.'/./']", (path ? &lpath_14 : NULL));
                return false;
            }
        }
        else
        {
            if (rep) jm_report_add_entry(rep, "unexpected prop [.gui.authorColors]", (path ? &lpath_14 : NULL));
            return false;
        }
    }
    return true;
}


// check _jm_f_26_map_border (.gui.border)
static bool _jm_f_29(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .gui.border
    res = json_is_string(val) && jm_search_cst(&(jm_constant_t) { cst_is_string, { .s = json_string_value(val) } }, _jm_cst_7, 4);;
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "value not in enum [.gui.border.'|']", path);
    }
    return res;
}

// check _jm_f_26_map_branchColors (.gui.branchColors)
static bool _jm_f_30(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    // .gui.branchColors
    if (! json_is_object(val))
    {
        if (rep) jm_report_add_entry(rep, "not an object [.gui.branchColors]", path);
        return false;
    }
    bool res;
    const char *prop;
    json_t *pval;
    json_object_foreach((json_t *) val, prop, pval)
    {
        jm_path_t lpath_15 = (jm_path_t) { prop, 0, path, NULL };
        if (_jm_re_1(prop, path, rep))
        {
            // handle 1 re props
            // .gui.branchColors.'/./'
            res = json_model_2(pval, (path ? &lpath_15 : NULL), rep);
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "unexpected $color [.gui.branchColors.'/./']", (path ? &lpath_15 : NULL));
                return false;
            }
        }
        else
        {
            if (rep) jm_report_add_entry(rep, "unexpected prop [.gui.branchColors]", (path ? &lpath_15 : NULL));
            return false;
        }
    }
    return true;
}

// check _jm_f_26_map_commandLogSize (.gui.commandLogSize)
static bool _jm_f_31(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .gui.commandLogSize
    res = json_is_integer(val) && json_integer_value(val) >= 0;
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "not a 0 strict int [.gui.commandLogSize]", path);
    }
    return res;
}

// check _jm_f_26_map_commitLength (.gui.commitLength)
static bool _jm_f_32(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    // .gui.commitLength
    if (! json_is_object(val))
    {
        if (rep) jm_report_add_entry(rep, "not an object [.gui.commitLength]", path);
        return false;
    }
    bool res;
    const char *prop;
    json_t *pval;
    json_object_foreach((json_t *) val, prop, pval)
    {
        jm_path_t lpath_16 = (jm_path_t) { prop, 0, path, NULL };
        if (jm_str_eq_5(prop, 0x00000000776f6873LL))
        {
            // handle may show property
            // .gui.commitLength.show
            res = json_is_boolean(pval);
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "not a bool [.gui.commitLength.show]", (path ? &lpath_16 : NULL));
                if (rep) jm_report_add_entry(rep, "invalid optional prop value [.gui.commitLength.show]", (path ? &lpath_16 : NULL));
                return false;
            }
        }
        else
        {
            if (rep) jm_report_add_entry(rep, "unexpected prop [.gui.commitLength]", (path ? &lpath_16 : NULL));
            return false;
        }
    }
    return true;
}

// check _jm_f_26_map_expandFocusedSidePanel (.gui.expandFocusedSidePanel)
static bool _jm_f_33(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .gui.expandFocusedSidePanel
    res = json_is_boolean(val);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "not a bool [.gui.expandFocusedSidePanel]", path);
    }
    return res;
}


// check _jm_f_26_map_language (.gui.language)
static bool _jm_f_34(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .gui.language
    res = json_is_string(val) && jm_search_cst(&(jm_constant_t) { cst_is_string, { .s = json_string_value(val) } }, _jm_cst_8, 9);;
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "value not in enum [.gui.language.'|']", path);
    }
    return res;
}


// check _jm_f_26_map_mainPanelSplitMode (.gui.mainPanelSplitMode)
static bool _jm_f_35(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .gui.mainPanelSplitMode
    res = json_is_string(val) && jm_search_cst(&(jm_constant_t) { cst_is_string, { .s = json_string_value(val) } }, _jm_cst_9, 3);;
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "value not in enum [.gui.mainPanelSplitMode.'|']", path);
    }
    return res;
}

// check _jm_f_26_map_mouseEvents (.gui.mouseEvents)
static bool _jm_f_36(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .gui.mouseEvents
    res = json_is_boolean(val);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "not a bool [.gui.mouseEvents]", path);
    }
    return res;
}


// check _jm_f_26_map_nerdFontsVersion (.gui.nerdFontsVersion)
static bool _jm_f_37(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .gui.nerdFontsVersion
    res = json_is_string(val) && jm_search_cst(&(jm_constant_t) { cst_is_string, { .s = json_string_value(val) } }, _jm_cst_10, 2);;
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "value not in enum [.gui.nerdFontsVersion.'|']", path);
    }
    if (! res)
    {
        res = json_is_string(val);
        if (! res)
        {
            if (rep) jm_report_add_entry(rep, "unexpected type [.gui.nerdFontsVersion.'|']", path);
        }
        if (res)
        {
            // .gui.nerdFontsVersion.'|'.0
            res = true;
            if (res)
            {
                if (rep) jm_report_free_entries(rep);
            }
            else
            {
                if (rep) jm_report_add_entry(rep, "unexpected string [.gui.nerdFontsVersion.'|'.0]", path);
                if (rep) jm_report_add_entry(rep, "no model matched [.gui.nerdFontsVersion.'|']", path);
            }
        }
    }
    return res;
}

// check _jm_f_26_map_scrollHeight (.gui.scrollHeight)
static bool _jm_f_38(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .gui.scrollHeight
    res = json_is_integer(val) && json_integer_value(val) >= 1;
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "not a 1 strict int [.gui.scrollHeight]", path);
    }
    return res;
}

// check _jm_f_26_map_scrollPastBottom (.gui.scrollPastBottom)
static bool _jm_f_39(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .gui.scrollPastBottom
    res = json_is_boolean(val);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "not a bool [.gui.scrollPastBottom]", path);
    }
    return res;
}

// check _jm_f_26_map_shortTimeFormat (.gui.shortTimeFormat)
static bool _jm_f_40(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .gui.shortTimeFormat
    res = json_is_string(val);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected string [.gui.shortTimeFormat]", path);
    }
    return res;
}

// check _jm_f_26_map_showBottomLine (.gui.showBottomLine)
static bool _jm_f_41(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .gui.showBottomLine
    res = json_is_boolean(val);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "not a bool [.gui.showBottomLine]", path);
    }
    return res;
}

// check _jm_f_26_map_showBranchCommitHash (.gui.showBranchCommitHash)
static bool _jm_f_42(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .gui.showBranchCommitHash
    res = json_is_boolean(val);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "not a bool [.gui.showBranchCommitHash]", path);
    }
    return res;
}

// check _jm_f_26_map_showCommandLog (.gui.showCommandLog)
static bool _jm_f_43(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .gui.showCommandLog
    res = json_is_boolean(val);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "not a bool [.gui.showCommandLog]", path);
    }
    return res;
}

// check _jm_f_26_map_showFileTree (.gui.showFileTree)
static bool _jm_f_44(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .gui.showFileTree
    res = json_is_boolean(val);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "not a bool [.gui.showFileTree]", path);
    }
    return res;
}

// check _jm_f_26_map_showListFooter (.gui.showListFooter)
static bool _jm_f_45(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .gui.showListFooter
    res = json_is_boolean(val);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "not a bool [.gui.showListFooter]", path);
    }
    return res;
}

// check _jm_f_26_map_showRandomTip (.gui.showRandomTip)
static bool _jm_f_46(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .gui.showRandomTip
    res = json_is_boolean(val);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "not a bool [.gui.showRandomTip]", path);
    }
    return res;
}

// check _jm_f_26_map_sidePanelWidth (.gui.sidePanelWidth)
static bool _jm_f_47(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .gui.sidePanelWidth
    // .gui.sidePanelWidth.'@'
    res = json_is_real(val) && json_real_value(val) >= 0.0;
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "not a 0.0 strict float [.gui.sidePanelWidth.'@']", path);
    }
    if (res)
    {
        double fval_0 = json_real_value(val);
        res = fval_0 <= 1.0;
        if (! res)
        {
            if (rep) jm_report_add_entry(rep, "constraints failed [.gui.sidePanelWidth]", path);
        }
    }
    return res;
}

// check _jm_f_26_map_skipDiscardChangeWarning (.gui.skipDiscardChangeWarning)
static bool _jm_f_48(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .gui.skipDiscardChangeWarning
    res = json_is_boolean(val);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "not a bool [.gui.skipDiscardChangeWarning]", path);
    }
    return res;
}

// check _jm_f_26_map_skipRewordInEditorWarning (.gui.skipRewordInEditorWarning)
static bool _jm_f_49(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .gui.skipRewordInEditorWarning
    res = json_is_boolean(val);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "not a bool [.gui.skipRewordInEditorWarning]", path);
    }
    return res;
}

// check _jm_f_26_map_skipStashWarning (.gui.skipStashWarning)
static bool _jm_f_50(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .gui.skipStashWarning
    res = json_is_boolean(val);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "not a bool [.gui.skipStashWarning]", path);
    }
    return res;
}


// check _jm_f_26_map_splitDiff (.gui.splitDiff)
static bool _jm_f_51(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .gui.splitDiff
    res = json_is_string(val) && jm_search_cst(&(jm_constant_t) { cst_is_string, { .s = json_string_value(val) } }, _jm_cst_11, 2);;
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "value not in enum [.gui.splitDiff.'|']", path);
    }
    return res;
}

static INLINE jm_check_fun_t _jm_f_52_map(const char *pname)
{
    return jm_search_propmap(pname, _jm_f_52_map_tab, 10);
}

// check _jm_f_26_map_theme (.gui.theme)
static bool _jm_f_52(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    // .gui.theme
    if (! json_is_object(val))
    {
        if (rep) jm_report_add_entry(rep, "not an object [.gui.theme]", path);
        return false;
    }
    jm_check_fun_t pfun;
    const char *prop;
    json_t *pval;
    json_object_foreach((json_t *) val, prop, pval)
    {
        jm_path_t lpath_17 = (jm_path_t) { prop, 0, path, NULL };
        if ((pfun = _jm_f_52_map(prop)))
        {
            // handle 10 may props
            if (pfun != NULL && ! pfun(pval, (path ? &lpath_17 : NULL), rep))
            {
                if (rep) jm_report_add_entry(rep, "invalid optional prop value [.gui.theme]", (path ? &lpath_17 : NULL));
                return false;
            }
        }
        else
        {
            if (rep) jm_report_add_entry(rep, "unexpected prop [.gui.theme]", (path ? &lpath_17 : NULL));
            return false;
        }
    }
    return true;
}

// check _jm_f_26_map_timeFormat (.gui.timeFormat)
static bool _jm_f_53(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .gui.timeFormat
    res = json_is_string(val);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected string [.gui.timeFormat]", path);
    }
    return res;
}


// check _jm_f_26_map_windowSize (.gui.windowSize)
static bool _jm_f_54(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .gui.windowSize
    res = json_is_string(val) && jm_search_cst(&(jm_constant_t) { cst_is_string, { .s = json_string_value(val) } }, _jm_cst_12, 3);;
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "value not in enum [.gui.windowSize.'|']", path);
    }
    return res;
}

static INLINE jm_check_fun_t _jm_f_26_map(const char *pname)
{
    return jm_search_propmap(pname, _jm_f_26_map_tab, 28);
}

// check json_model_1_map_gui (.gui)
static bool _jm_f_26(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    // .gui
    if (! json_is_object(val))
    {
        if (rep) jm_report_add_entry(rep, "not an object [.gui]", path);
        return false;
    }
    jm_check_fun_t pfun;
    const char *prop;
    json_t *pval;
    json_object_foreach((json_t *) val, prop, pval)
    {
        jm_path_t lpath_13 = (jm_path_t) { prop, 0, path, NULL };
        if ((pfun = _jm_f_26_map(prop)))
        {
            // handle 28 may props
            if (pfun != NULL && ! pfun(pval, (path ? &lpath_13 : NULL), rep))
            {
                if (rep) jm_report_add_entry(rep, "invalid optional prop value [.gui]", (path ? &lpath_13 : NULL));
                return false;
            }
        }
        else
        {
            if (rep) jm_report_add_entry(rep, "unexpected prop [.gui]", (path ? &lpath_13 : NULL));
            return false;
        }
    }
    return true;
}

static INLINE jm_check_fun_t _jm_f_56_map(const char *pname)
{
    return jm_search_propmap(pname, _jm_f_56_map_tab, 13);
}

// check _jm_f_55_map_branches (.keybinding.branches)
static bool _jm_f_56(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    // .keybinding.branches
    if (! json_is_object(val))
    {
        if (rep) jm_report_add_entry(rep, "not an object [.keybinding.branches]", path);
        return false;
    }
    jm_check_fun_t pfun;
    const char *prop;
    json_t *pval;
    json_object_foreach((json_t *) val, prop, pval)
    {
        jm_path_t lpath_19 = (jm_path_t) { prop, 0, path, NULL };
        if ((pfun = _jm_f_56_map(prop)))
        {
            // handle 13 may props
            if (pfun != NULL && ! pfun(pval, (path ? &lpath_19 : NULL), rep))
            {
                if (rep) jm_report_add_entry(rep, "invalid optional prop value [.keybinding.branches]", (path ? &lpath_19 : NULL));
                return false;
            }
        }
        else
        {
            if (rep) jm_report_add_entry(rep, "unexpected prop [.keybinding.branches]", (path ? &lpath_19 : NULL));
            return false;
        }
    }
    return true;
}

// check _jm_f_55_map_commitFiles (.keybinding.commitFiles)
static bool _jm_f_57(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    // .keybinding.commitFiles
    if (! json_is_object(val))
    {
        if (rep) jm_report_add_entry(rep, "not an object [.keybinding.commitFiles]", path);
        return false;
    }
    bool res;
    const char *prop;
    json_t *pval;
    json_object_foreach((json_t *) val, prop, pval)
    {
        jm_path_t lpath_20 = (jm_path_t) { prop, 0, path, NULL };
        if (jm_str_eq_8(prop, 0x74756f6b63656863LL) && jm_str_eq_8(prop + 8, 0x694674696d6d6f43LL) && jm_str_eq_3(prop + 16, 0x0000656c))
        {
            // handle may checkoutCommitFile property
            // .keybinding.commitFiles.checkoutCommitFile
            res = json_model_4(pval, (path ? &lpath_20 : NULL), rep);
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "unexpected $keybinding [.keybinding.commitFiles.checkoutCommitFile]", (path ? &lpath_20 : NULL));
                if (rep) jm_report_add_entry(rep, "invalid optional prop value [.keybinding.commitFiles.checkoutCommitFile]", (path ? &lpath_20 : NULL));
                return false;
            }
        }
        else
        {
            if (rep) jm_report_add_entry(rep, "unexpected prop [.keybinding.commitFiles]", (path ? &lpath_20 : NULL));
            return false;
        }
    }
    return true;
}

static INLINE jm_check_fun_t _jm_f_58_map(const char *pname)
{
    return jm_search_propmap(pname, _jm_f_58_map_tab, 21);
}

// check _jm_f_55_map_commits (.keybinding.commits)
static bool _jm_f_58(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    // .keybinding.commits
    if (! json_is_object(val))
    {
        if (rep) jm_report_add_entry(rep, "not an object [.keybinding.commits]", path);
        return false;
    }
    jm_check_fun_t pfun;
    const char *prop;
    json_t *pval;
    json_object_foreach((json_t *) val, prop, pval)
    {
        jm_path_t lpath_21 = (jm_path_t) { prop, 0, path, NULL };
        if ((pfun = _jm_f_58_map(prop)))
        {
            // handle 21 may props
            if (pfun != NULL && ! pfun(pval, (path ? &lpath_21 : NULL), rep))
            {
                if (rep) jm_report_add_entry(rep, "invalid optional prop value [.keybinding.commits]", (path ? &lpath_21 : NULL));
                return false;
            }
        }
        else
        {
            if (rep) jm_report_add_entry(rep, "unexpected prop [.keybinding.commits]", (path ? &lpath_21 : NULL));
            return false;
        }
    }
    return true;
}

static INLINE jm_check_fun_t _jm_f_59_map(const char *pname)
{
    return jm_search_propmap(pname, _jm_f_59_map_tab, 14);
}

// check _jm_f_55_map_files (.keybinding.files)
static bool _jm_f_59(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    // .keybinding.files
    if (! json_is_object(val))
    {
        if (rep) jm_report_add_entry(rep, "not an object [.keybinding.files]", path);
        return false;
    }
    jm_check_fun_t pfun;
    const char *prop;
    json_t *pval;
    json_object_foreach((json_t *) val, prop, pval)
    {
        jm_path_t lpath_22 = (jm_path_t) { prop, 0, path, NULL };
        if ((pfun = _jm_f_59_map(prop)))
        {
            // handle 14 may props
            if (pfun != NULL && ! pfun(pval, (path ? &lpath_22 : NULL), rep))
            {
                if (rep) jm_report_add_entry(rep, "invalid optional prop value [.keybinding.files]", (path ? &lpath_22 : NULL));
                return false;
            }
        }
        else
        {
            if (rep) jm_report_add_entry(rep, "unexpected prop [.keybinding.files]", (path ? &lpath_22 : NULL));
            return false;
        }
    }
    return true;
}

// check _jm_f_55_map_main (.keybinding.main)
static bool _jm_f_60(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    // .keybinding.main
    if (! json_is_object(val))
    {
        if (rep) jm_report_add_entry(rep, "not an object [.keybinding.main]", path);
        return false;
    }
    bool res;
    const char *prop;
    json_t *pval;
    json_object_foreach((json_t *) val, prop, pval)
    {
        jm_path_t lpath_23 = (jm_path_t) { prop, 0, path, NULL };
        if (jm_str_eq_8(prop, 0x7244656c67676f74LL) && jm_str_eq_8(prop + 8, 0x7463656c65536761LL) && jm_str_eq_1(prop + 16))
        {
            // handle may toggleDragSelect property
            // .keybinding.main.toggleDragSelect
            res = json_model_4(pval, (path ? &lpath_23 : NULL), rep);
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "unexpected $keybinding [.keybinding.main.toggleDragSelect]", (path ? &lpath_23 : NULL));
                if (rep) jm_report_add_entry(rep, "invalid optional prop value [.keybinding.main.toggleDragSelect]", (path ? &lpath_23 : NULL));
                return false;
            }
        }
        else if (jm_str_eq_8(prop, 0x7244656c67676f74LL) && jm_str_eq_8(prop + 8, 0x7463656c65536761LL) && jm_str_eq_5(prop + 16, 0x00000000746c612dLL))
        {
            // handle may toggleDragSelect-alt property
            // .keybinding.main.'toggleDragSelect-alt'
            res = json_model_4(pval, (path ? &lpath_23 : NULL), rep);
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "unexpected $keybinding [.keybinding.main.'toggleDragSelect-alt']", (path ? &lpath_23 : NULL));
                if (rep) jm_report_add_entry(rep, "invalid optional prop value [.keybinding.main.'toggleDragSelect-alt']", (path ? &lpath_23 : NULL));
                return false;
            }
        }
        else if (jm_str_eq_8(prop, 0x6553656c67676f74LL) && jm_str_eq_8(prop + 8, 0x6b6e75487463656cLL) && jm_str_eq_1(prop + 16))
        {
            // handle may toggleSelectHunk property
            // .keybinding.main.toggleSelectHunk
            res = json_model_4(pval, (path ? &lpath_23 : NULL), rep);
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "unexpected $keybinding [.keybinding.main.toggleSelectHunk]", (path ? &lpath_23 : NULL));
                if (rep) jm_report_add_entry(rep, "invalid optional prop value [.keybinding.main.toggleSelectHunk]", (path ? &lpath_23 : NULL));
                return false;
            }
        }
        else if (jm_str_eq_8(prop, 0x68746f426b636970LL) && jm_str_eq_6(prop + 8, 0x000000736b6e7548LL))
        {
            // handle may pickBothHunks property
            // .keybinding.main.pickBothHunks
            res = json_model_4(pval, (path ? &lpath_23 : NULL), rep);
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "unexpected $keybinding [.keybinding.main.pickBothHunks]", (path ? &lpath_23 : NULL));
                if (rep) jm_report_add_entry(rep, "invalid optional prop value [.keybinding.main.pickBothHunks]", (path ? &lpath_23 : NULL));
                return false;
            }
        }
        else
        {
            if (rep) jm_report_add_entry(rep, "unexpected prop [.keybinding.main]", (path ? &lpath_23 : NULL));
            return false;
        }
    }
    return true;
}

// check _jm_f_55_map_stash (.keybinding.stash)
static bool _jm_f_61(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    // .keybinding.stash
    if (! json_is_object(val))
    {
        if (rep) jm_report_add_entry(rep, "not an object [.keybinding.stash]", path);
        return false;
    }
    bool res;
    const char *prop;
    json_t *pval;
    json_object_foreach((json_t *) val, prop, pval)
    {
        jm_path_t lpath_24 = (jm_path_t) { prop, 0, path, NULL };
        if (jm_str_eq_8(prop, 0x6873617453706f70LL) && jm_str_eq_1(prop + 8))
        {
            // handle may popStash property
            // .keybinding.stash.popStash
            res = json_model_4(pval, (path ? &lpath_24 : NULL), rep);
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "unexpected $keybinding [.keybinding.stash.popStash]", (path ? &lpath_24 : NULL));
                if (rep) jm_report_add_entry(rep, "invalid optional prop value [.keybinding.stash.popStash]", (path ? &lpath_24 : NULL));
                return false;
            }
        }
        else if (jm_str_eq_8(prop, 0x7453656d616e6572LL) && jm_str_eq_4(prop + 8, 0x00687361))
        {
            // handle may renameStash property
            // .keybinding.stash.renameStash
            res = json_model_4(pval, (path ? &lpath_24 : NULL), rep);
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "unexpected $keybinding [.keybinding.stash.renameStash]", (path ? &lpath_24 : NULL));
                if (rep) jm_report_add_entry(rep, "invalid optional prop value [.keybinding.stash.renameStash]", (path ? &lpath_24 : NULL));
                return false;
            }
        }
        else
        {
            if (rep) jm_report_add_entry(rep, "unexpected prop [.keybinding.stash]", (path ? &lpath_24 : NULL));
            return false;
        }
    }
    return true;
}

// check _jm_f_55_map_status (.keybinding.status)
static bool _jm_f_62(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    // .keybinding.status
    if (! json_is_object(val))
    {
        if (rep) jm_report_add_entry(rep, "not an object [.keybinding.status]", path);
        return false;
    }
    bool res;
    const char *prop;
    json_t *pval;
    json_object_foreach((json_t *) val, prop, pval)
    {
        jm_path_t lpath_25 = (jm_path_t) { prop, 0, path, NULL };
        if (jm_str_eq_8(prop, 0x726f466b63656863LL) && jm_str_eq_7(prop + 8, 0x0000657461647055LL))
        {
            // handle may checkForUpdate property
            // .keybinding.status.checkForUpdate
            res = json_model_4(pval, (path ? &lpath_25 : NULL), rep);
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "unexpected $keybinding [.keybinding.status.checkForUpdate]", (path ? &lpath_25 : NULL));
                if (rep) jm_report_add_entry(rep, "invalid optional prop value [.keybinding.status.checkForUpdate]", (path ? &lpath_25 : NULL));
                return false;
            }
        }
        else if (jm_str_eq_8(prop, 0x6552746e65636572LL) && jm_str_eq_4(prop + 8, 0x00736f70))
        {
            // handle may recentRepos property
            // .keybinding.status.recentRepos
            res = json_model_4(pval, (path ? &lpath_25 : NULL), rep);
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "unexpected $keybinding [.keybinding.status.recentRepos]", (path ? &lpath_25 : NULL));
                if (rep) jm_report_add_entry(rep, "invalid optional prop value [.keybinding.status.recentRepos]", (path ? &lpath_25 : NULL));
                return false;
            }
        }
        else
        {
            if (rep) jm_report_add_entry(rep, "unexpected prop [.keybinding.status]", (path ? &lpath_25 : NULL));
            return false;
        }
    }
    return true;
}

// check _jm_f_55_map_submodules (.keybinding.submodules)
static bool _jm_f_63(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    // .keybinding.submodules
    if (! json_is_object(val))
    {
        if (rep) jm_report_add_entry(rep, "not an object [.keybinding.submodules]", path);
        return false;
    }
    bool res;
    const char *prop;
    json_t *pval;
    json_object_foreach((json_t *) val, prop, pval)
    {
        jm_path_t lpath_26 = (jm_path_t) { prop, 0, path, NULL };
        if (jm_str_eq_5(prop, 0x0000000074696e69LL))
        {
            // handle may init property
            // .keybinding.submodules.init
            res = json_model_4(pval, (path ? &lpath_26 : NULL), rep);
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "unexpected $keybinding [.keybinding.submodules.init]", (path ? &lpath_26 : NULL));
                if (rep) jm_report_add_entry(rep, "invalid optional prop value [.keybinding.submodules.init]", (path ? &lpath_26 : NULL));
                return false;
            }
        }
        else if (jm_str_eq_7(prop, 0x0000657461647075LL))
        {
            // handle may update property
            // .keybinding.submodules.update
            res = json_model_4(pval, (path ? &lpath_26 : NULL), rep);
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "unexpected $keybinding [.keybinding.submodules.update]", (path ? &lpath_26 : NULL));
                if (rep) jm_report_add_entry(rep, "invalid optional prop value [.keybinding.submodules.update]", (path ? &lpath_26 : NULL));
                return false;
            }
        }
        else if (jm_str_eq_8(prop, 0x756e654d6b6c7562LL) && jm_str_eq_1(prop + 8))
        {
            // handle may bulkMenu property
            // .keybinding.submodules.bulkMenu
            res = json_model_4(pval, (path ? &lpath_26 : NULL), rep);
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "unexpected $keybinding [.keybinding.submodules.bulkMenu]", (path ? &lpath_26 : NULL));
                if (rep) jm_report_add_entry(rep, "invalid optional prop value [.keybinding.submodules.bulkMenu]", (path ? &lpath_26 : NULL));
                return false;
            }
        }
        else
        {
            if (rep) jm_report_add_entry(rep, "unexpected prop [.keybinding.submodules]", (path ? &lpath_26 : NULL));
            return false;
        }
    }
    return true;
}

// check _jm_f_64_map_jumpToBlock (.keybinding.universal.jumpToBlock)
static bool _jm_f_65(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .keybinding.universal.jumpToBlock
    res = json_is_array(val);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "not array or unexpected array [.keybinding.universal.jumpToBlock]", path);
    }
    return res;
}

// check _jm_f_64_map_optionMenu (.keybinding.universal.optionMenu)
static bool _jm_f_66(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .keybinding.universal.optionMenu
    res = json_is_null(val);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "not null [.keybinding.universal.optionMenu]", path);
    }
    return res;
}

static INLINE jm_check_fun_t _jm_f_64_map(const char *pname)
{
    return jm_search_propmap(pname, _jm_f_64_map_tab, 59);
}

// check _jm_f_55_map_universal (.keybinding.universal)
static bool _jm_f_64(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    // .keybinding.universal
    if (! json_is_object(val))
    {
        if (rep) jm_report_add_entry(rep, "not an object [.keybinding.universal]", path);
        return false;
    }
    jm_check_fun_t pfun;
    const char *prop;
    json_t *pval;
    json_object_foreach((json_t *) val, prop, pval)
    {
        jm_path_t lpath_27 = (jm_path_t) { prop, 0, path, NULL };
        if ((pfun = _jm_f_64_map(prop)))
        {
            // handle 59 may props
            if (pfun != NULL && ! pfun(pval, (path ? &lpath_27 : NULL), rep))
            {
                if (rep) jm_report_add_entry(rep, "invalid optional prop value [.keybinding.universal]", (path ? &lpath_27 : NULL));
                return false;
            }
        }
        else
        {
            if (rep) jm_report_add_entry(rep, "unexpected prop [.keybinding.universal]", (path ? &lpath_27 : NULL));
            return false;
        }
    }
    return true;
}

static INLINE jm_check_fun_t _jm_f_55_map(const char *pname)
{
    return jm_search_propmap(pname, _jm_f_55_map_tab, 9);
}

// check json_model_1_map_keybinding (.keybinding)
static bool _jm_f_55(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    // .keybinding
    if (! json_is_object(val))
    {
        if (rep) jm_report_add_entry(rep, "not an object [.keybinding]", path);
        return false;
    }
    jm_check_fun_t pfun;
    const char *prop;
    json_t *pval;
    json_object_foreach((json_t *) val, prop, pval)
    {
        jm_path_t lpath_18 = (jm_path_t) { prop, 0, path, NULL };
        if ((pfun = _jm_f_55_map(prop)))
        {
            // handle 9 may props
            if (pfun != NULL && ! pfun(pval, (path ? &lpath_18 : NULL), rep))
            {
                if (rep) jm_report_add_entry(rep, "invalid optional prop value [.keybinding]", (path ? &lpath_18 : NULL));
                return false;
            }
        }
        else
        {
            if (rep) jm_report_add_entry(rep, "unexpected prop [.keybinding]", (path ? &lpath_18 : NULL));
            return false;
        }
    }
    return true;
}


// check json_model_1_map_notARepository (.notARepository)
static bool _jm_f_67(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .notARepository
    res = json_is_string(val) && jm_search_cst(&(jm_constant_t) { cst_is_string, { .s = json_string_value(val) } }, _jm_cst_13, 4);;
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "value not in enum [.notARepository.'|']", path);
    }
    return res;
}

// check _jm_f_68_map_copyToClipboardCmd (.os.copyToClipboardCmd)
static bool _jm_f_69(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .os.copyToClipboardCmd
    res = json_is_string(val);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected string [.os.copyToClipboardCmd]", path);
    }
    return res;
}

// check _jm_f_68_map_edit (.os.edit)
static bool _jm_f_70(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .os.edit
    res = json_is_string(val);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected string [.os.edit]", path);
    }
    return res;
}

// check _jm_f_68_map_editAtLine (.os.editAtLine)
static bool _jm_f_71(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .os.editAtLine
    res = json_is_string(val);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected string [.os.editAtLine]", path);
    }
    return res;
}

// check _jm_f_68_map_editAtLineAndWait (.os.editAtLineAndWait)
static bool _jm_f_72(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .os.editAtLineAndWait
    res = json_is_string(val);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected string [.os.editAtLineAndWait]", path);
    }
    return res;
}


// check _jm_f_68_map_editPreset (.os.editPreset)
static bool _jm_f_73(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .os.editPreset
    res = json_is_string(val) && jm_search_cst(&(jm_constant_t) { cst_is_string, { .s = json_string_value(val) } }, _jm_cst_14, 10);;
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "value not in enum [.os.editPreset.'|']", path);
    }
    if (! res)
    {
        res = json_is_string(val);
        if (! res)
        {
            if (rep) jm_report_add_entry(rep, "unexpected type [.os.editPreset.'|']", path);
        }
        if (res)
        {
            // .os.editPreset.'|'.0
            res = true;
            if (res)
            {
                if (rep) jm_report_free_entries(rep);
            }
            else
            {
                if (rep) jm_report_add_entry(rep, "unexpected string [.os.editPreset.'|'.0]", path);
                if (rep) jm_report_add_entry(rep, "no model matched [.os.editPreset.'|']", path);
            }
        }
    }
    return res;
}

// check _jm_f_68_map_open (.os.open)
static bool _jm_f_74(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .os.open
    res = json_is_string(val);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected string [.os.open]", path);
    }
    return res;
}

// check _jm_f_68_map_openLink (.os.openLink)
static bool _jm_f_75(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .os.openLink
    res = json_is_string(val);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "unexpected string [.os.openLink]", path);
    }
    return res;
}

static INLINE jm_check_fun_t _jm_f_68_map(const char *pname)
{
    return jm_search_propmap(pname, _jm_f_68_map_tab, 7);
}

// check json_model_1_map_os (.os)
static bool _jm_f_68(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    // .os
    if (! json_is_object(val))
    {
        if (rep) jm_report_add_entry(rep, "not an object [.os]", path);
        return false;
    }
    jm_check_fun_t pfun;
    const char *prop;
    json_t *pval;
    json_object_foreach((json_t *) val, prop, pval)
    {
        jm_path_t lpath_28 = (jm_path_t) { prop, 0, path, NULL };
        if ((pfun = _jm_f_68_map(prop)))
        {
            // handle 7 may props
            if (pfun != NULL && ! pfun(pval, (path ? &lpath_28 : NULL), rep))
            {
                if (rep) jm_report_add_entry(rep, "invalid optional prop value [.os]", (path ? &lpath_28 : NULL));
                return false;
            }
        }
        else
        {
            if (rep) jm_report_add_entry(rep, "unexpected prop [.os]", (path ? &lpath_28 : NULL));
            return false;
        }
    }
    return true;
}

// check json_model_1_map_promptToReturnFromSubprocess (.promptToReturnFromSubprocess)
static bool _jm_f_76(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .promptToReturnFromSubprocess
    res = json_is_boolean(val);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "not a bool [.promptToReturnFromSubprocess]", path);
    }
    return res;
}

// check json_model_1_map_quitOnTopLevelReturn (.quitOnTopLevelReturn)
static bool _jm_f_77(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    bool res;
    // .quitOnTopLevelReturn
    res = json_is_boolean(val);
    if (! res)
    {
        if (rep) jm_report_add_entry(rep, "not a bool [.quitOnTopLevelReturn]", path);
    }
    return res;
}

// check json_model_1_map_refresher (.refresher)
static bool _jm_f_78(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    // .refresher
    if (! json_is_object(val))
    {
        if (rep) jm_report_add_entry(rep, "not an object [.refresher]", path);
        return false;
    }
    bool res;
    const char *prop;
    json_t *pval;
    json_object_foreach((json_t *) val, prop, pval)
    {
        jm_path_t lpath_29 = (jm_path_t) { prop, 0, path, NULL };
        if (jm_str_eq_8(prop, 0x4968736572666572LL) && jm_str_eq_8(prop + 8, 0x006c61767265746eLL))
        {
            // handle may refreshInterval property
            // .refresher.refreshInterval
            res = json_is_integer(pval) && json_integer_value(pval) >= 0;
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "not a 0 strict int [.refresher.refreshInterval]", (path ? &lpath_29 : NULL));
                if (rep) jm_report_add_entry(rep, "invalid optional prop value [.refresher.refreshInterval]", (path ? &lpath_29 : NULL));
                return false;
            }
        }
        else if (jm_str_eq_8(prop, 0x746e496863746566LL) && jm_str_eq_6(prop + 8, 0x0000006c61767265LL))
        {
            // handle may fetchInterval property
            // .refresher.fetchInterval
            res = json_is_integer(pval) && json_integer_value(pval) >= 0;
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "not a 0 strict int [.refresher.fetchInterval]", (path ? &lpath_29 : NULL));
                if (rep) jm_report_add_entry(rep, "invalid optional prop value [.refresher.fetchInterval]", (path ? &lpath_29 : NULL));
                return false;
            }
        }
        else
        {
            if (rep) jm_report_add_entry(rep, "unexpected prop [.refresher]", (path ? &lpath_29 : NULL));
            return false;
        }
    }
    return true;
}

static bool _jm_re_2(const char *s, jm_path_t *path, jm_report_t *rep)
{
    size_t slen = strlen(s);
    return cre2_match(_jm_re_2_re2, s, slen, 0, slen, CRE2_UNANCHORED, NULL, 0);
}

// check json_model_1_map_services (.services)
static bool _jm_f_79(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    // .services
    if (! json_is_object(val))
    {
        if (rep) jm_report_add_entry(rep, "not an object [.services]", path);
        return false;
    }
    bool res;
    const char *prop;
    json_t *pval;
    json_object_foreach((json_t *) val, prop, pval)
    {
        jm_path_t lpath_30 = (jm_path_t) { prop, 0, path, NULL };
        if (_jm_re_1(prop, path, rep))
        {
            // handle 1 re props
            // .services.'/./'
            // "/^[^:]+:[^:]+$/"
            res = json_is_string(pval) && _jm_re_2(json_string_value(pval), (path ? &lpath_30 : NULL), rep);
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "unexpected /^[^:]+:[^:]+$/ [.services.'/./']", (path ? &lpath_30 : NULL));
                return false;
            }
        }
        else
        {
            if (rep) jm_report_add_entry(rep, "unexpected prop [.services]", (path ? &lpath_30 : NULL));
            return false;
        }
    }
    return true;
}


// check json_model_1_map_update (.update)
static bool _jm_f_80(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    // .update
    if (! json_is_object(val))
    {
        if (rep) jm_report_add_entry(rep, "not an object [.update]", path);
        return false;
    }
    bool res;
    const char *prop;
    json_t *pval;
    json_object_foreach((json_t *) val, prop, pval)
    {
        jm_path_t lpath_31 = (jm_path_t) { prop, 0, path, NULL };
        if (jm_str_eq_7(prop, 0x0000646f6874656dLL))
        {
            // handle may method property
            // .update.method
            res = json_is_string(pval) && jm_search_cst(&(jm_constant_t) { cst_is_string, { .s = json_string_value(pval) } }, _jm_cst_15, 3);;
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "value not in enum [.update.method.'|']", (path ? &lpath_31 : NULL));
                if (rep) jm_report_add_entry(rep, "invalid optional prop value [.update.method]", (path ? &lpath_31 : NULL));
                return false;
            }
        }
        else if (jm_str_eq_5(prop, 0x0000000073796164LL))
        {
            // handle may days property
            // .update.days
            res = json_is_integer(pval) && json_integer_value(pval) >= 0;
            if (! res)
            {
                if (rep) jm_report_add_entry(rep, "not a 0 strict int [.update.days]", (path ? &lpath_31 : NULL));
                if (rep) jm_report_add_entry(rep, "invalid optional prop value [.update.days]", (path ? &lpath_31 : NULL));
                return false;
            }
        }
        else
        {
            if (rep) jm_report_add_entry(rep, "unexpected prop [.update]", (path ? &lpath_31 : NULL));
            return false;
        }
    }
    return true;
}

static INLINE jm_check_fun_t json_model_1_map(const char *pname)
{
    return jm_search_propmap(pname, json_model_1_map_tab, 13);
}

// check $ (.)
static bool json_model_1(const json_t *val, jm_path_t *path, jm_report_t *rep)
{
    // JSON Model for Lazy Git
    // .
    if (! json_is_object(val))
    {
        if (rep) jm_report_add_entry(rep, "not an object [.]", path);
        return false;
    }
    jm_check_fun_t pfun;
    const char *prop;
    json_t *pval;
    json_object_foreach((json_t *) val, prop, pval)
    {
        jm_path_t lpath_4 = (jm_path_t) { prop, 0, path, NULL };
        if ((pfun = json_model_1_map(prop)))
        {
            // handle 13 may props
            if (pfun != NULL && ! pfun(pval, (path ? &lpath_4 : NULL), rep))
            {
                if (rep) jm_report_add_entry(rep, "invalid optional prop value [.]", (path ? &lpath_4 : NULL));
                return false;
            }
        }
        else
        {
            if (rep) jm_report_add_entry(rep, "unexpected prop [.]", (path ? &lpath_4 : NULL));
            return false;
        }
    }
    return true;
}

jm_check_fun_t check_model_map(const char *pname)
{
    return jm_search_propmap(pname, check_model_map_tab, 10);
}

static bool initialized = false;

const char *check_model_init(void)
{
    if (!initialized)
    {
        initialized = true;
        jm_version_string = JSON_MODEL_VERSION;
        // initialize sorted set _jm_cst_0
        _jm_cst_0[0] = (jm_constant_t) { cst_is_string, { .s = "black" } };
        _jm_cst_0[1] = (jm_constant_t) { cst_is_string, { .s = "red" } };
        _jm_cst_0[2] = (jm_constant_t) { cst_is_string, { .s = "green" } };
        _jm_cst_0[3] = (jm_constant_t) { cst_is_string, { .s = "yellow" } };
        _jm_cst_0[4] = (jm_constant_t) { cst_is_string, { .s = "blue" } };
        _jm_cst_0[5] = (jm_constant_t) { cst_is_string, { .s = "magenta" } };
        _jm_cst_0[6] = (jm_constant_t) { cst_is_string, { .s = "cyan" } };
        _jm_cst_0[7] = (jm_constant_t) { cst_is_string, { .s = "white" } };
        _jm_cst_0[8] = (jm_constant_t) { cst_is_string, { .s = "bold" } };
        _jm_cst_0[9] = (jm_constant_t) { cst_is_string, { .s = "default" } };
        _jm_cst_0[10] = (jm_constant_t) { cst_is_string, { .s = "reverse" } };
        _jm_cst_0[11] = (jm_constant_t) { cst_is_string, { .s = "underline" } };
        _jm_cst_0[12] = (jm_constant_t) { cst_is_string, { .s = "strikethrough" } };
        jm_sort_cst(_jm_cst_0, 13);
        _jm_re_0_re2 = cre2_new("^#[0-9a-fA-F]{6}$", strlen("^#[0-9a-fA-F]{6}$"), NULL);
        if (cre2_error_code(_jm_re_0_re2))
            return cre2_error_string(_jm_re_0_re2);
        _jm_re_0_nn = cre2_num_capturing_groups(_jm_re_0_re2) + 1;
        // initialize sorted set _jm_cst_1
        _jm_cst_1[0] = (jm_constant_t) { cst_is_string, { .s = "input" } };
        _jm_cst_1[1] = (jm_constant_t) { cst_is_string, { .s = "confirm" } };
        _jm_cst_1[2] = (jm_constant_t) { cst_is_string, { .s = "menu" } };
        _jm_cst_1[3] = (jm_constant_t) { cst_is_string, { .s = "menuFromCommand" } };
        jm_sort_cst(_jm_cst_1, 4);
        // initialize sorted set _jm_cst_2
        _jm_cst_2[0] = (jm_constant_t) { cst_is_string, { .s = "authors" } };
        _jm_cst_2[1] = (jm_constant_t) { cst_is_string, { .s = "branches" } };
        _jm_cst_2[2] = (jm_constant_t) { cst_is_string, { .s = "files" } };
        _jm_cst_2[3] = (jm_constant_t) { cst_is_string, { .s = "refs" } };
        _jm_cst_2[4] = (jm_constant_t) { cst_is_string, { .s = "remotes" } };
        _jm_cst_2[5] = (jm_constant_t) { cst_is_string, { .s = "remoteBranches" } };
        _jm_cst_2[6] = (jm_constant_t) { cst_is_string, { .s = "tags" } };
        jm_sort_cst(_jm_cst_2, 7);
        _jm_map_0_tab[0] = (jm_constmap_t) { (jm_constant_t) { cst_is_string, { .s = "input" } }, _jm_obj_0 };
        _jm_map_0_tab[1] = (jm_constmap_t) { (jm_constant_t) { cst_is_string, { .s = "confirm" } }, _jm_obj_3 };
        _jm_map_0_tab[2] = (jm_constmap_t) { (jm_constant_t) { cst_is_string, { .s = "menu" } }, _jm_obj_4 };
        _jm_map_0_tab[3] = (jm_constmap_t) { (jm_constant_t) { cst_is_string, { .s = "menuFromCommand" } }, _jm_obj_6 };
        jm_sort_constmap(_jm_map_0_tab, 4);
        // initialize sorted set _jm_cst_3
        _jm_cst_3[0] = (jm_constant_t) { cst_is_string, { .s = "status" } };
        _jm_cst_3[1] = (jm_constant_t) { cst_is_string, { .s = "files" } };
        _jm_cst_3[2] = (jm_constant_t) { cst_is_string, { .s = "worktrees" } };
        _jm_cst_3[3] = (jm_constant_t) { cst_is_string, { .s = "localBranches" } };
        _jm_cst_3[4] = (jm_constant_t) { cst_is_string, { .s = "remotes" } };
        _jm_cst_3[5] = (jm_constant_t) { cst_is_string, { .s = "remoteBranches" } };
        _jm_cst_3[6] = (jm_constant_t) { cst_is_string, { .s = "tags" } };
        _jm_cst_3[7] = (jm_constant_t) { cst_is_string, { .s = "commits" } };
        _jm_cst_3[8] = (jm_constant_t) { cst_is_string, { .s = "reflogCommits" } };
        _jm_cst_3[9] = (jm_constant_t) { cst_is_string, { .s = "subCommits" } };
        _jm_cst_3[10] = (jm_constant_t) { cst_is_string, { .s = "commitFiles" } };
        _jm_cst_3[11] = (jm_constant_t) { cst_is_string, { .s = "stash" } };
        _jm_cst_3[12] = (jm_constant_t) { cst_is_string, { .s = "global" } };
        jm_sort_cst(_jm_cst_3, 13);
        _jm_obj_7_map_tab[0] = (jm_propmap_t) { "after", _jm_f_2 };
        _jm_obj_7_map_tab[1] = (jm_propmap_t) { "description", _jm_f_3 };
        _jm_obj_7_map_tab[2] = (jm_propmap_t) { "loadingText", _jm_f_4 };
        _jm_obj_7_map_tab[3] = (jm_propmap_t) { "prompts", _jm_f_5 };
        _jm_obj_7_map_tab[4] = (jm_propmap_t) { "showOutput", _jm_f_6 };
        _jm_obj_7_map_tab[5] = (jm_propmap_t) { "stream", _jm_f_7 };
        _jm_obj_7_map_tab[6] = (jm_propmap_t) { "subprocess", _jm_f_8 };
        jm_sort_propmap(_jm_obj_7_map_tab, 7);
        _jm_re_1_re2 = cre2_new(".", strlen("."), NULL);
        if (cre2_error_code(_jm_re_1_re2))
            return cre2_error_string(_jm_re_1_re2);
        _jm_re_1_nn = cre2_num_capturing_groups(_jm_re_1_re2) + 1;
        // initialize sorted set _jm_cst_4
        _jm_cst_4[0] = (jm_constant_t) { cst_is_string, { .s = "date-order" } };
        _jm_cst_4[1] = (jm_constant_t) { cst_is_string, { .s = "author-date-order" } };
        _jm_cst_4[2] = (jm_constant_t) { cst_is_string, { .s = "topo-order" } };
        _jm_cst_4[3] = (jm_constant_t) { cst_is_string, { .s = "default" } };
        jm_sort_cst(_jm_cst_4, 4);
        // initialize sorted set _jm_cst_5
        _jm_cst_5[0] = (jm_constant_t) { cst_is_string, { .s = "always" } };
        _jm_cst_5[1] = (jm_constant_t) { cst_is_string, { .s = "never" } };
        _jm_cst_5[2] = (jm_constant_t) { cst_is_string, { .s = "when-maximised" } };
        jm_sort_cst(_jm_cst_5, 3);
        // initialize sorted set _jm_cst_6
        _jm_cst_6[0] = (jm_constant_t) { cst_is_string, { .s = "always" } };
        _jm_cst_6[1] = (jm_constant_t) { cst_is_string, { .s = "never" } };
        jm_sort_cst(_jm_cst_6, 2);
        _jm_f_10_map_tab[0] = (jm_propmap_t) { "allBranchesLogCmd", _jm_f_11 };
        _jm_f_10_map_tab[1] = (jm_propmap_t) { "autoFetch", _jm_f_12 };
        _jm_f_10_map_tab[2] = (jm_propmap_t) { "autoRefresh", _jm_f_13 };
        _jm_f_10_map_tab[3] = (jm_propmap_t) { "branchLogCmd", _jm_f_14 };
        _jm_f_10_map_tab[4] = (jm_propmap_t) { "commit", _jm_f_15 };
        _jm_f_10_map_tab[5] = (jm_propmap_t) { "commitPrefixes", _jm_f_16 };
        _jm_f_10_map_tab[6] = (jm_propmap_t) { "diffContextSize", _jm_f_17 };
        _jm_f_10_map_tab[7] = (jm_propmap_t) { "disableForcePushing", _jm_f_18 };
        _jm_f_10_map_tab[8] = (jm_propmap_t) { "fetchAll", _jm_f_19 };
        _jm_f_10_map_tab[9] = (jm_propmap_t) { "log", _jm_f_20 };
        _jm_f_10_map_tab[10] = (jm_propmap_t) { "mainBranches", json_model_9 };
        _jm_f_10_map_tab[11] = (jm_propmap_t) { "merging", _jm_f_21 };
        _jm_f_10_map_tab[12] = (jm_propmap_t) { "overrideGpg", _jm_f_22 };
        _jm_f_10_map_tab[13] = (jm_propmap_t) { "paging", _jm_f_23 };
        _jm_f_10_map_tab[14] = (jm_propmap_t) { "parseEmoji", _jm_f_24 };
        _jm_f_10_map_tab[15] = (jm_propmap_t) { "skipHookPrefix", _jm_f_25 };
        jm_sort_propmap(_jm_f_10_map_tab, 16);
        // initialize sorted set _jm_cst_7
        _jm_cst_7[0] = (jm_constant_t) { cst_is_string, { .s = "single" } };
        _jm_cst_7[1] = (jm_constant_t) { cst_is_string, { .s = "double" } };
        _jm_cst_7[2] = (jm_constant_t) { cst_is_string, { .s = "rounded" } };
        _jm_cst_7[3] = (jm_constant_t) { cst_is_string, { .s = "hidden" } };
        jm_sort_cst(_jm_cst_7, 4);
        // initialize sorted set _jm_cst_8
        _jm_cst_8[0] = (jm_constant_t) { cst_is_string, { .s = "auto" } };
        _jm_cst_8[1] = (jm_constant_t) { cst_is_string, { .s = "en" } };
        _jm_cst_8[2] = (jm_constant_t) { cst_is_string, { .s = "zh-CN" } };
        _jm_cst_8[3] = (jm_constant_t) { cst_is_string, { .s = "zh-TW" } };
        _jm_cst_8[4] = (jm_constant_t) { cst_is_string, { .s = "pl" } };
        _jm_cst_8[5] = (jm_constant_t) { cst_is_string, { .s = "nl" } };
        _jm_cst_8[6] = (jm_constant_t) { cst_is_string, { .s = "ja" } };
        _jm_cst_8[7] = (jm_constant_t) { cst_is_string, { .s = "ko" } };
        _jm_cst_8[8] = (jm_constant_t) { cst_is_string, { .s = "ru" } };
        jm_sort_cst(_jm_cst_8, 9);
        // initialize sorted set _jm_cst_9
        _jm_cst_9[0] = (jm_constant_t) { cst_is_string, { .s = "horizontal" } };
        _jm_cst_9[1] = (jm_constant_t) { cst_is_string, { .s = "flexible" } };
        _jm_cst_9[2] = (jm_constant_t) { cst_is_string, { .s = "vertical" } };
        jm_sort_cst(_jm_cst_9, 3);
        // initialize sorted set _jm_cst_10
        _jm_cst_10[0] = (jm_constant_t) { cst_is_string, { .s = "2" } };
        _jm_cst_10[1] = (jm_constant_t) { cst_is_string, { .s = "3" } };
        jm_sort_cst(_jm_cst_10, 2);
        // initialize sorted set _jm_cst_11
        _jm_cst_11[0] = (jm_constant_t) { cst_is_string, { .s = "auto" } };
        _jm_cst_11[1] = (jm_constant_t) { cst_is_string, { .s = "always" } };
        jm_sort_cst(_jm_cst_11, 2);
        _jm_f_52_map_tab[0] = (jm_propmap_t) { "activeBorderColor", json_model_3 };
        _jm_f_52_map_tab[1] = (jm_propmap_t) { "cherryPickedCommitBgColor", json_model_3 };
        _jm_f_52_map_tab[2] = (jm_propmap_t) { "cherryPickedCommitFgColor", json_model_3 };
        _jm_f_52_map_tab[3] = (jm_propmap_t) { "defaultFgColor", json_model_3 };
        _jm_f_52_map_tab[4] = (jm_propmap_t) { "inactiveBorderColor", json_model_3 };
        _jm_f_52_map_tab[5] = (jm_propmap_t) { "optionsTextColor", json_model_3 };
        _jm_f_52_map_tab[6] = (jm_propmap_t) { "searchingActiveBorderColor", json_model_3 };
        _jm_f_52_map_tab[7] = (jm_propmap_t) { "selectedLineBgColor", json_model_3 };
        _jm_f_52_map_tab[8] = (jm_propmap_t) { "selectedRangeBgColor", json_model_3 };
        _jm_f_52_map_tab[9] = (jm_propmap_t) { "unstagedChangesColor", json_model_3 };
        jm_sort_propmap(_jm_f_52_map_tab, 10);
        // initialize sorted set _jm_cst_12
        _jm_cst_12[0] = (jm_constant_t) { cst_is_string, { .s = "normal" } };
        _jm_cst_12[1] = (jm_constant_t) { cst_is_string, { .s = "half" } };
        _jm_cst_12[2] = (jm_constant_t) { cst_is_string, { .s = "full" } };
        jm_sort_cst(_jm_cst_12, 3);
        _jm_f_26_map_tab[0] = (jm_propmap_t) { "animateExplosion", _jm_f_27 };
        _jm_f_26_map_tab[1] = (jm_propmap_t) { "authorColors", _jm_f_28 };
        _jm_f_26_map_tab[2] = (jm_propmap_t) { "border", _jm_f_29 };
        _jm_f_26_map_tab[3] = (jm_propmap_t) { "branchColors", _jm_f_30 };
        _jm_f_26_map_tab[4] = (jm_propmap_t) { "commandLogSize", _jm_f_31 };
        _jm_f_26_map_tab[5] = (jm_propmap_t) { "commitLength", _jm_f_32 };
        _jm_f_26_map_tab[6] = (jm_propmap_t) { "expandFocusedSidePanel", _jm_f_33 };
        _jm_f_26_map_tab[7] = (jm_propmap_t) { "language", _jm_f_34 };
        _jm_f_26_map_tab[8] = (jm_propmap_t) { "mainPanelSplitMode", _jm_f_35 };
        _jm_f_26_map_tab[9] = (jm_propmap_t) { "mouseEvents", _jm_f_36 };
        _jm_f_26_map_tab[10] = (jm_propmap_t) { "nerdFontsVersion", _jm_f_37 };
        _jm_f_26_map_tab[11] = (jm_propmap_t) { "scrollHeight", _jm_f_38 };
        _jm_f_26_map_tab[12] = (jm_propmap_t) { "scrollPastBottom", _jm_f_39 };
        _jm_f_26_map_tab[13] = (jm_propmap_t) { "shortTimeFormat", _jm_f_40 };
        _jm_f_26_map_tab[14] = (jm_propmap_t) { "showBottomLine", _jm_f_41 };
        _jm_f_26_map_tab[15] = (jm_propmap_t) { "showBranchCommitHash", _jm_f_42 };
        _jm_f_26_map_tab[16] = (jm_propmap_t) { "showCommandLog", _jm_f_43 };
        _jm_f_26_map_tab[17] = (jm_propmap_t) { "showFileTree", _jm_f_44 };
        _jm_f_26_map_tab[18] = (jm_propmap_t) { "showListFooter", _jm_f_45 };
        _jm_f_26_map_tab[19] = (jm_propmap_t) { "showRandomTip", _jm_f_46 };
        _jm_f_26_map_tab[20] = (jm_propmap_t) { "sidePanelWidth", _jm_f_47 };
        _jm_f_26_map_tab[21] = (jm_propmap_t) { "skipDiscardChangeWarning", _jm_f_48 };
        _jm_f_26_map_tab[22] = (jm_propmap_t) { "skipRewordInEditorWarning", _jm_f_49 };
        _jm_f_26_map_tab[23] = (jm_propmap_t) { "skipStashWarning", _jm_f_50 };
        _jm_f_26_map_tab[24] = (jm_propmap_t) { "splitDiff", _jm_f_51 };
        _jm_f_26_map_tab[25] = (jm_propmap_t) { "theme", _jm_f_52 };
        _jm_f_26_map_tab[26] = (jm_propmap_t) { "timeFormat", _jm_f_53 };
        _jm_f_26_map_tab[27] = (jm_propmap_t) { "windowSize", _jm_f_54 };
        jm_sort_propmap(_jm_f_26_map_tab, 28);
        _jm_f_56_map_tab[0] = (jm_propmap_t) { "checkoutBranchByName", json_model_4 };
        _jm_f_56_map_tab[1] = (jm_propmap_t) { "createPullRequest", json_model_4 };
        _jm_f_56_map_tab[2] = (jm_propmap_t) { "createTag", json_model_4 };
        _jm_f_56_map_tab[3] = (jm_propmap_t) { "fastForward", json_model_4 };
        _jm_f_56_map_tab[4] = (jm_propmap_t) { "fetchRemote", json_model_4 };
        _jm_f_56_map_tab[5] = (jm_propmap_t) { "forceCheckoutBranch", json_model_4 };
        _jm_f_56_map_tab[6] = (jm_propmap_t) { "mergeIntoCurrentBranch", json_model_4 };
        _jm_f_56_map_tab[7] = (jm_propmap_t) { "pushTag", json_model_4 };
        _jm_f_56_map_tab[8] = (jm_propmap_t) { "rebaseBranch", json_model_4 };
        _jm_f_56_map_tab[9] = (jm_propmap_t) { "renameBranch", json_model_4 };
        _jm_f_56_map_tab[10] = (jm_propmap_t) { "setUpstream", json_model_4 };
        _jm_f_56_map_tab[11] = (jm_propmap_t) { "viewGitFlowOptions", json_model_4 };
        _jm_f_56_map_tab[12] = (jm_propmap_t) { "viewPullRequestOptions", json_model_4 };
        jm_sort_propmap(_jm_f_56_map_tab, 13);
        _jm_f_58_map_tab[0] = (jm_propmap_t) { "amendToCommit", json_model_4 };
        _jm_f_58_map_tab[1] = (jm_propmap_t) { "checkoutCommit", json_model_4 };
        _jm_f_58_map_tab[2] = (jm_propmap_t) { "cherryPickCopy", json_model_4 };
        _jm_f_58_map_tab[3] = (jm_propmap_t) { "cherryPickCopyRange", json_model_4 };
        _jm_f_58_map_tab[4] = (jm_propmap_t) { "copyCommitMessageToClipboard", json_model_4 };
        _jm_f_58_map_tab[5] = (jm_propmap_t) { "createFixupCommit", json_model_4 };
        _jm_f_58_map_tab[6] = (jm_propmap_t) { "markCommitAsFixup", json_model_4 };
        _jm_f_58_map_tab[7] = (jm_propmap_t) { "moveDownCommit", json_model_4 };
        _jm_f_58_map_tab[8] = (jm_propmap_t) { "moveUpCommit", json_model_4 };
        _jm_f_58_map_tab[9] = (jm_propmap_t) { "openLogMenu", json_model_4 };
        _jm_f_58_map_tab[10] = (jm_propmap_t) { "pasteCommits", json_model_4 };
        _jm_f_58_map_tab[11] = (jm_propmap_t) { "pickCommit", json_model_4 };
        _jm_f_58_map_tab[12] = (jm_propmap_t) { "renameCommit", json_model_4 };
        _jm_f_58_map_tab[13] = (jm_propmap_t) { "renameCommitWithEditor", json_model_4 };
        _jm_f_58_map_tab[14] = (jm_propmap_t) { "resetCherryPick", json_model_4 };
        _jm_f_58_map_tab[15] = (jm_propmap_t) { "revertCommit", json_model_4 };
        _jm_f_58_map_tab[16] = (jm_propmap_t) { "squashAboveCommits", json_model_4 };
        _jm_f_58_map_tab[17] = (jm_propmap_t) { "squashDown", json_model_4 };
        _jm_f_58_map_tab[18] = (jm_propmap_t) { "tagCommit", json_model_4 };
        _jm_f_58_map_tab[19] = (jm_propmap_t) { "viewBisectOptions", json_model_4 };
        _jm_f_58_map_tab[20] = (jm_propmap_t) { "viewResetOptions", json_model_4 };
        jm_sort_propmap(_jm_f_58_map_tab, 21);
        _jm_f_59_map_tab[0] = (jm_propmap_t) { "amendLastCommit", json_model_4 };
        _jm_f_59_map_tab[1] = (jm_propmap_t) { "commitChanges", json_model_4 };
        _jm_f_59_map_tab[2] = (jm_propmap_t) { "commitChangesWithEditor", json_model_4 };
        _jm_f_59_map_tab[3] = (jm_propmap_t) { "commitChangesWithoutHook", json_model_4 };
        _jm_f_59_map_tab[4] = (jm_propmap_t) { "fetch", json_model_4 };
        _jm_f_59_map_tab[5] = (jm_propmap_t) { "ignoreFile", json_model_4 };
        _jm_f_59_map_tab[6] = (jm_propmap_t) { "openMergeTool", json_model_4 };
        _jm_f_59_map_tab[7] = (jm_propmap_t) { "openStatusFilter", json_model_4 };
        _jm_f_59_map_tab[8] = (jm_propmap_t) { "refreshFiles", json_model_4 };
        _jm_f_59_map_tab[9] = (jm_propmap_t) { "stashAllChanges", json_model_4 };
        _jm_f_59_map_tab[10] = (jm_propmap_t) { "toggleStagedAll", json_model_4 };
        _jm_f_59_map_tab[11] = (jm_propmap_t) { "toggleTreeView", json_model_4 };
        _jm_f_59_map_tab[12] = (jm_propmap_t) { "viewResetOptions", json_model_4 };
        _jm_f_59_map_tab[13] = (jm_propmap_t) { "viewStashOptions", json_model_4 };
        jm_sort_propmap(_jm_f_59_map_tab, 14);
        _jm_f_64_map_tab[0] = (jm_propmap_t) { "confirm", json_model_4 };
        _jm_f_64_map_tab[1] = (jm_propmap_t) { "copyToClipboard", json_model_4 };
        _jm_f_64_map_tab[2] = (jm_propmap_t) { "createPatchOptionsMenu", json_model_4 };
        _jm_f_64_map_tab[3] = (jm_propmap_t) { "createRebaseOptionsMenu", json_model_4 };
        _jm_f_64_map_tab[4] = (jm_propmap_t) { "decreaseContextInDiffView", json_model_4 };
        _jm_f_64_map_tab[5] = (jm_propmap_t) { "diffingMenu", json_model_4 };
        _jm_f_64_map_tab[6] = (jm_propmap_t) { "diffingMenu-alt", json_model_4 };
        _jm_f_64_map_tab[7] = (jm_propmap_t) { "edit", json_model_4 };
        _jm_f_64_map_tab[8] = (jm_propmap_t) { "executeCustomCommand", json_model_4 };
        _jm_f_64_map_tab[9] = (jm_propmap_t) { "extrasMenu", json_model_4 };
        _jm_f_64_map_tab[10] = (jm_propmap_t) { "filteringMenu", json_model_4 };
        _jm_f_64_map_tab[11] = (jm_propmap_t) { "goInto", json_model_4 };
        _jm_f_64_map_tab[12] = (jm_propmap_t) { "gotoBottom", json_model_4 };
        _jm_f_64_map_tab[13] = (jm_propmap_t) { "gotoTop", json_model_4 };
        _jm_f_64_map_tab[14] = (jm_propmap_t) { "increaseContextInDiffView", json_model_4 };
        _jm_f_64_map_tab[15] = (jm_propmap_t) { "jumpToBlock", _jm_f_65 };
        _jm_f_64_map_tab[16] = (jm_propmap_t) { "new", json_model_4 };
        _jm_f_64_map_tab[17] = (jm_propmap_t) { "nextBlock", json_model_4 };
        _jm_f_64_map_tab[18] = (jm_propmap_t) { "nextBlock-alt", json_model_4 };
        _jm_f_64_map_tab[19] = (jm_propmap_t) { "nextItem", json_model_4 };
        _jm_f_64_map_tab[20] = (jm_propmap_t) { "nextItem-alt", json_model_4 };
        _jm_f_64_map_tab[21] = (jm_propmap_t) { "nextMatch", json_model_4 };
        _jm_f_64_map_tab[22] = (jm_propmap_t) { "nextPage", json_model_4 };
        _jm_f_64_map_tab[23] = (jm_propmap_t) { "nextScreenMode", json_model_4 };
        _jm_f_64_map_tab[24] = (jm_propmap_t) { "nextTab", json_model_4 };
        _jm_f_64_map_tab[25] = (jm_propmap_t) { "openFile", json_model_4 };
        _jm_f_64_map_tab[26] = (jm_propmap_t) { "openRecentRepos", json_model_4 };
        _jm_f_64_map_tab[27] = (jm_propmap_t) { "optionMenu", _jm_f_66 };
        _jm_f_64_map_tab[28] = (jm_propmap_t) { "optionMenu-alt1", json_model_4 };
        _jm_f_64_map_tab[29] = (jm_propmap_t) { "prevBlock", json_model_4 };
        _jm_f_64_map_tab[30] = (jm_propmap_t) { "prevBlock-alt", json_model_4 };
        _jm_f_64_map_tab[31] = (jm_propmap_t) { "prevItem", json_model_4 };
        _jm_f_64_map_tab[32] = (jm_propmap_t) { "prevItem-alt", json_model_4 };
        _jm_f_64_map_tab[33] = (jm_propmap_t) { "prevMatch", json_model_4 };
        _jm_f_64_map_tab[34] = (jm_propmap_t) { "prevPage", json_model_4 };
        _jm_f_64_map_tab[35] = (jm_propmap_t) { "prevScreenMode", json_model_4 };
        _jm_f_64_map_tab[36] = (jm_propmap_t) { "prevTab", json_model_4 };
        _jm_f_64_map_tab[37] = (jm_propmap_t) { "pullFiles", json_model_4 };
        _jm_f_64_map_tab[38] = (jm_propmap_t) { "pushFiles", json_model_4 };
        _jm_f_64_map_tab[39] = (jm_propmap_t) { "quit", json_model_4 };
        _jm_f_64_map_tab[40] = (jm_propmap_t) { "quit-alt1", json_model_4 };
        _jm_f_64_map_tab[41] = (jm_propmap_t) { "quitWithoutChangingDirectory", json_model_4 };
        _jm_f_64_map_tab[42] = (jm_propmap_t) { "redo", json_model_4 };
        _jm_f_64_map_tab[43] = (jm_propmap_t) { "refresh", json_model_4 };
        _jm_f_64_map_tab[44] = (jm_propmap_t) { "remove", json_model_4 };
        _jm_f_64_map_tab[45] = (jm_propmap_t) { "return", json_model_4 };
        _jm_f_64_map_tab[46] = (jm_propmap_t) { "scrollDownMain", json_model_4 };
        _jm_f_64_map_tab[47] = (jm_propmap_t) { "scrollDownMain-alt1", json_model_4 };
        _jm_f_64_map_tab[48] = (jm_propmap_t) { "scrollDownMain-alt2", json_model_4 };
        _jm_f_64_map_tab[49] = (jm_propmap_t) { "scrollLeft", json_model_4 };
        _jm_f_64_map_tab[50] = (jm_propmap_t) { "scrollRight", json_model_4 };
        _jm_f_64_map_tab[51] = (jm_propmap_t) { "scrollUpMain", json_model_4 };
        _jm_f_64_map_tab[52] = (jm_propmap_t) { "scrollUpMain-alt1", json_model_4 };
        _jm_f_64_map_tab[53] = (jm_propmap_t) { "scrollUpMain-alt2", json_model_4 };
        _jm_f_64_map_tab[54] = (jm_propmap_t) { "select", json_model_4 };
        _jm_f_64_map_tab[55] = (jm_propmap_t) { "submitEditorText", json_model_4 };
        _jm_f_64_map_tab[56] = (jm_propmap_t) { "togglePanel", json_model_4 };
        _jm_f_64_map_tab[57] = (jm_propmap_t) { "toggleWhitespaceInDiffView", json_model_4 };
        _jm_f_64_map_tab[58] = (jm_propmap_t) { "undo", json_model_4 };
        jm_sort_propmap(_jm_f_64_map_tab, 59);
        _jm_f_55_map_tab[0] = (jm_propmap_t) { "branches", _jm_f_56 };
        _jm_f_55_map_tab[1] = (jm_propmap_t) { "commitFiles", _jm_f_57 };
        _jm_f_55_map_tab[2] = (jm_propmap_t) { "commits", _jm_f_58 };
        _jm_f_55_map_tab[3] = (jm_propmap_t) { "files", _jm_f_59 };
        _jm_f_55_map_tab[4] = (jm_propmap_t) { "main", _jm_f_60 };
        _jm_f_55_map_tab[5] = (jm_propmap_t) { "stash", _jm_f_61 };
        _jm_f_55_map_tab[6] = (jm_propmap_t) { "status", _jm_f_62 };
        _jm_f_55_map_tab[7] = (jm_propmap_t) { "submodules", _jm_f_63 };
        _jm_f_55_map_tab[8] = (jm_propmap_t) { "universal", _jm_f_64 };
        jm_sort_propmap(_jm_f_55_map_tab, 9);
        // initialize sorted set _jm_cst_13
        _jm_cst_13[0] = (jm_constant_t) { cst_is_string, { .s = "prompt" } };
        _jm_cst_13[1] = (jm_constant_t) { cst_is_string, { .s = "create" } };
        _jm_cst_13[2] = (jm_constant_t) { cst_is_string, { .s = "skip" } };
        _jm_cst_13[3] = (jm_constant_t) { cst_is_string, { .s = "quit" } };
        jm_sort_cst(_jm_cst_13, 4);
        // initialize sorted set _jm_cst_14
        _jm_cst_14[0] = (jm_constant_t) { cst_is_string, { .s = "vim" } };
        _jm_cst_14[1] = (jm_constant_t) { cst_is_string, { .s = "nvim" } };
        _jm_cst_14[2] = (jm_constant_t) { cst_is_string, { .s = "emacs" } };
        _jm_cst_14[3] = (jm_constant_t) { cst_is_string, { .s = "nano" } };
        _jm_cst_14[4] = (jm_constant_t) { cst_is_string, { .s = "vscode" } };
        _jm_cst_14[5] = (jm_constant_t) { cst_is_string, { .s = "sublime" } };
        _jm_cst_14[6] = (jm_constant_t) { cst_is_string, { .s = "bbedit" } };
        _jm_cst_14[7] = (jm_constant_t) { cst_is_string, { .s = "kakoune" } };
        _jm_cst_14[8] = (jm_constant_t) { cst_is_string, { .s = "helix" } };
        _jm_cst_14[9] = (jm_constant_t) { cst_is_string, { .s = "xcode" } };
        jm_sort_cst(_jm_cst_14, 10);
        _jm_f_68_map_tab[0] = (jm_propmap_t) { "copyToClipboardCmd", _jm_f_69 };
        _jm_f_68_map_tab[1] = (jm_propmap_t) { "edit", _jm_f_70 };
        _jm_f_68_map_tab[2] = (jm_propmap_t) { "editAtLine", _jm_f_71 };
        _jm_f_68_map_tab[3] = (jm_propmap_t) { "editAtLineAndWait", _jm_f_72 };
        _jm_f_68_map_tab[4] = (jm_propmap_t) { "editPreset", _jm_f_73 };
        _jm_f_68_map_tab[5] = (jm_propmap_t) { "open", _jm_f_74 };
        _jm_f_68_map_tab[6] = (jm_propmap_t) { "openLink", _jm_f_75 };
        jm_sort_propmap(_jm_f_68_map_tab, 7);
        _jm_re_2_re2 = cre2_new("^[^:]+:[^:]+$", strlen("^[^:]+:[^:]+$"), NULL);
        if (cre2_error_code(_jm_re_2_re2))
            return cre2_error_string(_jm_re_2_re2);
        _jm_re_2_nn = cre2_num_capturing_groups(_jm_re_2_re2) + 1;
        // initialize sorted set _jm_cst_15
        _jm_cst_15[0] = (jm_constant_t) { cst_is_string, { .s = "prompt" } };
        _jm_cst_15[1] = (jm_constant_t) { cst_is_string, { .s = "background" } };
        _jm_cst_15[2] = (jm_constant_t) { cst_is_string, { .s = "never" } };
        jm_sort_cst(_jm_cst_15, 3);
        json_model_1_map_tab[0] = (jm_propmap_t) { "confirmOnQuit", _jm_f_0 };
        json_model_1_map_tab[1] = (jm_propmap_t) { "customCommands", _jm_f_1 };
        json_model_1_map_tab[2] = (jm_propmap_t) { "disableStartupPopups", _jm_f_9 };
        json_model_1_map_tab[3] = (jm_propmap_t) { "git", _jm_f_10 };
        json_model_1_map_tab[4] = (jm_propmap_t) { "gui", _jm_f_26 };
        json_model_1_map_tab[5] = (jm_propmap_t) { "keybinding", _jm_f_55 };
        json_model_1_map_tab[6] = (jm_propmap_t) { "notARepository", _jm_f_67 };
        json_model_1_map_tab[7] = (jm_propmap_t) { "os", _jm_f_68 };
        json_model_1_map_tab[8] = (jm_propmap_t) { "promptToReturnFromSubprocess", _jm_f_76 };
        json_model_1_map_tab[9] = (jm_propmap_t) { "quitOnTopLevelReturn", _jm_f_77 };
        json_model_1_map_tab[10] = (jm_propmap_t) { "refresher", _jm_f_78 };
        json_model_1_map_tab[11] = (jm_propmap_t) { "services", _jm_f_79 };
        json_model_1_map_tab[12] = (jm_propmap_t) { "update", _jm_f_80 };
        jm_sort_propmap(json_model_1_map_tab, 13);
        check_model_map_tab[0] = (jm_propmap_t) { "", json_model_1 };
        check_model_map_tab[1] = (jm_propmap_t) { "color", json_model_2 };
        check_model_map_tab[2] = (jm_propmap_t) { "colorArray", json_model_3 };
        check_model_map_tab[3] = (jm_propmap_t) { "keybinding", json_model_4 };
        check_model_map_tab[4] = (jm_propmap_t) { "custom-commands-prompts-type-property", json_model_5 };
        check_model_map_tab[5] = (jm_propmap_t) { "custom-commands-prompts-title-property", json_model_6 };
        check_model_map_tab[6] = (jm_propmap_t) { "custom-commands-prompts-key-property", json_model_7 };
        check_model_map_tab[7] = (jm_propmap_t) { "neString", json_model_8 };
        check_model_map_tab[8] = (jm_propmap_t) { "stringArray", json_model_9 };
        check_model_map_tab[9] = (jm_propmap_t) { "Prompts", json_model_10 };
        jm_sort_propmap(check_model_map_tab, 10);
    }
    return NULL;
}

void check_model_free(void)
{
    if (initialized)
    {
        initialized = false;

        // cleanup code
        cre2_delete(_jm_re_0_re2);
        _jm_re_0_re2 = NULL;
        _jm_re_0_nn = 0;
        cre2_delete(_jm_re_1_re2);
        _jm_re_1_re2 = NULL;
        _jm_re_1_nn = 0;
        cre2_delete(_jm_re_2_re2);
        _jm_re_2_re2 = NULL;
        _jm_re_2_nn = 0;
    }
}

/*
 * # API
 *
 * ```c
 * bool error;
 * char *message;
 *
 * bool valid = check(json_value, "model-name", &error, &message);
 *
 * if (message)
 *    free(message), message = NULL;
 * ```
 *
 * - `error` is set of there was an error during initialization or if the model does not exists.
 * - `message` is provided if a non NULL pointer is passed, and must be freed by the caller.
 */
bool
check_model(const json_t *val, const char *name, bool *error, char **reasons)
{
    return jm_generic_entry(check_model_init, check_model_map, val, name, error, reasons);
}
