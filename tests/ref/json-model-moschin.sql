--
-- Generated by JSON Model Compiler version 2.0b0
-- see https://github.com/clairey-zx81/json-model
--
-- JSON_MODEL_VERSION is 2.0b0

-- check $Model (.'$Model')
CREATE OR REPLACE FUNCTION json_model_3(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$Model'
  res := json_model_25(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check $ (.)
CREATE OR REPLACE FUNCTION json_model_1(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .
  res := json_model_3(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check $Model#RootModel (.'$Model#RootModel')
CREATE OR REPLACE FUNCTION json_model_25(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$Model#RootModel'
  -- .'$Model#RootModel'.'|'.0
  res := json_model_18(val, path, rep);
  IF NOT res THEN
    -- .'$Model#RootModel'.'|'.1
    res := json_model_9(val, path, rep);
    IF NOT res THEN
      -- .'$Model#RootModel'.'|'.2
      res := json_model_24(val, path, rep);
    END IF;
  END IF;
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check $Model#Array (.'$Model#Array')
CREATE OR REPLACE FUNCTION json_model_9(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  arr_0_idx INT8;
  arr_0_item JSONB;
BEGIN
  -- .'$Model#Array'
  res := JSONB_TYPEOF(val) = 'array';
  IF res THEN
    FOR arr_0_idx IN 0 .. JSONB_ARRAY_LENGTH(val) - 1 LOOP
      arr_0_item := val -> arr_0_idx;
      -- .'$Model#Array'.0
      res := json_model_19(arr_0_item, NULL, rep);
      IF NOT res THEN
        EXIT;
      END IF;
    END LOOP;
  END IF;
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION _jm_cst_0(value JSONB)
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  constants JSONB = JSONB '[null,true,0,1,-1,0.0,1.0,-1.0]';
BEGIN
  RETURN constants @> value;
END;
$$ LANGUAGE plpgsql;

-- check $Model#Scalar (.'$Model#Scalar')
CREATE OR REPLACE FUNCTION json_model_18(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$Model#Scalar'
  res := JSONB_TYPEOF(val) IN ('null', 'boolean', 'number', 'string') AND _jm_cst_0(val);
  IF NOT res THEN
    res := JSONB_TYPEOF(val) = 'string';
    IF res THEN
      -- .'$Model#Scalar'.'|'.0
      res := TRUE;
    END IF;
  END IF;
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check $Model#Model (.'$Model#Model')
CREATE OR REPLACE FUNCTION json_model_19(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$Model#Model'
  -- .'$Model#Model'.'|'.0
  res := json_model_18(val, path, rep);
  IF NOT res THEN
    -- .'$Model#Model'.'|'.1
    res := json_model_9(val, path, rep);
    IF NOT res THEN
      -- .'$Model#Model'.'|'.2
      res := json_model_16(val, path, rep);
    END IF;
  END IF;
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- object .'$Model#Elem'.'|'.5.'.schema'
CREATE OR REPLACE FUNCTION _jm_obj_1(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  -- accept any object
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- regex=^[@|&^+/*]$ opts=n
CREATE OR REPLACE FUNCTION _jm_re_0(val TEXT, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  RETURN regexp_like(val, '^[@|&^+/*]$', 'n');
END;
$$ LANGUAGE plpgsql;

-- object .'$Model#Elem'.'|'.5
CREATE OR REPLACE FUNCTION _jm_obj_0(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = '#' THEN
      -- handle may # property
      -- .'$Model#Elem'.'|'.5.'#'
      res := JSONB_TYPEOF(pval) = 'string';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = '.schema' THEN
      -- handle may .schema property
      -- .'$Model#Elem'.'|'.5.'.schema'
      res := _jm_obj_1(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF _jm_re_0(prop, path, rep) THEN
      -- handle 1 re props
      -- .'$Model#Elem'.'|'.5.'/^[@|&^+/*]$/'
      res := FALSE;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      -- handle other props
      -- .'$Model#Elem'.'|'.5.''
      res := json_model_19(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- object .'$Model#Elem'.'|'.4.'.schema'
CREATE OR REPLACE FUNCTION _jm_obj_3(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  -- accept any object
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- object .'$Model#Elem'.'|'.4
CREATE OR REPLACE FUNCTION _jm_obj_2(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  must_count int;
  prop TEXT;
  pval JSONB;
  arr_1_idx INT8;
  arr_1_item JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  must_count := 0;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = '+' THEN
      -- handle must + property
      must_count := must_count + 1;
      -- .'$Model#Elem'.'|'.4.'+'
      res := JSONB_TYPEOF(pval) = 'array';
      IF res THEN
        FOR arr_1_idx IN 0 .. JSONB_ARRAY_LENGTH(pval) - 1 LOOP
          arr_1_item := pval -> arr_1_idx;
          -- .'$Model#Elem'.'|'.4.'+'.0
          res := json_model_19(arr_1_item, NULL, rep);
          IF NOT res THEN
            EXIT;
          END IF;
        END LOOP;
      END IF;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = '#' THEN
      -- handle may # property
      -- .'$Model#Elem'.'|'.4.'#'
      res := JSONB_TYPEOF(pval) = 'string';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = '.schema' THEN
      -- handle may .schema property
      -- .'$Model#Elem'.'|'.4.'.schema'
      res := _jm_obj_3(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  IF must_count <> 1 THEN
    RETURN FALSE;
  END IF;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- object .'$Model#Elem'.'|'.3.'.schema'
CREATE OR REPLACE FUNCTION _jm_obj_5(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  -- accept any object
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- object .'$Model#Elem'.'|'.3
CREATE OR REPLACE FUNCTION _jm_obj_4(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  must_count int;
  prop TEXT;
  pval JSONB;
  arr_2_idx INT8;
  arr_2_item JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  must_count := 0;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = '^' THEN
      -- handle must ^ property
      must_count := must_count + 1;
      -- .'$Model#Elem'.'|'.3.'^'
      res := JSONB_TYPEOF(pval) = 'array';
      IF res THEN
        FOR arr_2_idx IN 0 .. JSONB_ARRAY_LENGTH(pval) - 1 LOOP
          arr_2_item := pval -> arr_2_idx;
          -- .'$Model#Elem'.'|'.3.'^'.0
          res := json_model_19(arr_2_item, NULL, rep);
          IF NOT res THEN
            EXIT;
          END IF;
        END LOOP;
      END IF;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = '#' THEN
      -- handle may # property
      -- .'$Model#Elem'.'|'.3.'#'
      res := JSONB_TYPEOF(pval) = 'string';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = '.schema' THEN
      -- handle may .schema property
      -- .'$Model#Elem'.'|'.3.'.schema'
      res := _jm_obj_5(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  IF must_count <> 1 THEN
    RETURN FALSE;
  END IF;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- object .'$Model#Elem'.'|'.2.'.schema'
CREATE OR REPLACE FUNCTION _jm_obj_7(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  -- accept any object
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- object .'$Model#Elem'.'|'.2
CREATE OR REPLACE FUNCTION _jm_obj_6(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  must_count int;
  prop TEXT;
  pval JSONB;
  arr_3_idx INT8;
  arr_3_item JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  must_count := 0;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = '&' THEN
      -- handle must & property
      must_count := must_count + 1;
      -- .'$Model#Elem'.'|'.2.'&'
      res := JSONB_TYPEOF(pval) = 'array';
      IF res THEN
        FOR arr_3_idx IN 0 .. JSONB_ARRAY_LENGTH(pval) - 1 LOOP
          arr_3_item := pval -> arr_3_idx;
          -- .'$Model#Elem'.'|'.2.'&'.0
          res := json_model_19(arr_3_item, NULL, rep);
          IF NOT res THEN
            EXIT;
          END IF;
        END LOOP;
      END IF;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = '#' THEN
      -- handle may # property
      -- .'$Model#Elem'.'|'.2.'#'
      res := JSONB_TYPEOF(pval) = 'string';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = '.schema' THEN
      -- handle may .schema property
      -- .'$Model#Elem'.'|'.2.'.schema'
      res := _jm_obj_7(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  IF must_count <> 1 THEN
    RETURN FALSE;
  END IF;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- object .'$Model#Elem'.'|'.1.'.schema'
CREATE OR REPLACE FUNCTION _jm_obj_9(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  -- accept any object
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- object .'$Model#Elem'.'|'.1
CREATE OR REPLACE FUNCTION _jm_obj_8(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  must_count int;
  prop TEXT;
  pval JSONB;
  arr_4_idx INT8;
  arr_4_item JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  must_count := 0;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = '|' THEN
      -- handle must | property
      must_count := must_count + 1;
      -- .'$Model#Elem'.'|'.1.'|'
      res := JSONB_TYPEOF(pval) = 'array';
      IF res THEN
        FOR arr_4_idx IN 0 .. JSONB_ARRAY_LENGTH(pval) - 1 LOOP
          arr_4_item := pval -> arr_4_idx;
          -- .'$Model#Elem'.'|'.1.'|'.0
          res := json_model_19(arr_4_item, NULL, rep);
          IF NOT res THEN
            EXIT;
          END IF;
        END LOOP;
      END IF;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = '#' THEN
      -- handle may # property
      -- .'$Model#Elem'.'|'.1.'#'
      res := JSONB_TYPEOF(pval) = 'string';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = '.schema' THEN
      -- handle may .schema property
      -- .'$Model#Elem'.'|'.1.'.schema'
      res := _jm_obj_9(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  IF must_count <> 1 THEN
    RETURN FALSE;
  END IF;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- object .'$Model#Elem'.'|'.0.'.schema'
CREATE OR REPLACE FUNCTION _jm_obj_11(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  -- accept any object
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- regex=^(<=|>=|<|>|≥|≤)$ opts=n
CREATE OR REPLACE FUNCTION _jm_re_1(val TEXT, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  RETURN regexp_like(val, '^(<=|>=|<|>|≥|≤)$', 'n');
END;
$$ LANGUAGE plpgsql;

-- regex=^(=|!=|≠)$ opts=n
CREATE OR REPLACE FUNCTION _jm_re_2(val TEXT, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  RETURN regexp_like(val, '^(=|!=|≠)$', 'n');
END;
$$ LANGUAGE plpgsql;

-- object .'$Model#Elem'.'|'.0
CREATE OR REPLACE FUNCTION _jm_obj_10(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  must_count int;
  prop TEXT;
  pval JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  must_count := 0;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = '@' THEN
      -- handle must @ property
      must_count := must_count + 1;
      -- .'$Model#Elem'.'|'.0.'@'
      res := json_model_19(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = '#' THEN
      -- handle may # property
      -- .'$Model#Elem'.'|'.0.'#'
      res := JSONB_TYPEOF(pval) = 'string';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = '.schema' THEN
      -- handle may .schema property
      -- .'$Model#Elem'.'|'.0.'.schema'
      res := _jm_obj_11(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = '!' THEN
      -- handle may ! property
      -- .'$Model#Elem'.'|'.0.'!'
      res := JSONB_TYPEOF(pval) = 'boolean';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = '.mo' THEN
      -- handle may .mo property
      -- .'$Model#Elem'.'|'.0.'.mo'
      res := JSONB_TYPEOF(pval) = 'number' AND (pval)::INT8 = (pval)::FLOAT8 AND (pval)::INT8 >= 1;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = '.in' THEN
      -- handle may .in property
      -- .'$Model#Elem'.'|'.0.'.in'
      res := json_model_19(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF _jm_re_1(prop, path, rep) THEN
      -- handle 2 re props
      -- .'$Model#Elem'.'|'.0.'/^(<=|>=|<|>|≥|≤)$/'
      -- .'$Model#Elem'.'|'.0.'/^(<=|>=|<|>|≥|≤)$/'.'|'.0
      res := JSONB_TYPEOF(pval) = 'number' AND (pval)::INT8 = (pval)::FLOAT8;
      IF NOT res THEN
        -- .'$Model#Elem'.'|'.0.'/^(<=|>=|<|>|≥|≤)$/'.'|'.1
        res := JSONB_TYPEOF(pval) = 'number';
        IF NOT res THEN
          -- .'$Model#Elem'.'|'.0.'/^(<=|>=|<|>|≥|≤)$/'.'|'.2
          res := JSONB_TYPEOF(pval) = 'string';
        END IF;
      END IF;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF _jm_re_2(prop, path, rep) THEN
      -- handle 2 re props
      -- .'$Model#Elem'.'|'.0.'/^(=|!=|≠)$/'
      res := json_model_5(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  IF must_count <> 1 THEN
    RETURN FALSE;
  END IF;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check $Model#Elem (.'$Model#Elem')
CREATE OR REPLACE FUNCTION json_model_16(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$Model#Elem'
  res := JSONB_TYPEOF(val) = 'object';
  IF res THEN
    -- .'$Model#Elem'.'|'.0
    res := _jm_obj_10(val, path, rep);
    IF NOT res THEN
      -- .'$Model#Elem'.'|'.1
      res := _jm_obj_8(val, path, rep);
      IF NOT res THEN
        -- .'$Model#Elem'.'|'.2
        res := _jm_obj_6(val, path, rep);
        IF NOT res THEN
          -- .'$Model#Elem'.'|'.3
          res := _jm_obj_4(val, path, rep);
          IF NOT res THEN
            -- .'$Model#Elem'.'|'.4
            res := _jm_obj_2(val, path, rep);
            IF NOT res THEN
              -- .'$Model#Elem'.'|'.5
              res := _jm_obj_0(val, path, rep);
            END IF;
          END IF;
        END IF;
      END IF;
    END IF;
  END IF;
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check $Model#Val (.'$Model#Val')
CREATE OR REPLACE FUNCTION json_model_5(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$Model#Val'
  -- .'$Model#Val'.'|'.0
  res := JSONB_TYPEOF(val) = 'null';
  IF NOT res THEN
    -- .'$Model#Val'.'|'.1
    res := JSONB_TYPEOF(val) = 'boolean';
    IF NOT res THEN
      -- .'$Model#Val'.'|'.2
      res := JSONB_TYPEOF(val) = 'number' AND (val)::INT8 = (val)::FLOAT8;
      IF NOT res THEN
        -- .'$Model#Val'.'|'.3
        res := JSONB_TYPEOF(val) = 'number';
        IF NOT res THEN
          -- .'$Model#Val'.'|'.4
          res := JSONB_TYPEOF(val) = 'string';
        END IF;
      END IF;
    END IF;
  END IF;
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- object .'$Model#Root'.'|'.5.'$'.'.schema'
CREATE OR REPLACE FUNCTION _jm_obj_14(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  -- accept any object
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- regex=.+ opts=n
CREATE OR REPLACE FUNCTION _jm_re_3(val TEXT, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  RETURN regexp_like(val, '.+', 'n');
END;
$$ LANGUAGE plpgsql;

-- object .'$Model#Root'.'|'.5.'$'
CREATE OR REPLACE FUNCTION _jm_obj_13(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = '#' THEN
      -- handle may # property
      -- .'$Model#Root'.'|'.5.'$'.'#'
      res := JSONB_TYPEOF(pval) = 'string';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = '.schema' THEN
      -- handle may .schema property
      -- .'$Model#Root'.'|'.5.'$'.'.schema'
      res := _jm_obj_14(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = '' THEN
      -- handle may  property
      -- .'$Model#Root'.'|'.5.'$'.''
      res := json_model_4(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF _jm_re_3(prop, path, rep) THEN
      -- handle 1 re props
      -- .'$Model#Root'.'|'.5.'$'.'/.+/'
      res := json_model_19(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- object .'$Model#Root'.'|'.5.'%'.'.schema'
CREATE OR REPLACE FUNCTION _jm_obj_16(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  -- accept any object
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- regex=^\$ opts=n
CREATE OR REPLACE FUNCTION _jm_re_4(val TEXT, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  RETURN regexp_like(val, '^\$', 'n');
END;
$$ LANGUAGE plpgsql;

-- regex=^\..+$ opts=n
CREATE OR REPLACE FUNCTION _jm_re_5(val TEXT, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  RETURN regexp_like(val, '^\..+$', 'n');
END;
$$ LANGUAGE plpgsql;

-- regex=^([#|&^+/*@~=$%]|[<>!]=?)$ opts=n
CREATE OR REPLACE FUNCTION _jm_re_6(val TEXT, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  RETURN regexp_like(val, '^([#|&^+/*@~=$%]|[<>!]=?)$', 'n');
END;
$$ LANGUAGE plpgsql;

-- regex=^\$.*$ opts=n
CREATE OR REPLACE FUNCTION _jm_re_7(val TEXT, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  RETURN regexp_like(val, '^\$.*$', 'n');
END;
$$ LANGUAGE plpgsql;

-- object .'$Model#Root'.'|'.5.'%'
CREATE OR REPLACE FUNCTION _jm_obj_15(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
  arr_5_idx INT8;
  arr_5_item JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = '#' THEN
      -- handle may # property
      -- .'$Model#Root'.'|'.5.'%'.'#'
      res := JSONB_TYPEOF(pval) = 'string';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = '.schema' THEN
      -- handle may .schema property
      -- .'$Model#Root'.'|'.5.'%'.'.schema'
      res := _jm_obj_16(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = '<' THEN
      -- handle may < property
      -- .'$Model#Root'.'|'.5.'%'.'<'
      res := JSONB_TYPEOF(pval) = 'array';
      IF res THEN
        FOR arr_5_idx IN 0 .. JSONB_ARRAY_LENGTH(pval) - 1 LOOP
          arr_5_item := pval -> arr_5_idx;
          -- .'$Model#Root'.'|'.5.'%'.'<'.0
          -- "/^\\$/"
          res := JSONB_TYPEOF(arr_5_item) = 'string' AND _jm_re_4(JSON_VALUE(arr_5_item, '$' RETURNING TEXT), NULL, rep);
          IF NOT res THEN
            EXIT;
          END IF;
        END LOOP;
      END IF;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF _jm_re_5(prop, path, rep) THEN
      -- handle 2 re props
      -- .'$Model#Root'.'|'.5.'%'.'/^\\..+$/'
      -- "/^([#|&^+/*@~=$%]|[<>!]=?)$/"
      res := JSONB_TYPEOF(pval) = 'string' AND _jm_re_6(JSON_VALUE(pval, '$' RETURNING TEXT), NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF _jm_re_7(prop, path, rep) THEN
      -- handle 2 re props
      -- .'$Model#Root'.'|'.5.'%'.'/^\\$.*$/'
      res := json_model_17(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- object .'$Model#Root'.'|'.5.'.schema'
CREATE OR REPLACE FUNCTION _jm_obj_17(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  -- accept any object
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- object .'$Model#Root'.'|'.5
CREATE OR REPLACE FUNCTION _jm_obj_12(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = '~' THEN
      -- handle may ~ property
      -- .'$Model#Root'.'|'.5.'~'
      res := json_model_4(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = '$' THEN
      -- handle may $ property
      -- .'$Model#Root'.'|'.5.'$'
      res := _jm_obj_13(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = '%' THEN
      -- handle may % property
      -- .'$Model#Root'.'|'.5.'%'
      res := _jm_obj_15(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = '#' THEN
      -- handle may # property
      -- .'$Model#Root'.'|'.5.'#'
      res := JSONB_TYPEOF(pval) = 'string';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = '.schema' THEN
      -- handle may .schema property
      -- .'$Model#Root'.'|'.5.'.schema'
      res := _jm_obj_17(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF _jm_re_0(prop, path, rep) THEN
      -- handle 1 re props
      -- .'$Model#Root'.'|'.5.'/^[@|&^+/*]$/'
      res := FALSE;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      -- handle other props
      -- .'$Model#Root'.'|'.5.''
      res := json_model_19(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- object .'$Model#Root'.'|'.4.'$'.'.schema'
CREATE OR REPLACE FUNCTION _jm_obj_20(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  -- accept any object
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- object .'$Model#Root'.'|'.4.'$'
CREATE OR REPLACE FUNCTION _jm_obj_19(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = '#' THEN
      -- handle may # property
      -- .'$Model#Root'.'|'.4.'$'.'#'
      res := JSONB_TYPEOF(pval) = 'string';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = '.schema' THEN
      -- handle may .schema property
      -- .'$Model#Root'.'|'.4.'$'.'.schema'
      res := _jm_obj_20(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = '' THEN
      -- handle may  property
      -- .'$Model#Root'.'|'.4.'$'.''
      res := json_model_4(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF _jm_re_3(prop, path, rep) THEN
      -- handle 1 re props
      -- .'$Model#Root'.'|'.4.'$'.'/.+/'
      res := json_model_19(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- object .'$Model#Root'.'|'.4.'%'.'.schema'
CREATE OR REPLACE FUNCTION _jm_obj_22(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  -- accept any object
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- object .'$Model#Root'.'|'.4.'%'
CREATE OR REPLACE FUNCTION _jm_obj_21(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
  arr_7_idx INT8;
  arr_7_item JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = '#' THEN
      -- handle may # property
      -- .'$Model#Root'.'|'.4.'%'.'#'
      res := JSONB_TYPEOF(pval) = 'string';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = '.schema' THEN
      -- handle may .schema property
      -- .'$Model#Root'.'|'.4.'%'.'.schema'
      res := _jm_obj_22(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = '<' THEN
      -- handle may < property
      -- .'$Model#Root'.'|'.4.'%'.'<'
      res := JSONB_TYPEOF(pval) = 'array';
      IF res THEN
        FOR arr_7_idx IN 0 .. JSONB_ARRAY_LENGTH(pval) - 1 LOOP
          arr_7_item := pval -> arr_7_idx;
          -- .'$Model#Root'.'|'.4.'%'.'<'.0
          -- "/^\\$/"
          res := JSONB_TYPEOF(arr_7_item) = 'string' AND _jm_re_4(JSON_VALUE(arr_7_item, '$' RETURNING TEXT), NULL, rep);
          IF NOT res THEN
            EXIT;
          END IF;
        END LOOP;
      END IF;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF _jm_re_5(prop, path, rep) THEN
      -- handle 2 re props
      -- .'$Model#Root'.'|'.4.'%'.'/^\\..+$/'
      -- "/^([#|&^+/*@~=$%]|[<>!]=?)$/"
      res := JSONB_TYPEOF(pval) = 'string' AND _jm_re_6(JSON_VALUE(pval, '$' RETURNING TEXT), NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF _jm_re_7(prop, path, rep) THEN
      -- handle 2 re props
      -- .'$Model#Root'.'|'.4.'%'.'/^\\$.*$/'
      res := json_model_17(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- object .'$Model#Root'.'|'.4.'.schema'
CREATE OR REPLACE FUNCTION _jm_obj_23(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  -- accept any object
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- object .'$Model#Root'.'|'.4
CREATE OR REPLACE FUNCTION _jm_obj_18(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  must_count int;
  prop TEXT;
  pval JSONB;
  arr_6_idx INT8;
  arr_6_item JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  must_count := 0;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = '+' THEN
      -- handle must + property
      must_count := must_count + 1;
      -- .'$Model#Root'.'|'.4.'+'
      res := JSONB_TYPEOF(pval) = 'array';
      IF res THEN
        FOR arr_6_idx IN 0 .. JSONB_ARRAY_LENGTH(pval) - 1 LOOP
          arr_6_item := pval -> arr_6_idx;
          -- .'$Model#Root'.'|'.4.'+'.0
          res := json_model_19(arr_6_item, NULL, rep);
          IF NOT res THEN
            EXIT;
          END IF;
        END LOOP;
      END IF;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = '~' THEN
      -- handle may ~ property
      -- .'$Model#Root'.'|'.4.'~'
      res := json_model_4(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = '$' THEN
      -- handle may $ property
      -- .'$Model#Root'.'|'.4.'$'
      res := _jm_obj_19(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = '%' THEN
      -- handle may % property
      -- .'$Model#Root'.'|'.4.'%'
      res := _jm_obj_21(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = '#' THEN
      -- handle may # property
      -- .'$Model#Root'.'|'.4.'#'
      res := JSONB_TYPEOF(pval) = 'string';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = '.schema' THEN
      -- handle may .schema property
      -- .'$Model#Root'.'|'.4.'.schema'
      res := _jm_obj_23(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  IF must_count <> 1 THEN
    RETURN FALSE;
  END IF;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- object .'$Model#Root'.'|'.3.'$'.'.schema'
CREATE OR REPLACE FUNCTION _jm_obj_26(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  -- accept any object
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- object .'$Model#Root'.'|'.3.'$'
CREATE OR REPLACE FUNCTION _jm_obj_25(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = '#' THEN
      -- handle may # property
      -- .'$Model#Root'.'|'.3.'$'.'#'
      res := JSONB_TYPEOF(pval) = 'string';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = '.schema' THEN
      -- handle may .schema property
      -- .'$Model#Root'.'|'.3.'$'.'.schema'
      res := _jm_obj_26(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = '' THEN
      -- handle may  property
      -- .'$Model#Root'.'|'.3.'$'.''
      res := json_model_4(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF _jm_re_3(prop, path, rep) THEN
      -- handle 1 re props
      -- .'$Model#Root'.'|'.3.'$'.'/.+/'
      res := json_model_19(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- object .'$Model#Root'.'|'.3.'%'.'.schema'
CREATE OR REPLACE FUNCTION _jm_obj_28(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  -- accept any object
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- object .'$Model#Root'.'|'.3.'%'
CREATE OR REPLACE FUNCTION _jm_obj_27(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
  arr_9_idx INT8;
  arr_9_item JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = '#' THEN
      -- handle may # property
      -- .'$Model#Root'.'|'.3.'%'.'#'
      res := JSONB_TYPEOF(pval) = 'string';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = '.schema' THEN
      -- handle may .schema property
      -- .'$Model#Root'.'|'.3.'%'.'.schema'
      res := _jm_obj_28(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = '<' THEN
      -- handle may < property
      -- .'$Model#Root'.'|'.3.'%'.'<'
      res := JSONB_TYPEOF(pval) = 'array';
      IF res THEN
        FOR arr_9_idx IN 0 .. JSONB_ARRAY_LENGTH(pval) - 1 LOOP
          arr_9_item := pval -> arr_9_idx;
          -- .'$Model#Root'.'|'.3.'%'.'<'.0
          -- "/^\\$/"
          res := JSONB_TYPEOF(arr_9_item) = 'string' AND _jm_re_4(JSON_VALUE(arr_9_item, '$' RETURNING TEXT), NULL, rep);
          IF NOT res THEN
            EXIT;
          END IF;
        END LOOP;
      END IF;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF _jm_re_5(prop, path, rep) THEN
      -- handle 2 re props
      -- .'$Model#Root'.'|'.3.'%'.'/^\\..+$/'
      -- "/^([#|&^+/*@~=$%]|[<>!]=?)$/"
      res := JSONB_TYPEOF(pval) = 'string' AND _jm_re_6(JSON_VALUE(pval, '$' RETURNING TEXT), NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF _jm_re_7(prop, path, rep) THEN
      -- handle 2 re props
      -- .'$Model#Root'.'|'.3.'%'.'/^\\$.*$/'
      res := json_model_17(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- object .'$Model#Root'.'|'.3.'.schema'
CREATE OR REPLACE FUNCTION _jm_obj_29(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  -- accept any object
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- object .'$Model#Root'.'|'.3
CREATE OR REPLACE FUNCTION _jm_obj_24(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  must_count int;
  prop TEXT;
  pval JSONB;
  arr_8_idx INT8;
  arr_8_item JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  must_count := 0;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = '^' THEN
      -- handle must ^ property
      must_count := must_count + 1;
      -- .'$Model#Root'.'|'.3.'^'
      res := JSONB_TYPEOF(pval) = 'array';
      IF res THEN
        FOR arr_8_idx IN 0 .. JSONB_ARRAY_LENGTH(pval) - 1 LOOP
          arr_8_item := pval -> arr_8_idx;
          -- .'$Model#Root'.'|'.3.'^'.0
          res := json_model_19(arr_8_item, NULL, rep);
          IF NOT res THEN
            EXIT;
          END IF;
        END LOOP;
      END IF;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = '~' THEN
      -- handle may ~ property
      -- .'$Model#Root'.'|'.3.'~'
      res := json_model_4(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = '$' THEN
      -- handle may $ property
      -- .'$Model#Root'.'|'.3.'$'
      res := _jm_obj_25(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = '%' THEN
      -- handle may % property
      -- .'$Model#Root'.'|'.3.'%'
      res := _jm_obj_27(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = '#' THEN
      -- handle may # property
      -- .'$Model#Root'.'|'.3.'#'
      res := JSONB_TYPEOF(pval) = 'string';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = '.schema' THEN
      -- handle may .schema property
      -- .'$Model#Root'.'|'.3.'.schema'
      res := _jm_obj_29(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  IF must_count <> 1 THEN
    RETURN FALSE;
  END IF;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- object .'$Model#Root'.'|'.2.'$'.'.schema'
CREATE OR REPLACE FUNCTION _jm_obj_32(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  -- accept any object
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- object .'$Model#Root'.'|'.2.'$'
CREATE OR REPLACE FUNCTION _jm_obj_31(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = '#' THEN
      -- handle may # property
      -- .'$Model#Root'.'|'.2.'$'.'#'
      res := JSONB_TYPEOF(pval) = 'string';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = '.schema' THEN
      -- handle may .schema property
      -- .'$Model#Root'.'|'.2.'$'.'.schema'
      res := _jm_obj_32(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = '' THEN
      -- handle may  property
      -- .'$Model#Root'.'|'.2.'$'.''
      res := json_model_4(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF _jm_re_3(prop, path, rep) THEN
      -- handle 1 re props
      -- .'$Model#Root'.'|'.2.'$'.'/.+/'
      res := json_model_19(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- object .'$Model#Root'.'|'.2.'%'.'.schema'
CREATE OR REPLACE FUNCTION _jm_obj_34(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  -- accept any object
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- object .'$Model#Root'.'|'.2.'%'
CREATE OR REPLACE FUNCTION _jm_obj_33(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
  arr_11_idx INT8;
  arr_11_item JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = '#' THEN
      -- handle may # property
      -- .'$Model#Root'.'|'.2.'%'.'#'
      res := JSONB_TYPEOF(pval) = 'string';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = '.schema' THEN
      -- handle may .schema property
      -- .'$Model#Root'.'|'.2.'%'.'.schema'
      res := _jm_obj_34(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = '<' THEN
      -- handle may < property
      -- .'$Model#Root'.'|'.2.'%'.'<'
      res := JSONB_TYPEOF(pval) = 'array';
      IF res THEN
        FOR arr_11_idx IN 0 .. JSONB_ARRAY_LENGTH(pval) - 1 LOOP
          arr_11_item := pval -> arr_11_idx;
          -- .'$Model#Root'.'|'.2.'%'.'<'.0
          -- "/^\\$/"
          res := JSONB_TYPEOF(arr_11_item) = 'string' AND _jm_re_4(JSON_VALUE(arr_11_item, '$' RETURNING TEXT), NULL, rep);
          IF NOT res THEN
            EXIT;
          END IF;
        END LOOP;
      END IF;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF _jm_re_5(prop, path, rep) THEN
      -- handle 2 re props
      -- .'$Model#Root'.'|'.2.'%'.'/^\\..+$/'
      -- "/^([#|&^+/*@~=$%]|[<>!]=?)$/"
      res := JSONB_TYPEOF(pval) = 'string' AND _jm_re_6(JSON_VALUE(pval, '$' RETURNING TEXT), NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF _jm_re_7(prop, path, rep) THEN
      -- handle 2 re props
      -- .'$Model#Root'.'|'.2.'%'.'/^\\$.*$/'
      res := json_model_17(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- object .'$Model#Root'.'|'.2.'.schema'
CREATE OR REPLACE FUNCTION _jm_obj_35(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  -- accept any object
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- object .'$Model#Root'.'|'.2
CREATE OR REPLACE FUNCTION _jm_obj_30(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  must_count int;
  prop TEXT;
  pval JSONB;
  arr_10_idx INT8;
  arr_10_item JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  must_count := 0;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = '&' THEN
      -- handle must & property
      must_count := must_count + 1;
      -- .'$Model#Root'.'|'.2.'&'
      res := JSONB_TYPEOF(pval) = 'array';
      IF res THEN
        FOR arr_10_idx IN 0 .. JSONB_ARRAY_LENGTH(pval) - 1 LOOP
          arr_10_item := pval -> arr_10_idx;
          -- .'$Model#Root'.'|'.2.'&'.0
          res := json_model_19(arr_10_item, NULL, rep);
          IF NOT res THEN
            EXIT;
          END IF;
        END LOOP;
      END IF;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = '~' THEN
      -- handle may ~ property
      -- .'$Model#Root'.'|'.2.'~'
      res := json_model_4(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = '$' THEN
      -- handle may $ property
      -- .'$Model#Root'.'|'.2.'$'
      res := _jm_obj_31(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = '%' THEN
      -- handle may % property
      -- .'$Model#Root'.'|'.2.'%'
      res := _jm_obj_33(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = '#' THEN
      -- handle may # property
      -- .'$Model#Root'.'|'.2.'#'
      res := JSONB_TYPEOF(pval) = 'string';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = '.schema' THEN
      -- handle may .schema property
      -- .'$Model#Root'.'|'.2.'.schema'
      res := _jm_obj_35(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  IF must_count <> 1 THEN
    RETURN FALSE;
  END IF;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- object .'$Model#Root'.'|'.1.'$'.'.schema'
CREATE OR REPLACE FUNCTION _jm_obj_38(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  -- accept any object
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- object .'$Model#Root'.'|'.1.'$'
CREATE OR REPLACE FUNCTION _jm_obj_37(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = '#' THEN
      -- handle may # property
      -- .'$Model#Root'.'|'.1.'$'.'#'
      res := JSONB_TYPEOF(pval) = 'string';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = '.schema' THEN
      -- handle may .schema property
      -- .'$Model#Root'.'|'.1.'$'.'.schema'
      res := _jm_obj_38(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = '' THEN
      -- handle may  property
      -- .'$Model#Root'.'|'.1.'$'.''
      res := json_model_4(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF _jm_re_3(prop, path, rep) THEN
      -- handle 1 re props
      -- .'$Model#Root'.'|'.1.'$'.'/.+/'
      res := json_model_19(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- object .'$Model#Root'.'|'.1.'%'.'.schema'
CREATE OR REPLACE FUNCTION _jm_obj_40(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  -- accept any object
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- object .'$Model#Root'.'|'.1.'%'
CREATE OR REPLACE FUNCTION _jm_obj_39(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
  arr_13_idx INT8;
  arr_13_item JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = '#' THEN
      -- handle may # property
      -- .'$Model#Root'.'|'.1.'%'.'#'
      res := JSONB_TYPEOF(pval) = 'string';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = '.schema' THEN
      -- handle may .schema property
      -- .'$Model#Root'.'|'.1.'%'.'.schema'
      res := _jm_obj_40(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = '<' THEN
      -- handle may < property
      -- .'$Model#Root'.'|'.1.'%'.'<'
      res := JSONB_TYPEOF(pval) = 'array';
      IF res THEN
        FOR arr_13_idx IN 0 .. JSONB_ARRAY_LENGTH(pval) - 1 LOOP
          arr_13_item := pval -> arr_13_idx;
          -- .'$Model#Root'.'|'.1.'%'.'<'.0
          -- "/^\\$/"
          res := JSONB_TYPEOF(arr_13_item) = 'string' AND _jm_re_4(JSON_VALUE(arr_13_item, '$' RETURNING TEXT), NULL, rep);
          IF NOT res THEN
            EXIT;
          END IF;
        END LOOP;
      END IF;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF _jm_re_5(prop, path, rep) THEN
      -- handle 2 re props
      -- .'$Model#Root'.'|'.1.'%'.'/^\\..+$/'
      -- "/^([#|&^+/*@~=$%]|[<>!]=?)$/"
      res := JSONB_TYPEOF(pval) = 'string' AND _jm_re_6(JSON_VALUE(pval, '$' RETURNING TEXT), NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF _jm_re_7(prop, path, rep) THEN
      -- handle 2 re props
      -- .'$Model#Root'.'|'.1.'%'.'/^\\$.*$/'
      res := json_model_17(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- object .'$Model#Root'.'|'.1.'.schema'
CREATE OR REPLACE FUNCTION _jm_obj_41(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  -- accept any object
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- object .'$Model#Root'.'|'.1
CREATE OR REPLACE FUNCTION _jm_obj_36(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  must_count int;
  prop TEXT;
  pval JSONB;
  arr_12_idx INT8;
  arr_12_item JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  must_count := 0;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = '|' THEN
      -- handle must | property
      must_count := must_count + 1;
      -- .'$Model#Root'.'|'.1.'|'
      res := JSONB_TYPEOF(pval) = 'array';
      IF res THEN
        FOR arr_12_idx IN 0 .. JSONB_ARRAY_LENGTH(pval) - 1 LOOP
          arr_12_item := pval -> arr_12_idx;
          -- .'$Model#Root'.'|'.1.'|'.0
          res := json_model_19(arr_12_item, NULL, rep);
          IF NOT res THEN
            EXIT;
          END IF;
        END LOOP;
      END IF;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = '~' THEN
      -- handle may ~ property
      -- .'$Model#Root'.'|'.1.'~'
      res := json_model_4(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = '$' THEN
      -- handle may $ property
      -- .'$Model#Root'.'|'.1.'$'
      res := _jm_obj_37(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = '%' THEN
      -- handle may % property
      -- .'$Model#Root'.'|'.1.'%'
      res := _jm_obj_39(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = '#' THEN
      -- handle may # property
      -- .'$Model#Root'.'|'.1.'#'
      res := JSONB_TYPEOF(pval) = 'string';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = '.schema' THEN
      -- handle may .schema property
      -- .'$Model#Root'.'|'.1.'.schema'
      res := _jm_obj_41(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  IF must_count <> 1 THEN
    RETURN FALSE;
  END IF;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_42_map_! (.'$Model#Root'.'|'.0.'!')
CREATE OR REPLACE FUNCTION _jm_f_0(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$Model#Root'.'|'.0.'!'
  res := JSONB_TYPEOF(val) = 'boolean';
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_42_map_# (.'$Model#Root'.'|'.0.'#')
CREATE OR REPLACE FUNCTION _jm_f_1(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$Model#Root'.'|'.0.'#'
  res := JSONB_TYPEOF(val) = 'string';
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- object .'$Model#Root'.'|'.0.'$'.'.schema'
CREATE OR REPLACE FUNCTION _jm_obj_44(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  -- accept any object
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- object .'$Model#Root'.'|'.0.'$'
CREATE OR REPLACE FUNCTION _jm_obj_43(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = '#' THEN
      -- handle may # property
      -- .'$Model#Root'.'|'.0.'$'.'#'
      res := JSONB_TYPEOF(pval) = 'string';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = '.schema' THEN
      -- handle may .schema property
      -- .'$Model#Root'.'|'.0.'$'.'.schema'
      res := _jm_obj_44(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = '' THEN
      -- handle may  property
      -- .'$Model#Root'.'|'.0.'$'.''
      res := json_model_4(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF _jm_re_3(prop, path, rep) THEN
      -- handle 1 re props
      -- .'$Model#Root'.'|'.0.'$'.'/.+/'
      res := json_model_19(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_42_map_$ (.'$Model#Root'.'|'.0.'$')
CREATE OR REPLACE FUNCTION _jm_f_2(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$Model#Root'.'|'.0.'$'
  res := _jm_obj_43(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- object .'$Model#Root'.'|'.0.'%'.'.schema'
CREATE OR REPLACE FUNCTION _jm_obj_46(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  -- accept any object
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- object .'$Model#Root'.'|'.0.'%'
CREATE OR REPLACE FUNCTION _jm_obj_45(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
  arr_14_idx INT8;
  arr_14_item JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = '#' THEN
      -- handle may # property
      -- .'$Model#Root'.'|'.0.'%'.'#'
      res := JSONB_TYPEOF(pval) = 'string';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = '.schema' THEN
      -- handle may .schema property
      -- .'$Model#Root'.'|'.0.'%'.'.schema'
      res := _jm_obj_46(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = '<' THEN
      -- handle may < property
      -- .'$Model#Root'.'|'.0.'%'.'<'
      res := JSONB_TYPEOF(pval) = 'array';
      IF res THEN
        FOR arr_14_idx IN 0 .. JSONB_ARRAY_LENGTH(pval) - 1 LOOP
          arr_14_item := pval -> arr_14_idx;
          -- .'$Model#Root'.'|'.0.'%'.'<'.0
          -- "/^\\$/"
          res := JSONB_TYPEOF(arr_14_item) = 'string' AND _jm_re_4(JSON_VALUE(arr_14_item, '$' RETURNING TEXT), NULL, rep);
          IF NOT res THEN
            EXIT;
          END IF;
        END LOOP;
      END IF;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF _jm_re_5(prop, path, rep) THEN
      -- handle 2 re props
      -- .'$Model#Root'.'|'.0.'%'.'/^\\..+$/'
      -- "/^([#|&^+/*@~=$%]|[<>!]=?)$/"
      res := JSONB_TYPEOF(pval) = 'string' AND _jm_re_6(JSON_VALUE(pval, '$' RETURNING TEXT), NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF _jm_re_7(prop, path, rep) THEN
      -- handle 2 re props
      -- .'$Model#Root'.'|'.0.'%'.'/^\\$.*$/'
      res := json_model_17(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_42_map_% (.'$Model#Root'.'|'.0.'%')
CREATE OR REPLACE FUNCTION _jm_f_3(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$Model#Root'.'|'.0.'%'
  res := _jm_obj_45(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_42_map_.in (.'$Model#Root'.'|'.0.'.in')
CREATE OR REPLACE FUNCTION _jm_f_4(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$Model#Root'.'|'.0.'.in'
  res := json_model_19(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_42_map_.mo (.'$Model#Root'.'|'.0.'.mo')
CREATE OR REPLACE FUNCTION _jm_f_5(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$Model#Root'.'|'.0.'.mo'
  res := JSONB_TYPEOF(val) = 'number' AND (val)::INT8 = (val)::FLOAT8 AND (val)::INT8 >= 1;
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- object .'$Model#Root'.'|'.0.'.schema'
CREATE OR REPLACE FUNCTION _jm_obj_47(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  -- accept any object
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_42_map_.schema (.'$Model#Root'.'|'.0.'.schema')
CREATE OR REPLACE FUNCTION _jm_f_6(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$Model#Root'.'|'.0.'.schema'
  res := _jm_obj_47(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check _jm_obj_42_map_~ (.'$Model#Root'.'|'.0.'~')
CREATE OR REPLACE FUNCTION _jm_f_7(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$Model#Root'.'|'.0.'~'
  res := json_model_4(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION _jm_obj_42_map(name TEXT)
RETURNS TEXT STRICT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  map JSONB := JSONB '{"!":"_jm_f_0","#":"_jm_f_1","$":"_jm_f_2","%":"_jm_f_3",".in":"_jm_f_4",".mo":"_jm_f_5",".schema":"_jm_f_6","~":"_jm_f_7"}';
BEGIN
  RETURN map->>name;
END;
$$ LANGUAGE plpgsql;

-- object .'$Model#Root'.'|'.0
CREATE OR REPLACE FUNCTION _jm_obj_42(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  pfun TEXT;
  must_count int;
  prop TEXT;
  pval JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  must_count := 0;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = '@' THEN
      -- handle must @ property
      must_count := must_count + 1;
      -- .'$Model#Root'.'|'.0.'@'
      res := json_model_19(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF _jm_obj_42_map(prop) IS NOT NULL THEN
      -- handle 8 may props
      pfun := _jm_obj_42_map(prop);
      IF NOT jm_call(pfun, pval, NULL, rep) THEN
        RETURN FALSE;
      END IF;
    ELSEIF _jm_re_1(prop, path, rep) THEN
      -- handle 2 re props
      -- .'$Model#Root'.'|'.0.'/^(<=|>=|<|>|≥|≤)$/'
      -- .'$Model#Root'.'|'.0.'/^(<=|>=|<|>|≥|≤)$/'.'|'.0
      res := JSONB_TYPEOF(pval) = 'number' AND (pval)::INT8 = (pval)::FLOAT8;
      IF NOT res THEN
        -- .'$Model#Root'.'|'.0.'/^(<=|>=|<|>|≥|≤)$/'.'|'.1
        res := JSONB_TYPEOF(pval) = 'number';
        IF NOT res THEN
          -- .'$Model#Root'.'|'.0.'/^(<=|>=|<|>|≥|≤)$/'.'|'.2
          res := JSONB_TYPEOF(pval) = 'string';
        END IF;
      END IF;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF _jm_re_2(prop, path, rep) THEN
      -- handle 2 re props
      -- .'$Model#Root'.'|'.0.'/^(=|!=|≠)$/'
      res := json_model_5(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  IF must_count <> 1 THEN
    RETURN FALSE;
  END IF;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check $Model#Root (.'$Model#Root')
CREATE OR REPLACE FUNCTION json_model_24(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$Model#Root'
  res := JSONB_TYPEOF(val) = 'object';
  IF res THEN
    -- .'$Model#Root'.'|'.0
    res := _jm_obj_42(val, path, rep);
    IF NOT res THEN
      -- .'$Model#Root'.'|'.1
      res := _jm_obj_36(val, path, rep);
      IF NOT res THEN
        -- .'$Model#Root'.'|'.2
        res := _jm_obj_30(val, path, rep);
        IF NOT res THEN
          -- .'$Model#Root'.'|'.3
          res := _jm_obj_24(val, path, rep);
          IF NOT res THEN
            -- .'$Model#Root'.'|'.4
            res := _jm_obj_18(val, path, rep);
            IF NOT res THEN
              -- .'$Model#Root'.'|'.5
              res := _jm_obj_12(val, path, rep);
            END IF;
          END IF;
        END IF;
      END IF;
    END IF;
  END IF;
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- regex=^((file|https?)://.+|\./.*|\.\./.*)$ opts=n
CREATE OR REPLACE FUNCTION _jm_re_8(val TEXT, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  RETURN regexp_like(val, '^((file|https?)://.+|\./.*|\.\./.*)$', 'n');
END;
$$ LANGUAGE plpgsql;

-- check $Model#Url (.'$Model#Url')
CREATE OR REPLACE FUNCTION json_model_4(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$Model#Url'
  -- "/^((file|https?)://.+|\\./.*|\\.\\./.*)$/"
  res := JSONB_TYPEOF(val) = 'string' AND _jm_re_8(JSON_VALUE(val, '$' RETURNING TEXT), path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- object .'$Model#Trafo'.'|'.2.'*'.'|'.1
CREATE OR REPLACE FUNCTION _jm_obj_49(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    -- handle other props
    -- .'$Model#Trafo'.'|'.2.'*'.'|'.1.''
    res := json_model_19(pval, NULL, rep);
    IF NOT res THEN
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- object .'$Model#Trafo'.'|'.2.'.schema'
CREATE OR REPLACE FUNCTION _jm_obj_50(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  -- accept any object
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- object .'$Model#Trafo'.'|'.2
CREATE OR REPLACE FUNCTION _jm_obj_48(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  must_count int;
  prop TEXT;
  pval JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  must_count := 0;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = '*' THEN
      -- handle must * property
      must_count := must_count + 1;
      -- .'$Model#Trafo'.'|'.2.'*'
      -- .'$Model#Trafo'.'|'.2.'*'.'|'.0
      res := JSONB_TYPEOF(pval) = 'array';
      IF res THEN
        -- accept any array
        NULL;
      END IF;
      IF NOT res THEN
        -- .'$Model#Trafo'.'|'.2.'*'.'|'.1
        res := _jm_obj_49(pval, NULL, rep);
      END IF;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = '#' THEN
      -- handle may # property
      -- .'$Model#Trafo'.'|'.2.'#'
      res := JSONB_TYPEOF(pval) = 'string';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = '.schema' THEN
      -- handle may .schema property
      -- .'$Model#Trafo'.'|'.2.'.schema'
      res := _jm_obj_50(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = '/' THEN
      -- handle may / property
      -- .'$Model#Trafo'.'|'.2.'/'
      res := TRUE;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  IF must_count <> 1 THEN
    RETURN FALSE;
  END IF;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- object .'$Model#Trafo'.'|'.1.'.schema'
CREATE OR REPLACE FUNCTION _jm_obj_52(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  -- accept any object
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- object .'$Model#Trafo'.'|'.1.'*'.'|'.1
CREATE OR REPLACE FUNCTION _jm_obj_53(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    -- handle other props
    -- .'$Model#Trafo'.'|'.1.'*'.'|'.1.''
    res := json_model_19(pval, NULL, rep);
    IF NOT res THEN
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- object .'$Model#Trafo'.'|'.1
CREATE OR REPLACE FUNCTION _jm_obj_51(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  must_count int;
  prop TEXT;
  pval JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  must_count := 0;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = '/' THEN
      -- handle must / property
      must_count := must_count + 1;
      -- .'$Model#Trafo'.'|'.1.'/'
      res := TRUE;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = '#' THEN
      -- handle may # property
      -- .'$Model#Trafo'.'|'.1.'#'
      res := JSONB_TYPEOF(pval) = 'string';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = '.schema' THEN
      -- handle may .schema property
      -- .'$Model#Trafo'.'|'.1.'.schema'
      res := _jm_obj_52(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = '*' THEN
      -- handle may * property
      -- .'$Model#Trafo'.'|'.1.'*'
      -- .'$Model#Trafo'.'|'.1.'*'.'|'.0
      res := JSONB_TYPEOF(pval) = 'array';
      IF res THEN
        -- accept any array
        NULL;
      END IF;
      IF NOT res THEN
        -- .'$Model#Trafo'.'|'.1.'*'.'|'.1
        res := _jm_obj_53(pval, NULL, rep);
      END IF;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  IF must_count <> 1 THEN
    RETURN FALSE;
  END IF;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check $Model#Trafo (.'$Model#Trafo')
CREATE OR REPLACE FUNCTION json_model_17(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$Model#Trafo'
  -- .'$Model#Trafo'.'|'.0
  res := json_model_19(val, path, rep);
  IF NOT res THEN
    -- .'$Model#Trafo'.'|'.1
    res := _jm_obj_51(val, path, rep);
    IF NOT res THEN
      -- .'$Model#Trafo'.'|'.2
      res := _jm_obj_48(val, path, rep);
    END IF;
  END IF;
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION check_model_map(name TEXT)
RETURNS TEXT STRICT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  map JSONB := JSONB '{"":"json_model_1","Model":"json_model_3"}';
BEGIN
  RETURN map->>name;
END;
$$ LANGUAGE plpgsql;

--
-- constant maps initialization
--
TRUNCATE jm_constant_maps;


--
-- JSON Model checking entry point
--
-- TODO INOUT rep?
CREATE OR REPLACE FUNCTION check_model(val JSONB, name TEXT, rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  fun TEXT;
BEGIN
  fun := check_model_map(name);
  IF fun IS NULL THEN
    RAISE EXCEPTION 'model for % not found', name;
  END IF;
  RETURN jm_call(fun, val, NULL, rep);
END;
$$ LANGUAGE plpgsql;
