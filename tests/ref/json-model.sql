--
-- Generated by JSON Model Compiler version 2
-- see https://github.com/clairey-zx81/json-model
--
-- JSON_MODEL_VERSION is 2
CREATE EXTENSION IF NOT EXISTS json_model;

-- regex=^((file|https?)://.+|\./.*|\.\./.*)$ opts=n
CREATE OR REPLACE FUNCTION _jm_re_0(val TEXT, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  RETURN regexp_like(val, '^((file|https?)://.+|\./.*|\.\./.*)$', 'n');
END;
$$ LANGUAGE plpgsql;

-- check $Url (.'$Url')
CREATE OR REPLACE FUNCTION json_model_2(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$Url'
  -- "/^((file|https?)://.+|\\./.*|\\.\\./.*)$/"
  res := JSONB_TYPEOF(val) = 'string' AND _jm_re_0(JSON_VALUE(val, '$' RETURNING TEXT), path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION _jm_cst_0(value JSONB)
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  constants JSONB = JSONB '["$DATE","$TIME","$DATETIME","$URL","$URI","$UUID","$EMAIL","$REGEX","$EXREG","$NULL","$BOOL","$FLOAT","$F16","$F32","$F64","$NUMBER","$INT","$INTEGER","$I8","$I16","$I32","$I64","$U8","$U16","$U32","$U64","$STRING","$NONE","$ANY"]';
BEGIN
  RETURN constants @> value;
END;
$$ LANGUAGE plpgsql;

-- check $PreDef (.'$PreDef')
CREATE OR REPLACE FUNCTION json_model_3(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$PreDef'
  res := JSONB_TYPEOF(val) IN ('null', 'boolean', 'number', 'string') AND _jm_cst_0(val);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- regex=[^A-Z0-9] opts=n
CREATE OR REPLACE FUNCTION _jm_re_1(val TEXT, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  RETURN regexp_like(val, '[^A-Z0-9]', 'n');
END;
$$ LANGUAGE plpgsql;

-- regex=^\w+$ opts=n
CREATE OR REPLACE FUNCTION _jm_re_2(val TEXT, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  RETURN regexp_like(val, '^\w+$', 'n');
END;
$$ LANGUAGE plpgsql;

-- check $Identifier (.'$Identifier')
CREATE OR REPLACE FUNCTION json_model_4(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$Identifier'
  res := JSONB_TYPEOF(val) = 'string';
  IF res THEN
    -- .'$Identifier'.'&'.0
    -- "/^\\w+$/"
    res := _jm_re_2(JSON_VALUE(val, '$' RETURNING TEXT), path, rep);
    IF res THEN
      -- .'$Identifier'.'&'.1
      -- "/[^A-Z0-9]/"
      res := _jm_re_1(JSON_VALUE(val, '$' RETURNING TEXT), path, rep);
    END IF;
  END IF;
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check $ArrayComment (.'$ArrayComment')
CREATE OR REPLACE FUNCTION json_model_5(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$ArrayComment'
  -- "/^#/"
  res := JSONB_TYPEOF(val) = 'string' AND STARTS_WITH(JSON_VALUE(val, '$' RETURNING TEXT), '#');
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- object .'$ObjectComment'
CREATE OR REPLACE FUNCTION _jm_obj_0(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = '#' THEN
      -- handle may # property
      -- .'$ObjectComment'.'#'
      res := JSONB_TYPEOF(pval) = 'string';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF STARTS_WITH(prop, '#') THEN
      -- handle 1 re props
      -- .'$ObjectComment'.'/^#/'
      res := TRUE;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check $ObjectComment (.'$ObjectComment')
CREATE OR REPLACE FUNCTION json_model_6(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$ObjectComment'
  res := _jm_obj_0(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- regex=^\$. opts=n
CREATE OR REPLACE FUNCTION _jm_re_3(val TEXT, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  RETURN regexp_like(val, '^\$.', 'n');
END;
$$ LANGUAGE plpgsql;

-- check $Ref (.'$Ref')
CREATE OR REPLACE FUNCTION json_model_7(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$Ref'
  -- "/^\\$./"
  res := JSONB_TYPEOF(val) = 'string' AND _jm_re_3(JSON_VALUE(val, '$' RETURNING TEXT), path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- regex=^=(null|true|false|[-+]?\d+(\.\d+)?([Ee][-+]?\d+)?)$ opts=n
CREATE OR REPLACE FUNCTION _jm_re_4(val TEXT, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  RETURN regexp_like(val, '^=(null|true|false|[-+]?\d+(\.\d+)?([Ee][-+]?\d+)?)$', 'n');
END;
$$ LANGUAGE plpgsql;

-- check $ValConst (.'$ValConst')
CREATE OR REPLACE FUNCTION json_model_8(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$ValConst'
  -- "/^=(null|true|false|[-+]?\\d+(\\.\\d+)?([Ee][-+]?\\d+)?)$/"
  res := JSONB_TYPEOF(val) = 'string' AND _jm_re_4(JSON_VALUE(val, '$' RETURNING TEXT), path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- regex=^[A-Za-z0-9_] opts=n
CREATE OR REPLACE FUNCTION _jm_re_5(val TEXT, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  RETURN regexp_like(val, '^[A-Za-z0-9_]', 'n');
END;
$$ LANGUAGE plpgsql;

-- check $StrConst (.'$StrConst')
CREATE OR REPLACE FUNCTION json_model_9(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$StrConst'
  -- "/^[A-Za-z0-9_]/"
  res := JSONB_TYPEOF(val) = 'string' AND _jm_re_5(JSON_VALUE(val, '$' RETURNING TEXT), path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- regex=^/(.*)/[a-z]*$ opts=n
CREATE OR REPLACE FUNCTION _jm_xre_0_re(val TEXT, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  RETURN regexp_like(val, '^/(.*)/[a-z]*$', 'n');
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION _jm_xre_0(val TEXT, path TEXT[], rep jm_report_entry[])
RETURNS BOOL CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  extract TEXT;
  match TEXT[];
BEGIN
  match := regexp_match(val, '^/(.*)/[a-z]*$', 'n');
  IF match IS NULL THEN
    RETURN FALSE;
  END IF;
  extract := match[1];
  IF NOT jm_is_valid_regex(extract, path, rep) THEN
    RETURN FALSE;
  END IF;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- regex=^/(.*)/[a-z]*X[a-z]*$ opts=n
CREATE OR REPLACE FUNCTION _jm_xre_1_re(val TEXT, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  RETURN regexp_like(val, '^/(.*)/[a-z]*X[a-z]*$', 'n');
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION _jm_xre_1(val TEXT, path TEXT[], rep jm_report_entry[])
RETURNS BOOL CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  extract TEXT;
  match TEXT[];
BEGIN
  match := regexp_match(val, '^/(.*)/[a-z]*X[a-z]*$', 'n');
  IF match IS NULL THEN
    RETURN FALSE;
  END IF;
  extract := match[1];
  IF NOT jm_is_valid_extreg(extract, path, rep) THEN
    RETURN FALSE;
  END IF;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check $Regex (.'$Regex')
CREATE OR REPLACE FUNCTION json_model_10(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$Regex'
  res := JSONB_TYPEOF(val) = 'string';
  IF res THEN
    -- .'$Regex'.'|'.0
    -- "/^/($EXREG)/[a-z]*X[a-z]*$/X"
    res := _jm_xre_1(JSON_VALUE(val, '$' RETURNING TEXT), path, rep);
    IF NOT res THEN
      -- .'$Regex'.'|'.1
      -- "/^/($REGEX)/[a-z]*$/X"
      res := _jm_xre_0(JSON_VALUE(val, '$' RETURNING TEXT), path, rep);
    END IF;
  END IF;
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- regex=^\..+$ opts=n
CREATE OR REPLACE FUNCTION _jm_re_6(val TEXT, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  RETURN regexp_like(val, '^\..+$', 'n');
END;
$$ LANGUAGE plpgsql;

-- check $Name (.'$Name')
CREATE OR REPLACE FUNCTION json_model_11(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$Name'
  -- "/^\\..+$/"
  res := JSONB_TYPEOF(val) = 'string' AND _jm_re_6(JSON_VALUE(val, '$' RETURNING TEXT), path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check $CmpValue (.'$CmpValue')
CREATE OR REPLACE FUNCTION json_model_12(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$CmpValue'
  -- .'$CmpValue'.'|'.0
  res := JSONB_TYPEOF(val) = 'number' AND (val)::INT8 = (val)::FLOAT8;
  IF NOT res THEN
    -- .'$CmpValue'.'|'.1
    res := JSONB_TYPEOF(val) = 'number';
    IF NOT res THEN
      -- .'$CmpValue'.'|'.2
      res := JSONB_TYPEOF(val) = 'string';
    END IF;
  END IF;
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check $EqValue (.'$EqValue')
CREATE OR REPLACE FUNCTION json_model_13(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$EqValue'
  -- .'$EqValue'.'|'.0
  res := JSONB_TYPEOF(val) = 'null';
  IF NOT res THEN
    -- .'$EqValue'.'|'.1
    res := JSONB_TYPEOF(val) = 'boolean';
    IF NOT res THEN
      -- .'$EqValue'.'|'.2
      res := JSONB_TYPEOF(val) = 'number' AND (val)::INT8 = (val)::FLOAT8;
      IF NOT res THEN
        -- .'$EqValue'.'|'.3
        res := JSONB_TYPEOF(val) = 'number';
        IF NOT res THEN
          -- .'$EqValue'.'|'.4
          res := JSONB_TYPEOF(val) = 'string';
        END IF;
      END IF;
    END IF;
  END IF;
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION _jm_cst_1(value JSONB)
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  constants JSONB = JSONB '[null,true,0,1,-1,0.0,1.0,-1.0]';
BEGIN
  RETURN constants @> value;
END;
$$ LANGUAGE plpgsql;

-- check $ValModel (.'$ValModel')
CREATE OR REPLACE FUNCTION json_model_14(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$ValModel'
  res := JSONB_TYPEOF(val) IN ('null', 'boolean', 'number', 'string') AND _jm_cst_1(val);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION _jm_cst_2(value JSONB)
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  constants JSONB = JSONB '["$DATE","$TIME","$DATETIME","$URL","$URI","$UUID","$EMAIL","$REGEX","$EXREG","$NULL","$BOOL","$FLOAT","$F16","$F32","$F64","$NUMBER","$INT","$INTEGER","$I8","$I16","$I32","$I64","$U8","$U16","$U32","$U64","$STRING","$NONE","$ANY",""]';
BEGIN
  RETURN constants @> value;
END;
$$ LANGUAGE plpgsql;

-- check $StrModel (.'$StrModel')
CREATE OR REPLACE FUNCTION json_model_15(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$StrModel'
  res := JSONB_TYPEOF(val) IN ('null', 'boolean', 'number', 'string') AND _jm_cst_2(val);
  IF NOT res THEN
    -- .'$StrModel'.'|'.0
    res := json_model_9(val, path, rep);
    IF NOT res THEN
      -- .'$StrModel'.'|'.1
      res := json_model_8(val, path, rep);
      IF NOT res THEN
        -- .'$StrModel'.'|'.2
        -- "/^/($EXREG)/[a-z]*X[a-z]*$/X"
        res := JSONB_TYPEOF(val) = 'string' AND _jm_xre_1(JSON_VALUE(val, '$' RETURNING TEXT), path, rep);
        IF NOT res THEN
          -- .'$StrModel'.'|'.3
          -- "/^/($REGEX)/[a-z]*$/X"
          res := JSONB_TYPEOF(val) = 'string' AND _jm_xre_0(JSON_VALUE(val, '$' RETURNING TEXT), path, rep);
          IF NOT res THEN
            -- .'$StrModel'.'|'.4
            res := json_model_7(val, path, rep);
          END IF;
        END IF;
      END IF;
    END IF;
  END IF;
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check $Any (.'$Any')
CREATE OR REPLACE FUNCTION json_model_16(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$Any'
  res := TRUE;
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check $None (.'$None')
CREATE OR REPLACE FUNCTION json_model_17(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$None'
  res := FALSE;
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- object .'$Array'.0.'|'.5
CREATE OR REPLACE FUNCTION _jm_obj_1(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = '#' THEN
      -- handle may # property
      -- .'$Array'.0.'|'.5.'#'
      res := JSONB_TYPEOF(pval) = 'string';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF json_model_25(TO_JSONB(prop), NULL, rep) THEN
      -- handle 1 key props
      -- .'$Array'.0.'|'.5.'$Prop'
      res := json_model_32(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF STARTS_WITH(prop, '#') THEN
      -- handle 1 re props
      -- .'$Array'.0.'|'.5.'/^#/'
      res := TRUE;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- object .'$Array'.0.'|'.4
CREATE OR REPLACE FUNCTION _jm_obj_2(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  must_count int;
  prop TEXT;
  pval JSONB;
  arr_1_idx INT8;
  arr_1_item JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  must_count := 0;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = '+' THEN
      -- handle must + property
      must_count := must_count + 1;
      -- .'$Array'.0.'|'.4.'+'
      res := JSONB_TYPEOF(pval) = 'array';
      IF res THEN
        FOR arr_1_idx IN 0 .. JSONB_ARRAY_LENGTH(pval) - 1 LOOP
          arr_1_item := pval -> arr_1_idx;
          -- .'$Array'.0.'|'.4.'+'.0
          res := json_model_32(arr_1_item, NULL, rep);
          IF NOT res THEN
            EXIT;
          END IF;
        END LOOP;
      END IF;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = '#' THEN
      -- handle may # property
      -- .'$Array'.0.'|'.4.'#'
      res := JSONB_TYPEOF(pval) = 'string';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF STARTS_WITH(prop, '#') THEN
      -- handle 1 re props
      -- .'$Array'.0.'|'.4.'/^#/'
      res := TRUE;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  IF must_count <> 1 THEN
    RETURN FALSE;
  END IF;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- object .'$Array'.0.'|'.3
CREATE OR REPLACE FUNCTION _jm_obj_3(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  must_count int;
  prop TEXT;
  pval JSONB;
  arr_2_idx INT8;
  arr_2_item JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  must_count := 0;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = '^' THEN
      -- handle must ^ property
      must_count := must_count + 1;
      -- .'$Array'.0.'|'.3.'^'
      res := JSONB_TYPEOF(pval) = 'array';
      IF res THEN
        FOR arr_2_idx IN 0 .. JSONB_ARRAY_LENGTH(pval) - 1 LOOP
          arr_2_item := pval -> arr_2_idx;
          -- .'$Array'.0.'|'.3.'^'.0
          res := json_model_32(arr_2_item, NULL, rep);
          IF NOT res THEN
            EXIT;
          END IF;
        END LOOP;
      END IF;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = '#' THEN
      -- handle may # property
      -- .'$Array'.0.'|'.3.'#'
      res := JSONB_TYPEOF(pval) = 'string';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF STARTS_WITH(prop, '#') THEN
      -- handle 1 re props
      -- .'$Array'.0.'|'.3.'/^#/'
      res := TRUE;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  IF must_count <> 1 THEN
    RETURN FALSE;
  END IF;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- object .'$Array'.0.'|'.2
CREATE OR REPLACE FUNCTION _jm_obj_4(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  must_count int;
  prop TEXT;
  pval JSONB;
  arr_3_idx INT8;
  arr_3_item JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  must_count := 0;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = '&' THEN
      -- handle must & property
      must_count := must_count + 1;
      -- .'$Array'.0.'|'.2.'&'
      res := JSONB_TYPEOF(pval) = 'array';
      IF res THEN
        FOR arr_3_idx IN 0 .. JSONB_ARRAY_LENGTH(pval) - 1 LOOP
          arr_3_item := pval -> arr_3_idx;
          -- .'$Array'.0.'|'.2.'&'.0
          res := json_model_32(arr_3_item, NULL, rep);
          IF NOT res THEN
            EXIT;
          END IF;
        END LOOP;
      END IF;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = '#' THEN
      -- handle may # property
      -- .'$Array'.0.'|'.2.'#'
      res := JSONB_TYPEOF(pval) = 'string';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF STARTS_WITH(prop, '#') THEN
      -- handle 1 re props
      -- .'$Array'.0.'|'.2.'/^#/'
      res := TRUE;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  IF must_count <> 1 THEN
    RETURN FALSE;
  END IF;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- object .'$Array'.0.'|'.1
CREATE OR REPLACE FUNCTION _jm_obj_5(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  must_count int;
  prop TEXT;
  pval JSONB;
  arr_4_idx INT8;
  arr_4_item JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  must_count := 0;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = '|' THEN
      -- handle must | property
      must_count := must_count + 1;
      -- .'$Array'.0.'|'.1.'|'
      res := JSONB_TYPEOF(pval) = 'array';
      IF res THEN
        FOR arr_4_idx IN 0 .. JSONB_ARRAY_LENGTH(pval) - 1 LOOP
          arr_4_item := pval -> arr_4_idx;
          -- .'$Array'.0.'|'.1.'|'.0
          res := json_model_32(arr_4_item, NULL, rep);
          IF NOT res THEN
            EXIT;
          END IF;
        END LOOP;
      END IF;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = '#' THEN
      -- handle may # property
      -- .'$Array'.0.'|'.1.'#'
      res := JSONB_TYPEOF(pval) = 'string';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF STARTS_WITH(prop, '#') THEN
      -- handle 1 re props
      -- .'$Array'.0.'|'.1.'/^#/'
      res := TRUE;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  IF must_count <> 1 THEN
    RETURN FALSE;
  END IF;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- regex=^(<=|>=|<|>)$ opts=n
CREATE OR REPLACE FUNCTION _jm_re_7(val TEXT, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  RETURN regexp_like(val, '^(<=|>=|<|>)$', 'n');
END;
$$ LANGUAGE plpgsql;

-- regex=^(=|!=)$ opts=n
CREATE OR REPLACE FUNCTION _jm_re_8(val TEXT, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  RETURN regexp_like(val, '^(=|!=)$', 'n');
END;
$$ LANGUAGE plpgsql;

-- object .'$Array'.0.'|'.0
CREATE OR REPLACE FUNCTION _jm_obj_6(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  must_count int;
  prop TEXT;
  pval JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  must_count := 0;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = '@' THEN
      -- handle must @ property
      must_count := must_count + 1;
      -- .'$Array'.0.'|'.0.'@'
      res := json_model_32(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = '#' THEN
      -- handle may # property
      -- .'$Array'.0.'|'.0.'#'
      res := JSONB_TYPEOF(pval) = 'string';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = '!' THEN
      -- handle may ! property
      -- .'$Array'.0.'|'.0.'!'
      res := JSONB_TYPEOF(pval) = 'boolean';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF STARTS_WITH(prop, '#') THEN
      -- handle 3 re props
      -- .'$Array'.0.'|'.0.'/^#/'
      res := TRUE;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF _jm_re_7(prop, path, rep) THEN
      -- handle 3 re props
      -- .'$Array'.0.'|'.0.'/^(<=|>=|<|>)$/'
      res := json_model_12(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF _jm_re_8(prop, path, rep) THEN
      -- handle 3 re props
      -- .'$Array'.0.'|'.0.'/^(=|!=)$/'
      res := json_model_13(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  IF must_count <> 1 THEN
    RETURN FALSE;
  END IF;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION _jm_cst_3(value JSONB)
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  constants JSONB = JSONB '[null,true,0,1,-1,0.0,1.0,-1.0,"$DATE","$TIME","$DATETIME","$URL","$URI","$UUID","$EMAIL","$REGEX","$EXREG","$NULL","$BOOL","$FLOAT","$F16","$F32","$F64","$NUMBER","$INT","$INTEGER","$I8","$I16","$I32","$I64","$U8","$U16","$U32","$U64","$STRING","$NONE","$ANY",""]';
BEGIN
  RETURN constants @> value;
END;
$$ LANGUAGE plpgsql;

-- check $Array (.'$Array')
CREATE OR REPLACE FUNCTION json_model_18(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  arr_0_idx INT8;
  arr_0_item JSONB;
BEGIN
  -- .'$Array'
  res := JSONB_TYPEOF(val) = 'array';
  IF res THEN
    FOR arr_0_idx IN 0 .. JSONB_ARRAY_LENGTH(val) - 1 LOOP
      arr_0_item := val -> arr_0_idx;
      -- .'$Array'.0
      res := JSONB_TYPEOF(arr_0_item) = 'object';
      IF res THEN
        -- .'$Array'.0.'|'.0
        res := _jm_obj_6(arr_0_item, NULL, rep);
        IF NOT res THEN
          -- .'$Array'.0.'|'.1
          res := _jm_obj_5(arr_0_item, NULL, rep);
          IF NOT res THEN
            -- .'$Array'.0.'|'.2
            res := _jm_obj_4(arr_0_item, NULL, rep);
            IF NOT res THEN
              -- .'$Array'.0.'|'.3
              res := _jm_obj_3(arr_0_item, NULL, rep);
              IF NOT res THEN
                -- .'$Array'.0.'|'.4
                res := _jm_obj_2(arr_0_item, NULL, rep);
                IF NOT res THEN
                  -- .'$Array'.0.'|'.5
                  res := _jm_obj_1(arr_0_item, NULL, rep);
                END IF;
              END IF;
            END IF;
          END IF;
        END IF;
      END IF;
      IF NOT res THEN
        res := JSONB_TYPEOF(arr_0_item) IN ('null', 'boolean', 'number', 'string') AND _jm_cst_3(arr_0_item);
        IF NOT res THEN
          -- .'$Array'.0.'|'.0
          res := json_model_9(arr_0_item, NULL, rep);
          IF NOT res THEN
            -- .'$Array'.0.'|'.1
            res := json_model_8(arr_0_item, NULL, rep);
            IF NOT res THEN
              -- .'$Array'.0.'|'.2
              -- "/^/($EXREG)/[a-z]*X[a-z]*$/X"
              res := JSONB_TYPEOF(arr_0_item) = 'string' AND _jm_xre_1(JSON_VALUE(arr_0_item, '$' RETURNING TEXT), NULL, rep);
              IF NOT res THEN
                -- .'$Array'.0.'|'.3
                -- "/^/($REGEX)/[a-z]*$/X"
                res := JSONB_TYPEOF(arr_0_item) = 'string' AND _jm_xre_0(JSON_VALUE(arr_0_item, '$' RETURNING TEXT), NULL, rep);
                IF NOT res THEN
                  -- .'$Array'.0.'|'.4
                  res := json_model_7(arr_0_item, NULL, rep);
                  IF NOT res THEN
                    -- .'$Array'.0.'|'.5
                    res := json_model_18(arr_0_item, NULL, rep);
                    IF NOT res THEN
                      -- .'$Array'.0.'|'.6
                      res := json_model_5(arr_0_item, NULL, rep);
                    END IF;
                  END IF;
                END IF;
              END IF;
            END IF;
          END IF;
        END IF;
      END IF;
      IF NOT res THEN
        EXIT;
      END IF;
    END LOOP;
  END IF;
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check $Common (.'$Common')
CREATE OR REPLACE FUNCTION json_model_19(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$Common'
  res := json_model_6(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- object .'$Constraint'
CREATE OR REPLACE FUNCTION _jm_obj_7(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  must_count int;
  prop TEXT;
  pval JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  must_count := 0;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = '@' THEN
      -- handle must @ property
      must_count := must_count + 1;
      -- .'$Constraint'.'@'
      res := json_model_32(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = '!' THEN
      -- handle may ! property
      -- .'$Constraint'.'!'
      res := JSONB_TYPEOF(pval) = 'boolean';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF _jm_re_7(prop, path, rep) THEN
      -- handle 2 re props
      -- .'$Constraint'.'/^(<=|>=|<|>)$/'
      res := json_model_12(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF _jm_re_8(prop, path, rep) THEN
      -- handle 2 re props
      -- .'$Constraint'.'/^(=|!=)$/'
      res := json_model_13(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  IF must_count <> 1 THEN
    RETURN FALSE;
  END IF;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check $Constraint (.'$Constraint')
CREATE OR REPLACE FUNCTION json_model_20(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$Constraint'
  res := _jm_obj_7(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- object .'$Or'
CREATE OR REPLACE FUNCTION _jm_obj_8(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  must_count int;
  prop TEXT;
  pval JSONB;
  arr_5_idx INT8;
  arr_5_item JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  must_count := 0;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = '|' THEN
      -- handle must | property
      must_count := must_count + 1;
      -- .'$Or'.'|'
      res := JSONB_TYPEOF(pval) = 'array';
      IF res THEN
        FOR arr_5_idx IN 0 .. JSONB_ARRAY_LENGTH(pval) - 1 LOOP
          arr_5_item := pval -> arr_5_idx;
          -- .'$Or'.'|'.0
          res := json_model_32(arr_5_item, NULL, rep);
          IF NOT res THEN
            EXIT;
          END IF;
        END LOOP;
      END IF;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  IF must_count <> 1 THEN
    RETURN FALSE;
  END IF;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check $Or (.'$Or')
CREATE OR REPLACE FUNCTION json_model_21(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$Or'
  res := _jm_obj_8(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- object .'$And'
CREATE OR REPLACE FUNCTION _jm_obj_9(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  must_count int;
  prop TEXT;
  pval JSONB;
  arr_6_idx INT8;
  arr_6_item JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  must_count := 0;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = '&' THEN
      -- handle must & property
      must_count := must_count + 1;
      -- .'$And'.'&'
      res := JSONB_TYPEOF(pval) = 'array';
      IF res THEN
        FOR arr_6_idx IN 0 .. JSONB_ARRAY_LENGTH(pval) - 1 LOOP
          arr_6_item := pval -> arr_6_idx;
          -- .'$And'.'&'.0
          res := json_model_32(arr_6_item, NULL, rep);
          IF NOT res THEN
            EXIT;
          END IF;
        END LOOP;
      END IF;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  IF must_count <> 1 THEN
    RETURN FALSE;
  END IF;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check $And (.'$And')
CREATE OR REPLACE FUNCTION json_model_22(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$And'
  res := _jm_obj_9(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- object .'$Xor'
CREATE OR REPLACE FUNCTION _jm_obj_10(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  must_count int;
  prop TEXT;
  pval JSONB;
  arr_7_idx INT8;
  arr_7_item JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  must_count := 0;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = '^' THEN
      -- handle must ^ property
      must_count := must_count + 1;
      -- .'$Xor'.'^'
      res := JSONB_TYPEOF(pval) = 'array';
      IF res THEN
        FOR arr_7_idx IN 0 .. JSONB_ARRAY_LENGTH(pval) - 1 LOOP
          arr_7_item := pval -> arr_7_idx;
          -- .'$Xor'.'^'.0
          res := json_model_32(arr_7_item, NULL, rep);
          IF NOT res THEN
            EXIT;
          END IF;
        END LOOP;
      END IF;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  IF must_count <> 1 THEN
    RETURN FALSE;
  END IF;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check $Xor (.'$Xor')
CREATE OR REPLACE FUNCTION json_model_23(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$Xor'
  res := _jm_obj_10(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- object .'$Add'
CREATE OR REPLACE FUNCTION _jm_obj_11(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  must_count int;
  prop TEXT;
  pval JSONB;
  arr_8_idx INT8;
  arr_8_item JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  must_count := 0;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = '+' THEN
      -- handle must + property
      must_count := must_count + 1;
      -- .'$Add'.'+'
      res := JSONB_TYPEOF(pval) = 'array';
      IF res THEN
        FOR arr_8_idx IN 0 .. JSONB_ARRAY_LENGTH(pval) - 1 LOOP
          arr_8_item := pval -> arr_8_idx;
          -- .'$Add'.'+'.0
          res := json_model_32(arr_8_item, NULL, rep);
          IF NOT res THEN
            EXIT;
          END IF;
        END LOOP;
      END IF;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  IF must_count <> 1 THEN
    RETURN FALSE;
  END IF;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check $Add (.'$Add')
CREATE OR REPLACE FUNCTION json_model_24(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$Add'
  res := _jm_obj_11(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- regex=^[?!] opts=n
CREATE OR REPLACE FUNCTION _jm_re_9(val TEXT, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  RETURN regexp_like(val, '^[?!]', 'n');
END;
$$ LANGUAGE plpgsql;

-- check $Prop (.'$Prop')
CREATE OR REPLACE FUNCTION json_model_25(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$Prop'
  -- .'$Prop'.'|'.0
  -- "/^[?!]/"
  res := JSONB_TYPEOF(val) = 'string' AND _jm_re_9(JSON_VALUE(val, '$' RETURNING TEXT), path, rep);
  IF NOT res THEN
    -- .'$Prop'.'|'.1
    res := json_model_9(val, path, rep);
    IF NOT res THEN
      -- .'$Prop'.'|'.2
      -- "/^/($EXREG)/[a-z]*X[a-z]*$/X"
      res := JSONB_TYPEOF(val) = 'string' AND _jm_xre_1(JSON_VALUE(val, '$' RETURNING TEXT), path, rep);
      IF NOT res THEN
        -- .'$Prop'.'|'.3
        -- "/^/($REGEX)/[a-z]*$/X"
        res := JSONB_TYPEOF(val) = 'string' AND _jm_xre_0(JSON_VALUE(val, '$' RETURNING TEXT), path, rep);
        IF NOT res THEN
          -- .'$Prop'.'|'.4
          res := json_model_7(val, path, rep);
          IF NOT res THEN
            -- .'$Prop'.'|'.5
            res := json_model_11(val, path, rep);
            IF NOT res THEN
              -- .'$Prop'.'|'.6
              res := JSONB_TYPEOF(val) = 'string' AND JSON_VALUE(val, '$' RETURNING TEXT) = '';
            END IF;
          END IF;
        END IF;
      END IF;
    END IF;
  END IF;
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- object .'$Obj'
CREATE OR REPLACE FUNCTION _jm_obj_12(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF json_model_25(TO_JSONB(prop), NULL, rep) THEN
      -- handle 1 key props
      -- .'$Obj'.'$Prop'
      res := json_model_32(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check $Obj (.'$Obj')
CREATE OR REPLACE FUNCTION json_model_26(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$Obj'
  res := _jm_obj_12(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check $Elem (.'$Elem')
CREATE OR REPLACE FUNCTION json_model_27(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$Elem'
  -- .'$Elem'.'|'.0
  res := json_model_20(val, path, rep);
  IF NOT res THEN
    -- .'$Elem'.'|'.1
    res := json_model_21(val, path, rep);
    IF NOT res THEN
      -- .'$Elem'.'|'.2
      res := json_model_22(val, path, rep);
      IF NOT res THEN
        -- .'$Elem'.'|'.3
        res := json_model_23(val, path, rep);
        IF NOT res THEN
          -- .'$Elem'.'|'.4
          res := json_model_24(val, path, rep);
          IF NOT res THEN
            -- .'$Elem'.'|'.5
            res := json_model_26(val, path, rep);
          END IF;
        END IF;
      END IF;
    END IF;
  END IF;
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- object .'$Element'.'|'.5
CREATE OR REPLACE FUNCTION _jm_obj_13(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = '#' THEN
      -- handle may # property
      -- .'$Element'.'|'.5.'#'
      res := JSONB_TYPEOF(pval) = 'string';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF json_model_25(TO_JSONB(prop), NULL, rep) THEN
      -- handle 1 key props
      -- .'$Element'.'|'.5.'$Prop'
      res := json_model_32(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF STARTS_WITH(prop, '#') THEN
      -- handle 1 re props
      -- .'$Element'.'|'.5.'/^#/'
      res := TRUE;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- object .'$Element'.'|'.4
CREATE OR REPLACE FUNCTION _jm_obj_14(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  must_count int;
  prop TEXT;
  pval JSONB;
  arr_9_idx INT8;
  arr_9_item JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  must_count := 0;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = '+' THEN
      -- handle must + property
      must_count := must_count + 1;
      -- .'$Element'.'|'.4.'+'
      res := JSONB_TYPEOF(pval) = 'array';
      IF res THEN
        FOR arr_9_idx IN 0 .. JSONB_ARRAY_LENGTH(pval) - 1 LOOP
          arr_9_item := pval -> arr_9_idx;
          -- .'$Element'.'|'.4.'+'.0
          res := json_model_32(arr_9_item, NULL, rep);
          IF NOT res THEN
            EXIT;
          END IF;
        END LOOP;
      END IF;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = '#' THEN
      -- handle may # property
      -- .'$Element'.'|'.4.'#'
      res := JSONB_TYPEOF(pval) = 'string';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF STARTS_WITH(prop, '#') THEN
      -- handle 1 re props
      -- .'$Element'.'|'.4.'/^#/'
      res := TRUE;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  IF must_count <> 1 THEN
    RETURN FALSE;
  END IF;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- object .'$Element'.'|'.3
CREATE OR REPLACE FUNCTION _jm_obj_15(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  must_count int;
  prop TEXT;
  pval JSONB;
  arr_10_idx INT8;
  arr_10_item JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  must_count := 0;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = '^' THEN
      -- handle must ^ property
      must_count := must_count + 1;
      -- .'$Element'.'|'.3.'^'
      res := JSONB_TYPEOF(pval) = 'array';
      IF res THEN
        FOR arr_10_idx IN 0 .. JSONB_ARRAY_LENGTH(pval) - 1 LOOP
          arr_10_item := pval -> arr_10_idx;
          -- .'$Element'.'|'.3.'^'.0
          res := json_model_32(arr_10_item, NULL, rep);
          IF NOT res THEN
            EXIT;
          END IF;
        END LOOP;
      END IF;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = '#' THEN
      -- handle may # property
      -- .'$Element'.'|'.3.'#'
      res := JSONB_TYPEOF(pval) = 'string';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF STARTS_WITH(prop, '#') THEN
      -- handle 1 re props
      -- .'$Element'.'|'.3.'/^#/'
      res := TRUE;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  IF must_count <> 1 THEN
    RETURN FALSE;
  END IF;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- object .'$Element'.'|'.2
CREATE OR REPLACE FUNCTION _jm_obj_16(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  must_count int;
  prop TEXT;
  pval JSONB;
  arr_11_idx INT8;
  arr_11_item JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  must_count := 0;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = '&' THEN
      -- handle must & property
      must_count := must_count + 1;
      -- .'$Element'.'|'.2.'&'
      res := JSONB_TYPEOF(pval) = 'array';
      IF res THEN
        FOR arr_11_idx IN 0 .. JSONB_ARRAY_LENGTH(pval) - 1 LOOP
          arr_11_item := pval -> arr_11_idx;
          -- .'$Element'.'|'.2.'&'.0
          res := json_model_32(arr_11_item, NULL, rep);
          IF NOT res THEN
            EXIT;
          END IF;
        END LOOP;
      END IF;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = '#' THEN
      -- handle may # property
      -- .'$Element'.'|'.2.'#'
      res := JSONB_TYPEOF(pval) = 'string';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF STARTS_WITH(prop, '#') THEN
      -- handle 1 re props
      -- .'$Element'.'|'.2.'/^#/'
      res := TRUE;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  IF must_count <> 1 THEN
    RETURN FALSE;
  END IF;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- object .'$Element'.'|'.1
CREATE OR REPLACE FUNCTION _jm_obj_17(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  must_count int;
  prop TEXT;
  pval JSONB;
  arr_12_idx INT8;
  arr_12_item JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  must_count := 0;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = '|' THEN
      -- handle must | property
      must_count := must_count + 1;
      -- .'$Element'.'|'.1.'|'
      res := JSONB_TYPEOF(pval) = 'array';
      IF res THEN
        FOR arr_12_idx IN 0 .. JSONB_ARRAY_LENGTH(pval) - 1 LOOP
          arr_12_item := pval -> arr_12_idx;
          -- .'$Element'.'|'.1.'|'.0
          res := json_model_32(arr_12_item, NULL, rep);
          IF NOT res THEN
            EXIT;
          END IF;
        END LOOP;
      END IF;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = '#' THEN
      -- handle may # property
      -- .'$Element'.'|'.1.'#'
      res := JSONB_TYPEOF(pval) = 'string';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF STARTS_WITH(prop, '#') THEN
      -- handle 1 re props
      -- .'$Element'.'|'.1.'/^#/'
      res := TRUE;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  IF must_count <> 1 THEN
    RETURN FALSE;
  END IF;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- object .'$Element'.'|'.0
CREATE OR REPLACE FUNCTION _jm_obj_18(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  must_count int;
  prop TEXT;
  pval JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  must_count := 0;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = '@' THEN
      -- handle must @ property
      must_count := must_count + 1;
      -- .'$Element'.'|'.0.'@'
      res := json_model_32(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = '#' THEN
      -- handle may # property
      -- .'$Element'.'|'.0.'#'
      res := JSONB_TYPEOF(pval) = 'string';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = '!' THEN
      -- handle may ! property
      -- .'$Element'.'|'.0.'!'
      res := JSONB_TYPEOF(pval) = 'boolean';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF STARTS_WITH(prop, '#') THEN
      -- handle 3 re props
      -- .'$Element'.'|'.0.'/^#/'
      res := TRUE;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF _jm_re_7(prop, path, rep) THEN
      -- handle 3 re props
      -- .'$Element'.'|'.0.'/^(<=|>=|<|>)$/'
      res := json_model_12(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF _jm_re_8(prop, path, rep) THEN
      -- handle 3 re props
      -- .'$Element'.'|'.0.'/^(=|!=)$/'
      res := json_model_13(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  IF must_count <> 1 THEN
    RETURN FALSE;
  END IF;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check $Element (.'$Element')
CREATE OR REPLACE FUNCTION json_model_28(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$Element'
  res := JSONB_TYPEOF(val) = 'object';
  IF res THEN
    -- .'$Element'.'|'.0
    res := _jm_obj_18(val, path, rep);
    IF NOT res THEN
      -- .'$Element'.'|'.1
      res := _jm_obj_17(val, path, rep);
      IF NOT res THEN
        -- .'$Element'.'|'.2
        res := _jm_obj_16(val, path, rep);
        IF NOT res THEN
          -- .'$Element'.'|'.3
          res := _jm_obj_15(val, path, rep);
          IF NOT res THEN
            -- .'$Element'.'|'.4
            res := _jm_obj_14(val, path, rep);
            IF NOT res THEN
              -- .'$Element'.'|'.5
              res := _jm_obj_13(val, path, rep);
            END IF;
          END IF;
        END IF;
      END IF;
    END IF;
  END IF;
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- object .'$Trafo'.'~'
CREATE OR REPLACE FUNCTION _jm_obj_20(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    -- handle other props
    -- .'$Trafo'.'~'.''
    res := JSONB_TYPEOF(pval) = 'string';
    IF NOT res THEN
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- object .'$Trafo'
CREATE OR REPLACE FUNCTION _jm_obj_19(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = '/' THEN
      -- handle may / property
      -- .'$Trafo'.'/'
      -- .'$Trafo'.'/'.'|'.0
      res := JSONB_TYPEOF(pval) = 'null';
      IF NOT res THEN
        -- .'$Trafo'.'/'.'|'.1
        res := JSONB_TYPEOF(pval) = 'boolean';
        IF NOT res THEN
          -- .'$Trafo'.'/'.'|'.2
          res := JSONB_TYPEOF(pval) = 'number' AND (pval)::INT8 = (pval)::FLOAT8;
          IF NOT res THEN
            -- .'$Trafo'.'/'.'|'.3
            res := JSONB_TYPEOF(pval) = 'number';
            IF NOT res THEN
              -- .'$Trafo'.'/'.'|'.4
              res := JSONB_TYPEOF(pval) = 'string';
              IF NOT res THEN
                -- .'$Trafo'.'/'.'|'.5
                res := JSONB_TYPEOF(pval) = 'array';
                IF res THEN
                  -- accept any array
                  NULL;
                END IF;
              END IF;
            END IF;
          END IF;
        END IF;
      END IF;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = '~' THEN
      -- handle may ~ property
      -- .'$Trafo'.'~'
      res := _jm_obj_20(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = '*' THEN
      -- handle may * property
      -- .'$Trafo'.'*'
      res := TRUE;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check $Trafo (.'$Trafo')
CREATE OR REPLACE FUNCTION json_model_29(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- remove, rename or add stuff
  -- .'$Trafo'
  res := _jm_obj_19(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- object .'$Transformation'.'|'.6.'~'
CREATE OR REPLACE FUNCTION _jm_obj_22(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    -- handle other props
    -- .'$Transformation'.'|'.6.'~'.''
    res := JSONB_TYPEOF(pval) = 'string';
    IF NOT res THEN
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- object .'$Transformation'.'|'.6
CREATE OR REPLACE FUNCTION _jm_obj_21(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = '#' THEN
      -- handle may # property
      -- .'$Transformation'.'|'.6.'#'
      res := JSONB_TYPEOF(pval) = 'string';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = '/' THEN
      -- handle may / property
      -- .'$Transformation'.'|'.6.'/'
      -- .'$Transformation'.'|'.6.'/'.'|'.0
      res := JSONB_TYPEOF(pval) = 'null';
      IF NOT res THEN
        -- .'$Transformation'.'|'.6.'/'.'|'.1
        res := JSONB_TYPEOF(pval) = 'boolean';
        IF NOT res THEN
          -- .'$Transformation'.'|'.6.'/'.'|'.2
          res := JSONB_TYPEOF(pval) = 'number' AND (pval)::INT8 = (pval)::FLOAT8;
          IF NOT res THEN
            -- .'$Transformation'.'|'.6.'/'.'|'.3
            res := JSONB_TYPEOF(pval) = 'number';
            IF NOT res THEN
              -- .'$Transformation'.'|'.6.'/'.'|'.4
              res := JSONB_TYPEOF(pval) = 'string';
              IF NOT res THEN
                -- .'$Transformation'.'|'.6.'/'.'|'.5
                res := JSONB_TYPEOF(pval) = 'array';
                IF res THEN
                  -- accept any array
                  NULL;
                END IF;
              END IF;
            END IF;
          END IF;
        END IF;
      END IF;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = '~' THEN
      -- handle may ~ property
      -- .'$Transformation'.'|'.6.'~'
      res := _jm_obj_22(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = '*' THEN
      -- handle may * property
      -- .'$Transformation'.'|'.6.'*'
      res := TRUE;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF STARTS_WITH(prop, '#') THEN
      -- handle 1 re props
      -- .'$Transformation'.'|'.6.'/^#/'
      res := TRUE;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- object .'$Transformation'.'|'.5
CREATE OR REPLACE FUNCTION _jm_obj_23(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = '#' THEN
      -- handle may # property
      -- .'$Transformation'.'|'.5.'#'
      res := JSONB_TYPEOF(pval) = 'string';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF json_model_25(TO_JSONB(prop), NULL, rep) THEN
      -- handle 1 key props
      -- .'$Transformation'.'|'.5.'$Prop'
      res := json_model_32(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF STARTS_WITH(prop, '#') THEN
      -- handle 1 re props
      -- .'$Transformation'.'|'.5.'/^#/'
      res := TRUE;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- object .'$Transformation'.'|'.4
CREATE OR REPLACE FUNCTION _jm_obj_24(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  must_count int;
  prop TEXT;
  pval JSONB;
  arr_13_idx INT8;
  arr_13_item JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  must_count := 0;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = '+' THEN
      -- handle must + property
      must_count := must_count + 1;
      -- .'$Transformation'.'|'.4.'+'
      res := JSONB_TYPEOF(pval) = 'array';
      IF res THEN
        FOR arr_13_idx IN 0 .. JSONB_ARRAY_LENGTH(pval) - 1 LOOP
          arr_13_item := pval -> arr_13_idx;
          -- .'$Transformation'.'|'.4.'+'.0
          res := json_model_32(arr_13_item, NULL, rep);
          IF NOT res THEN
            EXIT;
          END IF;
        END LOOP;
      END IF;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = '#' THEN
      -- handle may # property
      -- .'$Transformation'.'|'.4.'#'
      res := JSONB_TYPEOF(pval) = 'string';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF STARTS_WITH(prop, '#') THEN
      -- handle 1 re props
      -- .'$Transformation'.'|'.4.'/^#/'
      res := TRUE;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  IF must_count <> 1 THEN
    RETURN FALSE;
  END IF;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- object .'$Transformation'.'|'.3
CREATE OR REPLACE FUNCTION _jm_obj_25(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  must_count int;
  prop TEXT;
  pval JSONB;
  arr_14_idx INT8;
  arr_14_item JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  must_count := 0;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = '^' THEN
      -- handle must ^ property
      must_count := must_count + 1;
      -- .'$Transformation'.'|'.3.'^'
      res := JSONB_TYPEOF(pval) = 'array';
      IF res THEN
        FOR arr_14_idx IN 0 .. JSONB_ARRAY_LENGTH(pval) - 1 LOOP
          arr_14_item := pval -> arr_14_idx;
          -- .'$Transformation'.'|'.3.'^'.0
          res := json_model_32(arr_14_item, NULL, rep);
          IF NOT res THEN
            EXIT;
          END IF;
        END LOOP;
      END IF;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = '#' THEN
      -- handle may # property
      -- .'$Transformation'.'|'.3.'#'
      res := JSONB_TYPEOF(pval) = 'string';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF STARTS_WITH(prop, '#') THEN
      -- handle 1 re props
      -- .'$Transformation'.'|'.3.'/^#/'
      res := TRUE;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  IF must_count <> 1 THEN
    RETURN FALSE;
  END IF;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- object .'$Transformation'.'|'.2
CREATE OR REPLACE FUNCTION _jm_obj_26(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  must_count int;
  prop TEXT;
  pval JSONB;
  arr_15_idx INT8;
  arr_15_item JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  must_count := 0;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = '&' THEN
      -- handle must & property
      must_count := must_count + 1;
      -- .'$Transformation'.'|'.2.'&'
      res := JSONB_TYPEOF(pval) = 'array';
      IF res THEN
        FOR arr_15_idx IN 0 .. JSONB_ARRAY_LENGTH(pval) - 1 LOOP
          arr_15_item := pval -> arr_15_idx;
          -- .'$Transformation'.'|'.2.'&'.0
          res := json_model_32(arr_15_item, NULL, rep);
          IF NOT res THEN
            EXIT;
          END IF;
        END LOOP;
      END IF;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = '#' THEN
      -- handle may # property
      -- .'$Transformation'.'|'.2.'#'
      res := JSONB_TYPEOF(pval) = 'string';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF STARTS_WITH(prop, '#') THEN
      -- handle 1 re props
      -- .'$Transformation'.'|'.2.'/^#/'
      res := TRUE;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  IF must_count <> 1 THEN
    RETURN FALSE;
  END IF;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- object .'$Transformation'.'|'.1
CREATE OR REPLACE FUNCTION _jm_obj_27(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  must_count int;
  prop TEXT;
  pval JSONB;
  arr_16_idx INT8;
  arr_16_item JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  must_count := 0;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = '|' THEN
      -- handle must | property
      must_count := must_count + 1;
      -- .'$Transformation'.'|'.1.'|'
      res := JSONB_TYPEOF(pval) = 'array';
      IF res THEN
        FOR arr_16_idx IN 0 .. JSONB_ARRAY_LENGTH(pval) - 1 LOOP
          arr_16_item := pval -> arr_16_idx;
          -- .'$Transformation'.'|'.1.'|'.0
          res := json_model_32(arr_16_item, NULL, rep);
          IF NOT res THEN
            EXIT;
          END IF;
        END LOOP;
      END IF;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = '#' THEN
      -- handle may # property
      -- .'$Transformation'.'|'.1.'#'
      res := JSONB_TYPEOF(pval) = 'string';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF STARTS_WITH(prop, '#') THEN
      -- handle 1 re props
      -- .'$Transformation'.'|'.1.'/^#/'
      res := TRUE;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  IF must_count <> 1 THEN
    RETURN FALSE;
  END IF;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- object .'$Transformation'.'|'.0
CREATE OR REPLACE FUNCTION _jm_obj_28(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  must_count int;
  prop TEXT;
  pval JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  must_count := 0;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = '@' THEN
      -- handle must @ property
      must_count := must_count + 1;
      -- .'$Transformation'.'|'.0.'@'
      res := json_model_32(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = '#' THEN
      -- handle may # property
      -- .'$Transformation'.'|'.0.'#'
      res := JSONB_TYPEOF(pval) = 'string';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = '!' THEN
      -- handle may ! property
      -- .'$Transformation'.'|'.0.'!'
      res := JSONB_TYPEOF(pval) = 'boolean';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF STARTS_WITH(prop, '#') THEN
      -- handle 3 re props
      -- .'$Transformation'.'|'.0.'/^#/'
      res := TRUE;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF _jm_re_7(prop, path, rep) THEN
      -- handle 3 re props
      -- .'$Transformation'.'|'.0.'/^(<=|>=|<|>)$/'
      res := json_model_12(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF _jm_re_8(prop, path, rep) THEN
      -- handle 3 re props
      -- .'$Transformation'.'|'.0.'/^(=|!=)$/'
      res := json_model_13(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  IF must_count <> 1 THEN
    RETURN FALSE;
  END IF;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION _jm_cst_4(value JSONB)
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  constants JSONB = JSONB '[null,true,0,1,-1,0.0,1.0,-1.0,"$DATE","$TIME","$DATETIME","$URL","$URI","$UUID","$EMAIL","$REGEX","$EXREG","$NULL","$BOOL","$FLOAT","$F16","$F32","$F64","$NUMBER","$INT","$INTEGER","$I8","$I16","$I32","$I64","$U8","$U16","$U32","$U64","$STRING","$NONE","$ANY",""]';
BEGIN
  RETURN constants @> value;
END;
$$ LANGUAGE plpgsql;

-- check $Transformation (.'$Transformation')
CREATE OR REPLACE FUNCTION json_model_30(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$Transformation'
  res := JSONB_TYPEOF(val) = 'object';
  IF res THEN
    -- .'$Transformation'.'|'.0
    res := _jm_obj_28(val, path, rep);
    IF NOT res THEN
      -- .'$Transformation'.'|'.1
      res := _jm_obj_27(val, path, rep);
      IF NOT res THEN
        -- .'$Transformation'.'|'.2
        res := _jm_obj_26(val, path, rep);
        IF NOT res THEN
          -- .'$Transformation'.'|'.3
          res := _jm_obj_25(val, path, rep);
          IF NOT res THEN
            -- .'$Transformation'.'|'.4
            res := _jm_obj_24(val, path, rep);
            IF NOT res THEN
              -- .'$Transformation'.'|'.5
              res := _jm_obj_23(val, path, rep);
              IF NOT res THEN
                -- .'$Transformation'.'|'.6
                res := _jm_obj_21(val, path, rep);
              END IF;
            END IF;
          END IF;
        END IF;
      END IF;
    END IF;
  END IF;
  IF NOT res THEN
    res := JSONB_TYPEOF(val) IN ('null', 'boolean', 'number', 'string') AND _jm_cst_4(val);
    IF NOT res THEN
      -- .'$Transformation'.'|'.0
      res := json_model_9(val, path, rep);
      IF NOT res THEN
        -- .'$Transformation'.'|'.1
        res := json_model_8(val, path, rep);
        IF NOT res THEN
          -- .'$Transformation'.'|'.2
          -- "/^/($EXREG)/[a-z]*X[a-z]*$/X"
          res := JSONB_TYPEOF(val) = 'string' AND _jm_xre_1(JSON_VALUE(val, '$' RETURNING TEXT), path, rep);
          IF NOT res THEN
            -- .'$Transformation'.'|'.3
            -- "/^/($REGEX)/[a-z]*$/X"
            res := JSONB_TYPEOF(val) = 'string' AND _jm_xre_0(JSON_VALUE(val, '$' RETURNING TEXT), path, rep);
            IF NOT res THEN
              -- .'$Transformation'.'|'.4
              res := json_model_7(val, path, rep);
              IF NOT res THEN
                -- .'$Transformation'.'|'.5
                res := json_model_18(val, path, rep);
              END IF;
            END IF;
          END IF;
        END IF;
      END IF;
    END IF;
  END IF;
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION _jm_cst_5(value JSONB)
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  constants JSONB = JSONB '[null,true,0,1,-1,0.0,1.0,-1.0,"$DATE","$TIME","$DATETIME","$URL","$URI","$UUID","$EMAIL","$REGEX","$EXREG","$NULL","$BOOL","$FLOAT","$F16","$F32","$F64","$NUMBER","$INT","$INTEGER","$I8","$I16","$I32","$I64","$U8","$U16","$U32","$U64","$STRING","$NONE","$ANY",""]';
BEGIN
  RETURN constants @> value;
END;
$$ LANGUAGE plpgsql;

-- check $ScalarModel (.'$ScalarModel')
CREATE OR REPLACE FUNCTION json_model_31(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$ScalarModel'
  res := JSONB_TYPEOF(val) IN ('null', 'boolean', 'number', 'string') AND _jm_cst_5(val);
  IF NOT res THEN
    -- .'$ScalarModel'.'|'.0
    res := json_model_9(val, path, rep);
    IF NOT res THEN
      -- .'$ScalarModel'.'|'.1
      res := json_model_8(val, path, rep);
      IF NOT res THEN
        -- .'$ScalarModel'.'|'.2
        -- "/^/($EXREG)/[a-z]*X[a-z]*$/X"
        res := JSONB_TYPEOF(val) = 'string' AND _jm_xre_1(JSON_VALUE(val, '$' RETURNING TEXT), path, rep);
        IF NOT res THEN
          -- .'$ScalarModel'.'|'.3
          -- "/^/($REGEX)/[a-z]*$/X"
          res := JSONB_TYPEOF(val) = 'string' AND _jm_xre_0(JSON_VALUE(val, '$' RETURNING TEXT), path, rep);
          IF NOT res THEN
            -- .'$ScalarModel'.'|'.4
            res := json_model_7(val, path, rep);
          END IF;
        END IF;
      END IF;
    END IF;
  END IF;
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- object .'$Model'.'|'.5
CREATE OR REPLACE FUNCTION _jm_obj_29(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = '#' THEN
      -- handle may # property
      -- .'$Model'.'|'.5.'#'
      res := JSONB_TYPEOF(pval) = 'string';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF json_model_25(TO_JSONB(prop), NULL, rep) THEN
      -- handle 1 key props
      -- .'$Model'.'|'.5.'$Prop'
      res := json_model_32(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF STARTS_WITH(prop, '#') THEN
      -- handle 1 re props
      -- .'$Model'.'|'.5.'/^#/'
      res := TRUE;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- object .'$Model'.'|'.4
CREATE OR REPLACE FUNCTION _jm_obj_30(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  must_count int;
  prop TEXT;
  pval JSONB;
  arr_17_idx INT8;
  arr_17_item JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  must_count := 0;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = '+' THEN
      -- handle must + property
      must_count := must_count + 1;
      -- .'$Model'.'|'.4.'+'
      res := JSONB_TYPEOF(pval) = 'array';
      IF res THEN
        FOR arr_17_idx IN 0 .. JSONB_ARRAY_LENGTH(pval) - 1 LOOP
          arr_17_item := pval -> arr_17_idx;
          -- .'$Model'.'|'.4.'+'.0
          res := json_model_32(arr_17_item, NULL, rep);
          IF NOT res THEN
            EXIT;
          END IF;
        END LOOP;
      END IF;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = '#' THEN
      -- handle may # property
      -- .'$Model'.'|'.4.'#'
      res := JSONB_TYPEOF(pval) = 'string';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF STARTS_WITH(prop, '#') THEN
      -- handle 1 re props
      -- .'$Model'.'|'.4.'/^#/'
      res := TRUE;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  IF must_count <> 1 THEN
    RETURN FALSE;
  END IF;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- object .'$Model'.'|'.3
CREATE OR REPLACE FUNCTION _jm_obj_31(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  must_count int;
  prop TEXT;
  pval JSONB;
  arr_18_idx INT8;
  arr_18_item JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  must_count := 0;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = '^' THEN
      -- handle must ^ property
      must_count := must_count + 1;
      -- .'$Model'.'|'.3.'^'
      res := JSONB_TYPEOF(pval) = 'array';
      IF res THEN
        FOR arr_18_idx IN 0 .. JSONB_ARRAY_LENGTH(pval) - 1 LOOP
          arr_18_item := pval -> arr_18_idx;
          -- .'$Model'.'|'.3.'^'.0
          res := json_model_32(arr_18_item, NULL, rep);
          IF NOT res THEN
            EXIT;
          END IF;
        END LOOP;
      END IF;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = '#' THEN
      -- handle may # property
      -- .'$Model'.'|'.3.'#'
      res := JSONB_TYPEOF(pval) = 'string';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF STARTS_WITH(prop, '#') THEN
      -- handle 1 re props
      -- .'$Model'.'|'.3.'/^#/'
      res := TRUE;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  IF must_count <> 1 THEN
    RETURN FALSE;
  END IF;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- object .'$Model'.'|'.2
CREATE OR REPLACE FUNCTION _jm_obj_32(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  must_count int;
  prop TEXT;
  pval JSONB;
  arr_19_idx INT8;
  arr_19_item JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  must_count := 0;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = '&' THEN
      -- handle must & property
      must_count := must_count + 1;
      -- .'$Model'.'|'.2.'&'
      res := JSONB_TYPEOF(pval) = 'array';
      IF res THEN
        FOR arr_19_idx IN 0 .. JSONB_ARRAY_LENGTH(pval) - 1 LOOP
          arr_19_item := pval -> arr_19_idx;
          -- .'$Model'.'|'.2.'&'.0
          res := json_model_32(arr_19_item, NULL, rep);
          IF NOT res THEN
            EXIT;
          END IF;
        END LOOP;
      END IF;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = '#' THEN
      -- handle may # property
      -- .'$Model'.'|'.2.'#'
      res := JSONB_TYPEOF(pval) = 'string';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF STARTS_WITH(prop, '#') THEN
      -- handle 1 re props
      -- .'$Model'.'|'.2.'/^#/'
      res := TRUE;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  IF must_count <> 1 THEN
    RETURN FALSE;
  END IF;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- object .'$Model'.'|'.1
CREATE OR REPLACE FUNCTION _jm_obj_33(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  must_count int;
  prop TEXT;
  pval JSONB;
  arr_20_idx INT8;
  arr_20_item JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  must_count := 0;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = '|' THEN
      -- handle must | property
      must_count := must_count + 1;
      -- .'$Model'.'|'.1.'|'
      res := JSONB_TYPEOF(pval) = 'array';
      IF res THEN
        FOR arr_20_idx IN 0 .. JSONB_ARRAY_LENGTH(pval) - 1 LOOP
          arr_20_item := pval -> arr_20_idx;
          -- .'$Model'.'|'.1.'|'.0
          res := json_model_32(arr_20_item, NULL, rep);
          IF NOT res THEN
            EXIT;
          END IF;
        END LOOP;
      END IF;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = '#' THEN
      -- handle may # property
      -- .'$Model'.'|'.1.'#'
      res := JSONB_TYPEOF(pval) = 'string';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF STARTS_WITH(prop, '#') THEN
      -- handle 1 re props
      -- .'$Model'.'|'.1.'/^#/'
      res := TRUE;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  IF must_count <> 1 THEN
    RETURN FALSE;
  END IF;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- object .'$Model'.'|'.0
CREATE OR REPLACE FUNCTION _jm_obj_34(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  must_count int;
  prop TEXT;
  pval JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  must_count := 0;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = '@' THEN
      -- handle must @ property
      must_count := must_count + 1;
      -- .'$Model'.'|'.0.'@'
      res := json_model_32(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = '#' THEN
      -- handle may # property
      -- .'$Model'.'|'.0.'#'
      res := JSONB_TYPEOF(pval) = 'string';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = '!' THEN
      -- handle may ! property
      -- .'$Model'.'|'.0.'!'
      res := JSONB_TYPEOF(pval) = 'boolean';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF STARTS_WITH(prop, '#') THEN
      -- handle 3 re props
      -- .'$Model'.'|'.0.'/^#/'
      res := TRUE;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF _jm_re_7(prop, path, rep) THEN
      -- handle 3 re props
      -- .'$Model'.'|'.0.'/^(<=|>=|<|>)$/'
      res := json_model_12(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF _jm_re_8(prop, path, rep) THEN
      -- handle 3 re props
      -- .'$Model'.'|'.0.'/^(=|!=)$/'
      res := json_model_13(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  IF must_count <> 1 THEN
    RETURN FALSE;
  END IF;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION _jm_cst_6(value JSONB)
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  constants JSONB = JSONB '[null,true,0,1,-1,0.0,1.0,-1.0,"$DATE","$TIME","$DATETIME","$URL","$URI","$UUID","$EMAIL","$REGEX","$EXREG","$NULL","$BOOL","$FLOAT","$F16","$F32","$F64","$NUMBER","$INT","$INTEGER","$I8","$I16","$I32","$I64","$U8","$U16","$U32","$U64","$STRING","$NONE","$ANY",""]';
BEGIN
  RETURN constants @> value;
END;
$$ LANGUAGE plpgsql;

-- check $Model (.'$Model')
CREATE OR REPLACE FUNCTION json_model_32(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$Model'
  res := JSONB_TYPEOF(val) = 'object';
  IF res THEN
    -- .'$Model'.'|'.0
    res := _jm_obj_34(val, path, rep);
    IF NOT res THEN
      -- .'$Model'.'|'.1
      res := _jm_obj_33(val, path, rep);
      IF NOT res THEN
        -- .'$Model'.'|'.2
        res := _jm_obj_32(val, path, rep);
        IF NOT res THEN
          -- .'$Model'.'|'.3
          res := _jm_obj_31(val, path, rep);
          IF NOT res THEN
            -- .'$Model'.'|'.4
            res := _jm_obj_30(val, path, rep);
            IF NOT res THEN
              -- .'$Model'.'|'.5
              res := _jm_obj_29(val, path, rep);
            END IF;
          END IF;
        END IF;
      END IF;
    END IF;
  END IF;
  IF NOT res THEN
    res := JSONB_TYPEOF(val) IN ('null', 'boolean', 'number', 'string') AND _jm_cst_6(val);
    IF NOT res THEN
      -- .'$Model'.'|'.0
      res := json_model_9(val, path, rep);
      IF NOT res THEN
        -- .'$Model'.'|'.1
        res := json_model_8(val, path, rep);
        IF NOT res THEN
          -- .'$Model'.'|'.2
          -- "/^/($EXREG)/[a-z]*X[a-z]*$/X"
          res := JSONB_TYPEOF(val) = 'string' AND _jm_xre_1(JSON_VALUE(val, '$' RETURNING TEXT), path, rep);
          IF NOT res THEN
            -- .'$Model'.'|'.3
            -- "/^/($REGEX)/[a-z]*$/X"
            res := JSONB_TYPEOF(val) = 'string' AND _jm_xre_0(JSON_VALUE(val, '$' RETURNING TEXT), path, rep);
            IF NOT res THEN
              -- .'$Model'.'|'.4
              res := json_model_7(val, path, rep);
              IF NOT res THEN
                -- .'$Model'.'|'.5
                res := json_model_18(val, path, rep);
              END IF;
            END IF;
          END IF;
        END IF;
      END IF;
    END IF;
  END IF;
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- object .'$Defs'
CREATE OR REPLACE FUNCTION _jm_obj_35(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = '' THEN
      -- handle may  property
      -- .'$Defs'.''
      res := json_model_2(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF json_model_4(TO_JSONB(prop), NULL, rep) THEN
      -- handle 1 key props
      -- .'$Defs'.'$Identifier'
      res := json_model_32(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check $Defs (.'$Defs')
CREATE OR REPLACE FUNCTION json_model_33(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$Defs'
  res := _jm_obj_35(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- regex=^([#|&^+/*@~=$%]|[<>!]=?)$ opts=n
CREATE OR REPLACE FUNCTION _jm_re_10(val TEXT, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  RETURN regexp_like(val, '^([#|&^+/*@~=$%]|[<>!]=?)$', 'n');
END;
$$ LANGUAGE plpgsql;

-- object .'$Rename'
CREATE OR REPLACE FUNCTION _jm_obj_36(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF json_model_11(TO_JSONB(prop), NULL, rep) THEN
      -- handle 1 key props
      -- .'$Rename'.'$Name'
      -- "/^([#|&^+/*@~=$%]|[<>!]=?)$/"
      res := JSONB_TYPEOF(pval) = 'string' AND _jm_re_10(JSON_VALUE(pval, '$' RETURNING TEXT), NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check $Rename (.'$Rename')
CREATE OR REPLACE FUNCTION json_model_34(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$Rename'
  res := _jm_obj_36(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- regex=^\$.*$ opts=n
CREATE OR REPLACE FUNCTION _jm_re_11(val TEXT, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
BEGIN
  RETURN regexp_like(val, '^\$.*$', 'n');
END;
$$ LANGUAGE plpgsql;

-- object .'$Rewrite'
CREATE OR REPLACE FUNCTION _jm_obj_37(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF _jm_re_11(prop, path, rep) THEN
      -- handle 1 re props
      -- .'$Rewrite'.'/^\\$.*$/'
      res := json_model_30(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check $Rewrite (.'$Rewrite')
CREATE OR REPLACE FUNCTION json_model_35(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$Rewrite'
  res := _jm_obj_37(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- object .'$Import'
CREATE OR REPLACE FUNCTION _jm_obj_38(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
  arr_21_idx INT8;
  arr_21_item JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = '<' THEN
      -- handle may < property
      -- .'$Import'.'<'
      -- .'$Import'.'<'.'|'.0
      res := json_model_7(pval, NULL, rep);
      IF NOT res THEN
        -- .'$Import'.'<'.'|'.1
        res := JSONB_TYPEOF(pval) = 'array';
        IF res THEN
          FOR arr_21_idx IN 0 .. JSONB_ARRAY_LENGTH(pval) - 1 LOOP
            arr_21_item := pval -> arr_21_idx;
            -- .'$Import'.'<'.'|'.1.0
            res := json_model_7(arr_21_item, NULL, rep);
            IF NOT res THEN
              EXIT;
            END IF;
          END LOOP;
        END IF;
      END IF;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check $Import (.'$Import')
CREATE OR REPLACE FUNCTION json_model_36(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$Import'
  res := _jm_obj_38(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- object .'$RootOnly'.'$'
CREATE OR REPLACE FUNCTION _jm_obj_40(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = '#' THEN
      -- handle may # property
      -- .'$RootOnly'.'$'.'#'
      res := JSONB_TYPEOF(pval) = 'string';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = '' THEN
      -- handle may  property
      -- .'$RootOnly'.'$'.''
      res := json_model_2(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF json_model_4(TO_JSONB(prop), NULL, rep) THEN
      -- handle 1 key props
      -- .'$RootOnly'.'$'.'$Identifier'
      res := json_model_32(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF STARTS_WITH(prop, '#') THEN
      -- handle 1 re props
      -- .'$RootOnly'.'$'.'/^#/'
      res := TRUE;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- object .'$RootOnly'.'%'
CREATE OR REPLACE FUNCTION _jm_obj_41(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
  arr_22_idx INT8;
  arr_22_item JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = '#' THEN
      -- handle may # property
      -- .'$RootOnly'.'%'.'#'
      res := JSONB_TYPEOF(pval) = 'string';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = '<' THEN
      -- handle may < property
      -- .'$RootOnly'.'%'.'<'
      -- .'$RootOnly'.'%'.'<'.'|'.0
      res := json_model_7(pval, NULL, rep);
      IF NOT res THEN
        -- .'$RootOnly'.'%'.'<'.'|'.1
        res := JSONB_TYPEOF(pval) = 'array';
        IF res THEN
          FOR arr_22_idx IN 0 .. JSONB_ARRAY_LENGTH(pval) - 1 LOOP
            arr_22_item := pval -> arr_22_idx;
            -- .'$RootOnly'.'%'.'<'.'|'.1.0
            res := json_model_7(arr_22_item, NULL, rep);
            IF NOT res THEN
              EXIT;
            END IF;
          END LOOP;
        END IF;
      END IF;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF json_model_11(TO_JSONB(prop), NULL, rep) THEN
      -- handle 1 key props
      -- .'$RootOnly'.'%'.'$Name'
      -- "/^([#|&^+/*@~=$%]|[<>!]=?)$/"
      res := JSONB_TYPEOF(pval) = 'string' AND _jm_re_10(JSON_VALUE(pval, '$' RETURNING TEXT), NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF STARTS_WITH(prop, '#') THEN
      -- handle 2 re props
      -- .'$RootOnly'.'%'.'/^#/'
      res := TRUE;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF _jm_re_11(prop, path, rep) THEN
      -- handle 2 re props
      -- .'$RootOnly'.'%'.'/^\\$.*$/'
      res := json_model_30(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- object .'$RootOnly'
CREATE OR REPLACE FUNCTION _jm_obj_39(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = '~' THEN
      -- handle may ~ property
      -- .'$RootOnly'.'~'
      res := json_model_2(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = '$' THEN
      -- handle may $ property
      -- .'$RootOnly'.'$'
      res := _jm_obj_40(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = '%' THEN
      -- handle may % property
      -- .'$RootOnly'.'%'
      res := _jm_obj_41(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check $RootOnly (.'$RootOnly')
CREATE OR REPLACE FUNCTION json_model_37(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- symbols that can only appear at the model's root
  -- .'$RootOnly'
  res := _jm_obj_39(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- object .'$Root'.'|'.5.'$'
CREATE OR REPLACE FUNCTION _jm_obj_43(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = '#' THEN
      -- handle may # property
      -- .'$Root'.'|'.5.'$'.'#'
      res := JSONB_TYPEOF(pval) = 'string';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = '' THEN
      -- handle may  property
      -- .'$Root'.'|'.5.'$'.''
      res := json_model_2(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF json_model_4(TO_JSONB(prop), NULL, rep) THEN
      -- handle 1 key props
      -- .'$Root'.'|'.5.'$'.'$Identifier'
      res := json_model_32(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF STARTS_WITH(prop, '#') THEN
      -- handle 1 re props
      -- .'$Root'.'|'.5.'$'.'/^#/'
      res := TRUE;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- object .'$Root'.'|'.5.'%'
CREATE OR REPLACE FUNCTION _jm_obj_44(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
  arr_23_idx INT8;
  arr_23_item JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = '#' THEN
      -- handle may # property
      -- .'$Root'.'|'.5.'%'.'#'
      res := JSONB_TYPEOF(pval) = 'string';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = '<' THEN
      -- handle may < property
      -- .'$Root'.'|'.5.'%'.'<'
      -- .'$Root'.'|'.5.'%'.'<'.'|'.0
      res := json_model_7(pval, NULL, rep);
      IF NOT res THEN
        -- .'$Root'.'|'.5.'%'.'<'.'|'.1
        res := JSONB_TYPEOF(pval) = 'array';
        IF res THEN
          FOR arr_23_idx IN 0 .. JSONB_ARRAY_LENGTH(pval) - 1 LOOP
            arr_23_item := pval -> arr_23_idx;
            -- .'$Root'.'|'.5.'%'.'<'.'|'.1.0
            res := json_model_7(arr_23_item, NULL, rep);
            IF NOT res THEN
              EXIT;
            END IF;
          END LOOP;
        END IF;
      END IF;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF json_model_11(TO_JSONB(prop), NULL, rep) THEN
      -- handle 1 key props
      -- .'$Root'.'|'.5.'%'.'$Name'
      -- "/^([#|&^+/*@~=$%]|[<>!]=?)$/"
      res := JSONB_TYPEOF(pval) = 'string' AND _jm_re_10(JSON_VALUE(pval, '$' RETURNING TEXT), NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF STARTS_WITH(prop, '#') THEN
      -- handle 2 re props
      -- .'$Root'.'|'.5.'%'.'/^#/'
      res := TRUE;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF _jm_re_11(prop, path, rep) THEN
      -- handle 2 re props
      -- .'$Root'.'|'.5.'%'.'/^\\$.*$/'
      res := json_model_30(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- object .'$Root'.'|'.5
CREATE OR REPLACE FUNCTION _jm_obj_42(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = '~' THEN
      -- handle may ~ property
      -- .'$Root'.'|'.5.'~'
      res := json_model_2(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = '$' THEN
      -- handle may $ property
      -- .'$Root'.'|'.5.'$'
      res := _jm_obj_43(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = '%' THEN
      -- handle may % property
      -- .'$Root'.'|'.5.'%'
      res := _jm_obj_44(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = '#' THEN
      -- handle may # property
      -- .'$Root'.'|'.5.'#'
      res := JSONB_TYPEOF(pval) = 'string';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF json_model_25(TO_JSONB(prop), NULL, rep) THEN
      -- handle 1 key props
      -- .'$Root'.'|'.5.'$Prop'
      res := json_model_32(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF STARTS_WITH(prop, '#') THEN
      -- handle 1 re props
      -- .'$Root'.'|'.5.'/^#/'
      res := TRUE;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- object .'$Root'.'|'.4.'$'
CREATE OR REPLACE FUNCTION _jm_obj_46(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = '#' THEN
      -- handle may # property
      -- .'$Root'.'|'.4.'$'.'#'
      res := JSONB_TYPEOF(pval) = 'string';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = '' THEN
      -- handle may  property
      -- .'$Root'.'|'.4.'$'.''
      res := json_model_2(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF json_model_4(TO_JSONB(prop), NULL, rep) THEN
      -- handle 1 key props
      -- .'$Root'.'|'.4.'$'.'$Identifier'
      res := json_model_32(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF STARTS_WITH(prop, '#') THEN
      -- handle 1 re props
      -- .'$Root'.'|'.4.'$'.'/^#/'
      res := TRUE;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- object .'$Root'.'|'.4.'%'
CREATE OR REPLACE FUNCTION _jm_obj_47(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
  arr_25_idx INT8;
  arr_25_item JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = '#' THEN
      -- handle may # property
      -- .'$Root'.'|'.4.'%'.'#'
      res := JSONB_TYPEOF(pval) = 'string';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = '<' THEN
      -- handle may < property
      -- .'$Root'.'|'.4.'%'.'<'
      -- .'$Root'.'|'.4.'%'.'<'.'|'.0
      res := json_model_7(pval, NULL, rep);
      IF NOT res THEN
        -- .'$Root'.'|'.4.'%'.'<'.'|'.1
        res := JSONB_TYPEOF(pval) = 'array';
        IF res THEN
          FOR arr_25_idx IN 0 .. JSONB_ARRAY_LENGTH(pval) - 1 LOOP
            arr_25_item := pval -> arr_25_idx;
            -- .'$Root'.'|'.4.'%'.'<'.'|'.1.0
            res := json_model_7(arr_25_item, NULL, rep);
            IF NOT res THEN
              EXIT;
            END IF;
          END LOOP;
        END IF;
      END IF;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF json_model_11(TO_JSONB(prop), NULL, rep) THEN
      -- handle 1 key props
      -- .'$Root'.'|'.4.'%'.'$Name'
      -- "/^([#|&^+/*@~=$%]|[<>!]=?)$/"
      res := JSONB_TYPEOF(pval) = 'string' AND _jm_re_10(JSON_VALUE(pval, '$' RETURNING TEXT), NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF STARTS_WITH(prop, '#') THEN
      -- handle 2 re props
      -- .'$Root'.'|'.4.'%'.'/^#/'
      res := TRUE;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF _jm_re_11(prop, path, rep) THEN
      -- handle 2 re props
      -- .'$Root'.'|'.4.'%'.'/^\\$.*$/'
      res := json_model_30(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- object .'$Root'.'|'.4
CREATE OR REPLACE FUNCTION _jm_obj_45(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  must_count int;
  prop TEXT;
  pval JSONB;
  arr_24_idx INT8;
  arr_24_item JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  must_count := 0;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = '+' THEN
      -- handle must + property
      must_count := must_count + 1;
      -- .'$Root'.'|'.4.'+'
      res := JSONB_TYPEOF(pval) = 'array';
      IF res THEN
        FOR arr_24_idx IN 0 .. JSONB_ARRAY_LENGTH(pval) - 1 LOOP
          arr_24_item := pval -> arr_24_idx;
          -- .'$Root'.'|'.4.'+'.0
          res := json_model_32(arr_24_item, NULL, rep);
          IF NOT res THEN
            EXIT;
          END IF;
        END LOOP;
      END IF;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = '~' THEN
      -- handle may ~ property
      -- .'$Root'.'|'.4.'~'
      res := json_model_2(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = '$' THEN
      -- handle may $ property
      -- .'$Root'.'|'.4.'$'
      res := _jm_obj_46(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = '%' THEN
      -- handle may % property
      -- .'$Root'.'|'.4.'%'
      res := _jm_obj_47(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = '#' THEN
      -- handle may # property
      -- .'$Root'.'|'.4.'#'
      res := JSONB_TYPEOF(pval) = 'string';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF STARTS_WITH(prop, '#') THEN
      -- handle 1 re props
      -- .'$Root'.'|'.4.'/^#/'
      res := TRUE;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  IF must_count <> 1 THEN
    RETURN FALSE;
  END IF;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- object .'$Root'.'|'.3.'$'
CREATE OR REPLACE FUNCTION _jm_obj_49(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = '#' THEN
      -- handle may # property
      -- .'$Root'.'|'.3.'$'.'#'
      res := JSONB_TYPEOF(pval) = 'string';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = '' THEN
      -- handle may  property
      -- .'$Root'.'|'.3.'$'.''
      res := json_model_2(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF json_model_4(TO_JSONB(prop), NULL, rep) THEN
      -- handle 1 key props
      -- .'$Root'.'|'.3.'$'.'$Identifier'
      res := json_model_32(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF STARTS_WITH(prop, '#') THEN
      -- handle 1 re props
      -- .'$Root'.'|'.3.'$'.'/^#/'
      res := TRUE;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- object .'$Root'.'|'.3.'%'
CREATE OR REPLACE FUNCTION _jm_obj_50(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
  arr_27_idx INT8;
  arr_27_item JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = '#' THEN
      -- handle may # property
      -- .'$Root'.'|'.3.'%'.'#'
      res := JSONB_TYPEOF(pval) = 'string';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = '<' THEN
      -- handle may < property
      -- .'$Root'.'|'.3.'%'.'<'
      -- .'$Root'.'|'.3.'%'.'<'.'|'.0
      res := json_model_7(pval, NULL, rep);
      IF NOT res THEN
        -- .'$Root'.'|'.3.'%'.'<'.'|'.1
        res := JSONB_TYPEOF(pval) = 'array';
        IF res THEN
          FOR arr_27_idx IN 0 .. JSONB_ARRAY_LENGTH(pval) - 1 LOOP
            arr_27_item := pval -> arr_27_idx;
            -- .'$Root'.'|'.3.'%'.'<'.'|'.1.0
            res := json_model_7(arr_27_item, NULL, rep);
            IF NOT res THEN
              EXIT;
            END IF;
          END LOOP;
        END IF;
      END IF;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF json_model_11(TO_JSONB(prop), NULL, rep) THEN
      -- handle 1 key props
      -- .'$Root'.'|'.3.'%'.'$Name'
      -- "/^([#|&^+/*@~=$%]|[<>!]=?)$/"
      res := JSONB_TYPEOF(pval) = 'string' AND _jm_re_10(JSON_VALUE(pval, '$' RETURNING TEXT), NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF STARTS_WITH(prop, '#') THEN
      -- handle 2 re props
      -- .'$Root'.'|'.3.'%'.'/^#/'
      res := TRUE;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF _jm_re_11(prop, path, rep) THEN
      -- handle 2 re props
      -- .'$Root'.'|'.3.'%'.'/^\\$.*$/'
      res := json_model_30(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- object .'$Root'.'|'.3
CREATE OR REPLACE FUNCTION _jm_obj_48(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  must_count int;
  prop TEXT;
  pval JSONB;
  arr_26_idx INT8;
  arr_26_item JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  must_count := 0;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = '^' THEN
      -- handle must ^ property
      must_count := must_count + 1;
      -- .'$Root'.'|'.3.'^'
      res := JSONB_TYPEOF(pval) = 'array';
      IF res THEN
        FOR arr_26_idx IN 0 .. JSONB_ARRAY_LENGTH(pval) - 1 LOOP
          arr_26_item := pval -> arr_26_idx;
          -- .'$Root'.'|'.3.'^'.0
          res := json_model_32(arr_26_item, NULL, rep);
          IF NOT res THEN
            EXIT;
          END IF;
        END LOOP;
      END IF;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = '~' THEN
      -- handle may ~ property
      -- .'$Root'.'|'.3.'~'
      res := json_model_2(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = '$' THEN
      -- handle may $ property
      -- .'$Root'.'|'.3.'$'
      res := _jm_obj_49(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = '%' THEN
      -- handle may % property
      -- .'$Root'.'|'.3.'%'
      res := _jm_obj_50(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = '#' THEN
      -- handle may # property
      -- .'$Root'.'|'.3.'#'
      res := JSONB_TYPEOF(pval) = 'string';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF STARTS_WITH(prop, '#') THEN
      -- handle 1 re props
      -- .'$Root'.'|'.3.'/^#/'
      res := TRUE;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  IF must_count <> 1 THEN
    RETURN FALSE;
  END IF;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- object .'$Root'.'|'.2.'$'
CREATE OR REPLACE FUNCTION _jm_obj_52(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = '#' THEN
      -- handle may # property
      -- .'$Root'.'|'.2.'$'.'#'
      res := JSONB_TYPEOF(pval) = 'string';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = '' THEN
      -- handle may  property
      -- .'$Root'.'|'.2.'$'.''
      res := json_model_2(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF json_model_4(TO_JSONB(prop), NULL, rep) THEN
      -- handle 1 key props
      -- .'$Root'.'|'.2.'$'.'$Identifier'
      res := json_model_32(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF STARTS_WITH(prop, '#') THEN
      -- handle 1 re props
      -- .'$Root'.'|'.2.'$'.'/^#/'
      res := TRUE;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- object .'$Root'.'|'.2.'%'
CREATE OR REPLACE FUNCTION _jm_obj_53(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
  arr_29_idx INT8;
  arr_29_item JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = '#' THEN
      -- handle may # property
      -- .'$Root'.'|'.2.'%'.'#'
      res := JSONB_TYPEOF(pval) = 'string';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = '<' THEN
      -- handle may < property
      -- .'$Root'.'|'.2.'%'.'<'
      -- .'$Root'.'|'.2.'%'.'<'.'|'.0
      res := json_model_7(pval, NULL, rep);
      IF NOT res THEN
        -- .'$Root'.'|'.2.'%'.'<'.'|'.1
        res := JSONB_TYPEOF(pval) = 'array';
        IF res THEN
          FOR arr_29_idx IN 0 .. JSONB_ARRAY_LENGTH(pval) - 1 LOOP
            arr_29_item := pval -> arr_29_idx;
            -- .'$Root'.'|'.2.'%'.'<'.'|'.1.0
            res := json_model_7(arr_29_item, NULL, rep);
            IF NOT res THEN
              EXIT;
            END IF;
          END LOOP;
        END IF;
      END IF;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF json_model_11(TO_JSONB(prop), NULL, rep) THEN
      -- handle 1 key props
      -- .'$Root'.'|'.2.'%'.'$Name'
      -- "/^([#|&^+/*@~=$%]|[<>!]=?)$/"
      res := JSONB_TYPEOF(pval) = 'string' AND _jm_re_10(JSON_VALUE(pval, '$' RETURNING TEXT), NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF STARTS_WITH(prop, '#') THEN
      -- handle 2 re props
      -- .'$Root'.'|'.2.'%'.'/^#/'
      res := TRUE;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF _jm_re_11(prop, path, rep) THEN
      -- handle 2 re props
      -- .'$Root'.'|'.2.'%'.'/^\\$.*$/'
      res := json_model_30(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- object .'$Root'.'|'.2
CREATE OR REPLACE FUNCTION _jm_obj_51(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  must_count int;
  prop TEXT;
  pval JSONB;
  arr_28_idx INT8;
  arr_28_item JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  must_count := 0;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = '&' THEN
      -- handle must & property
      must_count := must_count + 1;
      -- .'$Root'.'|'.2.'&'
      res := JSONB_TYPEOF(pval) = 'array';
      IF res THEN
        FOR arr_28_idx IN 0 .. JSONB_ARRAY_LENGTH(pval) - 1 LOOP
          arr_28_item := pval -> arr_28_idx;
          -- .'$Root'.'|'.2.'&'.0
          res := json_model_32(arr_28_item, NULL, rep);
          IF NOT res THEN
            EXIT;
          END IF;
        END LOOP;
      END IF;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = '~' THEN
      -- handle may ~ property
      -- .'$Root'.'|'.2.'~'
      res := json_model_2(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = '$' THEN
      -- handle may $ property
      -- .'$Root'.'|'.2.'$'
      res := _jm_obj_52(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = '%' THEN
      -- handle may % property
      -- .'$Root'.'|'.2.'%'
      res := _jm_obj_53(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = '#' THEN
      -- handle may # property
      -- .'$Root'.'|'.2.'#'
      res := JSONB_TYPEOF(pval) = 'string';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF STARTS_WITH(prop, '#') THEN
      -- handle 1 re props
      -- .'$Root'.'|'.2.'/^#/'
      res := TRUE;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  IF must_count <> 1 THEN
    RETURN FALSE;
  END IF;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- object .'$Root'.'|'.1.'$'
CREATE OR REPLACE FUNCTION _jm_obj_55(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = '#' THEN
      -- handle may # property
      -- .'$Root'.'|'.1.'$'.'#'
      res := JSONB_TYPEOF(pval) = 'string';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = '' THEN
      -- handle may  property
      -- .'$Root'.'|'.1.'$'.''
      res := json_model_2(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF json_model_4(TO_JSONB(prop), NULL, rep) THEN
      -- handle 1 key props
      -- .'$Root'.'|'.1.'$'.'$Identifier'
      res := json_model_32(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF STARTS_WITH(prop, '#') THEN
      -- handle 1 re props
      -- .'$Root'.'|'.1.'$'.'/^#/'
      res := TRUE;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- object .'$Root'.'|'.1.'%'
CREATE OR REPLACE FUNCTION _jm_obj_56(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
  arr_31_idx INT8;
  arr_31_item JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = '#' THEN
      -- handle may # property
      -- .'$Root'.'|'.1.'%'.'#'
      res := JSONB_TYPEOF(pval) = 'string';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = '<' THEN
      -- handle may < property
      -- .'$Root'.'|'.1.'%'.'<'
      -- .'$Root'.'|'.1.'%'.'<'.'|'.0
      res := json_model_7(pval, NULL, rep);
      IF NOT res THEN
        -- .'$Root'.'|'.1.'%'.'<'.'|'.1
        res := JSONB_TYPEOF(pval) = 'array';
        IF res THEN
          FOR arr_31_idx IN 0 .. JSONB_ARRAY_LENGTH(pval) - 1 LOOP
            arr_31_item := pval -> arr_31_idx;
            -- .'$Root'.'|'.1.'%'.'<'.'|'.1.0
            res := json_model_7(arr_31_item, NULL, rep);
            IF NOT res THEN
              EXIT;
            END IF;
          END LOOP;
        END IF;
      END IF;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF json_model_11(TO_JSONB(prop), NULL, rep) THEN
      -- handle 1 key props
      -- .'$Root'.'|'.1.'%'.'$Name'
      -- "/^([#|&^+/*@~=$%]|[<>!]=?)$/"
      res := JSONB_TYPEOF(pval) = 'string' AND _jm_re_10(JSON_VALUE(pval, '$' RETURNING TEXT), NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF STARTS_WITH(prop, '#') THEN
      -- handle 2 re props
      -- .'$Root'.'|'.1.'%'.'/^#/'
      res := TRUE;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF _jm_re_11(prop, path, rep) THEN
      -- handle 2 re props
      -- .'$Root'.'|'.1.'%'.'/^\\$.*$/'
      res := json_model_30(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- object .'$Root'.'|'.1
CREATE OR REPLACE FUNCTION _jm_obj_54(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  must_count int;
  prop TEXT;
  pval JSONB;
  arr_30_idx INT8;
  arr_30_item JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  must_count := 0;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = '|' THEN
      -- handle must | property
      must_count := must_count + 1;
      -- .'$Root'.'|'.1.'|'
      res := JSONB_TYPEOF(pval) = 'array';
      IF res THEN
        FOR arr_30_idx IN 0 .. JSONB_ARRAY_LENGTH(pval) - 1 LOOP
          arr_30_item := pval -> arr_30_idx;
          -- .'$Root'.'|'.1.'|'.0
          res := json_model_32(arr_30_item, NULL, rep);
          IF NOT res THEN
            EXIT;
          END IF;
        END LOOP;
      END IF;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = '~' THEN
      -- handle may ~ property
      -- .'$Root'.'|'.1.'~'
      res := json_model_2(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = '$' THEN
      -- handle may $ property
      -- .'$Root'.'|'.1.'$'
      res := _jm_obj_55(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = '%' THEN
      -- handle may % property
      -- .'$Root'.'|'.1.'%'
      res := _jm_obj_56(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = '#' THEN
      -- handle may # property
      -- .'$Root'.'|'.1.'#'
      res := JSONB_TYPEOF(pval) = 'string';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF STARTS_WITH(prop, '#') THEN
      -- handle 1 re props
      -- .'$Root'.'|'.1.'/^#/'
      res := TRUE;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  IF must_count <> 1 THEN
    RETURN FALSE;
  END IF;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- object .'$Root'.'|'.0.'$'
CREATE OR REPLACE FUNCTION _jm_obj_58(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = '#' THEN
      -- handle may # property
      -- .'$Root'.'|'.0.'$'.'#'
      res := JSONB_TYPEOF(pval) = 'string';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = '' THEN
      -- handle may  property
      -- .'$Root'.'|'.0.'$'.''
      res := json_model_2(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF json_model_4(TO_JSONB(prop), NULL, rep) THEN
      -- handle 1 key props
      -- .'$Root'.'|'.0.'$'.'$Identifier'
      res := json_model_32(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF STARTS_WITH(prop, '#') THEN
      -- handle 1 re props
      -- .'$Root'.'|'.0.'$'.'/^#/'
      res := TRUE;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- object .'$Root'.'|'.0.'%'
CREATE OR REPLACE FUNCTION _jm_obj_59(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
  arr_32_idx INT8;
  arr_32_item JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = '#' THEN
      -- handle may # property
      -- .'$Root'.'|'.0.'%'.'#'
      res := JSONB_TYPEOF(pval) = 'string';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = '<' THEN
      -- handle may < property
      -- .'$Root'.'|'.0.'%'.'<'
      -- .'$Root'.'|'.0.'%'.'<'.'|'.0
      res := json_model_7(pval, NULL, rep);
      IF NOT res THEN
        -- .'$Root'.'|'.0.'%'.'<'.'|'.1
        res := JSONB_TYPEOF(pval) = 'array';
        IF res THEN
          FOR arr_32_idx IN 0 .. JSONB_ARRAY_LENGTH(pval) - 1 LOOP
            arr_32_item := pval -> arr_32_idx;
            -- .'$Root'.'|'.0.'%'.'<'.'|'.1.0
            res := json_model_7(arr_32_item, NULL, rep);
            IF NOT res THEN
              EXIT;
            END IF;
          END LOOP;
        END IF;
      END IF;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF json_model_11(TO_JSONB(prop), NULL, rep) THEN
      -- handle 1 key props
      -- .'$Root'.'|'.0.'%'.'$Name'
      -- "/^([#|&^+/*@~=$%]|[<>!]=?)$/"
      res := JSONB_TYPEOF(pval) = 'string' AND _jm_re_10(JSON_VALUE(pval, '$' RETURNING TEXT), NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF STARTS_WITH(prop, '#') THEN
      -- handle 2 re props
      -- .'$Root'.'|'.0.'%'.'/^#/'
      res := TRUE;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF _jm_re_11(prop, path, rep) THEN
      -- handle 2 re props
      -- .'$Root'.'|'.0.'%'.'/^\\$.*$/'
      res := json_model_30(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- object .'$Root'.'|'.0
CREATE OR REPLACE FUNCTION _jm_obj_57(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  must_count int;
  prop TEXT;
  pval JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  must_count := 0;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = '@' THEN
      -- handle must @ property
      must_count := must_count + 1;
      -- .'$Root'.'|'.0.'@'
      res := json_model_32(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = '~' THEN
      -- handle may ~ property
      -- .'$Root'.'|'.0.'~'
      res := json_model_2(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = '$' THEN
      -- handle may $ property
      -- .'$Root'.'|'.0.'$'
      res := _jm_obj_58(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = '%' THEN
      -- handle may % property
      -- .'$Root'.'|'.0.'%'
      res := _jm_obj_59(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = '#' THEN
      -- handle may # property
      -- .'$Root'.'|'.0.'#'
      res := JSONB_TYPEOF(pval) = 'string';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = '!' THEN
      -- handle may ! property
      -- .'$Root'.'|'.0.'!'
      res := JSONB_TYPEOF(pval) = 'boolean';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF STARTS_WITH(prop, '#') THEN
      -- handle 3 re props
      -- .'$Root'.'|'.0.'/^#/'
      res := TRUE;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF _jm_re_7(prop, path, rep) THEN
      -- handle 3 re props
      -- .'$Root'.'|'.0.'/^(<=|>=|<|>)$/'
      res := json_model_12(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF _jm_re_8(prop, path, rep) THEN
      -- handle 3 re props
      -- .'$Root'.'|'.0.'/^(=|!=)$/'
      res := json_model_13(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  IF must_count <> 1 THEN
    RETURN FALSE;
  END IF;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- check $Root (.'$Root')
CREATE OR REPLACE FUNCTION json_model_38(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$Root'
  res := JSONB_TYPEOF(val) = 'object';
  IF res THEN
    -- .'$Root'.'|'.0
    res := _jm_obj_57(val, path, rep);
    IF NOT res THEN
      -- .'$Root'.'|'.1
      res := _jm_obj_54(val, path, rep);
      IF NOT res THEN
        -- .'$Root'.'|'.2
        res := _jm_obj_51(val, path, rep);
        IF NOT res THEN
          -- .'$Root'.'|'.3
          res := _jm_obj_48(val, path, rep);
          IF NOT res THEN
            -- .'$Root'.'|'.4
            res := _jm_obj_45(val, path, rep);
            IF NOT res THEN
              -- .'$Root'.'|'.5
              res := _jm_obj_42(val, path, rep);
            END IF;
          END IF;
        END IF;
      END IF;
    END IF;
  END IF;
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- object .'$RootModel'.'|'.5.'$'
CREATE OR REPLACE FUNCTION _jm_obj_61(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = '#' THEN
      -- handle may # property
      -- .'$RootModel'.'|'.5.'$'.'#'
      res := JSONB_TYPEOF(pval) = 'string';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = '' THEN
      -- handle may  property
      -- .'$RootModel'.'|'.5.'$'.''
      res := json_model_2(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF json_model_4(TO_JSONB(prop), NULL, rep) THEN
      -- handle 1 key props
      -- .'$RootModel'.'|'.5.'$'.'$Identifier'
      res := json_model_32(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF STARTS_WITH(prop, '#') THEN
      -- handle 1 re props
      -- .'$RootModel'.'|'.5.'$'.'/^#/'
      res := TRUE;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- object .'$RootModel'.'|'.5.'%'
CREATE OR REPLACE FUNCTION _jm_obj_62(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
  arr_33_idx INT8;
  arr_33_item JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = '#' THEN
      -- handle may # property
      -- .'$RootModel'.'|'.5.'%'.'#'
      res := JSONB_TYPEOF(pval) = 'string';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = '<' THEN
      -- handle may < property
      -- .'$RootModel'.'|'.5.'%'.'<'
      -- .'$RootModel'.'|'.5.'%'.'<'.'|'.0
      res := json_model_7(pval, NULL, rep);
      IF NOT res THEN
        -- .'$RootModel'.'|'.5.'%'.'<'.'|'.1
        res := JSONB_TYPEOF(pval) = 'array';
        IF res THEN
          FOR arr_33_idx IN 0 .. JSONB_ARRAY_LENGTH(pval) - 1 LOOP
            arr_33_item := pval -> arr_33_idx;
            -- .'$RootModel'.'|'.5.'%'.'<'.'|'.1.0
            res := json_model_7(arr_33_item, NULL, rep);
            IF NOT res THEN
              EXIT;
            END IF;
          END LOOP;
        END IF;
      END IF;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF json_model_11(TO_JSONB(prop), NULL, rep) THEN
      -- handle 1 key props
      -- .'$RootModel'.'|'.5.'%'.'$Name'
      -- "/^([#|&^+/*@~=$%]|[<>!]=?)$/"
      res := JSONB_TYPEOF(pval) = 'string' AND _jm_re_10(JSON_VALUE(pval, '$' RETURNING TEXT), NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF STARTS_WITH(prop, '#') THEN
      -- handle 2 re props
      -- .'$RootModel'.'|'.5.'%'.'/^#/'
      res := TRUE;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF _jm_re_11(prop, path, rep) THEN
      -- handle 2 re props
      -- .'$RootModel'.'|'.5.'%'.'/^\\$.*$/'
      res := json_model_30(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- object .'$RootModel'.'|'.5
CREATE OR REPLACE FUNCTION _jm_obj_60(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = '~' THEN
      -- handle may ~ property
      -- .'$RootModel'.'|'.5.'~'
      res := json_model_2(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = '$' THEN
      -- handle may $ property
      -- .'$RootModel'.'|'.5.'$'
      res := _jm_obj_61(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = '%' THEN
      -- handle may % property
      -- .'$RootModel'.'|'.5.'%'
      res := _jm_obj_62(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = '#' THEN
      -- handle may # property
      -- .'$RootModel'.'|'.5.'#'
      res := JSONB_TYPEOF(pval) = 'string';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF json_model_25(TO_JSONB(prop), NULL, rep) THEN
      -- handle 1 key props
      -- .'$RootModel'.'|'.5.'$Prop'
      res := json_model_32(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF STARTS_WITH(prop, '#') THEN
      -- handle 1 re props
      -- .'$RootModel'.'|'.5.'/^#/'
      res := TRUE;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- object .'$RootModel'.'|'.4.'$'
CREATE OR REPLACE FUNCTION _jm_obj_64(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = '#' THEN
      -- handle may # property
      -- .'$RootModel'.'|'.4.'$'.'#'
      res := JSONB_TYPEOF(pval) = 'string';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = '' THEN
      -- handle may  property
      -- .'$RootModel'.'|'.4.'$'.''
      res := json_model_2(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF json_model_4(TO_JSONB(prop), NULL, rep) THEN
      -- handle 1 key props
      -- .'$RootModel'.'|'.4.'$'.'$Identifier'
      res := json_model_32(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF STARTS_WITH(prop, '#') THEN
      -- handle 1 re props
      -- .'$RootModel'.'|'.4.'$'.'/^#/'
      res := TRUE;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- object .'$RootModel'.'|'.4.'%'
CREATE OR REPLACE FUNCTION _jm_obj_65(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
  arr_35_idx INT8;
  arr_35_item JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = '#' THEN
      -- handle may # property
      -- .'$RootModel'.'|'.4.'%'.'#'
      res := JSONB_TYPEOF(pval) = 'string';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = '<' THEN
      -- handle may < property
      -- .'$RootModel'.'|'.4.'%'.'<'
      -- .'$RootModel'.'|'.4.'%'.'<'.'|'.0
      res := json_model_7(pval, NULL, rep);
      IF NOT res THEN
        -- .'$RootModel'.'|'.4.'%'.'<'.'|'.1
        res := JSONB_TYPEOF(pval) = 'array';
        IF res THEN
          FOR arr_35_idx IN 0 .. JSONB_ARRAY_LENGTH(pval) - 1 LOOP
            arr_35_item := pval -> arr_35_idx;
            -- .'$RootModel'.'|'.4.'%'.'<'.'|'.1.0
            res := json_model_7(arr_35_item, NULL, rep);
            IF NOT res THEN
              EXIT;
            END IF;
          END LOOP;
        END IF;
      END IF;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF json_model_11(TO_JSONB(prop), NULL, rep) THEN
      -- handle 1 key props
      -- .'$RootModel'.'|'.4.'%'.'$Name'
      -- "/^([#|&^+/*@~=$%]|[<>!]=?)$/"
      res := JSONB_TYPEOF(pval) = 'string' AND _jm_re_10(JSON_VALUE(pval, '$' RETURNING TEXT), NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF STARTS_WITH(prop, '#') THEN
      -- handle 2 re props
      -- .'$RootModel'.'|'.4.'%'.'/^#/'
      res := TRUE;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF _jm_re_11(prop, path, rep) THEN
      -- handle 2 re props
      -- .'$RootModel'.'|'.4.'%'.'/^\\$.*$/'
      res := json_model_30(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- object .'$RootModel'.'|'.4
CREATE OR REPLACE FUNCTION _jm_obj_63(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  must_count int;
  prop TEXT;
  pval JSONB;
  arr_34_idx INT8;
  arr_34_item JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  must_count := 0;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = '+' THEN
      -- handle must + property
      must_count := must_count + 1;
      -- .'$RootModel'.'|'.4.'+'
      res := JSONB_TYPEOF(pval) = 'array';
      IF res THEN
        FOR arr_34_idx IN 0 .. JSONB_ARRAY_LENGTH(pval) - 1 LOOP
          arr_34_item := pval -> arr_34_idx;
          -- .'$RootModel'.'|'.4.'+'.0
          res := json_model_32(arr_34_item, NULL, rep);
          IF NOT res THEN
            EXIT;
          END IF;
        END LOOP;
      END IF;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = '~' THEN
      -- handle may ~ property
      -- .'$RootModel'.'|'.4.'~'
      res := json_model_2(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = '$' THEN
      -- handle may $ property
      -- .'$RootModel'.'|'.4.'$'
      res := _jm_obj_64(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = '%' THEN
      -- handle may % property
      -- .'$RootModel'.'|'.4.'%'
      res := _jm_obj_65(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = '#' THEN
      -- handle may # property
      -- .'$RootModel'.'|'.4.'#'
      res := JSONB_TYPEOF(pval) = 'string';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF STARTS_WITH(prop, '#') THEN
      -- handle 1 re props
      -- .'$RootModel'.'|'.4.'/^#/'
      res := TRUE;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  IF must_count <> 1 THEN
    RETURN FALSE;
  END IF;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- object .'$RootModel'.'|'.3.'$'
CREATE OR REPLACE FUNCTION _jm_obj_67(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = '#' THEN
      -- handle may # property
      -- .'$RootModel'.'|'.3.'$'.'#'
      res := JSONB_TYPEOF(pval) = 'string';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = '' THEN
      -- handle may  property
      -- .'$RootModel'.'|'.3.'$'.''
      res := json_model_2(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF json_model_4(TO_JSONB(prop), NULL, rep) THEN
      -- handle 1 key props
      -- .'$RootModel'.'|'.3.'$'.'$Identifier'
      res := json_model_32(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF STARTS_WITH(prop, '#') THEN
      -- handle 1 re props
      -- .'$RootModel'.'|'.3.'$'.'/^#/'
      res := TRUE;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- object .'$RootModel'.'|'.3.'%'
CREATE OR REPLACE FUNCTION _jm_obj_68(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
  arr_37_idx INT8;
  arr_37_item JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = '#' THEN
      -- handle may # property
      -- .'$RootModel'.'|'.3.'%'.'#'
      res := JSONB_TYPEOF(pval) = 'string';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = '<' THEN
      -- handle may < property
      -- .'$RootModel'.'|'.3.'%'.'<'
      -- .'$RootModel'.'|'.3.'%'.'<'.'|'.0
      res := json_model_7(pval, NULL, rep);
      IF NOT res THEN
        -- .'$RootModel'.'|'.3.'%'.'<'.'|'.1
        res := JSONB_TYPEOF(pval) = 'array';
        IF res THEN
          FOR arr_37_idx IN 0 .. JSONB_ARRAY_LENGTH(pval) - 1 LOOP
            arr_37_item := pval -> arr_37_idx;
            -- .'$RootModel'.'|'.3.'%'.'<'.'|'.1.0
            res := json_model_7(arr_37_item, NULL, rep);
            IF NOT res THEN
              EXIT;
            END IF;
          END LOOP;
        END IF;
      END IF;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF json_model_11(TO_JSONB(prop), NULL, rep) THEN
      -- handle 1 key props
      -- .'$RootModel'.'|'.3.'%'.'$Name'
      -- "/^([#|&^+/*@~=$%]|[<>!]=?)$/"
      res := JSONB_TYPEOF(pval) = 'string' AND _jm_re_10(JSON_VALUE(pval, '$' RETURNING TEXT), NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF STARTS_WITH(prop, '#') THEN
      -- handle 2 re props
      -- .'$RootModel'.'|'.3.'%'.'/^#/'
      res := TRUE;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF _jm_re_11(prop, path, rep) THEN
      -- handle 2 re props
      -- .'$RootModel'.'|'.3.'%'.'/^\\$.*$/'
      res := json_model_30(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- object .'$RootModel'.'|'.3
CREATE OR REPLACE FUNCTION _jm_obj_66(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  must_count int;
  prop TEXT;
  pval JSONB;
  arr_36_idx INT8;
  arr_36_item JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  must_count := 0;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = '^' THEN
      -- handle must ^ property
      must_count := must_count + 1;
      -- .'$RootModel'.'|'.3.'^'
      res := JSONB_TYPEOF(pval) = 'array';
      IF res THEN
        FOR arr_36_idx IN 0 .. JSONB_ARRAY_LENGTH(pval) - 1 LOOP
          arr_36_item := pval -> arr_36_idx;
          -- .'$RootModel'.'|'.3.'^'.0
          res := json_model_32(arr_36_item, NULL, rep);
          IF NOT res THEN
            EXIT;
          END IF;
        END LOOP;
      END IF;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = '~' THEN
      -- handle may ~ property
      -- .'$RootModel'.'|'.3.'~'
      res := json_model_2(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = '$' THEN
      -- handle may $ property
      -- .'$RootModel'.'|'.3.'$'
      res := _jm_obj_67(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = '%' THEN
      -- handle may % property
      -- .'$RootModel'.'|'.3.'%'
      res := _jm_obj_68(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = '#' THEN
      -- handle may # property
      -- .'$RootModel'.'|'.3.'#'
      res := JSONB_TYPEOF(pval) = 'string';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF STARTS_WITH(prop, '#') THEN
      -- handle 1 re props
      -- .'$RootModel'.'|'.3.'/^#/'
      res := TRUE;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  IF must_count <> 1 THEN
    RETURN FALSE;
  END IF;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- object .'$RootModel'.'|'.2.'$'
CREATE OR REPLACE FUNCTION _jm_obj_70(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = '#' THEN
      -- handle may # property
      -- .'$RootModel'.'|'.2.'$'.'#'
      res := JSONB_TYPEOF(pval) = 'string';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = '' THEN
      -- handle may  property
      -- .'$RootModel'.'|'.2.'$'.''
      res := json_model_2(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF json_model_4(TO_JSONB(prop), NULL, rep) THEN
      -- handle 1 key props
      -- .'$RootModel'.'|'.2.'$'.'$Identifier'
      res := json_model_32(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF STARTS_WITH(prop, '#') THEN
      -- handle 1 re props
      -- .'$RootModel'.'|'.2.'$'.'/^#/'
      res := TRUE;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- object .'$RootModel'.'|'.2.'%'
CREATE OR REPLACE FUNCTION _jm_obj_71(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
  arr_39_idx INT8;
  arr_39_item JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = '#' THEN
      -- handle may # property
      -- .'$RootModel'.'|'.2.'%'.'#'
      res := JSONB_TYPEOF(pval) = 'string';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = '<' THEN
      -- handle may < property
      -- .'$RootModel'.'|'.2.'%'.'<'
      -- .'$RootModel'.'|'.2.'%'.'<'.'|'.0
      res := json_model_7(pval, NULL, rep);
      IF NOT res THEN
        -- .'$RootModel'.'|'.2.'%'.'<'.'|'.1
        res := JSONB_TYPEOF(pval) = 'array';
        IF res THEN
          FOR arr_39_idx IN 0 .. JSONB_ARRAY_LENGTH(pval) - 1 LOOP
            arr_39_item := pval -> arr_39_idx;
            -- .'$RootModel'.'|'.2.'%'.'<'.'|'.1.0
            res := json_model_7(arr_39_item, NULL, rep);
            IF NOT res THEN
              EXIT;
            END IF;
          END LOOP;
        END IF;
      END IF;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF json_model_11(TO_JSONB(prop), NULL, rep) THEN
      -- handle 1 key props
      -- .'$RootModel'.'|'.2.'%'.'$Name'
      -- "/^([#|&^+/*@~=$%]|[<>!]=?)$/"
      res := JSONB_TYPEOF(pval) = 'string' AND _jm_re_10(JSON_VALUE(pval, '$' RETURNING TEXT), NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF STARTS_WITH(prop, '#') THEN
      -- handle 2 re props
      -- .'$RootModel'.'|'.2.'%'.'/^#/'
      res := TRUE;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF _jm_re_11(prop, path, rep) THEN
      -- handle 2 re props
      -- .'$RootModel'.'|'.2.'%'.'/^\\$.*$/'
      res := json_model_30(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- object .'$RootModel'.'|'.2
CREATE OR REPLACE FUNCTION _jm_obj_69(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  must_count int;
  prop TEXT;
  pval JSONB;
  arr_38_idx INT8;
  arr_38_item JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  must_count := 0;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = '&' THEN
      -- handle must & property
      must_count := must_count + 1;
      -- .'$RootModel'.'|'.2.'&'
      res := JSONB_TYPEOF(pval) = 'array';
      IF res THEN
        FOR arr_38_idx IN 0 .. JSONB_ARRAY_LENGTH(pval) - 1 LOOP
          arr_38_item := pval -> arr_38_idx;
          -- .'$RootModel'.'|'.2.'&'.0
          res := json_model_32(arr_38_item, NULL, rep);
          IF NOT res THEN
            EXIT;
          END IF;
        END LOOP;
      END IF;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = '~' THEN
      -- handle may ~ property
      -- .'$RootModel'.'|'.2.'~'
      res := json_model_2(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = '$' THEN
      -- handle may $ property
      -- .'$RootModel'.'|'.2.'$'
      res := _jm_obj_70(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = '%' THEN
      -- handle may % property
      -- .'$RootModel'.'|'.2.'%'
      res := _jm_obj_71(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = '#' THEN
      -- handle may # property
      -- .'$RootModel'.'|'.2.'#'
      res := JSONB_TYPEOF(pval) = 'string';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF STARTS_WITH(prop, '#') THEN
      -- handle 1 re props
      -- .'$RootModel'.'|'.2.'/^#/'
      res := TRUE;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  IF must_count <> 1 THEN
    RETURN FALSE;
  END IF;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- object .'$RootModel'.'|'.1.'$'
CREATE OR REPLACE FUNCTION _jm_obj_73(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = '#' THEN
      -- handle may # property
      -- .'$RootModel'.'|'.1.'$'.'#'
      res := JSONB_TYPEOF(pval) = 'string';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = '' THEN
      -- handle may  property
      -- .'$RootModel'.'|'.1.'$'.''
      res := json_model_2(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF json_model_4(TO_JSONB(prop), NULL, rep) THEN
      -- handle 1 key props
      -- .'$RootModel'.'|'.1.'$'.'$Identifier'
      res := json_model_32(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF STARTS_WITH(prop, '#') THEN
      -- handle 1 re props
      -- .'$RootModel'.'|'.1.'$'.'/^#/'
      res := TRUE;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- object .'$RootModel'.'|'.1.'%'
CREATE OR REPLACE FUNCTION _jm_obj_74(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
  arr_41_idx INT8;
  arr_41_item JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = '#' THEN
      -- handle may # property
      -- .'$RootModel'.'|'.1.'%'.'#'
      res := JSONB_TYPEOF(pval) = 'string';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = '<' THEN
      -- handle may < property
      -- .'$RootModel'.'|'.1.'%'.'<'
      -- .'$RootModel'.'|'.1.'%'.'<'.'|'.0
      res := json_model_7(pval, NULL, rep);
      IF NOT res THEN
        -- .'$RootModel'.'|'.1.'%'.'<'.'|'.1
        res := JSONB_TYPEOF(pval) = 'array';
        IF res THEN
          FOR arr_41_idx IN 0 .. JSONB_ARRAY_LENGTH(pval) - 1 LOOP
            arr_41_item := pval -> arr_41_idx;
            -- .'$RootModel'.'|'.1.'%'.'<'.'|'.1.0
            res := json_model_7(arr_41_item, NULL, rep);
            IF NOT res THEN
              EXIT;
            END IF;
          END LOOP;
        END IF;
      END IF;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF json_model_11(TO_JSONB(prop), NULL, rep) THEN
      -- handle 1 key props
      -- .'$RootModel'.'|'.1.'%'.'$Name'
      -- "/^([#|&^+/*@~=$%]|[<>!]=?)$/"
      res := JSONB_TYPEOF(pval) = 'string' AND _jm_re_10(JSON_VALUE(pval, '$' RETURNING TEXT), NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF STARTS_WITH(prop, '#') THEN
      -- handle 2 re props
      -- .'$RootModel'.'|'.1.'%'.'/^#/'
      res := TRUE;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF _jm_re_11(prop, path, rep) THEN
      -- handle 2 re props
      -- .'$RootModel'.'|'.1.'%'.'/^\\$.*$/'
      res := json_model_30(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- object .'$RootModel'.'|'.1
CREATE OR REPLACE FUNCTION _jm_obj_72(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  must_count int;
  prop TEXT;
  pval JSONB;
  arr_40_idx INT8;
  arr_40_item JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  must_count := 0;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = '|' THEN
      -- handle must | property
      must_count := must_count + 1;
      -- .'$RootModel'.'|'.1.'|'
      res := JSONB_TYPEOF(pval) = 'array';
      IF res THEN
        FOR arr_40_idx IN 0 .. JSONB_ARRAY_LENGTH(pval) - 1 LOOP
          arr_40_item := pval -> arr_40_idx;
          -- .'$RootModel'.'|'.1.'|'.0
          res := json_model_32(arr_40_item, NULL, rep);
          IF NOT res THEN
            EXIT;
          END IF;
        END LOOP;
      END IF;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = '~' THEN
      -- handle may ~ property
      -- .'$RootModel'.'|'.1.'~'
      res := json_model_2(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = '$' THEN
      -- handle may $ property
      -- .'$RootModel'.'|'.1.'$'
      res := _jm_obj_73(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = '%' THEN
      -- handle may % property
      -- .'$RootModel'.'|'.1.'%'
      res := _jm_obj_74(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = '#' THEN
      -- handle may # property
      -- .'$RootModel'.'|'.1.'#'
      res := JSONB_TYPEOF(pval) = 'string';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF STARTS_WITH(prop, '#') THEN
      -- handle 1 re props
      -- .'$RootModel'.'|'.1.'/^#/'
      res := TRUE;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  IF must_count <> 1 THEN
    RETURN FALSE;
  END IF;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- object .'$RootModel'.'|'.0.'$'
CREATE OR REPLACE FUNCTION _jm_obj_76(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = '#' THEN
      -- handle may # property
      -- .'$RootModel'.'|'.0.'$'.'#'
      res := JSONB_TYPEOF(pval) = 'string';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = '' THEN
      -- handle may  property
      -- .'$RootModel'.'|'.0.'$'.''
      res := json_model_2(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF json_model_4(TO_JSONB(prop), NULL, rep) THEN
      -- handle 1 key props
      -- .'$RootModel'.'|'.0.'$'.'$Identifier'
      res := json_model_32(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF STARTS_WITH(prop, '#') THEN
      -- handle 1 re props
      -- .'$RootModel'.'|'.0.'$'.'/^#/'
      res := TRUE;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- object .'$RootModel'.'|'.0.'%'
CREATE OR REPLACE FUNCTION _jm_obj_77(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  prop TEXT;
  pval JSONB;
  arr_42_idx INT8;
  arr_42_item JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = '#' THEN
      -- handle may # property
      -- .'$RootModel'.'|'.0.'%'.'#'
      res := JSONB_TYPEOF(pval) = 'string';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = '<' THEN
      -- handle may < property
      -- .'$RootModel'.'|'.0.'%'.'<'
      -- .'$RootModel'.'|'.0.'%'.'<'.'|'.0
      res := json_model_7(pval, NULL, rep);
      IF NOT res THEN
        -- .'$RootModel'.'|'.0.'%'.'<'.'|'.1
        res := JSONB_TYPEOF(pval) = 'array';
        IF res THEN
          FOR arr_42_idx IN 0 .. JSONB_ARRAY_LENGTH(pval) - 1 LOOP
            arr_42_item := pval -> arr_42_idx;
            -- .'$RootModel'.'|'.0.'%'.'<'.'|'.1.0
            res := json_model_7(arr_42_item, NULL, rep);
            IF NOT res THEN
              EXIT;
            END IF;
          END LOOP;
        END IF;
      END IF;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF json_model_11(TO_JSONB(prop), NULL, rep) THEN
      -- handle 1 key props
      -- .'$RootModel'.'|'.0.'%'.'$Name'
      -- "/^([#|&^+/*@~=$%]|[<>!]=?)$/"
      res := JSONB_TYPEOF(pval) = 'string' AND _jm_re_10(JSON_VALUE(pval, '$' RETURNING TEXT), NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF STARTS_WITH(prop, '#') THEN
      -- handle 2 re props
      -- .'$RootModel'.'|'.0.'%'.'/^#/'
      res := TRUE;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF _jm_re_11(prop, path, rep) THEN
      -- handle 2 re props
      -- .'$RootModel'.'|'.0.'%'.'/^\\$.*$/'
      res := json_model_30(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

-- object .'$RootModel'.'|'.0
CREATE OR REPLACE FUNCTION _jm_obj_75(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
  must_count int;
  prop TEXT;
  pval JSONB;
BEGIN
  IF NOT (JSONB_TYPEOF(val) = 'object') THEN
    RETURN FALSE;
  END IF;
  must_count := 0;
  FOR prop, pval IN SELECT * FROM JSONB_EACH(val) LOOP
    IF prop = '@' THEN
      -- handle must @ property
      must_count := must_count + 1;
      -- .'$RootModel'.'|'.0.'@'
      res := json_model_32(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = '~' THEN
      -- handle may ~ property
      -- .'$RootModel'.'|'.0.'~'
      res := json_model_2(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = '$' THEN
      -- handle may $ property
      -- .'$RootModel'.'|'.0.'$'
      res := _jm_obj_76(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = '%' THEN
      -- handle may % property
      -- .'$RootModel'.'|'.0.'%'
      res := _jm_obj_77(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = '#' THEN
      -- handle may # property
      -- .'$RootModel'.'|'.0.'#'
      res := JSONB_TYPEOF(pval) = 'string';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF prop = '!' THEN
      -- handle may ! property
      -- .'$RootModel'.'|'.0.'!'
      res := JSONB_TYPEOF(pval) = 'boolean';
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF STARTS_WITH(prop, '#') THEN
      -- handle 3 re props
      -- .'$RootModel'.'|'.0.'/^#/'
      res := TRUE;
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF _jm_re_7(prop, path, rep) THEN
      -- handle 3 re props
      -- .'$RootModel'.'|'.0.'/^(<=|>=|<|>)$/'
      res := json_model_12(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSEIF _jm_re_8(prop, path, rep) THEN
      -- handle 3 re props
      -- .'$RootModel'.'|'.0.'/^(=|!=)$/'
      res := json_model_13(pval, NULL, rep);
      IF NOT res THEN
        RETURN FALSE;
      END IF;
    ELSE
      RETURN FALSE;
    END IF;
  END LOOP;
  IF must_count <> 1 THEN
    RETURN FALSE;
  END IF;
  RETURN TRUE;
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION _jm_cst_7(value JSONB)
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  constants JSONB = JSONB '[null,true,0,1,-1,0.0,1.0,-1.0,"$DATE","$TIME","$DATETIME","$URL","$URI","$UUID","$EMAIL","$REGEX","$EXREG","$NULL","$BOOL","$FLOAT","$F16","$F32","$F64","$NUMBER","$INT","$INTEGER","$I8","$I16","$I32","$I64","$U8","$U16","$U32","$U64","$STRING","$NONE","$ANY",""]';
BEGIN
  RETURN constants @> value;
END;
$$ LANGUAGE plpgsql;

-- check $RootModel (.'$RootModel')
CREATE OR REPLACE FUNCTION json_model_39(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .'$RootModel'
  res := JSONB_TYPEOF(val) = 'object';
  IF res THEN
    -- .'$RootModel'.'|'.0
    res := _jm_obj_75(val, path, rep);
    IF NOT res THEN
      -- .'$RootModel'.'|'.1
      res := _jm_obj_72(val, path, rep);
      IF NOT res THEN
        -- .'$RootModel'.'|'.2
        res := _jm_obj_69(val, path, rep);
        IF NOT res THEN
          -- .'$RootModel'.'|'.3
          res := _jm_obj_66(val, path, rep);
          IF NOT res THEN
            -- .'$RootModel'.'|'.4
            res := _jm_obj_63(val, path, rep);
            IF NOT res THEN
              -- .'$RootModel'.'|'.5
              res := _jm_obj_60(val, path, rep);
            END IF;
          END IF;
        END IF;
      END IF;
    END IF;
  END IF;
  IF NOT res THEN
    res := JSONB_TYPEOF(val) IN ('null', 'boolean', 'number', 'string') AND _jm_cst_7(val);
    IF NOT res THEN
      -- .'$RootModel'.'|'.0
      res := json_model_9(val, path, rep);
      IF NOT res THEN
        -- .'$RootModel'.'|'.1
        res := json_model_8(val, path, rep);
        IF NOT res THEN
          -- .'$RootModel'.'|'.2
          -- "/^/($EXREG)/[a-z]*X[a-z]*$/X"
          res := JSONB_TYPEOF(val) = 'string' AND _jm_xre_1(JSON_VALUE(val, '$' RETURNING TEXT), path, rep);
          IF NOT res THEN
            -- .'$RootModel'.'|'.3
            -- "/^/($REGEX)/[a-z]*$/X"
            res := JSONB_TYPEOF(val) = 'string' AND _jm_xre_0(JSON_VALUE(val, '$' RETURNING TEXT), path, rep);
            IF NOT res THEN
              -- .'$RootModel'.'|'.4
              res := json_model_7(val, path, rep);
              IF NOT res THEN
                -- .'$RootModel'.'|'.5
                res := json_model_18(val, path, rep);
              END IF;
            END IF;
          END IF;
        END IF;
      END IF;
    END IF;
  END IF;
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

-- check $ (.)
CREATE OR REPLACE FUNCTION json_model_1(val JSONB, path TEXT[], rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  res bool;
BEGIN
  -- .
  res := json_model_39(val, path, rep);
  RETURN res;
END;
$$ LANGUAGE PLpgSQL;

CREATE OR REPLACE FUNCTION check_model_map(name TEXT)
RETURNS TEXT STRICT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  map JSONB := JSONB '{"":"json_model_39","Url":"json_model_2","PreDef":"json_model_3","Identifier":"json_model_4","ArrayComment":"json_model_5","ObjectComment":"json_model_6","Ref":"json_model_7","ValConst":"json_model_8","StrConst":"json_model_9","Regex":"json_model_10","Name":"json_model_11","CmpValue":"json_model_12","EqValue":"json_model_13","ValModel":"json_model_14","StrModel":"json_model_15","Any":"json_model_16","None":"json_model_17","Array":"json_model_18","Common":"json_model_6","Constraint":"json_model_20","Or":"json_model_21","And":"json_model_22","Xor":"json_model_23","Add":"json_model_24","Prop":"json_model_25","Obj":"json_model_26","Elem":"json_model_27","Element":"json_model_28","Trafo":"json_model_29","Transformation":"json_model_30","ScalarModel":"json_model_31","Model":"json_model_32","Defs":"json_model_33","Rename":"json_model_34","Rewrite":"json_model_35","Import":"json_model_36","RootOnly":"json_model_37","Root":"json_model_38","RootModel":"json_model_39"}';
BEGIN
  RETURN map->>name;
END;
$$ LANGUAGE plpgsql;

--
-- constant maps initialization
--
TRUNCATE jm_constant_maps;

--
-- JSON Model checking entry point
--
-- TODO INOUT rep?
CREATE OR REPLACE FUNCTION check_model(val JSONB, name TEXT, rep jm_report_entry[])
RETURNS BOOLEAN CALLED ON NULL INPUT IMMUTABLE PARALLEL SAFE AS $$
DECLARE
  fun TEXT;
BEGIN
  fun := check_model_map(name);
  IF fun IS NULL THEN
    RAISE EXCEPTION 'model for % not found', name;
  END IF;
  RETURN jm_call(fun, val, NULL, rep);
END;
$$ LANGUAGE plpgsql;
