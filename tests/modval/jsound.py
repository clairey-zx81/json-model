#! /bin/env python
#
# Model: ./jsound.model.json
#
# Generated by jmc (JSON Model Compiler) (https://github.com/clairey-zx81/json-model)
#

from typing import Callable
import re as re
import datetime
import urllib.parse

type Jsonable = None|bool|int|float|str|list[Jsonable]|dict[str, Jsonable]
type Path = list[str]
type Report = list[str]|None
type CheckFun = Callable[[Jsonable, str, Report], bool]
type PropMap = dict[str, CheckFun]
type TagMap = dict[None|bool|float|int|str, CheckFun]

# extract type name
def _tname(value: Jsonable) -> str:
    return type(value).__name__

# maybe add message to report
def _rep(msg: str, rep: Report) -> bool:
    rep is None or rep.append(msg)
    return False

json_model_2_must: PropMap
json_model_2_may: PropMap
jm_f_1_may: PropMap
json_model_6_must: PropMap
json_model_6_may: PropMap
json_model_7_must: PropMap
json_model_7_may: PropMap
json_model_8_must: PropMap
json_model_8_may: PropMap
json_model_9_must: PropMap
json_model_9_may: PropMap
json_model_10_must: PropMap
json_model_10_may: PropMap

# define "json_model_2_must_types" ($.'$Schema'.types)
def jm_f_0(value: Jsonable, path: str, rep: Report = None) -> bool:
    # $.'$Schema'.types
    result = isinstance(value, list)
    if result:
        for array_0_idx, array_0_item in enumerate(value):
            lpath = path + '.' + str(array_0_idx)
            # $.'$Schema'.types.0
            result = json_model_3(array_0_item, path, rep)
            if not result:
                rep is None or rep.append(f"not an expected $Type at {lpath} [$.'$Schema'.types.0]")
            if not result:
                break
    if not result:
        rep is None or rep.append(f"not array or unexpected array at {path} [$.'$Schema'.types]")
    return result

# define "jm_f_1_may_name" ($.'$Schema'.metadata.name)
def jm_f_2(value: Jsonable, path: str, rep: Report = None) -> bool:
    # $.'$Schema'.metadata.name
    result = isinstance(value, str)
    if not result:
        rep is None or rep.append(f"not an expected string at {path} [$.'$Schema'.metadata.name]")
    return result

# define "jm_f_1_may_previous" ($.'$Schema'.metadata.previous)
def jm_f_3(value: Jsonable, path: str, rep: Report = None) -> bool:
    # $.'$Schema'.metadata.previous
    result = isinstance(value, str)
    if not result:
        rep is None or rep.append(f"not an expected string at {path} [$.'$Schema'.metadata.previous]")
    return result

# define "jm_f_1_may_date" ($.'$Schema'.metadata.date)
def jm_f_4(value: Jsonable, path: str, rep: Report = None) -> bool:
    # $.'$Schema'.metadata.date
    result = isinstance(value, str)
    if not result:
        rep is None or rep.append(f"not an expected string at {path} [$.'$Schema'.metadata.date]")
    return result

# define "jm_f_1_may_authors" ($.'$Schema'.metadata.authors)
def jm_f_5(value: Jsonable, path: str, rep: Report = None) -> bool:
    # $.'$Schema'.metadata.authors
    result = isinstance(value, list)
    if result:
        for array_1_idx, array_1_item in enumerate(value):
            lpath = path + '.' + str(array_1_idx)
            # $.'$Schema'.metadata.authors.0
            result = isinstance(array_1_item, str)
            if not result:
                rep is None or rep.append(f"not an expected string at {lpath} [$.'$Schema'.metadata.authors.0]")
            if not result:
                break
    if not result:
        rep is None or rep.append(f"not array or unexpected array at {path} [$.'$Schema'.metadata.authors]")
    return result



# define "json_model_6_must_kind" ($.'$Atomic'.kind)
def jm_f_6(value: Jsonable, path: str, rep: Report = None) -> bool:
    # $.'$Atomic'.kind
    result = isinstance(value, str) and value == "atomic"
    if not result:
        rep is None or rep.append(f"not an expected atomic at {path} [$.'$Atomic'.kind]")
    return result

# define "json_model_6_must_baseType" ($.'$Atomic'.baseType)
def jm_f_7(value: Jsonable, path: str, rep: Report = None) -> bool:
    # $.'$Atomic'.baseType
    result = json_model_4(value, path, rep)
    if not result:
        rep is None or rep.append(f"not an expected $atomic-types at {path} [$.'$Atomic'.baseType]")
    return result

# define "json_model_6_may_name" ($.'$Atomic'.name)
def jm_f_8(value: Jsonable, path: str, rep: Report = None) -> bool:
    # $.'$Atomic'.name
    result = isinstance(value, str)
    if not result:
        rep is None or rep.append(f"not an expected string at {path} [$.'$Atomic'.name]")
    return result

# define "json_model_6_may_pattern" ($.'$Atomic'.pattern)
def jm_f_9(value: Jsonable, path: str, rep: Report = None) -> bool:
    # $.'$Atomic'.pattern
    result = isinstance(value, str)
    if not result:
        rep is None or rep.append(f"not an expected string at {path} [$.'$Atomic'.pattern]")
    return result

# define "json_model_6_may_length" ($.'$Atomic'.length)
def jm_f_10(value: Jsonable, path: str, rep: Report = None) -> bool:
    # $.'$Atomic'.length
    result = isinstance(value, int) and not isinstance(value, bool) and value >= 0
    if not result:
        rep is None or rep.append(f"not a 0 int at {path} [$.'$Atomic'.length]")
    return result

# define "json_model_6_may_minLength" ($.'$Atomic'.minLength)
def jm_f_11(value: Jsonable, path: str, rep: Report = None) -> bool:
    # $.'$Atomic'.minLength
    result = isinstance(value, int) and not isinstance(value, bool) and value >= 0
    if not result:
        rep is None or rep.append(f"not a 0 int at {path} [$.'$Atomic'.minLength]")
    return result

# define "json_model_6_may_maxLength" ($.'$Atomic'.maxLength)
def jm_f_12(value: Jsonable, path: str, rep: Report = None) -> bool:
    # $.'$Atomic'.maxLength
    result = isinstance(value, int) and not isinstance(value, bool) and value >= 0
    if not result:
        rep is None or rep.append(f"not a 0 int at {path} [$.'$Atomic'.maxLength]")
    return result

# define "json_model_6_may_totalDigits" ($.'$Atomic'.totalDigits)
def jm_f_13(value: Jsonable, path: str, rep: Report = None) -> bool:
    # $.'$Atomic'.totalDigits
    result = isinstance(value, int) and not isinstance(value, bool) and value >= 0
    if not result:
        rep is None or rep.append(f"not a 0 int at {path} [$.'$Atomic'.totalDigits]")
    return result

# define "json_model_6_may_fractionDigits" ($.'$Atomic'.fractionDigits)
def jm_f_14(value: Jsonable, path: str, rep: Report = None) -> bool:
    # $.'$Atomic'.fractionDigits
    result = isinstance(value, int) and not isinstance(value, bool) and value >= 0
    if not result:
        rep is None or rep.append(f"not a 0 int at {path} [$.'$Atomic'.fractionDigits]")
    return result

# define "json_model_6_may_maxInclusive" ($.'$Atomic'.maxInclusive)
def jm_f_15(value: Jsonable, path: str, rep: Report = None) -> bool:
    # $.'$Atomic'.maxInclusive
    result = json_model_5(value, path, rep)
    if not result:
        rep is None or rep.append(f"not an expected $atomic at {path} [$.'$Atomic'.maxInclusive]")
    return result

# define "json_model_6_may_maxExclusive" ($.'$Atomic'.maxExclusive)
def jm_f_16(value: Jsonable, path: str, rep: Report = None) -> bool:
    # $.'$Atomic'.maxExclusive
    result = json_model_5(value, path, rep)
    if not result:
        rep is None or rep.append(f"not an expected $atomic at {path} [$.'$Atomic'.maxExclusive]")
    return result

# define "json_model_6_may_minInclusive" ($.'$Atomic'.minInclusive)
def jm_f_17(value: Jsonable, path: str, rep: Report = None) -> bool:
    # $.'$Atomic'.minInclusive
    result = json_model_5(value, path, rep)
    if not result:
        rep is None or rep.append(f"not an expected $atomic at {path} [$.'$Atomic'.minInclusive]")
    return result

# define "json_model_6_may_minExclusive" ($.'$Atomic'.minExclusive)
def jm_f_18(value: Jsonable, path: str, rep: Report = None) -> bool:
    # $.'$Atomic'.minExclusive
    result = json_model_5(value, path, rep)
    if not result:
        rep is None or rep.append(f"not an expected $atomic at {path} [$.'$Atomic'.minExclusive]")
    return result

# define "json_model_6_may_enumeration" ($.'$Atomic'.enumeration)
def jm_f_19(value: Jsonable, path: str, rep: Report = None) -> bool:
    # $.'$Atomic'.enumeration
    result = isinstance(value, list)
    if result:
        for array_2_idx, array_2_item in enumerate(value):
            lpath = path + '.' + str(array_2_idx)
            # $.'$Atomic'.enumeration.0
            result = json_model_5(array_2_item, path, rep)
            if not result:
                rep is None or rep.append(f"not an expected $atomic at {lpath} [$.'$Atomic'.enumeration.0]")
            if not result:
                break
    if not result:
        rep is None or rep.append(f"not array or unexpected array at {path} [$.'$Atomic'.enumeration]")
    return result

# define "json_model_6_may_explicitTypeZone" ($.'$Atomic'.explicitTypeZone)
def jm_f_20(value: Jsonable, path: str, rep: Report = None) -> bool:
    # $.'$Atomic'.explicitTypeZone
    result = not isinstance(value, (list, dict)) and value in {'optional', 'prohibited', 'required'}
    if not result:
        rep is None or rep.append(f"value not in enum at {path} [$.'$Atomic'.explicitTypeZone.'|']")
    return result

# define "json_model_7_must_kind" ($.'$Object'.kind)
def jm_f_21(value: Jsonable, path: str, rep: Report = None) -> bool:
    # $.'$Object'.kind
    result = isinstance(value, str) and value == "object"
    if not result:
        rep is None or rep.append(f"not an expected object at {path} [$.'$Object'.kind]")
    return result

# define "json_model_7_may_name" ($.'$Object'.name)
def jm_f_22(value: Jsonable, path: str, rep: Report = None) -> bool:
    # $.'$Object'.name
    result = isinstance(value, str)
    if not result:
        rep is None or rep.append(f"not an expected string at {path} [$.'$Object'.name]")
    return result

# define "json_model_7_may_baseType" ($.'$Object'.baseType)
def jm_f_23(value: Jsonable, path: str, rep: Report = None) -> bool:
    # $.'$Object'.baseType
    result = isinstance(value, str)
    if not result:
        rep is None or rep.append(f"not an expected string at {path} [$.'$Object'.baseType]")
    return result

# define "json_model_7_may_content" ($.'$Object'.content)
def jm_f_24(value: Jsonable, path: str, rep: Report = None) -> bool:
    # $.'$Object'.content
    result = isinstance(value, list)
    if result:
        for array_3_idx, array_3_item in enumerate(value):
            lpath = path + '.' + str(array_3_idx)
            # $.'$Object'.content.0
            result = json_model_8(array_3_item, path, rep)
            if not result:
                rep is None or rep.append(f"not an expected $Fields at {lpath} [$.'$Object'.content.0]")
            if not result:
                break
    if not result:
        rep is None or rep.append(f"not array or unexpected array at {path} [$.'$Object'.content]")
    return result

# define "json_model_7_may_closed" ($.'$Object'.closed)
def jm_f_25(value: Jsonable, path: str, rep: Report = None) -> bool:
    # $.'$Object'.closed
    result = isinstance(value, bool)
    if not result:
        rep is None or rep.append(f"not a bool at {path} [$.'$Object'.closed]")
    return result

# define "json_model_8_must_name" ($.'$Fields'.name)
def jm_f_26(value: Jsonable, path: str, rep: Report = None) -> bool:
    # $.'$Fields'.name
    result = isinstance(value, str)
    if not result:
        rep is None or rep.append(f"not an expected string at {path} [$.'$Fields'.name]")
    return result

# define "json_model_8_must_type" ($.'$Fields'.type)
def jm_f_27(value: Jsonable, path: str, rep: Report = None) -> bool:
    # $.'$Fields'.type
    result = json_model_11(value, path, rep)
    if not result:
        rep is None or rep.append(f"not an expected $type-or-ref at {path} [$.'$Fields'.type]")
    return result

# define "json_model_8_may_required" ($.'$Fields'.required)
def jm_f_28(value: Jsonable, path: str, rep: Report = None) -> bool:
    # $.'$Fields'.required
    result = isinstance(value, bool)
    if not result:
        rep is None or rep.append(f"not a bool at {path} [$.'$Fields'.required]")
    return result

# define "json_model_8_may_default" ($.'$Fields'.default)
def jm_f_29(value: Jsonable, path: str, rep: Report = None) -> bool:
    # $.'$Fields'.default
    result = True or _rep(f"invalid $ANY at {path}", rep)
    if not result:
        rep is None or rep.append(f"not an expected $ANY at {path} [$.'$Fields'.default]")
    return result

# define "json_model_8_may_unique" ($.'$Fields'.unique)
def jm_f_30(value: Jsonable, path: str, rep: Report = None) -> bool:
    # $.'$Fields'.unique
    result = isinstance(value, bool)
    if not result:
        rep is None or rep.append(f"not a bool at {path} [$.'$Fields'.unique]")
    return result

# define "json_model_9_must_kind" ($.'$Array'.kind)
def jm_f_31(value: Jsonable, path: str, rep: Report = None) -> bool:
    # $.'$Array'.kind
    result = isinstance(value, str) and value == "array"
    if not result:
        rep is None or rep.append(f"not an expected array at {path} [$.'$Array'.kind]")
    return result

# define "json_model_9_may_name" ($.'$Array'.name)
def jm_f_32(value: Jsonable, path: str, rep: Report = None) -> bool:
    # $.'$Array'.name
    result = isinstance(value, str)
    if not result:
        rep is None or rep.append(f"not an expected string at {path} [$.'$Array'.name]")
    return result

# define "json_model_9_may_baseType" ($.'$Array'.baseType)
def jm_f_33(value: Jsonable, path: str, rep: Report = None) -> bool:
    # $.'$Array'.baseType
    result = isinstance(value, str)
    if not result:
        rep is None or rep.append(f"not an expected string at {path} [$.'$Array'.baseType]")
    return result

# define "json_model_9_may_content" ($.'$Array'.content)
def jm_f_34(value: Jsonable, path: str, rep: Report = None) -> bool:
    # $.'$Array'.content
    result = json_model_11(value, path, rep)
    if not result:
        rep is None or rep.append(f"not an expected $type-or-ref at {path} [$.'$Array'.content]")
    return result

# define "json_model_9_may_minLength" ($.'$Array'.minLength)
def jm_f_35(value: Jsonable, path: str, rep: Report = None) -> bool:
    # $.'$Array'.minLength
    result = isinstance(value, int) and not isinstance(value, bool) and value >= 0
    if not result:
        rep is None or rep.append(f"not a 0 int at {path} [$.'$Array'.minLength]")
    return result

# define "json_model_9_may_maxLength" ($.'$Array'.maxLength)
def jm_f_36(value: Jsonable, path: str, rep: Report = None) -> bool:
    # $.'$Array'.maxLength
    result = isinstance(value, int) and not isinstance(value, bool) and value >= 0
    if not result:
        rep is None or rep.append(f"not a 0 int at {path} [$.'$Array'.maxLength]")
    return result

# define "json_model_10_must_name" ($.'$Union'.name)
def jm_f_37(value: Jsonable, path: str, rep: Report = None) -> bool:
    # $.'$Union'.name
    result = isinstance(value, str)
    if not result:
        rep is None or rep.append(f"not an expected string at {path} [$.'$Union'.name]")
    return result

# define "json_model_10_must_kind" ($.'$Union'.kind)
def jm_f_38(value: Jsonable, path: str, rep: Report = None) -> bool:
    # $.'$Union'.kind
    result = isinstance(value, str) and value == "union"
    if not result:
        rep is None or rep.append(f"not an expected union at {path} [$.'$Union'.kind]")
    return result

# define "json_model_10_must_content" ($.'$Union'.content)
def jm_f_39(value: Jsonable, path: str, rep: Report = None) -> bool:
    # $.'$Union'.content
    result = isinstance(value, list)
    if result:
        for array_4_idx, array_4_item in enumerate(value):
            lpath = path + '.' + str(array_4_idx)
            # $.'$Union'.content.0
            result = json_model_11(array_4_item, path, rep)
            if not result:
                rep is None or rep.append(f"not an expected $type-or-ref at {lpath} [$.'$Union'.content.0]")
            if not result:
                break
    if not result:
        rep is None or rep.append(f"not array or unexpected array at {path} [$.'$Union'.content]")
    return result

# define "json_model_10_may_baseType" ($.'$Union'.baseType)
def jm_f_40(value: Jsonable, path: str, rep: Report = None) -> bool:
    # $.'$Union'.baseType
    result = isinstance(value, str)
    if not result:
        rep is None or rep.append(f"not an expected string at {path} [$.'$Union'.baseType]")
    return result



# object $.'$Schema'.metadata
def jm_f_1(value: Jsonable, path: str, rep: Report = None) -> bool:
    if not isinstance(value, dict):
        rep is None or rep.append(f"not an object at {path} [$.'$Schema'.metadata]")
        return False
    for prop, val in value.items():
        assert isinstance(prop, str)
        lpath = path + "." + prop
        if prop in jm_f_1_may:  # may
            if not jm_f_1_may[prop](val, lpath, rep):
                rep is None or rep.append(f"invalid may prop value at {lpath} [$.'$Schema'.metadata.{prop}]")
                return False
        else:  # no catch all
            rep is None or rep.append(f"no other prop expected at {path} [$.'$Schema'.metadata]")
            return False
    return True


# object $.'$Schema'
def json_model_2(value: Jsonable, path: str, rep: Report = None) -> bool:
    if not isinstance(value, dict):
        rep is None or rep.append(f"not an object at {path} [$.'$Schema']")
        return False
    must_count = 0
    for prop, val in value.items():
        assert isinstance(prop, str)
        lpath = path + "." + prop
        if prop in json_model_2_must:  # must
            must_count += 1
            if not json_model_2_must[prop](val, lpath, rep):
                rep is None or rep.append(f"invalid must prop value at {lpath} [$.'$Schema'.{prop}]")
                return False
        elif prop in json_model_2_may:  # may
            if not json_model_2_may[prop](val, lpath, rep):
                rep is None or rep.append(f"invalid may prop value at {lpath} [$.'$Schema'.{prop}]")
                return False
        else:  # no catch all
            rep is None or rep.append(f"no other prop expected at {path} [$.'$Schema']")
            return False
    result = must_count == 1
    if not result:
        rep is None or rep.append(f"missing must prop at {path} [$.'$Schema']")
    return result



# define "$Type" ($.'$Type')
def json_model_3(value: Jsonable, path: str, rep: Report = None) -> bool:
    # $.'$Type'
    # $.'$Type'.'|'.0
    result = json_model_6(value, path, rep)
    if not result:
        rep is None or rep.append(f"not an expected $Atomic at {path} [$.'$Type'.'|'.0]")
    if not result:
        # $.'$Type'.'|'.1
        result = json_model_7(value, path, rep)
        if not result:
            rep is None or rep.append(f"not an expected $Object at {path} [$.'$Type'.'|'.1]")
        if not result:
            # $.'$Type'.'|'.2
            result = json_model_9(value, path, rep)
            if not result:
                rep is None or rep.append(f"not an expected $Array at {path} [$.'$Type'.'|'.2]")
            if not result:
                # $.'$Type'.'|'.3
                result = json_model_10(value, path, rep)
                if not result:
                    rep is None or rep.append(f"not an expected $Union at {path} [$.'$Type'.'|'.3]")
    if not result:
        rep is None or rep.append(f"not any model match at {path} [$.'$Type'.'|']")
    return result

# define "$atomic-types" ($.'$atomic-types')
def json_model_4(value: Jsonable, path: str, rep: Report = None) -> bool:
    # $.'$atomic-types'
    result = not isinstance(value, (list, dict)) and value in {'anyURI', 'base64Binary', 'boolean', 'date', 'dateTime', 'dateTimeStamp', 'decimal', 'double', 'duration', 'hexBinary', 'integer', 'null', 'string', 'time'}
    if not result:
        rep is None or rep.append(f"value not in enum at {path} [$.'$atomic-types'.'|']")
    return result

# define "$atomic" ($.'$atomic')
def json_model_5(value: Jsonable, path: str, rep: Report = None) -> bool:
    # $.'$atomic'
    # $.'$atomic'.'|'.0
    result = value is None
    if not result:
        rep is None or rep.append(f"not null at {path} [$.'$atomic'.'|'.0]")
    if not result:
        # $.'$atomic'.'|'.1
        result = isinstance(value, bool)
        if not result:
            rep is None or rep.append(f"not a bool at {path} [$.'$atomic'.'|'.1]")
        if not result:
            # $.'$atomic'.'|'.2
            result = isinstance(value, int) and not isinstance(value, bool)
            if not result:
                rep is None or rep.append(f"not a -1 int at {path} [$.'$atomic'.'|'.2]")
            if not result:
                # $.'$atomic'.'|'.3
                result = isinstance(value, float)
                if not result:
                    rep is None or rep.append(f"not a -1.0 float at {path} [$.'$atomic'.'|'.3]")
                if not result:
                    # $.'$atomic'.'|'.4
                    result = isinstance(value, str)
                    if not result:
                        rep is None or rep.append(f"not an expected string at {path} [$.'$atomic'.'|'.4]")
    if not result:
        rep is None or rep.append(f"not any model match at {path} [$.'$atomic'.'|']")
    return result


# object $.'$Atomic'
def json_model_6(value: Jsonable, path: str, rep: Report = None) -> bool:
    if not isinstance(value, dict):
        rep is None or rep.append(f"not an object at {path} [$.'$Atomic']")
        return False
    must_count = 0
    for prop, val in value.items():
        assert isinstance(prop, str)
        lpath = path + "." + prop
        if prop in json_model_6_must:  # must
            must_count += 1
            if not json_model_6_must[prop](val, lpath, rep):
                rep is None or rep.append(f"invalid must prop value at {lpath} [$.'$Atomic'.{prop}]")
                return False
        elif prop in json_model_6_may:  # may
            if not json_model_6_may[prop](val, lpath, rep):
                rep is None or rep.append(f"invalid may prop value at {lpath} [$.'$Atomic'.{prop}]")
                return False
        else:  # no catch all
            rep is None or rep.append(f"no other prop expected at {path} [$.'$Atomic']")
            return False
    result = must_count == 2
    if not result:
        rep is None or rep.append(f"missing must prop at {path} [$.'$Atomic']")
    return result




# object $.'$Object'
def json_model_7(value: Jsonable, path: str, rep: Report = None) -> bool:
    if not isinstance(value, dict):
        rep is None or rep.append(f"not an object at {path} [$.'$Object']")
        return False
    must_count = 0
    for prop, val in value.items():
        assert isinstance(prop, str)
        lpath = path + "." + prop
        if prop in json_model_7_must:  # must
            must_count += 1
            if not json_model_7_must[prop](val, lpath, rep):
                rep is None or rep.append(f"invalid must prop value at {lpath} [$.'$Object'.{prop}]")
                return False
        elif prop in json_model_7_may:  # may
            if not json_model_7_may[prop](val, lpath, rep):
                rep is None or rep.append(f"invalid may prop value at {lpath} [$.'$Object'.{prop}]")
                return False
        else:  # no catch all
            rep is None or rep.append(f"no other prop expected at {path} [$.'$Object']")
            return False
    result = must_count == 1
    if not result:
        rep is None or rep.append(f"missing must prop at {path} [$.'$Object']")
    return result




# object $.'$Fields'
def json_model_8(value: Jsonable, path: str, rep: Report = None) -> bool:
    if not isinstance(value, dict):
        rep is None or rep.append(f"not an object at {path} [$.'$Fields']")
        return False
    must_count = 0
    for prop, val in value.items():
        assert isinstance(prop, str)
        lpath = path + "." + prop
        if prop in json_model_8_must:  # must
            must_count += 1
            if not json_model_8_must[prop](val, lpath, rep):
                rep is None or rep.append(f"invalid must prop value at {lpath} [$.'$Fields'.{prop}]")
                return False
        elif prop in json_model_8_may:  # may
            if not json_model_8_may[prop](val, lpath, rep):
                rep is None or rep.append(f"invalid may prop value at {lpath} [$.'$Fields'.{prop}]")
                return False
        else:  # no catch all
            rep is None or rep.append(f"no other prop expected at {path} [$.'$Fields']")
            return False
    result = must_count == 2
    if not result:
        rep is None or rep.append(f"missing must prop at {path} [$.'$Fields']")
    return result




# object $.'$Array'
def json_model_9(value: Jsonable, path: str, rep: Report = None) -> bool:
    if not isinstance(value, dict):
        rep is None or rep.append(f"not an object at {path} [$.'$Array']")
        return False
    must_count = 0
    for prop, val in value.items():
        assert isinstance(prop, str)
        lpath = path + "." + prop
        if prop in json_model_9_must:  # must
            must_count += 1
            if not json_model_9_must[prop](val, lpath, rep):
                rep is None or rep.append(f"invalid must prop value at {lpath} [$.'$Array'.{prop}]")
                return False
        elif prop in json_model_9_may:  # may
            if not json_model_9_may[prop](val, lpath, rep):
                rep is None or rep.append(f"invalid may prop value at {lpath} [$.'$Array'.{prop}]")
                return False
        else:  # no catch all
            rep is None or rep.append(f"no other prop expected at {path} [$.'$Array']")
            return False
    result = must_count == 1
    if not result:
        rep is None or rep.append(f"missing must prop at {path} [$.'$Array']")
    return result




# object $.'$Union'
def json_model_10(value: Jsonable, path: str, rep: Report = None) -> bool:
    if not isinstance(value, dict):
        rep is None or rep.append(f"not an object at {path} [$.'$Union']")
        return False
    must_count = 0
    for prop, val in value.items():
        assert isinstance(prop, str)
        lpath = path + "." + prop
        if prop in json_model_10_must:  # must
            must_count += 1
            if not json_model_10_must[prop](val, lpath, rep):
                rep is None or rep.append(f"invalid must prop value at {lpath} [$.'$Union'.{prop}]")
                return False
        elif prop in json_model_10_may:  # may
            if not json_model_10_may[prop](val, lpath, rep):
                rep is None or rep.append(f"invalid may prop value at {lpath} [$.'$Union'.{prop}]")
                return False
        else:  # no catch all
            rep is None or rep.append(f"no other prop expected at {path} [$.'$Union']")
            return False
    result = must_count == 3
    if not result:
        rep is None or rep.append(f"missing must prop at {path} [$.'$Union']")
    return result



# define "$type-or-ref" ($.'$type-or-ref')
def json_model_11(value: Jsonable, path: str, rep: Report = None) -> bool:
    # $.'$type-or-ref'
    # $.'$type-or-ref'.'|'.0
    result = isinstance(value, str)
    if not result:
        rep is None or rep.append(f"not an expected string at {path} [$.'$type-or-ref'.'|'.0]")
    if not result:
        # $.'$type-or-ref'.'|'.1
        result = json_model_3(value, path, rep)
        if not result:
            rep is None or rep.append(f"not an expected $Type at {path} [$.'$type-or-ref'.'|'.1]")
    if not result:
        rep is None or rep.append(f"not any model match at {path} [$.'$type-or-ref'.'|']")
    return result

# define "$" ($)
def json_model_1(value: Jsonable, path: str, rep: Report = None) -> bool:
    # $
    result = json_model_2(value, path, rep)
    if not result:
        rep is None or rep.append(f"not an expected $Schema at {path} [$]")
    return result

# entry function check_model
def check_model(value: Jsonable, path: str = "$", rep: Report = None) -> bool:
    return json_model_1(value, path, rep)


# object properties maps
json_model_2_must = {
    "types": jm_f_0,
}
json_model_2_may = {
    "metadata": jm_f_1,
}
jm_f_1_may = {
    "name": jm_f_2,
    "previous": jm_f_3,
    "date": jm_f_4,
    "authors": jm_f_5,
}
json_model_6_must = {
    "kind": jm_f_6,
    "baseType": jm_f_7,
}
json_model_6_may = {
    "name": jm_f_8,
    "pattern": jm_f_9,
    "length": jm_f_10,
    "minLength": jm_f_11,
    "maxLength": jm_f_12,
    "totalDigits": jm_f_13,
    "fractionDigits": jm_f_14,
    "maxInclusive": jm_f_15,
    "maxExclusive": jm_f_16,
    "minInclusive": jm_f_17,
    "minExclusive": jm_f_18,
    "enumeration": jm_f_19,
    "explicitTypeZone": jm_f_20,
}
json_model_7_must = {
    "kind": jm_f_21,
}
json_model_7_may = {
    "name": jm_f_22,
    "baseType": jm_f_23,
    "content": jm_f_24,
    "closed": jm_f_25,
}
json_model_8_must = {
    "name": jm_f_26,
    "type": jm_f_27,
}
json_model_8_may = {
    "required": jm_f_28,
    "default": jm_f_29,
    "unique": jm_f_30,
}
json_model_9_must = {
    "kind": jm_f_31,
}
json_model_9_may = {
    "name": jm_f_32,
    "baseType": jm_f_33,
    "content": jm_f_34,
    "minLength": jm_f_35,
    "maxLength": jm_f_36,
}
json_model_10_must = {
    "name": jm_f_37,
    "kind": jm_f_38,
    "content": jm_f_39,
}
json_model_10_may = {
    "baseType": jm_f_40,
}


# possibly run as a script: $0 values...
if __name__ == "__main__":
    import json
    import sys
    for fn in sys.argv[1:]:
        try:
            with open(fn) as f:
                value = json.load(f)
            reasons = []
            if check_model(value, "", reasons):
                print(f"{fn}: PASS")
            else:
                print(f"{fn}: FAIL {reasons}")
        except Exception as e:
            print(f"{fn}: ERROR ({e})")

