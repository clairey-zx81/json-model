#! /bin/env python
#
# Generated by JSON Model Compiler version 2.0a0
# see https://github.com/clairey-zx81/json-model
#
__version__ = "2.0a0"
#
# type declarations for python jm runtime
#
type JsonScalar = None|bool|int|float|str
type Jsonable = JsonScalar|list[Jsonable]|dict[str, Jsonable]

type Path = list[int|str]|None
type Report = list[tuple[str, Path]]|None

type CheckFun = Callable[[Jsonable, Path, Report], bool]
type RegexFun = Callable[[str], bool]
type PropMap = dict[str, CheckFun]

type EntryCheckFun = Callable[[Jsonable, str, Report], bool]
from typing import Callable
import datetime
import urllib.parse

# call initialize only once
initialized: bool = False

# special undefined value
UNDEFINED: object = object()

# map model names to check functions
_check_model_map_size: int
_check_model_map: PropMap

# extract type name
def _tname(value: Jsonable) -> str:
    return type(value).__name__

# maybe add message to report
def _rep(msg: str, rep: Report) -> bool:
    rep is None or rep.append(msg)
    return False

# generate path for display
# TODO add appropriate escapingâ€¦
def _path(path: Path) -> str:
    return ".".join(str(i) for i in path)

def check_model_fun(name: str) -> CheckFun:
    """Return check function for JSON model name."""
    return _check_model_map[name]

# entry point for generated checkers
def check_model(val: Jsonable, name: str = "", rep: Report = None) -> bool:
    """Check val validity agains JSON Model name."""
    if name not in _check_model_map:
        raise Exception(f"unexpected model name: {name}")
    checker = _check_model_map[name]
    return checker(val, [], rep)

# types: JsonScalar

from collections.abc import MutableMapping, MutableSet

class Const:
    """A constant holder suitable for set/dict, with a stricly typed comparison.

    The point is to avoid 1 == 1.0 == True, 0 == 0.0 == False, n == n.0
    """

    def __init__(self, val: JsonScalar):
        self._val = val

    def __hash__(self):
        return hash(self._val)

    def __eq__(self, val):
        return (
            isinstance(val, Const) and
            type(self._val) is type(val._val) and
            self._val == val._val
        )


class ConstSet(MutableSet[JsonScalar]):
    """A set of constants, with strictly typed comparisons."""

    def __init__(self, init: list[JsonScalar]|str|None = None):
        self._set: set[Const] = set()
        if init:
            for item in init:
                self.add(item)

    def __len__(self):
        return len(self._set)

    def __iter__(self):
        return [ item._val for item in self._set ]

    def __contains__(self, item):
        return Const(item) in self._set

    def add(self, item):
        self._set.add(Const(item))

    def discard(self, item):
        self._set.discard(Const(item))


class ConstMap(MutableMapping[JsonScalar, CheckFun]):
    """A mapping of constants to check functions."""

    def __init__(self):
        self._map: dict[Const, CheckFun] = {}

    def __setitem__(self, key, val):
        self._map[Const(key)] = val

    def __getitem__(self, key):
        if isinstance(key, (list, dict)):
            return UNDEFINED
        else:
            return self._map[Const(key)]

    def __delitem__(self, key):
        del self._map[Const(key)]

    def __iter__(self):
        return [ (k._val, v) for k, v in self._map.items() ]

    def __len__(self):
        return self._map.__len__()

_check_model_map: PropMap

# check $ ($)
def json_model_1(val: Jsonable, path: Path, rep: Report) -> bool:
    res: bool
    # $
    res = isinstance(val, list)
    if res:
        # accept any array
        pass
    if not res:
        rep is None or rep.append(("not array or unexpected array [$]", path))
    return res


# differed module initializations
def check_model_init():
    global initialized
    if not initialized:
        initialized = True
        global _check_model_map
        _check_model_map = {
            "": json_model_1,
        }

# differed module cleanup
def check_model_free():
    global initialized
    if initialized:
        initialized = False


# possibly run as a script: $0 values...
if __name__ == "__main__":
    import json
    import sys
    import argparse
    import logging

    logging.basicConfig()
    log = logging.getLogger("checker")

    ap = argparse.ArgumentParser()
    ap.add_argument("--debug", "-d", action="store_true", help="set verbose mode")
    ap.add_argument("--name", "-n", default="", help="select model by name")
    ap.add_argument("--list", "-l", action="store_true", help="show available model names and exit")
    ap.add_argument("--version", "-v", action="store_true", help="show JSON Model compiler version")
    ap.add_argument("--report", "-r", action="store_true", help="show error locations on failure")
    ap.add_argument("values", nargs="*", help="JSON files")
    args = ap.parse_args()

    log.setLevel(logging.DEBUG if args.debug else logging.INFO)

    check_model_init()

    if args.list:
        print(f"JSON Models (empty for root):{' '.join(sorted(_json_model_map.keys()))}")
        sys.exit(0)
    if args.version:
        print(f"Python from JSON Model compiler version {__version__}")
        sys.exit(0)

    try:
        checker: CheckFun = check_model_fun(args.name)
    except Exception as e:
        log.debug(e, exc_info=args.debug)
        log.error(f"error on model for {args.name}: {e}")
        sys.exit(1)

    for fn in args.values:
        try:
            with open(fn) as f:
                value = json.load(f)
            reasons = [] if args.report else None
            path = [] if args.report else None
            if checker(value, path, reasons):
                print(f"{fn}: PASS")
            elif reasons:
                print(f"{fn}: FAIL {reasons}")
            else:
                print(f"{fn}: FAIL")
        except Exception as e:
            log.debug(e, exc_info=args.debug)
            print(f"{fn}: ERROR ({e})")

    check_model_free()
