#! /bin/env python
#
# Generated by JSON Model Compiler version 2.0a0
# see https://github.com/clairey-zx81/json-model
#
from typing import Callable
import re2 as re
from json_model.runtime import *
__version__ = "2.0a0"

def check_model_fun(name: str) -> CheckFun:
    """Return check function for JSON model name."""
    return check_model_map[name]

# entry point for generated checkers
def check_model(val: Jsonable, name: str = "", rep: Report = None) -> bool:
    """Check val validity agains JSON Model name."""
    if name not in check_model_map:
        raise Exception(f"unexpected model name: {name}")
    checker = check_model_map[name]
    return checker(val, [], rep)

_jm_obj_0_must: PropMap
_jm_obj_0_may: PropMap
_jm_obj_1_must: PropMap
_jm_obj_1_may: PropMap
_jm_obj_2_must: PropMap
_jm_obj_2_may: PropMap
_jm_obj_3_must: PropMap
_jm_obj_3_may: PropMap
_jm_obj_4_must: PropMap
_jm_obj_4_may: PropMap
_jm_obj_5_must: PropMap
_jm_obj_5_may: PropMap
_jm_map_0: dict[str, str]
_jm_obj_6_must: PropMap
_jm_obj_6_may: PropMap
_jm_obj_7_must: PropMap
_jm_obj_7_may: PropMap
_jm_obj_9_must: PropMap
_jm_obj_9_may: PropMap
check_model_map: PropMap

# check $position ($.'$position')
def json_model_2(val: Jsonable, path: Path, rep: Report) -> bool:
    res: bool
    # $.'$position'
    # $.'$position'.'@'
    res = isinstance(val, list)
    if res:
        for arr_0_idx, arr_0_item in enumerate(val):
            arr_0_lpath: Path = (path + [ arr_0_idx ]) if path is not None else None
            # $.'$position'.'@'.0
            res = isinstance(arr_0_item, (int, float)) and not isinstance(arr_0_item, bool)
            if not res:
                rep is None or rep.append(("not a -1.0 loose float [$.'$position'.'@'.0]", arr_0_lpath if path is not None else None))
            if not res:
                break
    if not res:
        rep is None or rep.append(("not array or unexpected array [$.'$position'.'@']", path))
    if res:
        ival_0: int = len(val)
        res = ival_0 <= 3 and ival_0 >= 2
    if not res:
        rep is None or rep.append(("constraints failed at [$.'$position']", path))
    return res

# check $coord_array ($.'$coord_array')
def json_model_3(val: Jsonable, path: Path, rep: Report) -> bool:
    res: bool
    # $.'$coord_array'
    # $.'$coord_array'.'@'
    res = isinstance(val, list)
    if res:
        for arr_1_idx, arr_1_item in enumerate(val):
            arr_1_lpath: Path = (path + [ arr_1_idx ]) if path is not None else None
            # $.'$coord_array'.'@'.0
            res = json_model_2(arr_1_item, path, rep)
            if not res:
                rep is None or rep.append(("unexpected $position [$.'$coord_array'.'@'.0]", arr_1_lpath if path is not None else None))
            if not res:
                break
    if not res:
        rep is None or rep.append(("not array or unexpected array [$.'$coord_array'.'@']", path))
    if res:
        ival_1: int = len(val)
        res = ival_1 >= 2
    if not res:
        rep is None or rep.append(("constraints failed at [$.'$coord_array']", path))
    return res

# check $linear_ring ($.'$linear_ring')
def json_model_4(val: Jsonable, path: Path, rep: Report) -> bool:
    res: bool
    # $.'$linear_ring'
    # $.'$linear_ring'.'@'
    res = isinstance(val, list)
    if res:
        for arr_2_idx, arr_2_item in enumerate(val):
            arr_2_lpath: Path = (path + [ arr_2_idx ]) if path is not None else None
            # $.'$linear_ring'.'@'.0
            res = json_model_2(arr_2_item, path, rep)
            if not res:
                rep is None or rep.append(("unexpected $position [$.'$linear_ring'.'@'.0]", arr_2_lpath if path is not None else None))
            if not res:
                break
    if not res:
        rep is None or rep.append(("not array or unexpected array [$.'$linear_ring'.'@']", path))
    if res:
        ival_2: int = len(val)
        res = ival_2 >= 4
    if not res:
        rep is None or rep.append(("constraints failed at [$.'$linear_ring']", path))
    return res

# check _jm_obj_0_must_coordinates ($.'$Point'.coordinates)
def _jm_f_0(val: Jsonable, path: Path, rep: Report) -> bool:
    res: bool
    # $.'$Point'.coordinates
    res = json_model_2(val, path, rep)
    if not res:
        rep is None or rep.append(("unexpected $position [$.'$Point'.coordinates]", path))
    return res

# check _jm_obj_0_must_type ($.'$Point'.type)
def _jm_f_1(val: Jsonable, path: Path, rep: Report) -> bool:
    res: bool
    # $.'$Point'.type
    res = isinstance(val, str) and val == "Point"
    if not res:
        rep is None or rep.append(("unexpected Point [$.'$Point'.type]", path))
    return res


# check _jm_obj_0_may_bbox ($.'$Point'.bbox)
def _jm_f_2(val: Jsonable, path: Path, rep: Report) -> bool:
    res: bool
    # $.'$Point'.bbox
    res = isinstance(val, list)
    if res:
        for arr_3_idx, arr_3_item in enumerate(val):
            arr_3_lpath: Path = (path + [ arr_3_idx ]) if path is not None else None
            # $.'$Point'.bbox.0
            res = isinstance(arr_3_item, (int, float)) and not isinstance(arr_3_item, bool)
            if not res:
                rep is None or rep.append(("not a -1.0 loose float [$.'$Point'.bbox.0]", arr_3_lpath if path is not None else None))
            if not res:
                break
    if not res:
        rep is None or rep.append(("not array or unexpected array [$.'$Point'.bbox]", path))
    return res


# object $.'$Point'
def _jm_obj_0(val: Jsonable, path: Path, rep: Report) -> bool:
    if not isinstance(val, dict):
        rep is None or rep.append(("not an object [$.'$Point']", path))
        return False
    pfun: CheckFun
    must_count: int = 0
    for prop, pval in val.items():
        assert isinstance(prop, str)
        lpath_0: Path = (path + [ prop ]) if path is not None else None
        if pfun := _jm_obj_0_must.get(prop):
            # handle 2 must props
            if pfun != UNDEFINED:
                must_count += 1
                if not pfun(pval, lpath_0 if path is not None else None, rep):
                    rep is None or rep.append(("invalid must property value [$.'$Point']", lpath_0 if path is not None else None))
                    return False
        elif pfun := _jm_obj_0_may.get(prop):
            # handle {len(may)} may props
            if pfun != UNDEFINED and not pfun(pval, lpath_0 if path is not None else None, rep):
                rep is None or rep.append(("invalid may property value [$.'$Point']", lpath_0 if path is not None else None))
                return False
        else:
            rep is None or rep.append(("no other prop expected [$.'$Point']", lpath_0 if path is not None else None))
            return False
    if must_count != 2:
        rep is None or rep.append(("missing must prop [$.'$Point']", path))
        return False
    return True

# check $Point ($.'$Point')
def json_model_5(val: Jsonable, path: Path, rep: Report) -> bool:
    res: bool
    # $.'$Point'
    res = _jm_obj_0(val, path, rep)
    if not res:
        rep is None or rep.append(("not an expected object at [$.'$Point']", path))
    return res

# check _jm_obj_1_must_coordinates ($.'$MultiPoint'.coordinates)
def _jm_f_3(val: Jsonable, path: Path, rep: Report) -> bool:
    res: bool
    # $.'$MultiPoint'.coordinates
    res = isinstance(val, list)
    if res:
        for arr_4_idx, arr_4_item in enumerate(val):
            arr_4_lpath: Path = (path + [ arr_4_idx ]) if path is not None else None
            # $.'$MultiPoint'.coordinates.0
            res = json_model_2(arr_4_item, path, rep)
            if not res:
                rep is None or rep.append(("unexpected $position [$.'$MultiPoint'.coordinates.0]", arr_4_lpath if path is not None else None))
            if not res:
                break
    if not res:
        rep is None or rep.append(("not array or unexpected array [$.'$MultiPoint'.coordinates]", path))
    return res

# check _jm_obj_1_must_type ($.'$MultiPoint'.type)
def _jm_f_4(val: Jsonable, path: Path, rep: Report) -> bool:
    res: bool
    # $.'$MultiPoint'.type
    res = isinstance(val, str) and val == "MultiPoint"
    if not res:
        rep is None or rep.append(("unexpected MultiPoint [$.'$MultiPoint'.type]", path))
    return res


# check _jm_obj_1_may_bbox ($.'$MultiPoint'.bbox)
def _jm_f_5(val: Jsonable, path: Path, rep: Report) -> bool:
    res: bool
    # $.'$MultiPoint'.bbox
    res = isinstance(val, list)
    if res:
        for arr_5_idx, arr_5_item in enumerate(val):
            arr_5_lpath: Path = (path + [ arr_5_idx ]) if path is not None else None
            # $.'$MultiPoint'.bbox.0
            res = isinstance(arr_5_item, (int, float)) and not isinstance(arr_5_item, bool)
            if not res:
                rep is None or rep.append(("not a -1.0 loose float [$.'$MultiPoint'.bbox.0]", arr_5_lpath if path is not None else None))
            if not res:
                break
    if not res:
        rep is None or rep.append(("not array or unexpected array [$.'$MultiPoint'.bbox]", path))
    return res


# object $.'$MultiPoint'
def _jm_obj_1(val: Jsonable, path: Path, rep: Report) -> bool:
    if not isinstance(val, dict):
        rep is None or rep.append(("not an object [$.'$MultiPoint']", path))
        return False
    pfun: CheckFun
    must_count: int = 0
    for prop, pval in val.items():
        assert isinstance(prop, str)
        lpath_1: Path = (path + [ prop ]) if path is not None else None
        if pfun := _jm_obj_1_must.get(prop):
            # handle 2 must props
            if pfun != UNDEFINED:
                must_count += 1
                if not pfun(pval, lpath_1 if path is not None else None, rep):
                    rep is None or rep.append(("invalid must property value [$.'$MultiPoint']", lpath_1 if path is not None else None))
                    return False
        elif pfun := _jm_obj_1_may.get(prop):
            # handle {len(may)} may props
            if pfun != UNDEFINED and not pfun(pval, lpath_1 if path is not None else None, rep):
                rep is None or rep.append(("invalid may property value [$.'$MultiPoint']", lpath_1 if path is not None else None))
                return False
        else:
            rep is None or rep.append(("no other prop expected [$.'$MultiPoint']", lpath_1 if path is not None else None))
            return False
    if must_count != 2:
        rep is None or rep.append(("missing must prop [$.'$MultiPoint']", path))
        return False
    return True

# check $MultiPoint ($.'$MultiPoint')
def json_model_6(val: Jsonable, path: Path, rep: Report) -> bool:
    res: bool
    # $.'$MultiPoint'
    res = _jm_obj_1(val, path, rep)
    if not res:
        rep is None or rep.append(("not an expected object at [$.'$MultiPoint']", path))
    return res

# check _jm_obj_2_must_coordinates ($.'$LineString'.coordinates)
def _jm_f_6(val: Jsonable, path: Path, rep: Report) -> bool:
    res: bool
    # $.'$LineString'.coordinates
    res = json_model_3(val, path, rep)
    if not res:
        rep is None or rep.append(("unexpected $coord_array [$.'$LineString'.coordinates]", path))
    return res

# check _jm_obj_2_must_type ($.'$LineString'.type)
def _jm_f_7(val: Jsonable, path: Path, rep: Report) -> bool:
    res: bool
    # $.'$LineString'.type
    res = isinstance(val, str) and val == "LineString"
    if not res:
        rep is None or rep.append(("unexpected LineString [$.'$LineString'.type]", path))
    return res


# check _jm_obj_2_may_bbox ($.'$LineString'.bbox)
def _jm_f_8(val: Jsonable, path: Path, rep: Report) -> bool:
    res: bool
    # $.'$LineString'.bbox
    res = isinstance(val, list)
    if res:
        for arr_6_idx, arr_6_item in enumerate(val):
            arr_6_lpath: Path = (path + [ arr_6_idx ]) if path is not None else None
            # $.'$LineString'.bbox.0
            res = isinstance(arr_6_item, (int, float)) and not isinstance(arr_6_item, bool)
            if not res:
                rep is None or rep.append(("not a -1.0 loose float [$.'$LineString'.bbox.0]", arr_6_lpath if path is not None else None))
            if not res:
                break
    if not res:
        rep is None or rep.append(("not array or unexpected array [$.'$LineString'.bbox]", path))
    return res


# object $.'$LineString'
def _jm_obj_2(val: Jsonable, path: Path, rep: Report) -> bool:
    if not isinstance(val, dict):
        rep is None or rep.append(("not an object [$.'$LineString']", path))
        return False
    pfun: CheckFun
    must_count: int = 0
    for prop, pval in val.items():
        assert isinstance(prop, str)
        lpath_2: Path = (path + [ prop ]) if path is not None else None
        if pfun := _jm_obj_2_must.get(prop):
            # handle 2 must props
            if pfun != UNDEFINED:
                must_count += 1
                if not pfun(pval, lpath_2 if path is not None else None, rep):
                    rep is None or rep.append(("invalid must property value [$.'$LineString']", lpath_2 if path is not None else None))
                    return False
        elif pfun := _jm_obj_2_may.get(prop):
            # handle {len(may)} may props
            if pfun != UNDEFINED and not pfun(pval, lpath_2 if path is not None else None, rep):
                rep is None or rep.append(("invalid may property value [$.'$LineString']", lpath_2 if path is not None else None))
                return False
        else:
            rep is None or rep.append(("no other prop expected [$.'$LineString']", lpath_2 if path is not None else None))
            return False
    if must_count != 2:
        rep is None or rep.append(("missing must prop [$.'$LineString']", path))
        return False
    return True

# check $LineString ($.'$LineString')
def json_model_7(val: Jsonable, path: Path, rep: Report) -> bool:
    res: bool
    # $.'$LineString'
    res = _jm_obj_2(val, path, rep)
    if not res:
        rep is None or rep.append(("not an expected object at [$.'$LineString']", path))
    return res

# check _jm_obj_3_must_coordinates ($.'$MultiLineString'.coordinates)
def _jm_f_9(val: Jsonable, path: Path, rep: Report) -> bool:
    res: bool
    # $.'$MultiLineString'.coordinates
    res = isinstance(val, list)
    if res:
        for arr_7_idx, arr_7_item in enumerate(val):
            arr_7_lpath: Path = (path + [ arr_7_idx ]) if path is not None else None
            # $.'$MultiLineString'.coordinates.0
            res = json_model_3(arr_7_item, path, rep)
            if not res:
                rep is None or rep.append(("unexpected $coord_array [$.'$MultiLineString'.coordinates.0]", arr_7_lpath if path is not None else None))
            if not res:
                break
    if not res:
        rep is None or rep.append(("not array or unexpected array [$.'$MultiLineString'.coordinates]", path))
    return res

# check _jm_obj_3_must_type ($.'$MultiLineString'.type)
def _jm_f_10(val: Jsonable, path: Path, rep: Report) -> bool:
    res: bool
    # $.'$MultiLineString'.type
    res = isinstance(val, str) and val == "MultiLineString"
    if not res:
        rep is None or rep.append(("unexpected MultiLineString [$.'$MultiLineString'.type]", path))
    return res


# check _jm_obj_3_may_bbox ($.'$MultiLineString'.bbox)
def _jm_f_11(val: Jsonable, path: Path, rep: Report) -> bool:
    res: bool
    # $.'$MultiLineString'.bbox
    res = isinstance(val, list)
    if res:
        for arr_8_idx, arr_8_item in enumerate(val):
            arr_8_lpath: Path = (path + [ arr_8_idx ]) if path is not None else None
            # $.'$MultiLineString'.bbox.0
            res = isinstance(arr_8_item, (int, float)) and not isinstance(arr_8_item, bool)
            if not res:
                rep is None or rep.append(("not a -1.0 loose float [$.'$MultiLineString'.bbox.0]", arr_8_lpath if path is not None else None))
            if not res:
                break
    if not res:
        rep is None or rep.append(("not array or unexpected array [$.'$MultiLineString'.bbox]", path))
    return res


# object $.'$MultiLineString'
def _jm_obj_3(val: Jsonable, path: Path, rep: Report) -> bool:
    if not isinstance(val, dict):
        rep is None or rep.append(("not an object [$.'$MultiLineString']", path))
        return False
    pfun: CheckFun
    must_count: int = 0
    for prop, pval in val.items():
        assert isinstance(prop, str)
        lpath_3: Path = (path + [ prop ]) if path is not None else None
        if pfun := _jm_obj_3_must.get(prop):
            # handle 2 must props
            if pfun != UNDEFINED:
                must_count += 1
                if not pfun(pval, lpath_3 if path is not None else None, rep):
                    rep is None or rep.append(("invalid must property value [$.'$MultiLineString']", lpath_3 if path is not None else None))
                    return False
        elif pfun := _jm_obj_3_may.get(prop):
            # handle {len(may)} may props
            if pfun != UNDEFINED and not pfun(pval, lpath_3 if path is not None else None, rep):
                rep is None or rep.append(("invalid may property value [$.'$MultiLineString']", lpath_3 if path is not None else None))
                return False
        else:
            rep is None or rep.append(("no other prop expected [$.'$MultiLineString']", lpath_3 if path is not None else None))
            return False
    if must_count != 2:
        rep is None or rep.append(("missing must prop [$.'$MultiLineString']", path))
        return False
    return True

# check $MultiLineString ($.'$MultiLineString')
def json_model_8(val: Jsonable, path: Path, rep: Report) -> bool:
    res: bool
    # $.'$MultiLineString'
    res = _jm_obj_3(val, path, rep)
    if not res:
        rep is None or rep.append(("not an expected object at [$.'$MultiLineString']", path))
    return res

# check _jm_obj_4_must_coordinates ($.'$Polygon'.coordinates)
def _jm_f_12(val: Jsonable, path: Path, rep: Report) -> bool:
    res: bool
    # $.'$Polygon'.coordinates
    res = isinstance(val, list)
    if res:
        for arr_9_idx, arr_9_item in enumerate(val):
            arr_9_lpath: Path = (path + [ arr_9_idx ]) if path is not None else None
            # $.'$Polygon'.coordinates.0
            res = json_model_4(arr_9_item, path, rep)
            if not res:
                rep is None or rep.append(("unexpected $linear_ring [$.'$Polygon'.coordinates.0]", arr_9_lpath if path is not None else None))
            if not res:
                break
    if not res:
        rep is None or rep.append(("not array or unexpected array [$.'$Polygon'.coordinates]", path))
    return res

# check _jm_obj_4_must_type ($.'$Polygon'.type)
def _jm_f_13(val: Jsonable, path: Path, rep: Report) -> bool:
    res: bool
    # $.'$Polygon'.type
    res = isinstance(val, str) and val == "Polygon"
    if not res:
        rep is None or rep.append(("unexpected Polygon [$.'$Polygon'.type]", path))
    return res


# check _jm_obj_4_may_bbox ($.'$Polygon'.bbox)
def _jm_f_14(val: Jsonable, path: Path, rep: Report) -> bool:
    res: bool
    # $.'$Polygon'.bbox
    res = isinstance(val, list)
    if res:
        for arr_10_idx, arr_10_item in enumerate(val):
            arr_10_lpath: Path = (path + [ arr_10_idx ]) if path is not None else None
            # $.'$Polygon'.bbox.0
            res = isinstance(arr_10_item, (int, float)) and not isinstance(arr_10_item, bool)
            if not res:
                rep is None or rep.append(("not a -1.0 loose float [$.'$Polygon'.bbox.0]", arr_10_lpath if path is not None else None))
            if not res:
                break
    if not res:
        rep is None or rep.append(("not array or unexpected array [$.'$Polygon'.bbox]", path))
    return res


# object $.'$Polygon'
def _jm_obj_4(val: Jsonable, path: Path, rep: Report) -> bool:
    if not isinstance(val, dict):
        rep is None or rep.append(("not an object [$.'$Polygon']", path))
        return False
    pfun: CheckFun
    must_count: int = 0
    for prop, pval in val.items():
        assert isinstance(prop, str)
        lpath_4: Path = (path + [ prop ]) if path is not None else None
        if pfun := _jm_obj_4_must.get(prop):
            # handle 2 must props
            if pfun != UNDEFINED:
                must_count += 1
                if not pfun(pval, lpath_4 if path is not None else None, rep):
                    rep is None or rep.append(("invalid must property value [$.'$Polygon']", lpath_4 if path is not None else None))
                    return False
        elif pfun := _jm_obj_4_may.get(prop):
            # handle {len(may)} may props
            if pfun != UNDEFINED and not pfun(pval, lpath_4 if path is not None else None, rep):
                rep is None or rep.append(("invalid may property value [$.'$Polygon']", lpath_4 if path is not None else None))
                return False
        else:
            rep is None or rep.append(("no other prop expected [$.'$Polygon']", lpath_4 if path is not None else None))
            return False
    if must_count != 2:
        rep is None or rep.append(("missing must prop [$.'$Polygon']", path))
        return False
    return True

# check $Polygon ($.'$Polygon')
def json_model_9(val: Jsonable, path: Path, rep: Report) -> bool:
    res: bool
    # $.'$Polygon'
    res = _jm_obj_4(val, path, rep)
    if not res:
        rep is None or rep.append(("not an expected object at [$.'$Polygon']", path))
    return res

# check _jm_obj_5_must_coordinates ($.'$MultiPolygon'.coordinates)
def _jm_f_15(val: Jsonable, path: Path, rep: Report) -> bool:
    res: bool
    # $.'$MultiPolygon'.coordinates
    res = isinstance(val, list)
    if res:
        for arr_11_idx, arr_11_item in enumerate(val):
            arr_11_lpath: Path = (path + [ arr_11_idx ]) if path is not None else None
            # $.'$MultiPolygon'.coordinates.0
            res = isinstance(arr_11_item, list)
            if res:
                for arr_12_idx, arr_12_item in enumerate(arr_11_item):
                    arr_12_lpath: Path = ((arr_11_lpath if path is not None else None) + [ arr_12_idx ]) if (arr_11_lpath if path is not None else None) is not None else None
                    # $.'$MultiPolygon'.coordinates.0.0
                    res = json_model_4(arr_12_item, path, rep)
                    if not res:
                        rep is None or rep.append(("unexpected $linear_ring [$.'$MultiPolygon'.coordinates.0.0]", arr_12_lpath if (arr_11_lpath if path is not None else None) is not None else None))
                    if not res:
                        break
            if not res:
                rep is None or rep.append(("not array or unexpected array [$.'$MultiPolygon'.coordinates.0]", arr_11_lpath if path is not None else None))
            if not res:
                break
    if not res:
        rep is None or rep.append(("not array or unexpected array [$.'$MultiPolygon'.coordinates]", path))
    return res

# check _jm_obj_5_must_type ($.'$MultiPolygon'.type)
def _jm_f_16(val: Jsonable, path: Path, rep: Report) -> bool:
    res: bool
    # $.'$MultiPolygon'.type
    res = isinstance(val, str) and val == "MultiPolygon"
    if not res:
        rep is None or rep.append(("unexpected MultiPolygon [$.'$MultiPolygon'.type]", path))
    return res


# check _jm_obj_5_may_bbox ($.'$MultiPolygon'.bbox)
def _jm_f_17(val: Jsonable, path: Path, rep: Report) -> bool:
    res: bool
    # $.'$MultiPolygon'.bbox
    res = isinstance(val, list)
    if res:
        for arr_13_idx, arr_13_item in enumerate(val):
            arr_13_lpath: Path = (path + [ arr_13_idx ]) if path is not None else None
            # $.'$MultiPolygon'.bbox.0
            res = isinstance(arr_13_item, (int, float)) and not isinstance(arr_13_item, bool)
            if not res:
                rep is None or rep.append(("not a -1.0 loose float [$.'$MultiPolygon'.bbox.0]", arr_13_lpath if path is not None else None))
            if not res:
                break
    if not res:
        rep is None or rep.append(("not array or unexpected array [$.'$MultiPolygon'.bbox]", path))
    return res


# object $.'$MultiPolygon'
def _jm_obj_5(val: Jsonable, path: Path, rep: Report) -> bool:
    if not isinstance(val, dict):
        rep is None or rep.append(("not an object [$.'$MultiPolygon']", path))
        return False
    pfun: CheckFun
    must_count: int = 0
    for prop, pval in val.items():
        assert isinstance(prop, str)
        lpath_5: Path = (path + [ prop ]) if path is not None else None
        if pfun := _jm_obj_5_must.get(prop):
            # handle 2 must props
            if pfun != UNDEFINED:
                must_count += 1
                if not pfun(pval, lpath_5 if path is not None else None, rep):
                    rep is None or rep.append(("invalid must property value [$.'$MultiPolygon']", lpath_5 if path is not None else None))
                    return False
        elif pfun := _jm_obj_5_may.get(prop):
            # handle {len(may)} may props
            if pfun != UNDEFINED and not pfun(pval, lpath_5 if path is not None else None, rep):
                rep is None or rep.append(("invalid may property value [$.'$MultiPolygon']", lpath_5 if path is not None else None))
                return False
        else:
            rep is None or rep.append(("no other prop expected [$.'$MultiPolygon']", lpath_5 if path is not None else None))
            return False
    if must_count != 2:
        rep is None or rep.append(("missing must prop [$.'$MultiPolygon']", path))
        return False
    return True

# check $MultiPolygon ($.'$MultiPolygon')
def json_model_10(val: Jsonable, path: Path, rep: Report) -> bool:
    res: bool
    # $.'$MultiPolygon'
    res = _jm_obj_5(val, path, rep)
    if not res:
        rep is None or rep.append(("not an expected object at [$.'$MultiPolygon']", path))
    return res


# check $geometry ($.'$geometry')
def json_model_11(val: Jsonable, path: Path, rep: Report) -> bool:
    res: bool
    # $.'$geometry'
    res = isinstance(val, dict)
    if res:
        tag_0: Jsonable = val.get("type", UNDEFINED)
        if tag_0 != UNDEFINED:
            fun_0: CheckFun = _jm_map_0.get(tag_0, UNDEFINED)
            if fun_0 != UNDEFINED:
                res = fun_0(val, path, rep)
            else:
                res = False
                rep is None or rep.append(("tag type value not found [$.'$geometry'.'|']", path))
        else:
            res = False
            rep is None or rep.append(("tag prop type is missing [$.'$geometry'.'|']", path))
    else:
        rep is None or rep.append(("value is not an object [$.'$geometry'.'|']", path))
    return res

# check _jm_obj_6_must_geometries ($.'$GeometryCollection'.geometries)
def _jm_f_18(val: Jsonable, path: Path, rep: Report) -> bool:
    res: bool
    # $.'$GeometryCollection'.geometries
    res = isinstance(val, list)
    if res:
        for arr_14_idx, arr_14_item in enumerate(val):
            arr_14_lpath: Path = (path + [ arr_14_idx ]) if path is not None else None
            # $.'$GeometryCollection'.geometries.0
            res = json_model_11(arr_14_item, path, rep)
            if not res:
                rep is None or rep.append(("unexpected $geometry [$.'$GeometryCollection'.geometries.0]", arr_14_lpath if path is not None else None))
            if not res:
                break
    if not res:
        rep is None or rep.append(("not array or unexpected array [$.'$GeometryCollection'.geometries]", path))
    return res

# check _jm_obj_6_must_type ($.'$GeometryCollection'.type)
def _jm_f_19(val: Jsonable, path: Path, rep: Report) -> bool:
    res: bool
    # $.'$GeometryCollection'.type
    res = isinstance(val, str) and val == "GeometryCollection"
    if not res:
        rep is None or rep.append(("unexpected GeometryCollection [$.'$GeometryCollection'.type]", path))
    return res


# check _jm_obj_6_may_bbox ($.'$GeometryCollection'.bbox)
def _jm_f_20(val: Jsonable, path: Path, rep: Report) -> bool:
    res: bool
    # $.'$GeometryCollection'.bbox
    res = isinstance(val, list)
    if res:
        for arr_15_idx, arr_15_item in enumerate(val):
            arr_15_lpath: Path = (path + [ arr_15_idx ]) if path is not None else None
            # $.'$GeometryCollection'.bbox.0
            res = isinstance(arr_15_item, (int, float)) and not isinstance(arr_15_item, bool)
            if not res:
                rep is None or rep.append(("not a -1.0 loose float [$.'$GeometryCollection'.bbox.0]", arr_15_lpath if path is not None else None))
            if not res:
                break
    if not res:
        rep is None or rep.append(("not array or unexpected array [$.'$GeometryCollection'.bbox]", path))
    return res


# object $.'$GeometryCollection'
def _jm_obj_6(val: Jsonable, path: Path, rep: Report) -> bool:
    if not isinstance(val, dict):
        rep is None or rep.append(("not an object [$.'$GeometryCollection']", path))
        return False
    pfun: CheckFun
    must_count: int = 0
    for prop, pval in val.items():
        assert isinstance(prop, str)
        lpath_6: Path = (path + [ prop ]) if path is not None else None
        if pfun := _jm_obj_6_must.get(prop):
            # handle 2 must props
            if pfun != UNDEFINED:
                must_count += 1
                if not pfun(pval, lpath_6 if path is not None else None, rep):
                    rep is None or rep.append(("invalid must property value [$.'$GeometryCollection']", lpath_6 if path is not None else None))
                    return False
        elif pfun := _jm_obj_6_may.get(prop):
            # handle {len(may)} may props
            if pfun != UNDEFINED and not pfun(pval, lpath_6 if path is not None else None, rep):
                rep is None or rep.append(("invalid may property value [$.'$GeometryCollection']", lpath_6 if path is not None else None))
                return False
        else:
            rep is None or rep.append(("no other prop expected [$.'$GeometryCollection']", lpath_6 if path is not None else None))
            return False
    if must_count != 2:
        rep is None or rep.append(("missing must prop [$.'$GeometryCollection']", path))
        return False
    return True

# check $GeometryCollection ($.'$GeometryCollection')
def json_model_12(val: Jsonable, path: Path, rep: Report) -> bool:
    res: bool
    # $.'$GeometryCollection'
    res = _jm_obj_6(val, path, rep)
    if not res:
        rep is None or rep.append(("not an expected object at [$.'$GeometryCollection']", path))
    return res

# check _jm_obj_7_must_geometry ($.'$Feature'.geometry)
def _jm_f_21(val: Jsonable, path: Path, rep: Report) -> bool:
    res: bool
    # $.'$Feature'.geometry
    # $.'$Feature'.geometry.'|'.0
    res = val is None
    if not res:
        rep is None or rep.append(("not null [$.'$Feature'.geometry.'|'.0]", path))
    if not res:
        # $.'$Feature'.geometry.'|'.1
        res = json_model_11(val, path, rep)
        if not res:
            rep is None or rep.append(("unexpected $geometry [$.'$Feature'.geometry.'|'.1]", path))
        if not res:
            # $.'$Feature'.geometry.'|'.2
            res = json_model_12(val, path, rep)
            if not res:
                rep is None or rep.append(("unexpected $GeometryCollection [$.'$Feature'.geometry.'|'.2]", path))
    if not res:
        rep is None or rep.append(("no model matched [$.'$Feature'.geometry.'|']", path))
    return res

# object $.'$Feature'.properties.'|'.1
def _jm_obj_8(val: Jsonable, path: Path, rep: Report) -> bool:
    if not isinstance(val, dict):
        rep is None or rep.append(("not an object [$.'$Feature'.properties.'|'.1]", path))
        return False
    # accept any object
    return True

# check _jm_obj_7_must_properties ($.'$Feature'.properties)
def _jm_f_22(val: Jsonable, path: Path, rep: Report) -> bool:
    res: bool
    # $.'$Feature'.properties
    # $.'$Feature'.properties.'|'.0
    res = val is None
    if not res:
        rep is None or rep.append(("not null [$.'$Feature'.properties.'|'.0]", path))
    if not res:
        # $.'$Feature'.properties.'|'.1
        res = _jm_obj_8(val, path, rep)
        if not res:
            rep is None or rep.append(("not an expected object at [$.'$Feature'.properties.'|'.1]", path))
    if not res:
        rep is None or rep.append(("no model matched [$.'$Feature'.properties.'|']", path))
    return res

# check _jm_obj_7_must_type ($.'$Feature'.type)
def _jm_f_23(val: Jsonable, path: Path, rep: Report) -> bool:
    res: bool
    # $.'$Feature'.type
    res = isinstance(val, str) and val == "Feature"
    if not res:
        rep is None or rep.append(("unexpected Feature [$.'$Feature'.type]", path))
    return res


# check _jm_obj_7_may_bbox ($.'$Feature'.bbox)
def _jm_f_24(val: Jsonable, path: Path, rep: Report) -> bool:
    res: bool
    # $.'$Feature'.bbox
    res = isinstance(val, list)
    if res:
        for arr_16_idx, arr_16_item in enumerate(val):
            arr_16_lpath: Path = (path + [ arr_16_idx ]) if path is not None else None
            # $.'$Feature'.bbox.0
            res = isinstance(arr_16_item, (int, float)) and not isinstance(arr_16_item, bool)
            if not res:
                rep is None or rep.append(("not a -1.0 loose float [$.'$Feature'.bbox.0]", arr_16_lpath if path is not None else None))
            if not res:
                break
    if not res:
        rep is None or rep.append(("not array or unexpected array [$.'$Feature'.bbox]", path))
    return res

# check _jm_obj_7_may_id ($.'$Feature'.id)
def _jm_f_25(val: Jsonable, path: Path, rep: Report) -> bool:
    res: bool
    # $.'$Feature'.id
    # $.'$Feature'.id.'|'.0
    res = isinstance(val, str)
    if not res:
        rep is None or rep.append(("unexpected string [$.'$Feature'.id.'|'.0]", path))
    if not res:
        # $.'$Feature'.id.'|'.1
        res = isinstance(val, (int, float)) and not isinstance(val, bool)
        if not res:
            rep is None or rep.append(("not a -1.0 loose float [$.'$Feature'.id.'|'.1]", path))
    if not res:
        rep is None or rep.append(("no model matched [$.'$Feature'.id.'|']", path))
    return res


# object $.'$Feature'
def _jm_obj_7(val: Jsonable, path: Path, rep: Report) -> bool:
    if not isinstance(val, dict):
        rep is None or rep.append(("not an object [$.'$Feature']", path))
        return False
    pfun: CheckFun
    must_count: int = 0
    for prop, pval in val.items():
        assert isinstance(prop, str)
        lpath_7: Path = (path + [ prop ]) if path is not None else None
        if pfun := _jm_obj_7_must.get(prop):
            # handle 3 must props
            if pfun != UNDEFINED:
                must_count += 1
                if not pfun(pval, lpath_7 if path is not None else None, rep):
                    rep is None or rep.append(("invalid must property value [$.'$Feature']", lpath_7 if path is not None else None))
                    return False
        elif pfun := _jm_obj_7_may.get(prop):
            # handle {len(may)} may props
            if pfun != UNDEFINED and not pfun(pval, lpath_7 if path is not None else None, rep):
                rep is None or rep.append(("invalid may property value [$.'$Feature']", lpath_7 if path is not None else None))
                return False
        else:
            rep is None or rep.append(("no other prop expected [$.'$Feature']", lpath_7 if path is not None else None))
            return False
    if must_count != 3:
        rep is None or rep.append(("missing must prop [$.'$Feature']", path))
        return False
    return True

# check $Feature ($.'$Feature')
def json_model_13(val: Jsonable, path: Path, rep: Report) -> bool:
    res: bool
    # $.'$Feature'
    res = _jm_obj_7(val, path, rep)
    if not res:
        rep is None or rep.append(("not an expected object at [$.'$Feature']", path))
    return res

# check _jm_obj_9_must_features ($.'$FeatureCollection'.features)
def _jm_f_26(val: Jsonable, path: Path, rep: Report) -> bool:
    res: bool
    # $.'$FeatureCollection'.features
    res = isinstance(val, list)
    if res:
        for arr_17_idx, arr_17_item in enumerate(val):
            arr_17_lpath: Path = (path + [ arr_17_idx ]) if path is not None else None
            # $.'$FeatureCollection'.features.0
            res = json_model_13(arr_17_item, path, rep)
            if not res:
                rep is None or rep.append(("unexpected $Feature [$.'$FeatureCollection'.features.0]", arr_17_lpath if path is not None else None))
            if not res:
                break
    if not res:
        rep is None or rep.append(("not array or unexpected array [$.'$FeatureCollection'.features]", path))
    return res

# check _jm_obj_9_must_type ($.'$FeatureCollection'.type)
def _jm_f_27(val: Jsonable, path: Path, rep: Report) -> bool:
    res: bool
    # $.'$FeatureCollection'.type
    res = isinstance(val, str) and val == "FeatureCollection"
    if not res:
        rep is None or rep.append(("unexpected FeatureCollection [$.'$FeatureCollection'.type]", path))
    return res


# check _jm_obj_9_may_bbox ($.'$FeatureCollection'.bbox)
def _jm_f_28(val: Jsonable, path: Path, rep: Report) -> bool:
    res: bool
    # $.'$FeatureCollection'.bbox
    res = isinstance(val, list)
    if res:
        for arr_18_idx, arr_18_item in enumerate(val):
            arr_18_lpath: Path = (path + [ arr_18_idx ]) if path is not None else None
            # $.'$FeatureCollection'.bbox.0
            res = isinstance(arr_18_item, (int, float)) and not isinstance(arr_18_item, bool)
            if not res:
                rep is None or rep.append(("not a -1.0 loose float [$.'$FeatureCollection'.bbox.0]", arr_18_lpath if path is not None else None))
            if not res:
                break
    if not res:
        rep is None or rep.append(("not array or unexpected array [$.'$FeatureCollection'.bbox]", path))
    return res


# object $.'$FeatureCollection'
def _jm_obj_9(val: Jsonable, path: Path, rep: Report) -> bool:
    if not isinstance(val, dict):
        rep is None or rep.append(("not an object [$.'$FeatureCollection']", path))
        return False
    pfun: CheckFun
    must_count: int = 0
    for prop, pval in val.items():
        assert isinstance(prop, str)
        lpath_8: Path = (path + [ prop ]) if path is not None else None
        if pfun := _jm_obj_9_must.get(prop):
            # handle 2 must props
            if pfun != UNDEFINED:
                must_count += 1
                if not pfun(pval, lpath_8 if path is not None else None, rep):
                    rep is None or rep.append(("invalid must property value [$.'$FeatureCollection']", lpath_8 if path is not None else None))
                    return False
        elif pfun := _jm_obj_9_may.get(prop):
            # handle {len(may)} may props
            if pfun != UNDEFINED and not pfun(pval, lpath_8 if path is not None else None, rep):
                rep is None or rep.append(("invalid may property value [$.'$FeatureCollection']", lpath_8 if path is not None else None))
                return False
        else:
            rep is None or rep.append(("no other prop expected [$.'$FeatureCollection']", lpath_8 if path is not None else None))
            return False
    if must_count != 2:
        rep is None or rep.append(("missing must prop [$.'$FeatureCollection']", path))
        return False
    return True

# check $FeatureCollection ($.'$FeatureCollection')
def json_model_14(val: Jsonable, path: Path, rep: Report) -> bool:
    res: bool
    # $.'$FeatureCollection'
    res = _jm_obj_9(val, path, rep)
    if not res:
        rep is None or rep.append(("not an expected object at [$.'$FeatureCollection']", path))
    return res

# check $ ($)
def json_model_1(val: Jsonable, path: Path, rep: Report) -> bool:
    res: bool
    # $
    # generic xor list
    xc_0: int = 0
    xr_0: bool
    # $.'^'.0
    xr_0 = json_model_11(val, path, rep)
    if not xr_0:
        rep is None or rep.append(("unexpected $geometry [$.'^'.0]", path))
    if xr_0:
        xc_0 += 1
    # $.'^'.1
    xr_0 = json_model_12(val, path, rep)
    if not xr_0:
        rep is None or rep.append(("unexpected $GeometryCollection [$.'^'.1]", path))
    if xr_0:
        xc_0 += 1
    if xc_0 <= 1:
        # $.'^'.2
        xr_0 = json_model_13(val, path, rep)
        if not xr_0:
            rep is None or rep.append(("unexpected $Feature [$.'^'.2]", path))
        if xr_0:
            xc_0 += 1
    if xc_0 <= 1:
        # $.'^'.3
        xr_0 = json_model_14(val, path, rep)
        if not xr_0:
            rep is None or rep.append(("unexpected $FeatureCollection [$.'^'.3]", path))
        if xr_0:
            xc_0 += 1
    res = xc_0 == 1
    if not res:
        rep is None or rep.append(("not one model match [$.'^']", path))
    return res


# initialization guard
initialized: bool = False

# differed module initializations
def check_model_init():
    global initialized
    if not initialized:
        initialized = True
        global _jm_obj_0_must
        _jm_obj_0_must = {
            "coordinates": _jm_f_0,
            "type": _jm_f_1,
        }
        global _jm_obj_0_may
        _jm_obj_0_may = {
            "bbox": _jm_f_2,
        }
        global _jm_obj_1_must
        _jm_obj_1_must = {
            "coordinates": _jm_f_3,
            "type": _jm_f_4,
        }
        global _jm_obj_1_may
        _jm_obj_1_may = {
            "bbox": _jm_f_5,
        }
        global _jm_obj_2_must
        _jm_obj_2_must = {
            "coordinates": _jm_f_6,
            "type": _jm_f_7,
        }
        global _jm_obj_2_may
        _jm_obj_2_may = {
            "bbox": _jm_f_8,
        }
        global _jm_obj_3_must
        _jm_obj_3_must = {
            "coordinates": _jm_f_9,
            "type": _jm_f_10,
        }
        global _jm_obj_3_may
        _jm_obj_3_may = {
            "bbox": _jm_f_11,
        }
        global _jm_obj_4_must
        _jm_obj_4_must = {
            "coordinates": _jm_f_12,
            "type": _jm_f_13,
        }
        global _jm_obj_4_may
        _jm_obj_4_may = {
            "bbox": _jm_f_14,
        }
        global _jm_obj_5_must
        _jm_obj_5_must = {
            "coordinates": _jm_f_15,
            "type": _jm_f_16,
        }
        global _jm_obj_5_may
        _jm_obj_5_may = {
            "bbox": _jm_f_17,
        }
        global _jm_map_0
        _jm_map_0 = {
            "Point": json_model_5,
            "MultiPoint": json_model_6,
            "LineString": json_model_7,
            "MultiLineString": json_model_8,
            "Polygon": json_model_9,
            "MultiPolygon": json_model_10,
        }
        global _jm_obj_6_must
        _jm_obj_6_must = {
            "geometries": _jm_f_18,
            "type": _jm_f_19,
        }
        global _jm_obj_6_may
        _jm_obj_6_may = {
            "bbox": _jm_f_20,
        }
        global _jm_obj_7_must
        _jm_obj_7_must = {
            "geometry": _jm_f_21,
            "properties": _jm_f_22,
            "type": _jm_f_23,
        }
        global _jm_obj_7_may
        _jm_obj_7_may = {
            "bbox": _jm_f_24,
            "id": _jm_f_25,
        }
        global _jm_obj_9_must
        _jm_obj_9_must = {
            "features": _jm_f_26,
            "type": _jm_f_27,
        }
        global _jm_obj_9_may
        _jm_obj_9_may = {
            "bbox": _jm_f_28,
        }
        global check_model_map
        check_model_map = {
            "": json_model_1,
            "position": json_model_2,
            "coord_array": json_model_3,
            "linear_ring": json_model_4,
            "Point": json_model_5,
            "MultiPoint": json_model_6,
            "LineString": json_model_7,
            "MultiLineString": json_model_8,
            "Polygon": json_model_9,
            "MultiPolygon": json_model_10,
            "geometry": json_model_11,
            "GeometryCollection": json_model_12,
            "Feature": json_model_13,
            "FeatureCollection": json_model_14,
        }

# differed module cleanup
def check_model_free():
    global initialized
    if initialized:
        initialized = False


if __name__ == "__main__":
    check_model_init()
    main(check_model_fun, check_model_map, __version__)
    check_model_free()
