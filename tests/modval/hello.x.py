#! /bin/env python
#
# Generated by JSON Model Compiler version 2.0a0
# see https://github.com/clairey-zx81/json-model
#
__version__ = "2.0a0"
#
# type declarations for python jm runtime
#
type JsonScalar = None|bool|int|float|str
type Jsonable = JsonScalar|list[Jsonable]|dict[str, Jsonable]

type Path = list[int|str]|None
type Report = list[tuple[str, Path]]|None

type CheckFun = Callable[[Jsonable, Path, Report], bool]
type RegexFun = Callable[[str], bool]
type PropMap = dict[str, CheckFun]

type EntryCheckFun = Callable[[Jsonable, str, Report], bool]
from typing import Callable
import datetime
import urllib.parse

# call initialize only once
initialized: bool = False

# special undefined value
UNDEFINED: object = object()

# map model names to check functions
jm_check_model_map_size: int
jm_check_model_map: PropMap

# extract type name
def _tname(value: Jsonable) -> str:
    return type(value).__name__

# maybe add message to report
def _rep(msg: str, rep: Report) -> bool:
    rep is None or rep.append(msg)
    return False

# generate path for display
# TODO add appropriate escapingâ€¦
def _path(path: Path) -> str:
    return ".".join(str(i) for i in path)

def check_model_fun(name: str) -> CheckFun:
    """Return check function for JSON model name."""
    return jm_check_model_map[name]

# entry point for generated checkers
def check_model(val: Jsonable, name: str = "", rep: Report = None) -> bool:
    """Check val validity agains JSON Model name."""
    if name not in jm_check_model_map:
        raise Exception(f"unexpected model name: {name}")
    checker = jm_check_model_map[name]
    return checker(val, [], rep)

# types: JsonScalar

from collections.abc import MutableMapping, MutableSet

class Const:
    """A constant holder suitable for set/dict, with a stricly typed comparison.

    The point is to avoid 1 == 1.0 == True, 0 == 0.0 == False, n == n.0
    """

    def __init__(self, val: JsonScalar):
        self._val = val

    def __hash__(self):
        return hash(self._val)

    def __eq__(self, val):
        return (
            isinstance(val, Const) and
            type(self._val) is type(val._val) and
            self._val == val._val
        )


class ConstSet(MutableSet[JsonScalar]):
    """A set of constants, with strictly typed comparisons."""

    def __init__(self, init: list[JsonScalar]|str|None = None):
        self._set: set[Const] = set()
        if init:
            for item in init:
                self.add(item)

    def __len__(self):
        return len(self._set)

    def __iter__(self):
        return [ item._val for item in self._set ]

    def __contains__(self, item):
        return Const(item) in self._set

    def add(self, item):
        self._set.add(Const(item))

    def discard(self, item):
        self._set.discard(Const(item))


class ConstMap(MutableMapping[JsonScalar, CheckFun]):
    """A mapping of constants to check functions."""

    def __init__(self):
        self._map: dict[Const, CheckFun] = {}

    def __setitem__(self, key, val):
        self._map[Const(key)] = val

    def __getitem__(self, key):
        if isinstance(key, (list, dict)):
            return UNDEFINED
        else:
            return self._map[Const(key)]

    def __delitem__(self, key):
        del self._map[Const(key)]

    def __iter__(self):
        return [ (k._val, v) for k, v in self._map.items() ]

    def __len__(self):
        return self._map.__len__()

_jm_obj_0_must: PropMap
jm_check_model_map: PropMap

# check _jm_obj_0_must_hello ($.hello)
def _jm_f_0(val: Jsonable, path: Path, rep: Report) -> bool:
    res: bool
    # $.hello
    res = isinstance(val, int) and not isinstance(val, bool) and val >= 0
    if not res:
        rep is None or rep.append(("not a 0 int [$.hello]", path))
    return res

# check _jm_obj_0_must_world ($.world)
def _jm_f_1(val: Jsonable, path: Path, rep: Report) -> bool:
    res: bool
    # $.world
    res = isinstance(val, bool)
    if not res:
        rep is None or rep.append(("not a bool [$.world]", path))
    return res


# object $
def _jm_obj_0(val: Jsonable, path: Path, rep: Report) -> bool:
    if not isinstance(val, dict):
        rep is None or rep.append(("not an object [$]", path))
        return False
    pfun: CheckFun
    must_count: int = 0
    for prop, pval in val.items():
        assert isinstance(prop, str)
        lpath_0: Path = (path + [ prop ]) if path is not None else None
        if pfun := _jm_obj_0_must.get(prop):
            # handle 2 must props
            if pfun != UNDEFINED:
                must_count += 1
                if not pfun(pval, lpath_0 if path is not None else None, rep):
                    rep is None or rep.append(("invalid must property value [$]", lpath_0 if path is not None else None))
                    return False
        else:
            rep is None or rep.append(("no other prop expected [$]", lpath_0 if path is not None else None))
            return False
    if must_count != 2:
        rep is None or rep.append(("missing must prop [$]", path))
        return False
    return True

# check $ ($)
def json_model_1(val: Jsonable, path: Path, rep: Report) -> bool:
    res: bool
    # $
    res = _jm_obj_0(val, path, rep)
    if not res:
        rep is None or rep.append(("not an expected object at [$]", path))
    return res


# differed module initializations
def check_model_init():
    global initialized
    if not initialized:
        initialized = True
        global _jm_obj_0_must
        _jm_obj_0_must = {
            "hello": _jm_f_0,
            "world": _jm_f_1,
        }
        global jm_check_model_map
        jm_check_model_map = {
            "": json_model_1,
        }

# differed module cleanup
def check_model_free():
    global initialized
    if initialized:
        initialized = False


# possibly run as a script: $0 values...
if __name__ == "__main__":
    import json
    import sys
    import argparse
    import logging

    logging.basicConfig()
    log = logging.getLogger("checker")

    ap = argparse.ArgumentParser()
    ap.add_argument("--debug", "-d", action="store_true", help="set verbose mode")
    ap.add_argument("--name", "-n", default="", help="select model by name")
    ap.add_argument("--list", "-l", action="store_true", help="show available model names and exit")
    ap.add_argument("--version", "-v", action="store_true", help="show JSON Model compiler version")
    ap.add_argument("--report", "-r", action="store_true", help="show error locations on failure")
    ap.add_argument("--test", "-t", action="store_true", help="assume test vector JSON files")
    ap.add_argument("values", nargs="*", help="JSON files")
    args = ap.parse_args()

    log.setLevel(logging.DEBUG if args.debug else logging.INFO)

    check_model_init()

    if args.list:
        print(f"JSON Models (empty for root):{' '.join(sorted(_json_model_map.keys()))}")
        sys.exit(0)
    if args.version:
        print(f"Python from JSON Model compiler version {__version__}")
        sys.exit(0)

    try:
        checker: CheckFun = check_model_fun(args.name)
    except Exception as e:
        log.debug(e, exc_info=args.debug)
        log.error(f"error on model for {args.name}: {e}")
        sys.exit(1)

    for fn in args.values:
        try:
            with open(fn) as f:
                value = json.load(f)
            values = value if args.test else [ [ None, value ] ]
            for i, (expect, val) in enumerate(values):
                info = "" if expect is None else f"[{i}]"
                reasons = [] if args.report else None
                path = [] if args.report else None
                valid = checker(val, path, reasons)
                if expect is not None and valid != expect:
                    print(f"{fn}{info}: ERROR unexpected {'PASS' if expect else 'FAIL'}")
                elif valid:
                    print(f"{fn}{info}: PASS")
                elif reasons:
                    print(f"{fn}{info}: FAIL {reasons}")
                else:
                    print(f"{fn}{info}: FAIL")
        except Exception as e:
            log.debug(e, exc_info=args.debug)
            print(f"{fn}: ERROR ({e})")

    check_model_free()
