#! /bin/env python
#
# Model: ./json-schema-draft-02.model.json
#
# Generated by jmc (JSON Model Compiler) (https://github.com/clairey-zx81/json-model)
#

from typing import Callable
import re as re
import datetime
import urllib.parse

type Jsonable = None|bool|int|float|str|list[Jsonable]|dict[str, Jsonable]
type Path = list[str]
type Report = list[str]|None
type CheckFun = Callable[[Jsonable, str, Report], bool]
type PropMap = dict[str, CheckFun]
type TagMap = dict[None|bool|float|int|str, CheckFun]

# extract type name
def _tname(value: Jsonable) -> str:
    return type(value).__name__

# maybe add message to report
def _rep(msg: str, rep: Report) -> bool:
    rep is None or rep.append(msg)
    return False

json_model_1_may: PropMap

def _is_valid_re(value: Jsonable, path: str, rep: Report = None) -> bool:
    if isinstance(value, str):
        try:
            re.compile(value)
            return True
        except Exception as e:
            rep is None or rep.append(f"regex compile error at {path}: {value} ({e})")
            return False
    rep is None or rep.append(f"incompatible type for regex at {path}: {_tname(value)}")
    return False

# define "json_model_1_may_type" ($.type)
def _jm_f_0(value: Jsonable, path: str, rep: Report = None) -> bool:
    # $.type
    # $.type.'|'.0
    result = json_model_2(value, path, rep)
    if not result:
        rep is None or rep.append(f"not an expected $allTypes at {path} [$.type.'|'.0]")
    if not result:
        # $.type.'|'.1
        result = isinstance(value, list)
        if result:
            for array_1_idx, array_1_item in enumerate(value):
                lpath = path + '.' + str(array_1_idx)
                # $.type.'|'.1.0
                # $.type.'|'.1.0.'|'.0
                result = isinstance(array_1_item, str)
                if not result:
                    rep is None or rep.append(f"not an expected string at {lpath} [$.type.'|'.1.0.'|'.0]")
                if not result:
                    # $.type.'|'.1.0.'|'.1
                    result = json_model_4(array_1_item, path, rep)
                    if not result:
                        rep is None or rep.append(f"not an expected $Schema at {lpath} [$.type.'|'.1.0.'|'.1]")
                if not result:
                    rep is None or rep.append(f"not any model match at {lpath} [$.type.'|'.1.0.'|']")
                if not result:
                    break
        if not result:
            rep is None or rep.append(f"not array or unexpected array at {path} [$.type.'|'.1]")
    if not result:
        rep is None or rep.append(f"not any model match at {path} [$.type.'|']")
    return result



# define "json_model_1_may_items" ($.items)
def _jm_f_2(value: Jsonable, path: str, rep: Report = None) -> bool:
    # $.items
    # $.items.'|'.0
    result = json_model_4(value, path, rep)
    if not result:
        rep is None or rep.append(f"not an expected $Schema at {path} [$.items.'|'.0]")
    if not result:
        # $.items.'|'.1
        result = isinstance(value, list)
        if result:
            for array_2_idx, array_2_item in enumerate(value):
                lpath = path + '.' + str(array_2_idx)
                # $.items.'|'.1.0
                result = json_model_4(array_2_item, path, rep)
                if not result:
                    rep is None or rep.append(f"not an expected $Schema at {lpath} [$.items.'|'.1.0]")
                if not result:
                    break
        if not result:
            rep is None or rep.append(f"not array or unexpected array at {path} [$.items.'|'.1]")
    if not result:
        rep is None or rep.append(f"not any model match at {path} [$.items.'|']")
    return result

# define "json_model_1_may_optional" ($.optional)
def _jm_f_3(value: Jsonable, path: str, rep: Report = None) -> bool:
    # $.optional
    result = isinstance(value, bool)
    if not result:
        rep is None or rep.append(f"not a bool at {path} [$.optional]")
    return result

# define "json_model_1_may_additionalProperties" ($.additionalProperties)
def _jm_f_4(value: Jsonable, path: str, rep: Report = None) -> bool:
    # $.additionalProperties
    # $.additionalProperties.'|'.0
    result = isinstance(value, bool)
    if not result:
        rep is None or rep.append(f"not a bool at {path} [$.additionalProperties.'|'.0]")
    if not result:
        # $.additionalProperties.'|'.1
        result = json_model_4(value, path, rep)
        if not result:
            rep is None or rep.append(f"not an expected $Schema at {path} [$.additionalProperties.'|'.1]")
    if not result:
        rep is None or rep.append(f"not any model match at {path} [$.additionalProperties.'|']")
    return result

# define "json_model_1_may_requires" ($.requires)
def _jm_f_5(value: Jsonable, path: str, rep: Report = None) -> bool:
    # $.requires
    # $.requires.'|'.0
    result = isinstance(value, str)
    if not result:
        rep is None or rep.append(f"not an expected string at {path} [$.requires.'|'.0]")
    if not result:
        # $.requires.'|'.1
        result = json_model_4(value, path, rep)
        if not result:
            rep is None or rep.append(f"not an expected $Schema at {path} [$.requires.'|'.1]")
    if not result:
        rep is None or rep.append(f"not any model match at {path} [$.requires.'|']")
    return result

# define "json_model_1_may_minimum" ($.minimum)
def _jm_f_6(value: Jsonable, path: str, rep: Report = None) -> bool:
    # $.minimum
    result = (isinstance(value, float) or isinstance(value, int) and not isinstance(value, bool))
    if not result:
        rep is None or rep.append(f"not a -1.0 float at {path} [$.minimum]")
    return result

# define "json_model_1_may_maximum" ($.maximum)
def _jm_f_7(value: Jsonable, path: str, rep: Report = None) -> bool:
    # $.maximum
    result = (isinstance(value, float) or isinstance(value, int) and not isinstance(value, bool))
    if not result:
        rep is None or rep.append(f"not a -1.0 float at {path} [$.maximum]")
    return result

# define "json_model_1_may_minimumCanEqual" ($.minimumCanEqual)
def _jm_f_8(value: Jsonable, path: str, rep: Report = None) -> bool:
    # $.minimumCanEqual
    result = isinstance(value, bool)
    if not result:
        rep is None or rep.append(f"not a bool at {path} [$.minimumCanEqual]")
    return result

# define "json_model_1_may_maximumCanEqual" ($.maximumCanEqual)
def _jm_f_9(value: Jsonable, path: str, rep: Report = None) -> bool:
    # $.maximumCanEqual
    result = isinstance(value, bool)
    if not result:
        rep is None or rep.append(f"not a bool at {path} [$.maximumCanEqual]")
    return result

# define "json_model_1_may_minItems" ($.minItems)
def _jm_f_10(value: Jsonable, path: str, rep: Report = None) -> bool:
    # $.minItems
    result = isinstance(value, int) and not isinstance(value, bool) and value >= 0
    if not result:
        rep is None or rep.append(f"not a 0 int at {path} [$.minItems]")
    return result

# define "json_model_1_may_maxItems" ($.maxItems)
def _jm_f_11(value: Jsonable, path: str, rep: Report = None) -> bool:
    # $.maxItems
    result = isinstance(value, int) and not isinstance(value, bool) and value >= 0
    if not result:
        rep is None or rep.append(f"not a 0 int at {path} [$.maxItems]")
    return result

# define "json_model_1_may_pattern" ($.pattern)
def _jm_f_12(value: Jsonable, path: str, rep: Report = None) -> bool:
    # $.pattern
    result = _is_valid_re(value, path, rep) or _rep(f"invalid $REGEX at {path}", rep)
    if not result:
        rep is None or rep.append(f"not an expected $REGEX at {path} [$.pattern]")
    return result

# define "json_model_1_may_minLength" ($.minLength)
def _jm_f_13(value: Jsonable, path: str, rep: Report = None) -> bool:
    # $.minLength
    result = isinstance(value, int) and not isinstance(value, bool) and value >= 0
    if not result:
        rep is None or rep.append(f"not a 0 int at {path} [$.minLength]")
    return result

# define "json_model_1_may_maxLength" ($.maxLength)
def _jm_f_14(value: Jsonable, path: str, rep: Report = None) -> bool:
    # $.maxLength
    result = isinstance(value, int) and not isinstance(value, bool) and value >= 0
    if not result:
        rep is None or rep.append(f"not a 0 int at {path} [$.maxLength]")
    return result

# define "json_model_1_may_enum" ($.enum)
def _jm_f_15(value: Jsonable, path: str, rep: Report = None) -> bool:
    # $.enum
    # $.enum.'@'
    result = isinstance(value, list)
    if result:
        for array_3_idx, array_3_item in enumerate(value):
            lpath = path + '.' + str(array_3_idx)
            # $.enum.'@'.0
            result = True or _rep(f"invalid $ANY at {path}", rep)
            if not result:
                rep is None or rep.append(f"not an expected $ANY at {lpath} [$.enum.'@'.0]")
            if not result:
                break
    if not result:
        rep is None or rep.append(f"not array or unexpected array at {path} [$.enum.'@']")
    result &= len(set(value)) == len(value)
    result &= len(value) >= 1
    if not result:
        rep is None or rep.append(f"invalid type or constraints at {path} [$.enum]")
    return result

# define "json_model_1_may_uniqueItems" ($.uniqueItems)
def _jm_f_16(value: Jsonable, path: str, rep: Report = None) -> bool:
    # $.uniqueItems
    result = isinstance(value, bool)
    if not result:
        rep is None or rep.append(f"not a bool at {path} [$.uniqueItems]")
    return result

# define "json_model_1_may_title" ($.title)
def _jm_f_17(value: Jsonable, path: str, rep: Report = None) -> bool:
    # $.title
    result = isinstance(value, str)
    if not result:
        rep is None or rep.append(f"not an expected string at {path} [$.title]")
    return result

# define "json_model_1_may_description" ($.description)
def _jm_f_18(value: Jsonable, path: str, rep: Report = None) -> bool:
    # $.description
    result = isinstance(value, str)
    if not result:
        rep is None or rep.append(f"not an expected string at {path} [$.description]")
    return result

# define "json_model_1_may_format" ($.format)
def _jm_f_19(value: Jsonable, path: str, rep: Report = None) -> bool:
    # $.format
    result = isinstance(value, str)
    if not result:
        rep is None or rep.append(f"not an expected string at {path} [$.format]")
    return result

# define "json_model_1_may_contentEncoding" ($.contentEncoding)
def _jm_f_20(value: Jsonable, path: str, rep: Report = None) -> bool:
    # $.contentEncoding
    result = isinstance(value, str)
    if not result:
        rep is None or rep.append(f"not an expected string at {path} [$.contentEncoding]")
    return result

# define "json_model_1_may_default" ($.default)
def _jm_f_21(value: Jsonable, path: str, rep: Report = None) -> bool:
    # $.default
    result = True or _rep(f"invalid $ANY at {path}", rep)
    if not result:
        rep is None or rep.append(f"not an expected $ANY at {path} [$.default]")
    return result

# define "json_model_1_may_divisibleBy" ($.divisibleBy)
def _jm_f_22(value: Jsonable, path: str, rep: Report = None) -> bool:
    # $.divisibleBy
    result = (isinstance(value, float) or isinstance(value, int) and not isinstance(value, bool)) and value > 0.0
    if not result:
        rep is None or rep.append(f"not a 1.0 float at {path} [$.divisibleBy]")
    return result

# define "json_model_1_may_disallow" ($.disallow)
def _jm_f_23(value: Jsonable, path: str, rep: Report = None) -> bool:
    # $.disallow
    # $.disallow.'|'.0
    result = isinstance(value, str)
    if not result:
        rep is None or rep.append(f"not an expected string at {path} [$.disallow.'|'.0]")
    if not result:
        # $.disallow.'|'.1
        result = json_model_3(value, path, rep)
        if not result:
            rep is None or rep.append(f"not an expected $distinctStringArray at {path} [$.disallow.'|'.1]")
    if not result:
        rep is None or rep.append(f"not any model match at {path} [$.disallow.'|']")
    return result

# define "json_model_1_may_extends" ($.extends)
def _jm_f_24(value: Jsonable, path: str, rep: Report = None) -> bool:
    # $.extends
    # $.extends.'|'.0
    result = json_model_4(value, path, rep)
    if not result:
        rep is None or rep.append(f"not an expected $Schema at {path} [$.extends.'|'.0]")
    if not result:
        # $.extends.'|'.1
        result = isinstance(value, list)
        if result:
            for array_4_idx, array_4_item in enumerate(value):
                lpath = path + '.' + str(array_4_idx)
                # $.extends.'|'.1.0
                result = json_model_4(array_4_item, path, rep)
                if not result:
                    rep is None or rep.append(f"not an expected $Schema at {lpath} [$.extends.'|'.1.0]")
                if not result:
                    break
        if not result:
            rep is None or rep.append(f"not array or unexpected array at {path} [$.extends.'|'.1]")
    if not result:
        rep is None or rep.append(f"not any model match at {path} [$.extends.'|']")
    return result

# define "json_model_1_may_id" ($.id)
def _jm_f_25(value: Jsonable, path: str, rep: Report = None) -> bool:
    # $.id
    result = isinstance(value, str)
    if not result:
        rep is None or rep.append(f"not an expected string at {path} [$.id]")
    return result

# define "json_model_1_may_$schema" ($.'$schema')
def _jm_f_26(value: Jsonable, path: str, rep: Report = None) -> bool:
    # $.'$schema'
    result = isinstance(value, str)
    if not result:
        rep is None or rep.append(f"not an expected string at {path} [$.'$schema']")
    return result


# define "$allTypes" ($.'$allTypes')
def json_model_2(value: Jsonable, path: str, rep: Report = None) -> bool:
    # $.'$allTypes'
    result = not isinstance(value, (list, dict)) and value in {'any', 'array', 'boolean', 'integer', 'null', 'number', 'object', 'string'}
    if not result:
        rep is None or rep.append(f"value not in enum at {path} [$.'$allTypes'.'|']")
    return result

# define "$distinctStringArray" ($.'$distinctStringArray')
def json_model_3(value: Jsonable, path: str, rep: Report = None) -> bool:
    # $.'$distinctStringArray'
    # $.'$distinctStringArray'.'@'
    result = isinstance(value, list)
    if result:
        for array_0_idx, array_0_item in enumerate(value):
            lpath = path + '.' + str(array_0_idx)
            # $.'$distinctStringArray'.'@'.0
            result = isinstance(array_0_item, str)
            if not result:
                rep is None or rep.append(f"not an expected string at {lpath} [$.'$distinctStringArray'.'@'.0]")
            if not result:
                break
    if not result:
        rep is None or rep.append(f"not array or unexpected array at {path} [$.'$distinctStringArray'.'@']")
    result &= len(set(value)) == len(value)
    if not result:
        rep is None or rep.append(f"invalid type or constraints at {path} [$.'$distinctStringArray']")
    return result

# define "$Schema" ($.'$Schema')
def json_model_4(value: Jsonable, path: str, rep: Report = None) -> bool:
    # $.'$Schema'
    result = json_model_1(value, path, rep)
    if not result:
        rep is None or rep.append(f"not an expected $# at {path} [$.'$Schema']")
    return result


# object $.properties
def _jm_f_1(value: Jsonable, path: str, rep: Report = None) -> bool:
    if not isinstance(value, dict):
        rep is None or rep.append(f"not an object at {path} [$.properties]")
        return False
    for prop, val in value.items():
        assert isinstance(prop, str)
        lpath = path + "." + prop
        # $.properties.''
        result = json_model_4(val, path, rep)
        if not result:
            rep is None or rep.append(f"not an expected $Schema at {lpath} [$.properties.'']")
        if not result:
            rep is None or rep.append(f"unexpected other value at {lpath} [$.properties.'']")
            return False
    return True


# object $
def json_model_1(value: Jsonable, path: str, rep: Report = None) -> bool:
    if not isinstance(value, dict):
        rep is None or rep.append(f"not an object at {path} [$]")
        return False
    for prop, val in value.items():
        assert isinstance(prop, str)
        lpath = path + "." + prop
        if prop in json_model_1_may:  # may
            if not json_model_1_may[prop](val, lpath, rep):
                rep is None or rep.append(f"invalid may prop value at {lpath} [$.{prop}]")
                return False
        else:  # no catch all
            rep is None or rep.append(f"no other prop expected at {path} [$]")
            return False
    return True



# entry function check_model
def check_model(value: Jsonable, path: str = "$", rep: Report = None) -> bool:
    return json_model_1(value, path, rep)


# object properties maps
json_model_1_may = {
    "type": _jm_f_0,
    "properties": _jm_f_1,
    "items": _jm_f_2,
    "optional": _jm_f_3,
    "additionalProperties": _jm_f_4,
    "requires": _jm_f_5,
    "minimum": _jm_f_6,
    "maximum": _jm_f_7,
    "minimumCanEqual": _jm_f_8,
    "maximumCanEqual": _jm_f_9,
    "minItems": _jm_f_10,
    "maxItems": _jm_f_11,
    "pattern": _jm_f_12,
    "minLength": _jm_f_13,
    "maxLength": _jm_f_14,
    "enum": _jm_f_15,
    "uniqueItems": _jm_f_16,
    "title": _jm_f_17,
    "description": _jm_f_18,
    "format": _jm_f_19,
    "contentEncoding": _jm_f_20,
    "default": _jm_f_21,
    "divisibleBy": _jm_f_22,
    "disallow": _jm_f_23,
    "extends": _jm_f_24,
    "id": _jm_f_25,
    "$schema": _jm_f_26,
}


# possibly run as a script: $0 values...
if __name__ == "__main__":
    import json
    import sys
    for fn in sys.argv[1:]:
        try:
            with open(fn) as f:
                value = json.load(f)
            reasons = []
            if check_model(value, "", reasons):
                print(f"{fn}: PASS")
            else:
                print(f"{fn}: FAIL {reasons}")
        except Exception as e:
            print(f"{fn}: ERROR ({e})")

