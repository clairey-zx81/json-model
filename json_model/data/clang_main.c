#ifdef WITH_MAIN
#include <stdio.h>
#include <unistd.h>
#include <assert.h>

typedef enum {
    expect_nothing,
    expect_fail,
    expect_pass
} process_mode_t;

// check value and report if there was some error wrt expectations
static bool
process_value(check_fun_t checker, json_t * value,
    const char *fname, size_t index, process_mode_t mode, bool report)
{
    // check value against model, fast (no path nor reasons)
    bool valid = checker(value, NULL, NULL);
    bool unexpected = (mode == expect_fail && valid) || (mode == expect_pass && !valid);

    if (mode == expect_nothing)  // just show
        fprintf(stdout, "%s: %s", fname, valid ? "PASS" : "FAIL");
    else if (unexpected)
        fprintf(stdout, "%s[%zu]: ERROR unexpected %s", fname, index, valid ? "PASS" : "FAIL");
    else  // as expected
        fprintf(stdout, "%s[%zu]: %s", fname, index, valid ? "PASS" : "FAIL");

    // second pass with report collection
    if (!valid && report)
    {
        Path path = (Path) { "", 0, NULL, NULL };
        Report report = (Report) { NULL };

        bool valid2 = checker(value, &path, &report);
        assert(valid == valid2);

        for (ReportEntry *entry = report.entry; entry != NULL; entry = entry->prev)
            fprintf(stdout, " (%s: %s)", entry->path, entry->message);

        report_free_entries(&report);
    }

    fprintf(stdout, "\n");

    return unexpected;
}

int main(int argc, char* argv[])
{
    // get options
    int opt;
    char *name = "";
    bool report = false;
    bool test = false;
    while ((opt = getopt(argc, argv, "hvln:rt")) != -1)
    {
        switch (opt) {
            case 'h':
                fprintf(stdout,
                        "Usage: %s [-h] [-v] [-l] [-n name] [files...]\n"
                        "Check JSON values validity against a JSON model\n"
                        "Generated by jmc (JSON Model Compiler) version %s\n"
                        "see https://github.com/clairey-zx81/json-model\n",
                        argv[0], JSON_MODEL_VERSION);
                return 0;
            case 'l':
                fprintf(stdout, "JSON Model names (empty for default):");
                for (int i = 0; i < array_length(_check_model_map_tab); i++)
                    fprintf(stdout, "%s ", _check_model_map_tab[i].name);
                fprintf(stdout, "\n");
                return 0;
            case 'v':
                fprintf(stdout, "C from JSON Model compiler version %s\n", JSON_MODEL_VERSION);
                return 0;
            case 'n':
                name = optarg;
                break;
            case 'r':
                report = true;
                break;
            case 't':
                test = true;
                break;
            case '?':
            default:
                fprintf(stdout, "unexpected option encountered\n");
                return 1;
        }
    }

    // initialization
    char *error;
    if ((error = CHECK_FUNCTION_NAME_init()) != NULL)
    {
        fprintf(stderr, "CHECK_FUNCTION_NAME initialization error: %s\n", error);
        return 2;
    }


    // check checker function
    const check_fun_t checker = CHECK_FUNCTION_NAME_fun(name);
    if (checker == NULL)
    {
        fprintf(stderr, "check function not found for %s\n", name);
        return 3;
    }

    int errors = 0;

    for (int i = optind; i < argc; i++)
    {
        json_error_t error;

        // read and parse JSON file
        json_t *value = json_load_file(argv[i], JSON_DECODE_ANY|JSON_ALLOW_NUL, &error);
        if (value == NULL)
        {
            errors++;
            fprintf(stdout, "%s: ERROR (%s at %d:%d)\n",
                    argv[i], error.text, error.line, error.column);
            continue;
        }

        if (test)
        {
            if (!json_is_array(value))
            {
                fprintf(stdout, "%s: ERROR not a JSON array in test mode\n", argv[i]);
                errors++;
                continue;
            }

            size_t index;
            json_t *val;
            json_array_foreach(value, index, val)
            {
                if (!json_is_array(val) || json_array_size(val) != 2 ||
                    !json_is_boolean(json_array_get(val, 0)))
                {
                    fprintf(stdout,
                            "%s[%zu]: ERROR not an ordered pair with a boolean first element\n",
                            argv[i], index);
                    errors++;
                    continue;
                }

                process_mode_t
                    mode = json_is_true(json_array_get(val, 0)) ? expect_pass : expect_fail;

                if (!process_value(checker, json_array_get(val, 1), argv[i], index, mode, report))
                    errors++;
            }
        }
        else
            (void) process_value(checker, value, argv[i], 0, expect_nothing, report);

        // free json value
        json_decref(value);
    }

    CHECK_FUNCTION_NAME_free();

    return errors? 4: 0;
}
#endif  // WITH_MAIN
