#ifdef WITH_MAIN
#include <stdio.h>
#include <unistd.h>
#include <assert.h>

int main(int argc, char* argv[])
{
    // get options
    int opt;
    char *name = "";
    bool report = false;
    while ((opt = getopt(argc, argv, "hvln:r")) != -1)
    {
        switch (opt) {
            case 'h':
                fprintf(stdout,
                        "Usage: %s [-h] [-v] [-l] [-n name] [files...]\n"
                        "Check JSON values validity against a JSON model\n"
                        "Generated by jmc (JSON Model Compiler) version %s\n"
                        "see https://github.com/clairey-zx81/json-model\n",
                        argv[0], JSON_MODEL_VERSION);
                return 0;
            case 'l':
                fprintf(stdout, "JSON Model names (empty for default):");
                for (int i = 0; i < array_length(_check_model_map_tab); i++)
                    fprintf(stdout, "%s ", _check_model_map_tab[i].name);
                fprintf(stdout, "\n");
                return 0;
            case 'v':
                fprintf(stdout, "C from JSON Model compiler version %s\n", JSON_MODEL_VERSION);
                return 0;
            case 'n':
                name = optarg;
                break;
            case 'r':
                report = true;
                break;
            case '?':
                fprintf(stdout, "unexpected option: %c\n", opt);
                return 1;
        }
    }

    // initialization
    char *error;
    if ((error = CHECK_FUNCTION_NAME_init()) != NULL)
    {
        fprintf(stderr, "CHECK_FUNCTION_NAME initialization error: %s\n", error);
        return 2;
    }


    // check checker function
    const check_fun_t checker = CHECK_FUNCTION_NAME_fun(name);
    if (checker == NULL)
    {
        fprintf(stderr, "check function not found\n");
        return 3;
    }

    int errors = 0;

    for (int i = optind; i < argc; i++)
    {
        json_error_t error;

        // read and parse JSON file
        json_t *value = json_load_file(argv[i], JSON_DECODE_ANY|JSON_ALLOW_NUL, &error);
        if (value == NULL)
        {
            errors++;
            fprintf(stdout, "%s: ERROR (%s at %d:%d)\n",
                    argv[i], error.text, error.line, error.column);
            continue;
        }

        // check value against model, fast (no path nor reasons)
        bool valid = checker(value, NULL, NULL);

        fprintf(stdout, "%s: %s", argv[i], valid ? "PASS" : "FAIL");

        // re-execute with report collection
        if (!valid && report)
        {
            Path path = (Path) { "", 0, NULL, NULL };
            Report report = (Report) { NULL };

            bool valid2 = checker(value, &path, &report);
            assert(valid == valid2);

            for (ReportEntry *entry = report.entry; entry != NULL; entry = entry->prev)
                fprintf(stdout, " (%s: %s)", entry->path, entry->message);

            report_free_entries(&report);
        }

        fprintf(stdout, "\n");

        // free json value
        json_decref(value);
    }

    CHECK_FUNCTION_NAME_free();

    return errors? 4: 0;
}
#endif  // WITH_MAIN
