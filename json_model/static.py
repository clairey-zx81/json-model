# primitive python source code generation for a model
#
# TODO
# - language agnostic?
# - cache already compiled models!
# - optimize out redundant checks! (WIP)
# - check name override
# - generate error messages
#
# FIXME
# - Python is fuzzy about int/bool distinction, eg
#   - isinstance(True, int) is True
#   - True == 1 is True
#   - { True, 1, 1.0 } == { True }
#   as a consequence, some generated code may not provide the hoped answer

from typing import Callable
import re
import json

from .mtypes import ModelType, ModelError, ModelPath, UnknownModel, Symbols, Jsonable
from .utils import split_object, model_in_models, all_model_type, constant_value
from .utils import log, tname, json_path
from .defines import Validator
from .model import JsonModel

type Line = tuple[int, str]

# variable names in generated code?!
_RES = "result"
_VAL = "value"
_PATH = "path"
_RE = "re2"

def _rep(msg: str) -> str:
    return f"rep is None or rep.append(f\"{msg}\")"


class Code():

    def __init__(self):
        self._code: list[Line] = []

    def add(self, indent: int, line: str):
        self._code.append((indent, line))

    def nl(self):
        self.add(0, "")

    def clear(self):
        self._code.clear()

    def __str__(self):
        return "\n".join(("    " * n + lc) for n, lc in self._code) + "\n"


PY_HEADER = """#
# Generated by jmc (JSON Model Compiler) (https://github.com/clairey-zx81/json-model)
#

from typing import Callable
import %s as re
import datetime
import urllib.parse

type Jsonable = None|bool|int|float|str|list[Jsonable]|dict[str, Jsonable]
type Path = list[str]
type Report = list[str]|None
type CheckFun = Callable[[Jsonable, str, Report], bool]
type PropMap = dict[str, CheckFun]
type TagMap = dict[None|bool|float|int|str, CheckFun]

# extract type name
def _tname(value: Jsonable) -> str:
    return type(value).__name__

# maybe add message to report
def _rep(msg: str, rep: Report) -> bool:
    rep is None or rep.append(msg)
    return False
"""

PY_VALID_REGEX = """
def is_valid_re(value: Jsonable, path: str, rep: Report = None) -> bool:
    if isinstance(value, str):
        try:
            re.compile(value)
            return True
        except Exception as e:
            rep is None or rep.append(f"regex compile error at {path}: {value} ({e})")
            return False
    rep is None or rep.append(f"incompatible type for regex at {path}: {tname(value)}")
    return False
"""

PY_VALID_DATE = """
def is_valid_date(value: Jsonable, path: str, rep: Report = None) -> bool:
    if isinstance(value, str):
        try:
            datetime.date.fromisoformat(value)
            return True
        except Exception as e:
            rep is None or rep.append(f"invalid date at {path}: {value} ({e})")
            return False
    rep is None or rep.append(f"incompatible type for date at {path}: {tname(value)}")
    return False
"""

PY_VALID_URL = """
def is_valid_url(value: Jsonable, path: str, rep: Report = None) -> bool:
    if isinstance(value, str):
        try:
            urllib.parse.urlparse(value)
            return True
        except Exception as e:
            rep is None or re.append(f"invalid url at {path}: {value} ({e})")
            return False
    rep is None or rep.append(f"incompatible type for url at {path}: {tname(value)}")
    return False
"""

PY_VALUE_LEN = """
def value_len(value: Jsonable, path: str) -> None|bool|int|float:
    match value:
        case str()|list()|dict():
            return len(value)
        case _:
            # FIXME should error out on None|bool?
            return value
"""


class SourceCode(Validator):
    """Source code for compiling JSON Models.

    - globs: global map of symbols.
    - prefix: use this prefix for function name generation.
    - debug: verbose debug mode.
    - remod: regular expression module, "re" or "re2".
    - loose_int: whether "42.0" is considered an int.
    - loose_float: whether "42" is considered a float.
    - report: whether to report rejection reasons.
    """

    def __init__(self, globs: Symbols, *, prefix: str = "",
                 debug: bool = False, remod: str = _RE,
                 loose_int: bool = False, loose_float: bool = False,
                 report: bool = True):

        super().__init__()

        self._prefix = prefix
        self._globs = globs
        self._debug = debug
        self._re = remod
        self._loose_int = loose_int
        self._loose_float = loose_float
        self._report = report

        def used(att: str, val: str) -> str:
            setattr(self, f"_{att}_used", True)
            return val

        # inlined predefs with variable name, return a conjunction
        self._PREDEFS: dict[str, Callable[[str, str], str]] = {
            "$ANY": lambda _v, _p: "True",
            "$NONE": lambda _v, _p: "False",
            "$NULL": lambda v, _p: f"{v} is None",
            "$BOOL": lambda v, _p: f"isinstance({v}, bool)",
            "$BOOLEAN": lambda v, _p: f"isinstance({v}, bool)",
            "$INTEGER": self._in_is_int,
            "$INT": self._in_is_int,
            "$I32": self._in_is_int,
            "$I64": self._in_is_int,
            "$U32": lambda v, p: self._in_is_int(v, p) + f" and {v} >= 0",
            "$U64": lambda v, p: self._in_is_int(v, p) + f" and {v} >= 0",
            "$FLOAT": self._in_is_float,
            "$F32": self._in_is_float,
            "$F64": self._in_is_float,
            "$NUMBER": lambda v, _p: f"isinstance({v}, (float, int)) and not isinstance({v}, bool)",
            "$STRING": lambda v, _p: f"isinstance({v}, str)",
            "$URL": lambda v, p: used("url", f"is_valid_url({v}, {p}, rep)"),
            "$DATE": lambda v, p: used("date", f"is_valid_date({v}, {p}, rep)"),
            "$REGEX": lambda v, p: used("regex", f"is_valid_re({v}, {p}, rep)"),
            # TODO more, /re/ ?
        }

        # identifiers and functions
        # ident-prefix -> next number to use to ensure unique identifiers
        self._nvars: dict[str, int] = {}
        # FIXME global namespace! $-definitions -> function
        self._names: dict[str, str] = {}
        # /re.../ -> regex function name
        self._regs: dict[str, str] = {}
        # model path -> function name
        self._paths: dict[str|tuple[int|str, ...], str] = {}
        # already generated object paths
        self._generated: set[str|tuple[int|str, ...]] = set()
        # compiled json models ids
        self._compiled: dict[int, Code] = {}
        self._to_compile: dict[int, tuple[JsonModel, str]] = {}
        #
        # generated stuff
        #
        self._defines: list[str] = []
        self._regex_used: bool = False
        self._date_used: bool = False
        self._url_used: bool = False
        self._len_used: bool = False
        self._help: list[Code] = []
        self._maps: dict[str, dict[str, str]] = {}
        self._subs: list[Code] = []
        # initialization
        self.reset()

    def reset(self):
        # self._defs.clear()
        self._nvars.clear()
        self._names.clear()
        self._regs.clear()
        self._defines.clear()
        self._regex_used = False
        self._date_used = False
        self._url_used = False
        self._len_used = False
        self._help.clear()
        self._maps.clear()
        self._subs.clear()
        self._compiled.clear()
        self._to_compile.clear()
        self.define(PY_HEADER % self._re)

    # add contents
    def subs(self, code: Code):
        self._subs.append(code)

    def help(self, code: Code):
        self._help.append(code)

    def define(self, line: str):
        """Append a definition."""
        self._defines.append(line)

    # show generated code
    def _map(self, mp: dict[str, str]) -> str:
        return "\n".join(f"    {self._esc(p)}: {v}," for p, v in mp.items())

    def __str__(self):
        """Generate check package."""

        res = ""
        defs = "\n".join(self._defines) + "\n"
        if self._regex_used:
            defs += PY_VALID_REGEX
        if self._date_used:
            defs += PY_VALID_DATE
        if self._url_used:
            defs += PY_VALID_URL
        if self._len_used:
            defs += PY_VALUE_LEN
        helps = "\n".join(map(str, self._help)) + "\n"
        subs = "\n".join(map(str, self._subs)) + "\n"
        maps = "\n".join(f"{name} = {{\n{self._map(mp)}\n}}"
                         for name, mp in self._maps.items()) + "\n"

        if defs:
            res += defs
        if helps and re.search(r"\S", helps):
            res += ("\n" if res else "") + helps
        if subs and re.search(r"\S", subs):
            res += ("\n" if res else "") + subs
        if maps and re.search(r"\S", maps):
            res += ("\n" if res else "") + "# object properties maps\n" + maps + "\n"

        return res

    # code generation

    def _in_is_int(self, v: str, p: str) -> str:
        if self._loose_int:
            return (f"((isinstance({v}, int) and not isinstance({v}, bool)) or"
                    f" (isinstance({v}, float) and int({v}) == {v}))")
            # (" or _rep(\"not a loose int at {{p}}\", rep)" if self._report else ""))
        else:
            return f"isinstance({v}, int) and not isinstance({v}, bool)"
            # (" or _rep(\"not an int at {{p}}\", rep)" if self._report else ""))

    def _in_is_float(self, v: str, p: str) -> str:
        if self._loose_float:
            return (f"(isinstance({v}, float) or"
                    f" isinstance({v}, int) and not isinstance({v}, bool))")
            # (" or _rep(\"not a loose float at {{p}}\", rep)" if self._report else ""))
        else:
            return f"isinstance({v}, float)"
            # (" or _rep(\"not a float at {{p}}\", rep)" if self._report else ""))

    def _ident(self, prefix: str, local: bool = False) -> str:
        """Generate a new identifier using a prefix and a counter."""
        if prefix not in self._nvars:
            self._nvars[prefix] = 0
        ident = f"{'' if local else self._prefix}{prefix}{self._nvars[prefix]}"
        self._nvars[prefix] += 1
        return ident

    def _regex(self, regex: str) -> str:
        """Compile are regular expression, with memoization."""
        if regex not in self._regs:
            try:
                # extract actual pattern
                pattern, ropts = regex[1:].rsplit("/", 1)
                assert ropts == "" or ropts.isalpha(), f"invalid options: {ropts}"
                pattern = f"(?{ropts}){pattern}" if ropts else pattern
                # statically check re validity
                if self._re == "re2":
                    import re2 as rex
                else:
                    import re as rex
                rex.compile(pattern)
            except Exception as e:
                raise ModelError(f"invalid regex: {regex} ({e})")
            # ok, generate code for pattern
            fun = self._ident("re_")
            self.define(f"# regex {self._esc(regex)}")
            if pattern in (".*", "^.*", "^.*$", ".*$") or len(pattern) == 2 and pattern[-1] == "*":
                self.define(f"{fun} = lambda _s: True")
            elif pattern in ("(?s).+", "(?s)."):  # s option is required!
                self.define(f"{fun} = lambda s: len(s) > 0 or None")
            else:
                self.define(f"{fun} = re.compile({self._esc(pattern)}).search")
            self._regs[regex] = fun
        return self._regs[regex]

    def _regExpr(self, regex: str, val: str, path: str):
        """Generate re check inlined expression on a value."""
        fun = self._regex(regex)
        return (f"{fun}({val}) is not None" +
                # FIXME self._fesc(regex)
                (f" or _rep(f\"does not match {self._fesc(regex)} at {{{path}}}\", rep)"
                 if self._report else ""))

    def _esc(self, val: Jsonable) -> str:
        """Escape value as necessary."""
        # return '"' + string.translate({"\"": "\\\"", "\\": "\\\\"}) + '"'
        return json.dumps(val) if isinstance(val, str) else str(val)

    def _fesc(self, val: str) -> str:
        """Escape string for an f-string."""
        # FIXME return val.translate({"{": "{{", "\\": "\\\\", "\"": "\\\""})
        return "FESC"

    def _dollarExpr(self, jm: JsonModel, ref: str, val: str, vpath: str):
        assert ref and ref[0] == "$"
        if ref in self._PREDEFS:  # inline predefs
            return (self._PREDEFS[ref](val, vpath) +
                    (f" or _rep(f\"invalid {ref} at {{{vpath}}}\", rep)" if self._report else ""))
        else:
            fun = self._getNameRef(jm, ref, [])
            return f"{fun}({val}, {vpath}, rep)"

    def _compileConstraint(self, code: Code, indent: int,
                           jm: JsonModel, model: ModelType, mpath: ModelPath,
                           res: str, val: str, vpath: str):
        assert isinstance(model, dict) and "@" in model
        smpath = json_path(mpath)
        self._compileModel(code, indent, jm, model["@"], mpath + ["@"], res, val, vpath)
        tmodel = self._ultimate_type(jm, model["@"])  # pyright: ignore
        # NOTE UnknownModel should raise an error on any constraint
        # FIXME see _untype00.model.json for multiple types
        assert tmodel in (int, float, str, list, dict, UnknownModel, None), f"simple {tmodel}"
        checks = []
        what = f"len({val})" if tmodel in (list, dict) else val
        twhat = int if tmodel in (list, dict, None) else tmodel
        for constraint in ("=", "!=", "<", "<=", ">", ">="):
            if constraint in model:
                op = "==" if constraint == "=" else constraint
                cst = model[constraint]
                if not isinstance(cst, (twhat, int)):
                    raise ModelError(f"invalid constant: {cst} ({twhat.__name__}) {mpath}")
                if isinstance(cst, int) and tmodel is str:
                    checks.append(f"len({val}) {op} {cst}")
                elif isinstance(cst, int) and tmodel == UnknownModel:
                    checks.append(f"(len({val}) {op} {cst} if isinstance({val}, (str, list, dict))"
                                  " else "
                                  f"{val} {op} {self._esc(cst) if isinstance(cst, str) else cst})")
                elif isinstance(cst, str):
                    checks.append(f"{what} {op} {self._esc(cst)}")
                else:  # same type or list or dict
                    checks.append(f"{what} {op} {cst}")
        if "!" in model:
            if not isinstance(model["!"], bool):
                raise ModelError(f"! constraint expects a boolean {mpath}")
            if model["!"]:
                log.warning("FIXME: ! generated code is not reliable")
                code.add(indent, f"{res} &= len(set({val})) == len({val})")
            # else defaut is nothing to check
        if checks:
            code.add(indent, f"{res} &= {' and '.join(checks)}")
        if self._report:
            code.add(indent, f"if not {res}:")
            code.add(indent + 1, _rep(f"invalid type or constraints at {{{vpath}}} [{smpath}]"))

    def _disjunction(self, code: Code, indent: int,
                     jm: JsonModel, model: ModelType, mpath: ModelPath,
                     res: str, val: str, vpath: str) -> bool:
        """Generate optimized disjunction check.

        model: `{"|": [ o1, o2, ... ] }`
        """

        dis = self._disjunct_analyse(jm, model, mpath)  # pyright: ignore
        if dis is None:
            return False
        tag_name, tag_type, models, all_const_props = dis
        smpath = json_path(mpath)

        # Compile all object models in the list if needed
        assert isinstance(model, dict)

        init = model["|"]
        assert isinstance(init, list)  # pyright hint
        assert len(models) == len(init)
        for i, m in enumerate(models):
            p = mpath + [i]
            tp = tuple(p)
            mi = init[i]  # initial model
            if isinstance(mi, str) and mi and mi[0] == "$":
                # it is a reference, it must be compiled for its name, no need to recompile it!
                fun = self._getNameRef(jm, mi, p)
                if tp not in self._paths:
                    # several path will lead to the same function
                    self._paths[tp] = fun
                # else nothing to do?
            elif tp not in self._paths:
                # else compile the direct object as a side effect…
                c = Code()
                self._compileModel(c, 0, jm, m, p, _RES, _VAL, _PATH)
                # log.debug(f"{self._paths}")

        # {disid}_tm = { tag-value: check_function_for_this_tag_value }
        # if v is dict:
        #     if v[tag] in object_tag:
        #         res = object_tag[v[tag]](v)
        disid = self._ident("map_")
        tag = self._ident("tag_", True)

        # mapping from tag values to check functions
        TAG_CHECKS = {}
        for i in range(len(models)):
            consts = all_const_props[i]
            TAG_CHECKS[consts[tag_name]] = self._paths[tuple(mpath + [i])]

        self.define(f"{disid}: TagMap")
        self._maps[disid] = TAG_CHECKS
        esctag = self._esc(tag_name)

        # val is Object, tag is in val, tag_value is valid
        code.add(indent, f"{res} = isinstance({val}, dict)")
        code.add(indent, f"if {res}:")
        code.add(indent, f"    {res} = {esctag} in {val}")
        code.add(indent, f"    if {res}:")
        code.add(indent, f"        {tag} = {val}[{esctag}]")
        code.add(indent, f"        if {tag} in {disid}:")
        code.add(indent, f"            {res} = {disid}[{tag}]({val}, {vpath})")
        code.add(indent, r"        else:")
        if self._report:
            code.add(indent + 3,
                     _rep(f"tag {tag_name} value not found at {{{vpath}}} [{smpath}.'|']"))
        code.add(indent, f"            {res} = False")
        if self._report:
            code.add(indent, r"    else:")
            code.add(indent + 2, _rep(f"missing tag prop {tag_name} at {{{vpath}}} [{smpath}.'|']"))
            code.add(indent, r"else:  # not a dict")
            code.add(indent + 1, _rep(f"not an object at {{{vpath}}} [{smpath}.'|']"))

        return True

    def _compileObject(self, code: Code, indent: int,
                       jm: JsonModel, model: ModelType, mpath: ModelPath,
                       oname: str, res: str, val: str, vpath: str):
        # separate properties
        assert isinstance(model, dict)
        must, may, defs, regs, oth = split_object(model, mpath)
        smpath = json_path(mpath)
        # TODO optimize must only case?
        code.add(indent, f"if not isinstance({val}, dict):")
        if self._report:
            code.add(indent + 1, _rep(f"not an object at {{{vpath}}} [{smpath}]"))
        code.add(indent, "    return False")
        prop_must = f"{oname}_must"
        if must:
            prop_must_map: dict[str, str] = {}
            self.define(f"{prop_must}: PropMap")
            self._maps[prop_must] = prop_must_map
            for p, m in must.items():
                pid = f"{prop_must}_{p}"  # tmp unique identifier
                self.help(self._compileName(jm, pid, m, mpath + [p]))
                prop_must_map[p] = self._getName(jm, pid)
        prop_may = f"{oname}_may"
        if may:
            prop_may_map: dict[str, str] = {}
            self.define(f"{prop_may}: PropMap")
            self._maps[prop_may] = prop_may_map
            for p, m in may.items():
                pid = f"{prop_may}_{p}"
                self.help(self._compileName(jm, pid, m, mpath + [p]))
                prop_may_map[p] = self._getName(jm, pid)
        prop, value, must_c = "prop", "val", "must_count"
        if must:
            code.add(indent, f"{must_c} = 0")
        code.add(indent, f"for {prop}, {value} in {val}.items():")
        code.add(indent, f"    assert isinstance({prop}, str)")
        code.add(indent, f"    lpath = {vpath} + \".\" + {prop}")
        cond = "if"
        if must:
            code.add(indent, f"    {cond} {prop} in {prop_must}:  # must")
            code.add(indent, f"        {must_c} += 1")
            code.add(indent, f"        if not {prop_must}[{prop}]({value}, lpath, rep):")
            if self._report:
                code.add(indent + 3, _rep(
                         f"invalid must prop value at {{lpath}} [{smpath}.{{{prop}}}]"))
            code.add(indent, r"            return False")
            # code.add(indent+3, f"continue")
            cond = "elif"
        if may:
            code.add(indent, f"    {cond} {prop} in {prop_may}:  # may")
            code.add(indent, f"        if not {prop_may}[{prop}]({value}, lpath, rep):")
            if self._report:
                code.add(indent + 3, _rep(
                         f"invalid may prop value at {{lpath}} [{smpath}.{{{prop}}}]"))
            code.add(indent, r"            return False")
            # code.add(indent+3, f"continue")
            cond = "elif"
        # $* is inlined expr (FIXME inlining does not work with vpath)
        for d, v in defs.items():
            dexpr = self._dollarExpr(jm, '$' + d, prop, 'path')
            if self._report:
                dexpr += f" or _rep(f\"prop {{prop}} does not match ${d} at {{{vpath}}}\", rep)"
            code.add(indent, f"    {cond} {dexpr}:  # ${d}")
            self._compileModel(code, indent + 2, jm, v, mpath + ["$" + d], res, value, "lpath")
            code.add(indent, f"        if not {res}:")
            # if self._report:
            #     code.add(indent + 3, _rep(
            #              f"invalid $ prop {{{vpath}}}.{{{prop}}} value [{smpath}.${d}]"))
            code.add(indent, r"            return False")
            # code.add(indent+3, f"continue")
            cond = "elif"
        # // is inlined
        for r, v in regs.items():
            regex = f"/{r}/"
            rexpr = f"{self._regex(regex)}({prop}) is not None"
            if self._report:
                rexpr += (f" or _rep(f\"prop {{prop}} does not match "
                          f"{self._fesc(regex)} at {{{vpath}}}\", rep)")
            code.add(indent, f"    {cond} {rexpr}:  # {regex}")
            self._compileModel(code, indent + 2, jm, v, mpath + [regex], res, value, "lpath")
            code.add(indent, f"        if not {res}:")
            # if self._report:  # FIXME escape re
            #     code.add(indent + 3, _rep(
            #              f"invalid re prop {{{vpath}}}.{{{prop}}}/ value [{smpath}./{{r}}/]"))
            code.add(indent, r"            return False")
            # code.add(indent+3, f"continue")
            cond = "elif"
        # catchall is inlined
        if oth:
            omodel = oth[""]
            smpath = json_path(mpath + [""])
            if cond == "if":  # direct
                self._compileModel(code, indent + 1, jm, omodel, mpath + [""], res, value, "lpath")
                code.add(indent, f"    if not {res}:")
                if self._report:
                    code.add(indent + 2, _rep(f"unexpected other value at {{lpath}} [{smpath}]"))
                code.add(indent, r"        return False")
            else:
                code.add(indent, r"    else:  # catch all")
                self._compileModel(code, indent + 2, jm, omodel, mpath + [""], res, value, "lpath")
                code.add(indent, f"        if not {res}:")
                if self._report:
                    code.add(indent + 3, _rep(f"unexpected other value at {{lpath}} [{smpath}]"))
                code.add(indent, r"            return False")
                # code.add(indent+3, f"continue")
        else:  # no catch all
            smpath = json_path(mpath)
            if cond == "if":
                # we are expecting an empty object
                code.add(indent, "    # no catch all")
                if self._report:
                    code.add(indent + 1, _rep(f"no other prop expected at {{{vpath}}} [{smpath}]"))
                code.add(indent, "    return False")
            else:
                code.add(indent, "    else:  # no catch all")
                if self._report:
                    code.add(indent + 2, _rep(f"no other prop expected at {{{vpath}}} [{smpath}]"))
                code.add(indent, "        return False")
        # check that all must were seen, although we do not know which ones
        if must:
            code.add(indent, f"{res} = {must_c} == {len(must)}")
            if self._report:
                smpath = json_path(mpath)
                code.add(indent, f"if not {res}:")
                code.add(indent + 1, _rep(f"missing must prop at {{{vpath}}} [{smpath}]"))
            code.add(indent, f"return {res}")
        else:
            code.add(indent, "return True")

    def _compileModel(self, code: Code, indent: int,
                      jm: JsonModel, model: ModelType, mpath: ModelPath,
                      res: str, val: str, vpath: str, known: set[str]|None = None):
        # known = expression already verified
        log.debug(f"mpath={mpath} model={model} res={res} val={val} vpath={vpath} indent={indent}")
        assert isinstance(mpath, list)
        smpath = json_path(mpath)
        code.add(indent, f"# {json_path(mpath)}")
        match model:
            case None:
                code.add(indent, f"{res} = {val} is None")
                if self._report:
                    code.add(indent, f"if not {res}:")
                    code.add(indent + 1, _rep(f"not null at {{{vpath}}} [{smpath}]"))
            case bool():
                code.add(indent, f"{res} = isinstance({val}, bool)")
                if self._report:
                    code.add(indent, f"if not {res}:")
                    code.add(indent + 1, _rep(f"not a bool at {{{vpath}}} [{smpath}]"))
            case int():
                expr = self._in_is_int(val, vpath)
                if known is not None:
                    if expr in known:
                        expr = None
                if model == -1:
                    if known is not None:
                        if expr is not None:
                            known.add(expr)
                    if not expr:
                        expr = "True"
                elif model == 0:
                    if expr:
                        expr += f" and {val} >= 0"
                    else:
                        expr = f"{val} >= 0"
                elif model == 1:
                    if expr:
                        expr += f" and {val} >= 1"
                    else:
                        expr = f"{val} >= 1"
                else:
                    raise ModelError(f"unexpected int value {model} at {smpath}")
                if expr:
                    code.add(indent, res + " = " + expr)
                    if self._report:
                        code.add(indent, f"if not {res}:")
                        code.add(indent + 1, _rep(f"not a {model} int at {{{vpath}}} [{smpath}]"))
            case float():
                expr = self._in_is_float(val, vpath)
                if known is not None:
                    if expr in known:
                        expr = None
                if model == -1.0:
                    if known is not None:
                        if expr is not None:
                            known.add(expr)
                    if not expr:
                        expr = "True"
                elif model == 0.0:
                    if expr:
                        expr += f" and {val} >= 0.0"
                    else:
                        expr = f"{val} >= 0.0"
                elif model == 1.0:
                    if expr:
                        expr += f" and {val} > 0.0"
                    else:
                        expr = f"{val} > 0.0"
                else:
                    raise ModelError(f"unexpected float value {model} at {mpath}")
                if expr:
                    code.add(indent, res + " = " + expr)
                    if self._report:
                        code.add(indent, f"if not {res}:")
                        code.add(indent + 1, _rep(f"not a {model} float at {{{vpath}}} [{smpath}]"))
            case str():
                expr = f"isinstance({val}, str)"
                if known is not None:
                    # Skip special cases
                    if model == "" or model[0] not in ["$", "="]:
                        # log.info(f"expr={expr} known={known}")
                        if expr in known:
                            expr = None
                if model == "":
                    if known is not None:
                        if expr is not None:
                            known.add(expr)
                    if expr:
                        code.add(indent, f"{res} = {expr}")
                    else:
                        code.add(indent, f"{res} = True")
                elif model[0] == "_":
                    if expr:
                        code.add(indent, f"{res} = {expr} and {val} == {self._esc(model[1:])}")
                    else:
                        code.add(indent, f"{res} = {val} == {self._esc(model[1:])}")
                elif model[0] == "=":
                    # TODO FIXME known
                    (a_cst, value) = constant_value(model, mpath)
                    if a_cst:
                        if value is None:
                            code.add(indent, f"{res} = {val} is None")
                        elif isinstance(value, bool):
                            code.add(indent,
                                     f"{res} = isinstance({val}, bool) and {val} == {value}")
                        elif isinstance(value, int):
                            code.add(indent,
                                     f"{res} = isinstance({val}, int) and "
                                     f"not isinstance({val}, bool) and {val} == {value}")
                        elif isinstance(value, float):
                            code.add(indent,
                                     f"{res} = isinstance({val}, float) and {val} == {value}")
                        elif isinstance(value, str):
                            code.add(indent, f"{res} = isinstance({val}, str) and {val} == {value}")
                        else:
                            raise ModelError(f"unexpected constant type: {tname(value)}")
                    else:
                        raise ModelError(f"unexpected constant: {model}")
                elif model[0] == "$":
                    # if jm._isPredef(model):
                    code.add(indent, f"{res} = " + self._dollarExpr(jm, model, val, "path"))
                elif model[0] == "/":
                    code.add(indent, f"# {self._esc(model)}")
                    if expr:
                        code.add(indent, f"{res} = {expr} and {self._regExpr(model, val, vpath)}")
                    else:
                        code.add(indent, f"{res} = {self._regExpr(model, val, vpath)}")
                else:  # simple string
                    if expr:
                        code.add(indent, f"{res} = {expr} and {val} == {self._esc(model)}")
                    else:
                        code.add(indent, f"{res} = {val} == {self._esc(model)}")
                if self._report:
                    code.add(indent, f"if not {res}:")
                    smodel = model if model else "string"
                    if model and model[0] == "/":  # FIXME workaround
                        smodel = "REGEX"
                    code.add(indent + 1,
                             _rep(f"not an expected {smodel} at {{{vpath}}} [{smpath}]"))
            case list():
                expr = f"isinstance({val}, list)"
                smpath = json_path(mpath)
                if known is not None:
                    if expr in known:
                        expr = None
                    if expr is not None:
                        known.add(expr)
                if len(model) == 0:
                    if expr:
                        expr += f" and len({val}) == 0"
                    else:
                        expr = f"len({val}) == 0"
                    code.add(indent, f"{res} = {expr}")
                elif len(model) == 1:
                    arrayid = self._ident("array_", True)
                    idx, item = f"{arrayid}_idx", f"{arrayid}_item"
                    if expr:
                        code.add(indent, f"{res} = {expr}")
                        code.add(indent, f"if {res}:")
                    else:
                        code.add(indent, "if True:")
                    # code.add(indent + 1, f"assert isinstance({val}, list)  # pyright helper")
                    code.add(indent + 1, f"for {idx}, {item} in enumerate({val}):")
                    code.add(indent + 1, f"    lpath = {vpath} + '.' + str({idx})")
                    self._compileModel(code, indent + 2, jm, model[0], mpath + [0],
                                       res, item, "lpath")
                    # shortcut
                    code.add(indent + 2, f"if not {res}:")
                    # if self._report:
                    #     code.add(indent + 3,
                    #              _rep(f"unexpected array value at {{lpath}} [{smpath}]"))
                    code.add(indent + 2, r"    break")
                else:
                    if expr:
                        code.add(indent, f"{res} = {expr} and len({val}) == {len(model)}")
                    else:
                        code.add(indent, f"{res} = len({val}) == {len(model)}")
                    for i, m in enumerate(model):
                        code.add(indent + i, f"if {res}:")
                        # FIXME vpath
                        self._compileModel(code, indent + i + 1, jm, model[i], mpath + [i],
                                           res, f"{val}[{i}]", f"{vpath}[{i}]")
                if self._report:
                    code.add(indent, f"if not {res}:")
                    code.add(indent + 1,
                             _rep(f"not array or unexpected array at {{{vpath}}} [{smpath}]"))
            case dict():
                # TODO report
                assert isinstance(model, dict)  # pyright hint
                assert "+" not in model, "merge must have been preprocessed"
                if "@" in model:
                    self._compileConstraint(code, indent, jm, model, mpath, res, val, vpath)
                elif "|" in model:
                    lpath = mpath + ["|"]
                    slpath = json_path(lpath)
                    models = model["|"]
                    assert isinstance(models, list)  # pyright hint
                    # partial list of constants optimization
                    l_const = list(map(lambda m: constant_value(m, lpath), models))
                    if len(list(filter(lambda t: t[0], l_const))) >= 2:
                        constants, n_models = set(), []
                        for i in range(len(models)):
                            # NOTE python equality is a pain, True == 1 == 1.0, False == 0 == 0.0
                            # NOTE python typing is a pain, isinstance(True, int) == True
                            # thus we only keep strings…
                            if l_const[i][0] and isinstance(l_const[i][1], str):
                                constants.add(l_const[i][1])
                            else:
                                n_models.append(models[i])
                        if constants:
                            # ensure a deterministic output
                            sconst = "{" + str(sorted(constants))[1:-1] + "}"
                            code.add(indent,
                                     f"{res} = not isinstance({val}, (list, dict)) and "
                                     f"{val} in {sconst}")
                            if self._report:
                                code.add(indent, f"if not {res}:")
                                code.add(indent + 1,
                                         _rep(f"value not in enum at {{{vpath}}} [{slpath}]"))
                            if not n_models:
                                return
                            code.add(indent, f"if not {res}:")
                            indent += 1
                            models = n_models
                    # empty list
                    if not models:
                        if self._report:
                            code.add(indent, _rep(f"empty or at {{{vpath}}} [{slpath}]"))
                        code.add(indent, f"{res} = False")
                        return
                    # discriminant optimization
                    if self._disjunction(code, indent, jm, model, lpath, res, val, vpath):
                        return
                    # homogeneous typed list
                    same, expected = all_model_type(models, lpath)
                    or_known = set()
                    if same:
                        # all models have the same ultimate type
                        if expected is int:
                            type_test = f"isinstance({val}, int) and not isinstance({val}, bool)"
                        else:
                            type_test = f"isinstance({val}, {expected.__name__})"  # type: ignore
                        code.add(indent, f"{res} = {type_test}")
                        code.add(indent, f"if {res}:")
                        indent += 1
                        or_known.add(type_test)
                    for i, m in enumerate(models):
                        if i:
                            code.add(indent + i - 1, f"if not {res}:")
                        self._compileModel(code, indent + i, jm, m, lpath + [i],
                                           res, val, vpath, or_known)
                    if self._report:
                        code.add(indent, f"if not {res}:")
                        code.add(indent + 1, _rep(f"not any model match at {{{vpath}}} [{slpath}]"))
                elif "&" in model:
                    and_known = set(known or [])
                    lpath = mpath + ["&"]
                    slpath = json_path(lpath)
                    models = model["&"]
                    assert isinstance(models, list)  # pyright hint
                    if not models:
                        code.add(indent, f"{res} = True")
                        return
                    # homogeneous typed list
                    same, expected = all_model_type(models, lpath)
                    if same:
                        # all models have the same ultimate type
                        if expected is int:
                            type_test = f"isinstance({val}, int) and not isinstance({val}, bool)"
                        else:
                            type_test = f"isinstance({val}, {expected.__name__})"  # type: ignore
                        code.add(indent, f"{res} = {type_test}")
                        code.add(indent, f"if {res}:")
                        indent += 1
                        and_known.add(type_test)
                    for i, m in enumerate(models):
                        if i:
                            code.add(indent + i - 1, f"if {res}:")
                        self._compileModel(code, indent + i, jm, m, lpath + [i],
                                           res, val, vpath, and_known)
                    if self._report:
                        code.add(indent, f"if not {res}:")
                        code.add(indent + 1, _rep(f"not all model match at {{{vpath}}} [{slpath}]"))
                elif "^" in model:
                    lpath = mpath + ["^"]
                    slpath = json_path(lpath)
                    models = model["^"]
                    assert isinstance(models, list)  # pyright hint

                    # optimize out repeated models
                    if len(models) >= 2:
                        seen, dups, kept = [], [], []
                        seen_i, dups_i, kept_i = [], [], []
                        for i, m in enumerate(models):
                            if model_in_models(m, seen):
                                if not model_in_models(m, dups):
                                    dups.append(m)
                                    dups_i.append(i)
                            else:
                                seen.append(m)
                                seen_i.append(i)
                        for i, m in zip(seen_i, seen):
                            if not model_in_models(m, dups):
                                kept.append(m)
                                kept_i.append(i)

                        # false if in dups
                        for i, m in enumerate(dups):
                            idx = dups_i[i]
                            self._compileModel(code, indent + i, jm, m, lpath + [idx],
                                               "isin", val, vpath)
                            code.add(indent + i, f"{res} = not isin")
                            code.add(indent + i, f"if {res}:")

                        # update remaining models and identation
                        models = kept
                        models_i = kept_i
                        depth = len(dups)
                    else:
                        models_i = list(range(len(models)))
                        depth = 0

                    # standard case
                    if not models:
                        code.add(indent + depth, f"{res} = False")
                    elif len(models) == 1:
                        mod, idx = models[0], models_i[0]
                        self._compileModel(code, indent + depth, jm, mod, lpath + [idx],
                                           res, val, vpath)
                    else:  # several models are inlined
                        if len(models) == 2 and "$ANY" in models:
                            # get other model
                            m = models[1] if models[0] == "$ANY" else models[0]
                            is_m = self._ident("is_m_", True)
                            self._compileModel(code, indent + depth, jm, m, lpath + ["?"],
                                               is_m, val, vpath)
                            code.add(indent + depth, f"{res} = not {is_m}")
                        else:
                            count = self._ident("xc_", True)
                            test = self._ident("xr_", True)
                            code.add(indent + depth, f"{count} = 0")
                            for i, m in enumerate(models):
                                idx = models_i[i]
                                code.add(indent + depth, f"if {count} <= 1:")
                                self._compileModel(code, indent + depth + 1, jm, m, lpath + [idx],
                                                   test, val, vpath)
                                code.add(indent + depth + 1, f"if {test}: {count} += 1")
                            code.add(indent + depth, f"{res} = {count} == 1")
                    if self._report:
                        code.add(indent, f"if not {res}:")
                        code.add(indent + 1, _rep(f"not one model match at {{{vpath}}} [{slpath}]"))
                else:
                    # TODO optimize empty model?
                    # generate separate functions for objects?
                    hpath = tuple(mpath)
                    if hpath not in self._paths:
                        objid = self._ident("obj_")
                        self._paths[hpath] = objid
                    else:
                        objid = self._paths[hpath]
                    if hpath not in self._generated:
                        ocode = Code()
                        ocode.nl()
                        ocode.add(0, f"# object {json_path(mpath)}")
                        path_init = " = \"$\"" if mpath == ["$"] else ""
                        ocode.add(0, f"def {objid}(value: Jsonable, path: str{path_init}, "
                                  f"rep: Report = None) -> bool:")
                        self._compileObject(ocode, 1, jm, model, mpath, objid, _RES, _VAL, _PATH)
                        self.subs(ocode)
                        self._generated.add(hpath)
                    del hpath
                    code.add(indent, f"{res} = {objid}({val}, {vpath}, rep)")
                    if self._report:
                        code.add(indent, f"if not {res}:")
                        code.add(indent + 1,
                                 _rep(f"not an expected object at {{{vpath}}} [{smpath}]"))
            case _:
                raise ModelError(f"unexpected model type: {tname(model)}")

    def _getName(self, jm: JsonModel, name: str) -> str:
        """Ensure global unique names for internal functions."""
        # FIXME global name space! prefix with jm._id ?
        if name not in self._names:
            self._names[name] = self._ident("f_")
        log.debug(f"{name} -> {self._names[name]}")
        return self._names[name]

    def _getNameRef(self, jm: JsonModel, ref: str, path: ModelPath) -> str:
        assert jm._isRef(ref), f"reference: {ref}"
        try:
            gref = jm._defs.gget(ref)
        except KeyError:
            if self._debug:
                log.debug(f"_getNameRef[{jm._id},{jm._defs._id}]({ref}) at {path}")
                log.debug(f"XXX gmap={jm._defs._gmap}")
            # FIXME maybe we already have a global reference?
            gref = ref
        # log.debug(f"ref={ref} gref={gref} at {path}")
        if gref not in self._names:
            jm = self._globs[gref]  # pyright: ignore
            if jm._id not in self._compiled:
                self._to_compile[jm._id] = (jm, gref)
            self._names[gref] = f"json_model_{jm._id}"
        return self._names[gref]

    def _compileName(self, jm: JsonModel, name: str, model: ModelType, mpath: ModelPath) -> Code:
        """Compile a model under a given name in a given scope."""
        log.debug(f"name: mpath={mpath} name={name} jm={jm._id}")
        code = Code()
        # FIXME explain this junk code, or remove it!
        # keep definitions
        # XXX self._defs.set(name, model)
        xname = name if not name or name[0] != "$" else name[1:]
        self._defs.set(xname, model)
        fun2 = None
        hpath = tuple(mpath)
        if hpath in self._paths:
            fun = self._paths[hpath]
            if name in self._names:
                fun2 = self._names[name]
            else:
                self._names[name] = fun
        else:
            fun = self._getName(jm, name)
            self._paths[hpath] = fun
        # generate code
        # code.nl()
        code.add(0, f"# define {self._esc(name)} ({json_path(mpath)})")
        code.add(0, f"def {fun}(value: Jsonable, path: str, rep: Report = None) -> bool:")
        self._compileModel(code, 1, jm, model, mpath, _RES, _VAL, _PATH, None)
        code.add(1, f"return {_RES}")
        if fun2 and fun2 != fun:
            code.nl()
            code.add(0, "# named root")
            code.add(0, f"{fun2} = {fun}")
        # FIXME!
        # NOTE yuk! the function may have been generated as a side effect of the previous call.
        # if so, this version is simply discarded
        if hpath not in self._generated:
            # on a named root, two names for the same path
            self._generated.add(hpath)
        else:
            code.clear()
        return code

    def compileOneJsonModel(self, jm: JsonModel, name: str, path: ModelPath):
        if jm._id not in self._compiled:
            if name not in self._names:
                self._names[name] = "json_model_" + str(jm._id)
            self._compiled[jm._id] = self._compileName(jm, name, jm._model, path)
        return self._compiled[jm._id]

def static_compile(
        model: JsonModel,
        name: str = "check_model",
        *,
        prefix: str = "jm_",
        remod: str = "re",
        debug: bool = False,
        loose_int: bool = False,
        loose_float: bool = False,
        report: bool = True,
    ) -> SourceCode:
    """Generate the check source code for a model.

    - `model`: JSON Model root to compile.
    - `name`: target function name.
    - `prefix`: prefix for generated functions
    - `remod`: regular expression module to use, "re" or "re2"
    - `debug`: debugging mode generates more traces
    - `loose_int`: whether 42.0 is an integer
    - `loose_float`: whether 42 is a float
    - `report`: whether to generate code to report rejection reasons
    """
    # TODO move to compileOneJsonModel
    # options
    if isinstance(model._model, dict) and "#" in model._model:
        comment = model._model["#"]
        assert isinstance(comment, str)
        loose_int = (True if "JSON_MODEL_LOOSE_INT" in comment else
                     False if "JSON_MODEL_STRICT_INT" in comment else
                     loose_int)
        loose_float = (True if "JSON_MODEL_LOOSE_FLOAT" in comment else
                       False if "JSON_MODEL_STRICT_FLOAT" in comment else
                       loose_float)
    sc = SourceCode(model._globs, prefix=prefix, debug=debug, remod=remod,  # pyright: ignore
                    loose_int=loose_int, loose_float=loose_float, report=report)
    # compile definitions
    for n, jm in model._defs.items():
        sc.subs(sc.compileOneJsonModel(jm, "$" + n, ["$" + n]))
    # compile main
    root = sc.compileOneJsonModel(model, "$", [])
    # compile other encountered references
    while todo := set(sc._to_compile.keys()) - set(sc._compiled.keys()):
        jm, gref = sc._to_compile[min(todo)]
        sc.subs(sc.compileOneJsonModel(jm, gref, [gref]))
    # register root
    sc.subs(root)
    # create main
    main = Code()
    main.add(0, f"# entry function {name}")
    main.add(0, f"def {name}(value: Jsonable, path: str = \"$\", rep: Report = None) -> bool:")
    main.add(1, f"return json_model_{model._id}(value, path, rep)")
    sc.subs(main)
    return sc
