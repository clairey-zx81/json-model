# primitive python source code generation for a model
#
# TODO
# - language agnostic?
# - cache already compiled models!
# - optimize out redundant checks! (WIP)
# - check name override
# - generate error messages
#
# FIXME
# - Python is fuzzy about int/bool distinction, eg
#   - isinstance(True, int) is True
#   - True == 1 is True
#   - { True, 1, 1.0 } == { True }
#   as a consequence, some generated code may not provide the hoped answer

from typing import Any, Callable
import re
import json
import logging
import argparse

from .types import ModelType, ModelError, ModelPath, UnknownModel, Symbols
from .utils import openfiles, split_object, model_in_models, all_model_type, constant_value, log, tname, json_path
from .defines import Validator
from .model import JsonModel

type Line = tuple[int, str]

# inlined predefs
_PREDEFS = {
    "$ANY": lambda _v: "True",
    "$NONE": lambda _v: "False",
    "$NULL": lambda v: f"{v} is None",
    "$BOOL": lambda v: f"isinstance({v}, bool)",
    "$BOOLEAN": lambda v: f"isinstance({v}, bool)",
    "$INTEGER": lambda v: f"isinstance({v}, int) and not isinstance({v}, bool)",
    "$INT": lambda v: f"isinstance({v}, int) and not isinstance({v}, bool)",
    "$I32": lambda v: f"isinstance({v}, int) and not isinstance({v}, bool)",
    "$I64": lambda v: f"isinstance({v}, int) and not isinstance({v}, bool)",
    "$U32": lambda v: f"isinstance({v}, int) and not isinstance({v}, bool) and {v} >= 0",
    "$U64": lambda v: f"isinstance({v}, int) and not isinstance({v}, bool) and {v} >= 0",
    "$FLOAT": lambda v: f"isinstance({v}, float)",
    "$F32": lambda v: f"isinstance({v}, float)",
    "$F64": lambda v: f"isinstance({v}, float)",
    "$NUMBER": lambda v: f"isinstance({v}, (float, int)) and not isinstance({v}, bool)",
    "$STRING": lambda v: f"isinstance({v}, str)",
    "$URL": lambda v: f"is_valid_url({v}, path)",
    "$DATE": lambda v: f"is_valid_date({v}, path)",
    "$REGEX": lambda v: f"is_valid_re({v}, path)",
    # TODO more, /re/ ?
}

# variable names in generated code?!
_RESULT = "result"
_VALUE = "value"
_PATH = "path"
_RE = "re2"


class Code():

    def __init__(self):
        self._code: list[Line] = []

    def add(self, indent: int, line: str):
        self._code.append((indent, line))

    def nl(self):
        self.add(0, "")

    def clear(self):
        self._code.clear()

    def __str__(self):
        return "\n".join(("    " * n + lc) for n, lc in self._code) + "\n"

PYTHON_HEADER = """#
# Generated by jmc (JSON Model Compiler) (https://github.com/clairey-zx81/json-model)
#

from typing import Callable
import %s as re
import datetime
import urllib.parse

type Jsonable = None|bool|int|float|str|list[Jsonable]|dict[str, Jsonable]
type CheckFun = Callable[[Jsonable, str], bool]
type PropMap = dict[str, CheckFun]
type TagMap = dict[None|bool|float|int|str, CheckFun]

def is_valid_re(value: Jsonable, path: str) -> bool:
    if isinstance(value, str):
        try:
            re.compile(value)
            return True
        except:
            return False
    return False

def is_valid_date(value: Jsonable, path: str) -> bool:
    if isinstance(value, str):
        try:
            datetime.date.fromisoformat(value)
            return True
        except:
            return False
    return False

def is_valid_url(value: Jsonable, path: str) -> bool:
    if isinstance(value, str):
        try:
            urllib.parse.urlparse(value)
            return True
        except:
            return False
    return False
"""


class SourceCode(Validator):
    """Source code for compiling JSON Models."""

    def __init__(self, globs: Symbols, prefix: str = "", debug: bool = False, remod: str = _RE):

        # No actual compiler
        super().__init__()

        self._prefix = prefix
        self._globs = globs
        self._debug = debug
        self._re = remod

        # identifiers and functions
        # ident-prefix -> next number to use to ensure unique identifiers
        self._nvars: dict[str, int] = {}
        # FIXME global namespace! $-definitions -> function
        self._names: dict[str, str] = {}
        # /re.../ -> regex function name
        self._regs: dict[str, str] = {}
        # model path -> function name
        self._paths: dict[str|tuple[int|str, ...], str] = {}
        # already generated object paths
        self._generated: set[str|tuple[int|str, ...]] = set()
        # compiled json models ids
        self._compiled: dict[int, Code] = {}
        self._to_compile: dict[int, tuple[JsonModel, str]] = {}
        #
        # generated stuff
        #
        self._defines: list[str] = []
        self._help: list[Code] = []
        self._maps: dict[str, dict[str, str]] = {}
        self._subs: list[Code] = []
        # initialization
        self.reset()

    def reset(self):
        # self._defs.clear()
        self._nvars.clear()
        self._names.clear()
        self._regs.clear()
        self._defines.clear()
        self._help.clear()
        self._maps.clear()
        self._subs.clear()
        self._compiled.clear()
        self._to_compile.clear()
        self.define(PYTHON_HEADER % self._re)

    # add contents
    def subs(self, code: Code):
        self._subs.append(code)

    def help(self, code: Code):
        self._help.append(code)

    def define(self, line: str):
        """Append a definition."""
        self._defines.append(line)

    # show generated code
    def _map(self, mp: dict[str, str]) -> str:
        return "\n".join(f"    {self._esc(p)}: {v}," for p, v in mp.items())

    def __str__(self):
        """Generate check package."""

        res = ""
        defs = "\n".join(self._defines) + "\n"
        helps = "\n".join(map(str, self._help)) + "\n"
        subs = "\n".join(map(str, self._subs)) + "\n"
        maps = "\n".join(f"{name} = {{\n{self._map(mp)}\n}}" for name, mp in self._maps.items()) + "\n"

        if defs:
            res += defs
        if helps and re.search(r"\S", helps):
            res += ("\n" if res else "") + helps
        if subs and re.search(r"\S", subs):
            res += ("\n" if res else "") + subs
        if maps and re.search(r"\S", maps):
            res += ("\n" if res else "") + "# object properties maps\n" + maps + "\n"

        return res

    # code generation
    def _ident(self, prefix: str, local: bool = False) -> str:
        """Generate a new identifier using a prefix and a counter."""
        if prefix not in self._nvars:
            self._nvars[prefix] = 0
        ident = f"{'' if local else self._prefix}{prefix}{self._nvars[prefix]}"
        self._nvars[prefix] += 1
        return ident

    def _regex(self, regex: str) -> str:
        """Compile are regular expression, with memoization."""
        if regex not in self._regs:
            self.define(f"# regex {self._esc(regex)}")
            if regex[-1] == "/":
                pattern = regex[1:-1]
                fun = self._ident("re_")
                self._regs[regex] = fun
                self.define(f"{fun} = re.compile({self._esc(pattern)}).search")
            elif regex.endswith("/i"):
                pattern = regex[1:-2]
                fun = self._ident("re_")
                self._regs[regex] = fun
                if _RE == "re2":
                    pattern = "(?i)" + pattern
                    self.define(f"{fun} = re.compile({self._esc(pattern)}).search")
                else:
                    self.define(f"{fun} = re.compile({self._esc(pattern)}, re.IGNORECASE).search")
            else:
                raise NotImplementedError("model = {regex}")
        return self._regs[regex]

    def _regExpr(self, regex: str, val: str):
        """Generate re check expression on a value."""
        return f"{self._regex(regex)}({val}) is not None"

    def _esc(self, val: Any):
        """Escape value as necessary."""
        # return '"' + string.translate({"\"": "\\\"", "\\": "\\\\"}) + '"'
        return json.dumps(val) if isinstance(val, str) else str(val)

    def _dollarExpr(self, jm: JsonModel, ref: str, val: str, vpath: str):
        assert ref and ref[0] == "$"
        if ref in _PREDEFS:
            return _PREDEFS[ref](val)
        else:
            fun = self._getNameRef(jm, ref, [])
            return f"{fun}({val}, {vpath})"

    def _compileConstraint(self, code: Code, indent: int,
                           jm: JsonModel, model: ModelType, mpath: ModelPath,
                           res: str, val: str, vpath: str):
        assert isinstance(model, dict) and "@" in model
        self._compileModel(code, indent, jm, model["@"], mpath + ["@"], res, val, vpath)
        tmodel = self._ultimate_type(jm, model["@"])  # pyright: ignore
        # NOTE UnknownModel should raise an error on any constraint
        # FIXME None?
        assert tmodel in (int, float, str, list, dict, UnknownModel), f"simple {tmodel}"
        checks = []
        what = f"len({val})" if tmodel in (list, dict) else val
        twhat = int if tmodel in (list, dict) else tmodel
        for constraint in ("=", "!=", "<", "<=", ">", ">="):
            if constraint in model:
                op = "==" if constraint == "=" else constraint
                cst = model[constraint]
                if not isinstance(cst, (twhat, int)):
                    raise ModelError(f"invalid constant: {cst} ({twhat.__name__}) {mpath}")
                if isinstance(cst, int) and tmodel is str:
                    checks.append(f"len({val}) {op} {cst}")
                elif isinstance(cst, int) and tmodel == UnknownModel:
                    checks.append(f"(len({val}) {op} {cst} if isinstance({val}, (str, list, dict))"
                                  " else "
                                  f"{val} {op} {self._esc(cst) if isinstance(cst, str) else cst})")
                elif isinstance(cst, str):
                    checks.append(f"{what} {op} {self._esc(cst)}")
                else:  # same type or list or dict
                    checks.append(f"{what} {op} {cst}")
        if "!" in model:
            if not isinstance(model["!"], bool):
                raise ModelError(f"! constraint expects a boolean {mpath}")
            # FIXME partial implementation
            if model["!"]:
                code.add(indent, f"{res} &= len(set({val})) == len({val})")
            # else defaut is nothing to check
            # raise NotImplementedError("! is not yet implemented")
        if checks:
            code.add(indent, f"{res} &= {' and '.join(checks)}")

    def _disjunction(self, code: Code, indent: int,
                     jm: JsonModel, model: ModelType, mpath: ModelPath,
                     res: str, val: str, vpath: str) -> bool:
        """Generate optimized disjunction check.

        model: `{"|": [ o1, o2, ... ] }`
        """

        dis = self._disjunct_analyse(jm, model, mpath)  # pyright: ignore
        if dis is None:
            return False
        tag_name, tag_type, models, all_const_props = dis

        # Compile all object models in the list if needed
        assert isinstance(model, dict)

        init = model["|"]
        assert isinstance(init, list)  # pyright hint
        assert len(models) == len(init)
        for i, m in enumerate(models):
            p = mpath + [i]
            tp = tuple(p)
            mi = init[i]  # initial model
            if isinstance(mi, str) and mi and mi[0] == "$":
                # it is a reference, it must be compiled for its name, no need to recompile it!
                fun = self._getNameRef(jm, mi, p)
                if tp not in self._paths:
                    # several path will lead to the same function
                    self._paths[tp] = fun
                # else nothing to do?
            elif tp not in self._paths:
                # else compile the direct object as a side effect…
                c = Code()
                self._compileModel(c, 0, jm, m, p, _RESULT, _VALUE, _PATH)
                # log.debug(f"{self._paths}")

        # {disid}_tm = { tag-value: check_function_for_this_tag_value }
        # if v is dict:
        #     if v[tag] in object_tag:
        #         res = object_tag[v[tag]](v)
        disid = self._ident("map_")
        tag = self._ident("tag_", True)

        # mapping from tag values to check functions
        TAG_CHECKS = {}
        for i in range(len(models)):
            consts = all_const_props[i]
            TAG_CHECKS[consts[tag_name]] = self._paths[tuple(mpath + [i])]

        self.define(f"{disid}: TagMap")
        self._maps[disid] = TAG_CHECKS
        esctag = self._esc(tag_name)

        # val is Object, tag is in val, tag_value is valid
        code.add(indent, f"{res} = isinstance({val}, dict)")
        code.add(indent, f"if {res}:")
        code.add(indent, f"    {res} = {esctag} in {val}")
        code.add(indent, f"    if {res}:")
        code.add(indent, f"        {tag} = {val}[{esctag}]")
        code.add(indent, f"        if {tag} in {disid}:")
        code.add(indent, f"            {res} = {disid}[{tag}]({val}, {vpath})")
        code.add(indent, r"        else:")
        code.add(indent, f"            {res} = False")

        return True

    def _compileObject(self, code: Code, indent: int,
                       jm: JsonModel, model: ModelType, mpath: ModelPath,
                       oname: str, res: str, val: str, vpath: str):
        # separate properties
        assert isinstance(model, dict)
        must, may, defs, regs, oth = split_object(model, mpath)
        # TODO optimize must only case?
        code.add(indent, f"if not isinstance({val}, dict):")
        code.add(indent + 1, "return False")
        prop_must = f"{oname}_must"
        if must:
            prop_must_map: dict[str, str] = {}
            self.define(f"{prop_must}: PropMap")
            self._maps[prop_must] = prop_must_map
            for p, m in must.items():
                pid = f"{prop_must}_{p}"  # tmp unique identifier
                self.help(self._compileName(jm, pid, m, mpath + [p]))
                prop_must_map[p] = self._getName(jm, pid)
        prop_may = f"{oname}_may"
        if may:
            prop_may_map: dict[str, str] = {}
            self.define(f"{prop_may}: PropMap")
            self._maps[prop_may] = prop_may_map
            for p, m in may.items():
                pid = f"{prop_may}_{p}"
                self.help(self._compileName(jm, pid, m, mpath + [p]))
                prop_may_map[p] = self._getName(jm, pid)
        prop, value, must_c = "prop", "model", "must_count"
        if must:
            code.add(indent, f"{must_c} = 0")
        code.add(indent, f"for {prop}, {value} in {val}.items():")
        code.add(indent, f"    assert isinstance({prop}, str)")
        cond = "if"
        if must:
            code.add(indent, f"    {cond} {prop} in {prop_must}:  # must")
            code.add(indent, f"        {must_c} += 1")
            code.add(indent, f"        if not {prop_must}[{prop}]({value}, "
                     f"f\"{{path}}.{{{prop}}}\"):")
            code.add(indent, r"            return False")
            # code.add(indent+3, f"continue")
            cond = "elif"
        if may:
            code.add(indent, f"    {cond} {prop} in {prop_may}:  # may")
            code.add(indent, f"        if not {prop_may}[{prop}]({value}, "
                     f"f\"{{path}}.{{{prop}}}\"):")
            code.add(indent, r"            return False")
            # code.add(indent+3, f"continue")
            cond = "elif"
        # $* is inlined expr
        for d, v in defs.items():
            code.add(indent, f"    {cond} {self._dollarExpr(jm, '$' + d, prop, 'path')}:  # ${d}")
            self._compileModel(code, indent + 2, jm, v, mpath + [d], res, value, vpath)
            code.add(indent, f"        if not {res}: return False")
            # code.add(indent+3, f"continue")
            cond = "elif"
        # // is inlined
        for r, v in regs.items():
            regex = f"/{r}/"
            code.add(indent, f"    {cond} {self._regex(regex)}({prop}) is not None:  # {regex}")
            self._compileModel(code, indent + 2, jm, v, mpath + [regex], res, value, vpath)
            code.add(indent, f"        if not {res}: return False")
            # code.add(indent+3, f"continue")
            cond = "elif"
        # catchall is inlined
        if oth:
            omodel = oth[""]
            if cond == "if":  # direct
                self._compileModel(code, indent + 1, jm, omodel, mpath + [""], res, value, vpath)
                code.add(indent, f"    if not {res}: return False")
            else:
                code.add(indent, r"    else:  # catch all")
                self._compileModel(code, indent + 2, jm, omodel, mpath + [""], res, value, vpath)
                code.add(indent, f"        if not {res}: return False")
                # code.add(indent+3, f"continue")
        else:
            if cond == "if":
                # we are expecting an empty object
                code.add(indent, "    # no catch all")
                code.add(indent, "    return False")
            else:
                code.add(indent, "    else:  # no catch all")
                code.add(indent, "        return False")
        # check that all must were seen
        if must:
            code.add(indent, f"return {must_c} == {len(must)}")
        else:
            code.add(indent, "return True")

    def _compileModel(self, code: Code, indent: int,
                      jm: JsonModel, model: ModelType, mpath: ModelPath,
                      res: str, val: str, vpath: str, known: set[str]|None = None):
        # known = expression already verified
        log.debug(f"mpath={mpath} model={model} res={res} val={val} vpath={vpath} indent={indent}")
        assert isinstance(mpath, list)
        code.add(indent, f"# {json_path(mpath)}")
        match model:
            case None:
                code.add(indent, f"{res} = {val} is None")
            case bool():
                code.add(indent, f"{res} = isinstance({val}, bool)")
            case int():
                expr = f"isinstance({val}, int) and not isinstance({val}, bool)"
                if known is not None:
                    if expr in known:
                        expr = None
                if model == -1:
                    if known is not None:
                        if expr is not None:
                            known.add(expr)
                    if not expr:
                        expr = "True"
                elif model == 0:
                    if expr:
                        expr += f" and {val} >= 0"
                    else:
                        expr = f"{val} >= 0"
                elif model == 1:
                    if expr:
                        expr += f" and {val} >= 1"
                    else:
                        expr = f"{val} >= 1"
                else:
                    raise ModelError(f"unexpected int value {model} at {mpath}")
                if expr:
                    code.add(indent, res + " = " + expr)
            case float():
                expr = f"isinstance({val}, float)"
                if known is not None:
                    if expr in known:
                        expr = None
                if model == -1.0:
                    if known is not None:
                        if expr is not None:
                            known.add(expr)
                    if not expr:
                        expr = "True"
                elif model == 0.0:
                    if expr:
                        expr += f" and {val} >= 0.0"
                    else:
                        expr = f"{val} >= 0.0"
                elif model == 1.0:
                    if expr:
                        expr += f" and {val} > 0.0"
                    else:
                        expr = f"{val} > 0.0"
                else:
                    raise ModelError(f"unexpected float value {model} at {mpath}")
                if expr:
                    code.add(indent, res + " = " + expr)
            case str():
                expr = f"isinstance({val}, str)"
                if known is not None:
                    # Skip special cases
                    if model == "" or model[0] not in ["$", "="]:
                        # log.info(f"expr={expr} known={known}")
                        if expr in known:
                            expr = None
                if model == "":
                    if known is not None:
                        if expr is not None:
                            known.add(expr)
                    if expr:
                        code.add(indent, f"{res} = {expr}")
                    else:
                        code.add(indent, f"{res} = True")
                elif model[0] == "_":
                    if expr:
                        code.add(indent, f"{res} = {expr} and {val} == {self._esc(model[1:])}")
                    else:
                        code.add(indent, f"{res} = {val} == {self._esc(model[1:])}")
                elif model[0] == "=":
                    # TODO FIXME known
                    (a_cst, value) = constant_value(model, mpath)
                    if a_cst:
                        if value is None:
                            code.add(indent, f"{res} = {val} is None")
                        elif isinstance(value, bool):
                            code.add(indent, f"{res} = isinstance({val}, bool) and {val} == {value}")
                        elif isinstance(value, int):
                            code.add(indent,
                                     f"{res} = isinstance({val}, int) and "
                                     f"not isinstance({val}, bool) and {val} == {value}")
                        elif isinstance(value, float):
                            code.add(indent, f"{res} = isinstance({val}, float) and {val} == {value}")
                        elif isinstance(value, str):
                            code.add(indent, f"{res} = isinstance({val}, str) and {val} == {value}")
                        else:
                            raise ModelError(f"unexpected constant type: {tname(value)}")
                    else:
                        raise ModelError(f"unexpected constant: {model}")
                elif model[0] == "$":
                    # if jm._isPredef(model):
                    code.add(indent, f"{res} = " + self._dollarExpr(jm, model, val, "path"))
                elif model[0] == "/":
                    code.add(indent, f"# {self._esc(model)}")
                    if expr:
                        code.add(indent, f"{res} = {expr} and {self._regExpr(model, val)}")
                    else:
                        code.add(indent, f"{res} = {self._regExpr(model, val)}")
                else:  # simple string
                    if expr:
                        code.add(indent, f"{res} = {expr} and {val} == {self._esc(model)}")
                    else:
                        code.add(indent, f"{res} = {val} == {self._esc(model)}")
            case list():
                expr = f"isinstance({val}, list)"
                if known is not None:
                    if expr in known:
                        expr = None
                    if expr is not None:
                        known.add(expr)
                if len(model) == 0:
                    if expr:
                        expr += f" and len({val}) == 0"
                    else:
                        expr = f"len({val}) == 0"
                    code.add(indent, f"{res} = {expr}")
                elif len(model) == 1:
                    arrayid = self._ident("array_", True)
                    idx, item = f"{arrayid}_idx", f"{arrayid}_item"
                    if expr:
                        code.add(indent, f"{res} = {expr}")
                        code.add(indent, f"if {res}:")
                    else:
                        code.add(indent, "if True:")
                    code.add(indent + 1, f"assert isinstance({val}, list)  # pyright helper")
                    code.add(indent + 1, f"for {idx}, {item} in enumerate({val}):")
                    self._compileModel(code, indent + 2, jm, model[0], mpath + [0],
                                       res, item, f"f\"{{{vpath}}}[{{{idx}}}]\"")
                    code.add(indent + 2, f"if not {res}: break")
                else:
                    if expr:
                        code.add(indent, f"{res} = {expr} and len({val}) == {len(model)}")
                    else:
                        code.add(indent, f"{res} = len({val}) == {len(model)}")
                    for i, m in enumerate(model):
                        code.add(indent + i, f"if {res}:")
                        # FIXME vpath
                        self._compileModel(code, indent + i + 1, jm, model[i], mpath + [i],
                                           res, f"{val}[{i}]", f"{vpath}[{i}]")
            case dict():
                assert isinstance(model, dict)  # pyright hint
                assert "+" not in model, "merge must have been preprocessed"
                if "@" in model:
                    self._compileConstraint(code, indent, jm, model, mpath, res, val, vpath)
                elif "|" in model:
                    lpath = mpath + ["|"]
                    models = model["|"]
                    assert isinstance(models, list)  # pyright hint
                    # partial list of constants optimization
                    l_const = list(map(lambda m: constant_value(m, lpath), models))
                    if len(list(filter(lambda t: t[0], l_const))) >= 2:
                        constants, n_models = set(), []
                        for i in range(len(models)):
                            # NOTE python equality is a pain, True == 1 == 1.0, False == 0 == 0.0
                            # NOTE python typing is a pain, isinstance(True, int) == True
                            # thus we only keep strings…
                            if l_const[i][0] and isinstance(l_const[i][1], str):
                                constants.add(l_const[i][1])
                            else:
                                n_models.append(models[i])
                        if constants:
                            # ensure a deterministic output
                            sconst = "{" + str(sorted(constants))[1:-1] + "}"
                            code.add(indent, f"{res} = not isinstance({val}, (list, dict)) and {val} in {sconst}")
                            if not n_models:
                                return
                            code.add(indent, f"if not {res}:")
                            indent += 1
                            models = n_models
                    # empty list
                    if not models:
                        code.add(indent, f"{res} = False")
                        return
                    # discriminant optimization
                    if self._disjunction(code, indent, jm, model, lpath, res, val, vpath):
                        return
                    # homogeneous typed list
                    same_type, expected_type = all_model_type(models, lpath)
                    or_known = set()
                    if same_type:
                        # all models have the same ultimate type
                        if expected_type is int:
                            type_test = f"isinstance({val}, int) and not isinstance({val}, bool)"
                        else:
                            type_test = f"isinstance({val}, {expected_type.__name__})"  # type: ignore
                        code.add(indent, f"{res} = {type_test}")
                        code.add(indent, f"if {res}:")
                        indent += 1
                        or_known.add(type_test)
                    for i, m in enumerate(models):
                        if i:
                            code.add(indent + i - 1, f"if not {res}:")
                        self._compileModel(code, indent + i, jm, m, lpath + [i],
                                           res, val, vpath, or_known)
                elif "&" in model:
                    and_known = set(known or [])
                    lpath = mpath + ["&"]
                    models = model["&"]
                    assert isinstance(models, list)  # pyright hint
                    if not models:
                        code.add(indent, f"{res} = True")
                        return
                    # homogeneous typed list
                    same_type, expected_type = all_model_type(models, lpath)
                    if same_type:
                        # all models have the same ultimate type
                        if expected_type is int:
                            type_test = f"isinstance({val}, int) and not isinstance({val}, bool)"
                        else:
                            type_test = f"isinstance({val}, {expected_type.__name__})"  # type: ignore
                        code.add(indent, f"{res} = {type_test}")
                        code.add(indent, f"if {res}:")
                        indent += 1
                        and_known.add(type_test)
                    for i, m in enumerate(models):
                        if i:
                            code.add(indent + i - 1, f"if {res}:")
                        self._compileModel(code, indent + i, jm, m, lpath + [i],
                                           res, val, vpath, and_known)
                elif "^" in model:
                    lpath = mpath + ["^"]
                    models = model["^"]
                    assert isinstance(models, list)  # pyright hint

                    # optimize out repeated models
                    if len(models) >= 2:
                        seen, dups, kept = [], [], []
                        seen_i, dups_i, kept_i = [], [], []
                        for i, m in enumerate(models):
                            if model_in_models(m, seen):
                                if not model_in_models(m, dups):
                                    dups.append(m)
                                    dups_i.append(i)
                            else:
                                seen.append(m)
                                seen_i.append(i)
                        for i, m in zip(seen_i, seen):
                            if not model_in_models(m, dups):
                                kept.append(m)
                                kept_i.append(i)

                        # false if in dups
                        for i, m in enumerate(dups):
                            idx = dups_i[i]
                            self._compileModel(code, indent + i, jm, m, lpath + [idx],
                                               "isin", val, vpath)
                            code.add(indent + i, f"{res} = not isin")
                            code.add(indent + i, f"if {res}:")

                        # update remaining models and identation
                        models = kept
                        models_i = kept_i
                        depth = len(dups)
                    else:
                        models_i = list(range(len(models)))
                        depth = 0

                    # standard case
                    if not models:
                        code.add(indent + depth, f"{res} = False")
                    elif len(models) == 1:
                        mod, idx = models[0], models_i[0]
                        self._compileModel(code, indent + depth, jm, mod, lpath + [idx],
                                           res, val, vpath)
                    else:  # several models are inlined
                        if len(models) == 2 and "$ANY" in models:
                            # get other model
                            m = models[1] if models[0] == "$ANY" else models[0]
                            is_m = self._ident("is_m_", True)
                            self._compileModel(code, indent + depth, jm, m, lpath + ["?"],
                                               is_m, val, vpath)
                            code.add(indent + depth, f"{res} = not {is_m}")
                        else:
                            count = self._ident("xc_", True)
                            test = self._ident("xr_", True)
                            code.add(indent + depth, f"{count} = 0")
                            for i, m in enumerate(models):
                                idx = models_i[i]
                                code.add(indent + depth, f"if {count} <= 1:")
                                self._compileModel(code, indent + depth + 1, jm, m, lpath + [idx],
                                                   test, val, vpath)
                                code.add(indent + depth + 1, f"if {test}: {count} += 1")
                            code.add(indent + depth, f"{res} = {count} == 1")
                else:
                    # TODO check for non-root %
                    # TODO optimize empty model?
                    # generate separate functions for objects?
                    hpath = tuple(mpath)
                    if hpath not in self._paths:
                        objid = self._ident("obj_")
                        self._paths[hpath] = objid
                    else:
                        objid = self._paths[hpath]
                    if hpath not in self._generated:
                        ocode = Code()
                        ocode.nl()
                        ocode.add(0, f"# object {json_path(mpath)}")
                        path_init = " = \"$\"" if mpath == ["$"] else ""
                        ocode.add(0, f"def {objid}(value: Jsonable, path: str{path_init}) -> bool:")
                        self._compileObject(ocode, 1, jm, model, mpath, objid, _RESULT, _VALUE, _PATH)
                        self.subs(ocode)
                        self._generated.add(hpath)
                    del hpath
                    code.add(indent, f"{res} = {objid}({val}, {vpath})")
            case _:
                raise ModelError(f"unexpected model type: {tname(model)}")

    def _getName(self, jm: JsonModel, name: str) -> str:
        """Ensure global unique names for internal functions."""
        # FIXME global name space! prefix with jm._id ?
        if name not in self._names:
            self._names[name] = self._ident("f_")
        log.debug(f"{name} -> {self._names[name]}")
        return self._names[name]

    def _getNameRef(self, jm: JsonModel, ref: str, path: ModelPath) -> str:
        assert jm._isRef(ref), f"reference: {ref}"
        gref = jm._defs.gget(ref)
        # log.debug(f"ref={ref} gref={gref} at {path}")
        if gref not in self._names:
            jm = self._globs[gref]  # pyright: ignore
            if jm._id not in self._compiled:
                self._to_compile[jm._id] = (jm, gref)
            self._names[gref] = f"json_model_{jm._id}"
        return self._names[gref]

    def _compileName(self, jm: JsonModel, name: str, model: ModelType, mpath: ModelPath) -> Code:
        """Compile a model under a given name in a given scope."""
        log.debug(f"name: mpath={mpath} name={name} jm={jm._id}")
        code = Code()
        # FIXME explain this junk code
        # keep definitions
        # XXX self._defs.set(name, model)
        xname = name if not name or name[0] != "$" else name[1:]
        self._defs.set(xname, model)
        fun2 = None
        hpath = tuple(mpath)
        if hpath in self._paths:
            fun = self._paths[hpath]
            if name in self._names:
                fun2 = self._names[name]
            else:
                self._names[name] = fun
        else:
            fun = self._getName(jm, name)
            self._paths[hpath] = fun
        # generate code
        # code.nl()
        code.add(0, f"# define {self._esc(name)} ({json_path(mpath)})")
        code.add(0, f"def {fun}(value: Jsonable, path: str) -> bool:")
        self._compileModel(code, 1, jm, model, mpath, _RESULT, _VALUE, _PATH, None)
        code.add(1, f"return {_RESULT}")
        if fun2 and fun2 != fun:
            code.nl()
            code.add(0, "# named root")
            code.add(0, f"{fun2} = {fun}")
        # FIXME!
        # NOTE yuk! the function may have been generated as a side effect of the previous call.
        # if so, this version is simply discarded
        if hpath not in self._generated:
            # on a named root, two names for the same path
            self._generated.add(hpath)
        else:
            code.clear()
        return code

    def compileOneJsonModel(self, jm: JsonModel, name: str, path: ModelPath):
        if jm._id not in self._compiled:
            if name not in self._names:
                self._names[name] = "json_model_" + str(jm._id)
            self._compiled[jm._id] = self._compileName(jm, name, jm._model, path)
        return self._compiled[jm._id]

def static_compile(
        model: JsonModel,
        name: str = "check_model",
        prefix: str = "jm_",
        remod: str = "re",
        debug: bool = False,
    ) -> SourceCode:
    """Generate the check source code for a model.

    - `model`: JSON Model root to compile.
    - `name`: target function name.
    - `prefix`: prefix for generated functions
    - `remod`: regular expression module to use, "re" or "re2"
    - `debug`: debugging mode generates more traces
    """
    sc = SourceCode(model._globs, prefix, debug, remod)  # pyright: ignore
    # compile definitions
    for n, jm in model._defs.items():
        sc.subs(sc.compileOneJsonModel(jm, "$" + n, [n]))
    # compile main
    root = sc.compileOneJsonModel(model, "$", [])
    # compile other encountered references
    while todo := set(sc._to_compile.keys()) - set(sc._compiled.keys()):
        jm, gref = sc._to_compile[min(todo)]
        sc.subs(sc.compileOneJsonModel(jm, gref, [gref]))
    # register root
    sc.subs(root)
    # create main
    main = Code()
    main.add(0, f"# entry function {name}")
    main.add(0, f"def {name}(value: Jsonable, path: str = \"$\") -> bool:")
    main.add(1, f"return json_model_{model._id}(value, path)")
    sc.subs(main)
    return sc
