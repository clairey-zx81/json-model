import re
from importlib.resources import files as data_files
from .mtypes import Jsonable
from .utils import log, __version__

# name
type Var = str

# typed expressions
type JsonExpr = str
type BoolExpr = str
type IntExpr = str
type FloatExpr = str
type NumExpr = str
type StrExpr = str
# all value expressions
type Expr = JsonExpr|BoolExpr|IntExpr|FloatExpr|NumExpr|StrExpr

type PathExpr = str

# actual code
type Inst = str|None
type Block = list[Inst]

# must or may property name -> corresponding check function
type PropMap = dict[str, str]
type ConstList = list[None|bool|int|float|str]


class Language:
    """Dumb abstraction of an imperative language to manipulate JSON data.

    Some reasonable defaults are provided base on operators and assuming Python,
    but the child must be instanciated to get meaningful code.
    """

    def __init__(self,
            name: str, *,
            debug: bool = False,
            # operators and separators
            eq: str = "==", ne: str = "!=",
            ge: str = ">=", gt: str = ">", le: str = "<=", lt: str = "<",
            not_op: str = "not", and_op: str = "and", or_op: str = "or",
            eoi: str = "", isep: str = "\n", indent: str = "    ",
            lcom: str = "#",
            relib: str = "re2",
            # options
            with_path: bool = True, with_report: bool = True,
            with_comment: bool = True, set_caps: list[type|None] = (str,),
        ):

        # parameter consistency
        if with_path and not with_report:
            log.warning(f"path collection but no reporting")

        # keep parameters
        self._name = name  # language name
        self._debug = debug
        self._with_path = with_path
        self._with_report = with_report
        self._with_comment = with_comment

        # comparison operators
        self._eq = eq
        self._ne = ne
        self._ge = ge
        self._gt = gt
        self._le = le
        self._lt = lt
        # logical operators
        self._not = not_op
        self._and = and_op
        self._or = or_op
        # instructions and blocks
        self._eoi = eoi
        self._isep = isep
        self._indent = indent
        self._lcom = lcom
        self._relib = relib

        # other stuff
        self._version = __version__
        self._idcounts: dict[str, int] = {}  # per-prefix ident count for unicity
        self._re_used: bool = False          # whether regular expressions are used
        self.set_caps = tuple(set_caps)      # constant types in a set

    #
    # variables
    #
    def ident(self, prefix: str) -> Var:
        """Return a new identifier using prefix."""
        if prefix not in self._idcounts:
            self._idcounts[prefix] = 0
        ident = prefix + "_" + str(self._idcounts[prefix])
        self._idcounts[prefix] += 1
        return ident

    #
    # file
    #
    def load_data(self, fn: str) -> Block:
        code = data_files("json_model.data").joinpath(fn).read_text().split("\n")
        # remove empty trailing lines
        while code and re.match(r"^\s*$", code[-1]):
            code = code[:-1]
        return code

    def file_header(self) -> Block:
        return [
            self.lcom(),
            self.lcom("Generated by JSON Model Compiler version {self._version}"),
            self.lcom("see https://github.com/clairey-zx81/json-model"),
            self.lcom(),
            # NOTE relib import is generated in python
        ]

    def file_footer(self) -> Block:
        return []

    #
    # inlined type test expressions about JSON data
    #
    def is_obj(self, var: Var) -> BoolExpr:
        return f"isinstance({var}, dict)"

    def is_arr(self, var: Var) -> BoolExpr:
        return f"isinstance({var}, list)"

    def is_str(self, var: Var) -> BoolExpr:
        return f"isinstance({var}, str)"

    def is_num(self, var: Var) -> BoolExpr:
        return f"isinstance({var}, (int, float)) and not isinstance({var}, bool)"

    def is_flt(self, var: Var, loose: bool = False) -> BoolExpr:
        return self.is_num(var) if loose else f"isinstance({var}, float)"

    def is_int(self, var: Var, loose: bool = False) -> BoolExpr:
        is_an_int = f"isinstance({var}, int) and not isinstance({var}, bool)"
        if loose:
            is_an_int = f"({is_an_int} or isinstance({var}, float) and {var} == int({var}))"
        return is_an_int

    def is_bool(self, var: Var) -> BoolExpr:
        return f"isinstance({var}, bool)"

    def is_null(self, var: Var) -> BoolExpr:
        return f"{var} is None"

    def is_def(self, var: Var) -> BoolExpr:
        return f"{var} is not None"

    def is_scalar(self, var: Var) -> BoolExpr:
        return f"({var} is None or isinstance({var}, (bool, int, float, str)))"

    def is_this_type(self, var: Var, tval: type|None) -> BoolExpr:
        if tval is None or tval == type(None):
            return self.is_null(var)
        elif tval is bool:
            return self.is_bool(var)
        elif tval is int:
            return self.is_int(var)
        elif tval is float:
            return self.is_flt(var)
        elif tval is str:
            return self.is_str(var)
        else:
            raise NotImplementedError("unexpected type {tval}")

    #
    # predefs
    #
    def predef(self, var: Var, name: str, path: Var) -> BoolExpr:
        if name == "$ANY":
            return self.bool_cst(True)
        elif name == "$NONE":
            return self.bool_cst(False)
        elif name == "$NULL":
            return self.is_null(var)
        elif name in ("$BOOL", "$BOOLEAN"):
            return self.is_bool(var)
        elif name in ("$INT", "$INTEGER", "$I32", "$I64"):
            return self.is_int(var)
        elif name in ("$U32", "$U64"):
            return self.and_op(self.is_int(var),
                               self.num_ge(self.int_val(var), self.int_cst(0)))
        elif name in ("$FLOAT", "$F32", "$F64"):
            return self.is_flt(var)
        elif name == "$NUMBER":
            return self.is_num(var)
        elif name == "$STRING":
            return self.is_str(var)
        elif name in ("$DATE", "$URL", "$REGEX", "$UUID"):
            raise NotImplementedError(f"TODO predef {name}")
        else:
            raise NotImplementedError(f"unexpected predef {name}")

    #
    # constants
    #
    def bool_cst(self, b: bool) -> BoolExpr:
        return "True" if b else "False"

    def int_cst(self, i: int) -> IntExpr:
        return str(i)

    def flt_cst(self, f: float) -> FloatExpr:
        return str(f)

    def str_cst(self, s: str) -> StrExpr:
        return self.esc(s)

    def json_cst(self, j: Jsonable) -> JsonExpr:
        return str(j)

    #
    # inline json scalar value extraction
    #
    def bool_val(self, var: Var) -> BoolExpr:
        return var

    def int_val(self, var: Var) -> IntExpr:
        return var

    def flt_val(self, var: Var) -> FloatExpr:
        return var

    def str_val(self, var: Var) -> StrExpr:
        return var

    def arr_item_val(self, arr: Var, idx: IntExpr) -> Expr:
        return f"{arr}[{idx}]"

    def obj_prop_val(self, obj: Var, prop: Var) -> Expr:
        return f"{obj}[{prop}]"

    #
    # inlined length computation
    #
    def obj_len(self, var: Var) -> IntExpr:
        return f"len({var})"

    def arr_len(self, var: Var) -> IntExpr:
        return f"len({var})"

    def str_len(self, var: Var) -> IntExpr:
        return f"len({var})"

    def any_len(self, var: Var) -> IntExpr:
        return f"len({var})"

    #
    # boolean expression
    #
    def str_check_call(self, name: str, val: StrExpr) -> BoolExpr:
        return f"{name}({val})"

    def check_call(self, name: Var, val: JsonExpr, path: Var) -> BoolExpr:
        return f"{name}({val}, {path}, rep)"

    def ternary(self, cond: BoolExpr, true: BoolExpr, false: BoolExpr) -> BoolExpr:
        return f"{true} if {cond} else {false}"

    #
    # logical expressions
    #
    def not_op(self, e: BoolExpr) -> BoolExpr:
        return f"{self._not} {e}"

    def and_op(self, *exprs: BoolExpr) -> BoolExpr:
        return f" {self._and} ".join(exprs)

    def or_op(self, *exprs: BoolExpr) -> BoolExpr:
        return f" {self._or} ".join(exprs)

    def paren(self, e: Expr) -> Expr:
        return f"({e})"

    #
    # inline comparison expressions for numbers
    #
    def num_eq(self, e1: NumExpr, e2: NumExpr) -> BoolExpr:
        return f"{e1} {self._eq} {e2}"

    def num_ne(self, e1: NumExpr, e2: NumExpr) -> BoolExpr:
        return f"{e1} {self._ne} {e2}"

    def num_ge(self, e1: NumExpr, e2: NumExpr) -> BoolExpr:
        return f"{e1} {self._ge} {e2}"

    def num_gt(self, e1: NumExpr, e2: NumExpr) -> BoolExpr:
        return f"{e1} {self._gt} {e2}"

    def num_le(self, e1: NumExpr, e2: NumExpr) -> BoolExpr:
        return f"{e1} {self._le} {e2}"

    def num_lt(self, e1: NumExpr, e2: NumExpr) -> BoolExpr:
        return f"{e1} {self._lt} {e2}"

    #
    # inline comparison expressions for strings
    #
    def str_eq(self, e1: StrExpr, e2: StrExpr) -> BoolExpr:
        return f"{e1} {self._eq} {e2}"

    def str_ne(self, e1: StrExpr, e2: StrExpr) -> BoolExpr:
        return f"{e1} {self._ne} {e2}"

    def str_ge(self, e1: StrExpr, e2: StrExpr) -> BoolExpr:
        return f"{e1} {self._ge} {e2}"

    def str_gt(self, e1: StrExpr, e2: StrExpr) -> BoolExpr:
        return f"{e1} {self._gt} {e2}"

    def str_le(self, e1: StrExpr, e2: StrExpr) -> BoolExpr:
        return f"{e1} {self._le} {e2}"

    def str_lt(self, e1: StrExpr, e2: StrExpr) -> BoolExpr:
        return f"{e1} {self._lt} {e2}"

    def prop_fun(self, fun: str, prop: str, mapname: str, nbprops: int) -> BoolExpr:
        return f"{fun} := {mapname}.get({prop})"

    #
    # for JSON values
    #
    def json_eq(self, e1: Expr, e2: Expr) -> BoolExpr:
        return f"e1 {self._eq} {e2}"

    def json_ne(self, e1: Expr, e2: Expr) -> BoolExpr:
        return f"e1 {self._ne} {e2}"

    #
    # simple instructions
    #
    def nope(self) -> Inst:
        return "pass"

    def lcom(self, text: str = "") -> Inst:
        """Generate a line comment."""
        if self._with_comment:
            return f"{self._lcom} {text}" if text else self._lcom
        else:
            return None

    def _var(self, var: Var, val: Expr|None, tname: str|None) -> Inst:
        """Declare and/or assign a variable."""
        assign = f" = {val}" if val else ""
        decl = f": {tname}" if tname else ""
        return f"{var}{decl}{assign}{self._eoi}"

    def json_var(self, var: Var, val: JsonExpr|None = None, declare: bool = False) -> Inst:
        """Declare a JSON variable."""
        return self._var(var, val, "Jsonable" if declare else None)

    def bool_var(self, var: Var, val: BoolExpr|None = None, declare: bool = False) -> Inst:
        """Declare a boolean variable."""
        return self._var(var, val, "bool" if declare else None)

    def int_var(self, var: Var, val: IntExpr|None = None, declare: bool = False) -> Inst:
        """Declare and assign to int variable."""
        return self._var(var, val, "int" if declare else None)

    def fun_var(self, var: Var, val: Expr|None = None, declare: bool = False) -> Inst:
        """Declare a check function variable pointer."""
        return self._var(var, val, "CheckFun" if declare else None)

    def iand_op(self, res: Var, e: BoolExpr) -> Inst:
        """And-update boolean variable."""
        return "{var} &= {e}{self.eoi}"

    def inc_var(self, var: Var) -> Inst:
        """Increment integer variable."""
        return f"{var} += 1{self._eoi}"

    def ret(self, res: BoolExpr) -> Inst:
        """Return boolean result."""
        return f"return {res}{self._eoi}"

    def brk(self) -> Inst:
        """Break from surrounding loop."""
        return f"break{self._eoi}"

    def esc(self, s: str) -> StrExpr:
        """Escape string."""
        return '"' + s.replace("\\", "\\\\").replace('"', r'\"') + '"'

    #
    # paths:
    #
    # fun(path: Path)
    # lpath: Path = path + [ segment ]  # if path is not None, else None !
    # checker(val, lpath, ...)
    #
    # fun(Path* path)
    # Path lpath = (Path) { ..., path }
    # checker(val, path ? &lpath : NULL, ...)
    #
    # TODO consider merging path_var and path_val?
    #
    def path_val(self, pvar: Var, pseg: str|int, is_prop: bool) -> PathExpr:
        """Append a segment variable/value to path."""
        # avoid nested if expressions
        pvar = f"({pvar})" if " if " in pvar else pvar
        return f"({pvar} + [ {pseg} ]) if {pvar} is not None else None" if self._with_path else "None"

    def path_var(self, pvar: Var, val: PathExpr|None = None, declare: bool = False) -> Inst:
        """Assign and possibly declare a value to a path variable."""
        assign = f" = {val}" if val else ""
        decl = ": Path" if declare else ""
        return f"{pvar}{decl}{assign}" if self._with_path else None

    def path_lvar(self, lvar: Var, rvar: Var) -> Expr:
        # avoid nested if expressions
        rvar = f"({rvar})" if " if " in rvar else rvar
        lvar = f"({lvar})" if " if " in lvar else lvar
        return f"{lvar} if {rvar} is not None else None" if self._with_path else "None"

    #
    # blocks
    #
    def report(self, msg: str, path: str) -> Block:
        """Add a a report entry."""
        return [ f"rep is None or rep.append(({self.esc(msg)}, {path}))" ] \
            if self._with_report else []

    def indent(self, block: Block) -> Block:
        """Indent a block."""
        return [ (self._indent + line) for line in filter(lambda s: s is not None, block) ]

    def arr_loop(self, arr: Var, idx: Var, val: Var, body: Block) -> Block:
        """Loop over all items of an array."""
        return [ f"for {idx}, {val} in enumerate({arr}):" ] + self.indent(body)

    def obj_loop(self, obj: Var, key: Var, val: Var, body: Block) -> Block:
        """Loop over all property-values pairs of an object."""
        return [ f"for {key}, {val} in {obj}.items():" ] + \
            self.indent([ f"assert isinstance({key}, str)" ] + body)

    def if_stmt(self, cond: BoolExpr, true: Block, false: Block = []) -> Block:
        """Generate a if-then[-else] statement."""
        if true and false:
            return [ f"if {cond}:" ] + self.indent(true) + ["else:"] + self.indent(false)
        elif true:
            return [ f"if {cond}:" ] + self.indent(true)
        else:
            return [ f"if not ({cond}):" ] + self.indent(false)

    def mif_stmt(self, cond_true: list[tuple[BoolExpr, Block]], false: Block = []) -> Block:
        """Generate a multi-if[-else] statement."""
        code, op = [], "if"
        for cond, true in cond_true:
            code += [ f"{op} {cond}:" ]
            code += self.indent(true)
            op = "elif"
        if false:
            if op != "if":
                code += [ "else:" ]
                code += self.indent(false)
            else:
                code += false
        return code

    #
    # stuff
    #
    def def_map(self, name: str, size: int) -> Block:
        """Define a new (property) map."""
        return [f"{name}: PropMap"]

    def ini_map(self, name: str, pmap: PropMap) -> Block:
        """Initialize a map."""
        return [
            f"global {name}",
            f"{name} = {{" ] + [
                (self._indent + self.esc(p) + ": " + f + ",")
                    for p, f in pmap.items()
                ] + [ "}" ]

    def def_cset(self, name: str, constants: ConstList) -> Block:
        return [ f"{name}: set[str]" ]

    def in_cset(self, name: str, var: Var, constants: ConstList) -> BoolExpr:
        return f"{var} in {name}"

    def ini_cset(self, name: str, constants: ConstList) -> Block:
        return [ f"global {name}", f"{name} = {set(constants)}" ]

    def def_fun(self, name: str) -> Block:
        """Define a function."""
        return []

    def gen_fun(self, name: str, body: Block) -> Block:
        """Generate a function."""
        return [
            f"def {name}(val: Jsonable, path: Path, rep: Report) -> bool:"
        ] + self.indent(body)

    def def_re(self, name: str, regex: str) -> Block:
        """Define a new (static) regex."""
        self._re_used = True
        return [
            # NOTE re2 imported as re
            f"{name}_search: Callable",
            f"{name}: RegexFun"
        ]

    # FIXME: remove?
    def gen_re(self, name: str, regex: str) -> Block:
        """Generate a regex check function."""
        self._re_used = True
        return []

    def ini_re(self, name: str, regex: str) -> Block:
        """Initialize a regex."""
        self._re_used = True
        sregex = self.esc(regex)
        return [
            f"global {name}_search, {name}",
            # rex engine imported as re; may raise an exception
            f"{name}_search = re.compile(r{sregex}).search",
            f"{name} = lambda s: {name}_search(s) is not None"
        ]

    def del_re(self, name: str, regex: str) -> Block:
        """Free a regex."""
        return [
            f"global {name}_search, {name}",
            f"{name}_search = None",
            f"{name} = None"
        ]

    def gen_init(self, init: Block) -> Block:
        """Generate the initialization function."""
        raise NotImplementedError("gen_init")

    def gen_free(self, free: Block) -> Block:
        """Generate the deallocation function."""
        raise NotImplementedError("gen_init")


class Code:
    """Hold generated source code for a .

    - `language`: language generator
    - `entry`: name of the entry function
    """

    def __init__(self, lang: Language, entry: str = "check_model"):
        self._lang = lang       # generated language abstraction
        self._entry = entry     # entry function name/prefix
        self._defs: Block = []  # definitions, declarations
        self._subs: Block = []  # subroutines
        self._init: Block = []  # initialization code
        self._free: Block = []  # deallocation code

    #
    # add blocks
    #
    def defs(self, b: Block = [""]):
        """Add lines to definitions."""
        self._defs += b

    def subs(self, b: Block = [""]):
        """Add lines to subroutines."""
        if self._subs:
            self._subs.append("")
        self._subs += b

    def init(self, b: Block = [""]):
        """Add lines to initialization code."""
        self._init += b

    def free(self, b: Block = [""]):
        """Add lines to cleanup code."""
        self._free += b

    # TODO rename!
    def sub(self, name: str, body: Block, *, comment: str = ""):
        """Add a function definition with a comment."""
        self.defs(self._lang.def_fun(name))
        fun = [ self._lang.lcom(comment) ] if comment else []
        fun += self._lang.gen_fun(name, body)
        self.subs(fun)

    def pmap(self, name: str, mapping: PropMap):
        """Add an mapping."""
        self.defs(self._lang.def_map(name))
        self.init(self._lang.ini_map(name, mapping))

    def cset(self, name: str, constants: ConstList):
        """Add an mapping."""
        self.defs(self._lang.def_cset(name, constants))
        self.init(self._lang.ini_cset(name, constants))

    def regex(self, name: str, regex: str):
        """Add a regex."""
        self.defs(self._lang.def_re(name, regex))
        self.subs(self._lang.gen_re(name, regex))
        self.init(self._lang.ini_re(name, regex))
        self.free(self._lang.del_re(name, regex))

    def __str__(self):
        """Gather everything to generate the full source code."""
        # compute init first as predefs may trigger more imports
        init = self._lang.gen_init(self._init)
        free = self._lang.gen_free(self._free)
        # reduce with empty lines between parts
        code: Block = []
        for block in (self._lang.file_header(), self._defs,
                self._subs, init, free, self._lang.file_footer()):
            if code and block:
                code += [""]
            code += [ line.replace("CHECK_FUNCTION_NAME", self._entry)
                        for line in block ]
        # generate source code, skipping none instructions if any
        return self._lang._isep.join(filter(lambda s: s is not None, code))
