import re
from importlib.resources import files as data_files
from .mtypes import Jsonable, JsonScalar, Number
from .utils import log, __version__

# name
type Var = str

# typed expressions
type JsonExpr = str
type BoolExpr = str
type IntExpr = str
type FloatExpr = str
type NumExpr = str
type StrExpr = str
# all value expressions
type Expr = JsonExpr|BoolExpr|IntExpr|FloatExpr|NumExpr|StrExpr

type PathExpr = str

# actual code
type Inst = str|None
type Block = list[Inst]

# must or may property name -> corresponding check function
type PropMap = dict[str, str]
type ConstList = list[None|bool|int|float|str]
type ConstMap = dict[JsonScalar, str]

class Language:
    """Dumb abstraction of an imperative language to manipulate JSON data.

    TODO reduce #funcs, eg var/val with type parameter.
    TODO move non generic methods to Python, to avoid generating python if unimplemented
    """

    def __init__(self,
            name: str, *,
            debug: bool = False,
            # operators and separators
            eq: str = "==", ne: str = "!=",
            ge: str = ">=", gt: str = ">", le: str = "<=", lt: str = "<",
            not_op: str = "not", and_op: str = "and", or_op: str = "or",
            eoi: str = "", isep: str = "\n", indent: str = "    ",
            lcom: str = "#",
            relib: str = "re2",
            # options
            with_path: bool = True, with_report: bool = True,
            with_comment: bool = True, set_caps: list[type|None] = (str,),
        ):

        # parameter consistency
        if with_path and not with_report:
            log.warning(f"path collection but no reporting")

        # keep parameters
        self._name = name  # language name
        self._debug = debug
        self._with_path = with_path
        self._with_report = with_report
        self._with_comment = with_comment

        # comparison operators
        self._eq = eq
        self._ne = ne
        self._ge = ge
        self._gt = gt
        self._le = le
        self._lt = lt
        # logical operators
        self._not = not_op
        self._and = and_op
        self._or = or_op
        # instructions and blocks
        self._eoi = eoi
        self._isep = isep
        self._indent = indent
        self._lcom = lcom
        self._relib = relib

        # other stuff
        self._version = __version__
        self._idcounts: dict[str, int] = {}  # per-prefix ident count for unicity
        self._re_used: bool = False          # whether regular expressions are used
        self.set_caps = tuple(set_caps)      # constant types in a set

    #
    # variables
    #
    def ident(self, prefix: str) -> Var:
        """Return a new identifier using prefix."""
        if prefix not in self._idcounts:
            self._idcounts[prefix] = 0
        ident = prefix + "_" + str(self._idcounts[prefix])
        self._idcounts[prefix] += 1
        return ident

    #
    # SOURCE FILE MANAGEMENT
    #
    def file_load(self, fn: str) -> Block:
        """Load a source file."""
        code = data_files("json_model.data").joinpath(fn).read_text().split("\n")
        # remove empty trailing lines
        while code and re.match(r"^\s*$", code[-1]):
            code = code[:-1]
        return code

    def file_subs(self, fname: str, block: Block) -> Block:
        """Load a file with a code block substitution."""
        code: Block = self.file_load(fname)
        body = self.indent(self.indent(block, False), False)
        bidx = code.index("CODE_BLOCK")
        assert bidx >= 0, "CODE_BLOCK marker found in file"
        code = code[:bidx] + body + code[bidx+1:]
        return code

    def file_header(self) -> Block:
        """File header."""
        return [
            self.lcom(),
            self.lcom(f"Generated by JSON Model Compiler version {self._version}"),
            self.lcom("see https://github.com/clairey-zx81/json-model"),
            self.lcom(),
        ]

    def file_footer(self) -> Block:
        """File footer."""
        return []

    #
    # inlined type test expressions about JSON data
    #
    # TODO is_a(var, type) in Python
    #
    def is_obj(self, var: Var) -> BoolExpr:
        return f"isinstance({var}, dict)"

    def is_arr(self, var: Var) -> BoolExpr:
        return f"isinstance({var}, list)"

    def is_str(self, var: Var) -> BoolExpr:
        return f"isinstance({var}, str)"

    def is_num(self, var: Var) -> BoolExpr:
        return f"isinstance({var}, (int, float)) and not isinstance({var}, bool)"

    def is_flt(self, var: Var, loose: bool = False) -> BoolExpr:
        return self.is_num(var) if loose else f"isinstance({var}, float)"

    def is_int(self, var: Var, loose: bool = False) -> BoolExpr:
        is_an_int = f"isinstance({var}, int) and not isinstance({var}, bool)"
        if loose:
            is_an_int = f"({is_an_int} or isinstance({var}, float) and {var} == int({var}))"
        return is_an_int

    def is_bool(self, var: Var) -> BoolExpr:
        return f"isinstance({var}, bool)"

    def is_null(self, var: Var) -> BoolExpr:
        return f"{var} is None"

    def is_def(self, var: Var) -> BoolExpr:
        return f"{var} != UNDEFINED"

    def is_scalar(self, var: Var) -> BoolExpr:
        return f"({var} is None or isinstance({var}, (bool, int, float, str)))"

    # FIXME number looseness is lost!
    def is_this_type(self, var: Var, tval: type|None) -> BoolExpr:
        if tval is None or tval == type(None):
            return self.is_null(var)
        elif tval is bool:
            return self.is_bool(var)
        elif tval is int:
            return self.is_int(var)
        elif tval is float:
            return self.is_flt(var)
        elif tval is str:
            return self.is_str(var)
        elif tval is list:
            return self.is_arr(var)
        elif tval is dict:
            return self.is_obj(var)
        else:
            raise NotImplementedError(f"unexpected type {tval}")

    #
    # predefs
    #
    # FIXME loose vs strict
    #
    def predef(self, var: Var, name: str, path: Var, is_str: bool = False) -> BoolExpr:
        # shortcut if the variable value is known to be a string
        if is_str:
            if name in { "$NULL", "$BOOL", "$INT", "$INTEGER", "$I32", "$I64",
                         "$U32", "$U64", "$FLOAT", "$F32", "$F64", "$NUMBER" }:
                name = "$NONE"
            elif name == "$STRING":
                name = "$ANY"
        # else full type checks
        if name == "$ANY":
            return self.const(True)
        elif name == "$NONE":
            return self.const(False)
        elif name == "$NULL":
            return self.is_null(var)
        elif name in ("$BOOL", "$BOOLEAN"):
            return self.is_bool(var)
        elif name in ("$INT", "$INTEGER", "$I32", "$I64"):
            return self.is_int(var)
        elif name in ("$U32", "$U64"):
            return self.and_op(self.is_int(var),
                               self.num_cmp(self.value(var, int), ">=", self.const(0)))
        elif name in ("$FLOAT", "$F32", "$F64"):
            return self.is_flt(var)
        elif name == "$NUMBER":
            return self.is_num(var)
        elif name == "$STRING":
            return self.is_str(var)
        elif name in ("$DATE", "$URL", "$REGEX", "$UUID"):
            raise NotImplementedError(f"TODO predef {name}")
        else:
            raise NotImplementedError(f"unexpected predef {name}")

    #
    # constants
    #
    def const(self, c: Jsonable) -> Expr:
        if c is None:
            return "None"
        elif isinstance(c, str):
            return self.esc(c)
        else:
            return str(c)

    #
    # inline json scalar value extraction
    #
    def value(self, var: Var, tvar: type) -> Expr:
        if tvar in (bool, int, float, Number, str):
            return var
        else:
            raise Exception(f"unexpected type for value extraction: {tvar.__name__}")

    def arr_item_val(self, arr: Var, idx: IntExpr) -> Expr:
        return f"{arr}[{idx}]"

    def obj_prop_val(self, obj: Var, prop: Var) -> Expr:
        return f"{obj}.get({prop}, UNDEFINED)"

    #
    # inlined length computation
    #
    def obj_len(self, var: Var) -> IntExpr:
        return f"len({var})"

    def arr_len(self, var: Var) -> IntExpr:
        return f"len({var})"

    def str_len(self, var: Var) -> IntExpr:
        return f"len({var})"

    def any_len(self, var: Var) -> IntExpr:
        return f"len({var})"

    def any_int_val(self, val: JsonExpr, tval: type) -> IntExpr:
        """Known type int extraction for constraints."""
        if tval is int:
            return self.int_val(val)
        elif tval is str:
            return self.str_len(val)
        elif tval is list:
            return self.arr_len(val)
        elif tval is dict:
            return self.obj_len(val)
        else:
            raise Exception(f"unexpected type for any_int_val: {tval.__name__}")

    #
    # boolean expression
    #
    def str_check_call(self, name: str, val: StrExpr) -> BoolExpr:
        return f"{name}({val})"

    def check_call(self, name: Var, val: JsonExpr, path: Var, is_str: bool = False) -> BoolExpr:
        return f"{name}({val}, {path}, rep)"

    def ternary(self, cond: BoolExpr, true: BoolExpr, false: BoolExpr) -> BoolExpr:
        return f"{true} if {cond} else {false}"

    def check_unique(self, val: JsonExpr, path: Var) -> BoolExpr:
        raise NotImplementedError("check_unique")

    def check_constraint(self, op: str, vop: int|float|str, val: JsonExpr, path: Var) -> BoolExpr:
        raise NotImplementedError("check_constraint")

    #
    # logical expressions
    #
    def not_op(self, e: BoolExpr) -> BoolExpr:
        return f"{self._not} {e}"

    def and_op(self, *exprs: BoolExpr) -> BoolExpr:
        return f" {self._and} ".join(exprs)

    def or_op(self, *exprs: BoolExpr) -> BoolExpr:
        return f" {self._or} ".join(exprs)

    def paren(self, e: Expr) -> Expr:
        return f"({e})"

    #
    # inline comparison expressions for numbers
    #
    def num_cmp(self, e1: NumExpr, op: str, e2: NumExpr) -> BoolExpr:
        assert op in ("=", "!=", "<", "<=", ">=", ">")
        if op == "=":
            return f"{e1} {self._eq} {e2}"
        elif op == "!=":
            return f"{e1} {self._ne} {e2}"
        elif op == "<":
            return f"{e1} {self._lt} {e2}"
        elif op == "<=":
            return f"{e1} {self._le} {e2}"
        elif op == ">=":
            return f"{e1} {self._ge} {e2}"
        elif op == ">":
            return f"{e1} {self._gt} {e2}"
        else:
            raise Exception(f"num_cmp unexpected op {op}")

    #
    # inline comparison expressions for strings
    #
    def str_cmp(self, e1: StrExpr, op: str, e2: StrExpr) -> BoolExpr:
        return self.num_cmp(e1, op, e2)

    def prop_fun(self, fun: str, prop: str, mapname: str) -> BoolExpr:
        return f"{fun} := {mapname}.get({prop})"

    #
    # for JSON values
    #
    def json_eq(self, e1: Expr, e2: Expr) -> BoolExpr:
        return f"{e1} {self._eq} {e2}"

    def json_ne(self, e1: Expr, e2: Expr) -> BoolExpr:
        return f"{e1} {self._ne} {e2}"

    #
    # simple instructions
    #
    def nope(self) -> Inst:
        return "pass"

    def lcom(self, text: str = "") -> Inst:
        """Generate a line comment."""
        if self._with_comment:
            return f"{self._lcom} {text}" if text else self._lcom
        else:
            return None

    def _var(self, var: Var, val: Expr|None, tname: str|None) -> Inst:
        """Declare and/or assign a variable."""
        assign = f" = {val}" if val else ""
        decl = f": {tname}" if tname else ""
        return f"{var}{decl}{assign}{self._eoi}"

    def json_var(self, var: Var, val: JsonExpr|None = None, declare: bool = False) -> Inst:
        """Declare a JSON variable."""
        return self._var(var, val, "Jsonable" if declare else None)

    def bool_var(self, var: Var, val: BoolExpr|None = None, declare: bool = False) -> Inst:
        """Declare a boolean variable."""
        return self._var(var, val, "bool" if declare else None)

    def int_var(self, var: Var, val: IntExpr|None = None, declare: bool = False) -> Inst:
        """Declare and assign to int variable."""
        return self._var(var, val, "int" if declare else None)

    def str_var(self, var: Var, val: IntExpr|None = None, declare: bool = False) -> Inst:
        """Declare and assign to str variable."""
        return self._var(var, val, "str" if declare else None)

    def flt_var(self, var: Var, val: IntExpr|None = None, declare: bool = False) -> Inst:
        """Declare and assign to str variable."""
        return self._var(var, val, "float" if declare else None)

    def fun_var(self, var: Var, val: Expr|None = None, declare: bool = False) -> Inst:
        """Declare a check function variable pointer."""
        # FIXME should guard for scalar?
        return self._var(var, val, "CheckFun" if declare else None)

    def iand_op(self, res: Var, e: BoolExpr) -> Inst:
        """And-update boolean variable."""
        return "{var} &= {e}{self.eoi}"

    def inc_var(self, var: Var) -> Inst:
        """Increment integer variable."""
        return f"{var} += 1{self._eoi}"

    def ret(self, res: BoolExpr) -> Inst:
        """Return boolean result."""
        return f"return {res}{self._eoi}"

    def brk(self) -> Inst:
        """Break from surrounding loop."""
        return f"break{self._eoi}"

    def esc(self, s: str) -> StrExpr:
        """Escape string."""
        return '"' + s.replace("\\", "\\\\").replace('"', r'\"') + '"'

    #
    # paths:
    #
    # fun(path: Path)
    # lpath: Path = path + [ segment ]  # if path is not None, else None !
    # checker(val, lpath, ...)
    #
    # fun(Path* path)
    # Path lpath = (Path) { ..., path }
    # checker(val, path ? &lpath : NULL, ...)
    #
    # TODO consider merging path_var and path_val?
    #
    def path_val(self, pvar: Var, pseg: str|int, is_prop: bool) -> PathExpr:
        """Append a segment variable/value to path."""
        # avoid nested if expressions
        pvar = f"({pvar})" if " if " in pvar else pvar
        return f"({pvar} + [ {pseg} ]) if {pvar} is not None else None" if self._with_path else "None"

    def path_var(self, pvar: Var, val: PathExpr|None = None, declare: bool = False) -> Inst:
        """Assign and possibly declare a value to a path variable."""
        assign = f" = {val}" if val else ""
        decl = ": Path" if declare else ""
        return f"{pvar}{decl}{assign}" if self._with_path else None

    def path_lvar(self, lvar: Var, rvar: Var) -> Expr:
        # avoid nested if expressions
        rvar = f"({rvar})" if " if " in rvar else rvar
        lvar = f"({lvar})" if " if " in lvar else lvar
        return f"{lvar} if {rvar} is not None else None" if self._with_path else "None"

    #
    # blocks
    #
    def report(self, msg: str, path: Var) -> Block:
        """Add a a report entry."""
        return [ f"rep is None or rep.append(({self.esc(msg)}, {path}))" ] \
            if self._with_report else []

    def indent(self, block: Block, sep: bool = True) -> Block:
        """Indent a block."""
        return [ (self._indent + line) for line in filter(lambda s: s is not None, block) ]

    def arr_loop(self, arr: Var, idx: Var, val: Var, body: Block) -> Block:
        """Loop over all items of an array."""
        return [ f"for {idx}, {val} in enumerate({arr}):" ] + self.indent(body)

    def obj_loop(self, obj: Var, key: Var, val: Var, body: Block) -> Block:
        """Loop over all property-values pairs of an object."""
        return [ f"for {key}, {val} in {obj}.items():" ] + \
            self.indent([ f"assert isinstance({key}, str)" ] + body)

    def if_stmt(self, cond: BoolExpr, true: Block, false: Block = []) -> Block:
        """Generate a if-then[-else] statement."""
        if true and false:
            return [ f"if {cond}:" ] + self.indent(true) + ["else:"] + self.indent(false)
        elif true:
            return [ f"if {cond}:" ] + self.indent(true)
        else:
            return [ f"if not ({cond}):" ] + self.indent(false)

    def mif_stmt(self, cond_true: list[tuple[BoolExpr, Block]], false: Block = []) -> Block:
        """Generate a multi-if[-else] statement."""
        code, op = [], "if"
        for cond, true in cond_true:
            code += [ f"{op} {cond}:" ]
            code += self.indent(true)
            op = "elif"
        if false:
            if op != "if":
                code += [ "else:" ]
                code += self.indent(false)
            else:
                code += false
        return code

    #
    # PROPERTY MAPPING : property value (constant string) to check function
    #
    def def_pmap(self, name: str, pmap: PropMap, public: bool) -> Block:
        """Define a new (property) map."""
        return [f"{name}: PropMap"]

    def sub_pmap(self, name: str, pmap: PropMap, public: bool) -> Block:
        return []

    def ini_pmap(self, name: str, pmap: PropMap, public: bool) -> Block:
        """Initialize a map."""
        return [
            f"global {name}",
            f"{name} = {{" ] + [
                (self._indent + self.esc(p) + ": " + f + ",")
                    for p, f in pmap.items()
                ] + [ "}" ]

    def del_pmap(self, name: str, pmap: PropMap, public: bool) -> Block:
        return []

    #
    # CONSTANT SET FOR ENUM OPTIMIZATION
    #
    def def_cset(self, name: str, constants: ConstList) -> Block:
        return [ f"{name}: set[str]" ]

    def ini_cset(self, name: str, constants: ConstList) -> Block:
        # generate a deterministic initialization
        dset = str(sorted(list(constants)))
        dset = f"{{{dset[1:-1]}}}"
        return [ f"global {name}", f"{name} = {dset}" ]

    def del_cset(self, name: str, constants: ConstList) -> Block:
        return []
        
    def sub_cset(self, name: str, constants: ConstList) -> Block:
        return []

    def in_cset(self, name: str, var: Var, constants: ConstList) -> BoolExpr:
        return f"{var} in {name}"

    #
    # CHECK FUNCTION SIGNATURE
    #
    def def_fun(self, name: str) -> Block:
        """Define a function."""
        return []

    def sub_fun(self, name: str, body: Block) -> Block:
        """Generate a check function."""
        return [
            f"def {name}(val: Jsonable, path: Path, rep: Report) -> bool:"
        ] + self.indent(body)

    #
    # REGULAR EXPRESSION PRECOMPILATION
    #
    def def_re(self, name: str, regex: str) -> Block:
        """Define a new (static) regex."""
        self._re_used = True
        return [
            # NOTE re2 imported as re
            f"{name}_search: Callable",
            f"{name}: RegexFun"
        ]

    # FIXME: remove?
    def sub_re(self, name: str, regex: str) -> Block:
        """Generate a regex check function."""
        self._re_used = True
        return []

    def ini_re(self, name: str, regex: str) -> Block:
        """Initialize a regex."""
        self._re_used = True
        sregex = self.esc(regex)
        return [
            f"global {name}_search, {name}",
            # rex engine imported as re; may raise an exception
            f"{name}_search = re.compile({sregex}).search",
            f"{name} = lambda s: {name}_search(s) is not None"
        ]

    def del_re(self, name: str, regex: str) -> Block:
        """Free a regex."""
        return [
            f"global {name}_search, {name}",
            f"{name}_search = None",
            f"{name} = None"
        ]

    #
    # CONSTANT MAPPING FOR DISCRIMINANT OPTIMIZATION
    # constant value to check function
    #
    def get_cmap(self, name: str, tag: Var, ttag: type) -> Expr:
        """Return the function associated to the tag value if any."""
        return f"{name}.get({self.value(tag, ttag)}, UNDEFINED)"

    def _str_map(self, mapping: dict[JsonScalar, str]) -> bool:
        return all(isinstance(k, str) for k in mapping.keys())

    def def_cmap(self, name: str, mapping: dict[JsonScalar, str]) -> Block:
        """Declare a new constant map."""
        if self._str_map(mapping):
            return [ f"{name}: dict[str, str]" ]
        else:
            return [ f"{name}: ConstMap = ConstMap()" ]

    def sub_cmap(self, name: str, mapping: dict[JsonScalar, str]) -> Block:
        return []

    def ini_cmap(self, name: str, mapping: dict[JsonScalar, str]) -> Block:
        """Initialize constant mapping."""
        icode = [ f"global {name}" ]
        if self._str_map(mapping):
            icode += [
                f"{name} = {{", ] + [
                f"    {self.const(v)}: {fun},"
                    for v, fun in mapping.items()
            ] + [ r"}" ]
        else:
            for v, fun in mapping.items():
                icode += [ f"{name}[{self.const(v)}] = {fun}" ]
        return icode

    def del_cmap(self, name: str, mapping: dict[JsonScalar, str]) -> Block:
        return []

    #
    # FUNCTIONS
    #
    def gen_init(self, init: Block) -> Block:
        """Generate the initialization function."""
        raise NotImplementedError("gen_init")

    def gen_free(self, free: Block) -> Block:
        """Generate the deallocation function."""
        raise NotImplementedError("gen_free")


class Code:
    """Hold generated source code for a .

    - `language`: language generator
    - `entry`: name of the entry function
    """

    def __init__(self, lang: Language, entry: str = "check_model"):
        self._lang = lang       # generated language abstraction
        self._entry = entry     # entry function name/prefix
        self._defs: Block = []  # definitions and declarations
        self._inis: Block = []  # initialization code
        self._dels: Block = []  # deallocation code
        self._subs: Block = []  # actual subroutines

    #
    # add blocks
    #
    def defs(self, b: Block = [""]):
        """Add lines to definitions."""
        self._defs += b

    def subs(self, b: Block = [""]):
        """Add lines to subroutines."""
        if self._subs:
            self._subs.append("")
        self._subs += b

    def inis(self, b: Block = [""]):
        """Add lines to initialization code."""
        self._inis += b

    def dels(self, b: Block = [""]):
        """Add lines to cleanup code."""
        self._dels += b

    # TODO rename!
    def sub(self, name: str, body: Block, *, comment: str = ""):
        """Add a function definition with a comment."""
        self.defs(self._lang.def_fun(name))
        fun = [ self._lang.lcom(comment) ] if comment else []
        fun += self._lang.sub_fun(name, body)
        self.subs(fun)

    def pmap(self, name: str, mapping: PropMap, public: bool = False):
        """Add a (property/name) mapping."""
        self.defs(self._lang.def_pmap(name, mapping, public))
        self.inis(self._lang.ini_pmap(name, mapping, public))
        self.dels(self._lang.del_pmap(name, mapping, public))
        self.subs(self._lang.sub_pmap(name, mapping, public))

    def cset(self, name: str, constants: ConstList):
        """Add a constant set."""
        self.defs(self._lang.def_cset(name, constants))
        self.inis(self._lang.ini_cset(name, constants))
        self.dels(self._lang.del_cset(name, constants))
        self.subs(self._lang.sub_cset(name, constants))

    def cmap(self, name: str, mapping: ConstMap):
        """Add a constant value mapping."""
        self.defs(self._lang.def_cmap(name, mapping))
        self.inis(self._lang.ini_cmap(name, mapping))
        self.dels(self._lang.del_cmap(name, mapping))
        self.subs(self._lang.sub_cmap(name, mapping))

    def regex(self, name: str, regex: str):
        """Add a regex."""
        self.defs(self._lang.def_re(name, regex))
        self.inis(self._lang.ini_re(name, regex))
        self.dels(self._lang.del_re(name, regex))
        self.subs(self._lang.sub_re(name, regex))

    def __str__(self):
        """Gather everything to generate the full source code."""

        # compute init first as predefs may trigger more imports
        inis = self._lang.gen_init(self._inis)
        dels = self._lang.gen_free(self._dels)

        # reduce with empty lines between parts
        code: Block = []
        for block in (self._lang.file_header(), self._defs,
                self._subs, inis, dels, self._lang.file_footer()):
            if code and block:
                code += [""]
            code += [ line.replace("CHECK_FUNCTION_NAME", self._entry)
                        for line in block ]

        # generate source code, skipping none instructions if any
        return self._lang._isep.join(filter(lambda s: s is not None, code)) + "\n"
