from importlib.resources import files as data_files
from .mtypes import Jsonable
from .utils import log

# name
type Var = str

# typed expressions
type JsonExpr = str
type BoolExpr = str
type IntExpr = str
type FloatExpr = str
type NumExpr = str
type StrExpr = str
type Expr = JsonExpr|BoolExpr|IntExpr|FloatExpr|NumExpr|StrExpr

# actual code
type Inst = str
type Block = list[Inst]

# must or may property name -> corresponding check function
type PropMap = dict[str, str]


class Language:
    """Dumb abstraction of an imperative language to manipulate JSON data.

    Some reasonable defaults are provided base on operators and assuming Python,
    but the child must be instanciated to get meaningful code.
    """

    def __init__(self,
            name: str, *,
            eq: str = "==", ne: str = "!=",
            ge: str = ">=", gt: str = ">", le: str = "<=", lt: str = "<",
            not_op: str = "not", and_op: str = "and", or_op: str = "or",
            eoi: str = "", isep: str = "\n", indent: str = "    ",
            lcom: str = "#",
            relib: str = "re2",
            debug: bool = False,
        ):
        # keep parameters
        self._name = name  # language name
        self._debug = debug
        # comparison operators
        self._eq = eq
        self._ne = ne
        self._ge = ge
        self._gt = gt
        self._le = le
        self._lt = lt
        # logical operators
        self._not = not_op
        self._and = and_op
        self._or = or_op
        # instructions and blocks
        self._eoi = eoi
        self._isep = isep
        self._indent = indent
        self._lcom = lcom
        self._relib = relib
        # per prefix identifier count
        self._idcounts: dict[str, int] = {}

    #
    # variables
    #
    def new_ident(self, prefix: str) -> Var:
        """Return a new identifier using prefix."""
        if prefix not in self._idcounts:
            self._idcounts[prefix] = 0
        ident = prefix + "_" + str(self._idcounts[prefix])
        self._idcounts[prefix] += 1
        return ident

    #
    # file
    #
    def load_data(self, fn: str) -> Block:
        code = data_files("json_model.data").joinpath(fn).read_text().split("\n")
        assert code[-1] == "", f"newline-terminated source file {fn}"
        return code[:-1]

    def file_header(self) -> Block:
        return [
            self.lcom(),
            self.lcom("Generated by JSON Model Compiler"),
            self.lcom("see https://github.com/clairey-zx81/json-model"),
            self.lcom(),
        ]

    def file_footer(self) -> Block:
        return []

    #
    # inlined type test expressions about JSON data
    #
    def is_obj(self, var: Var) -> BoolExpr:
        return f"isinstance({var}, dict)"

    def is_arr(self, var: Var) -> BoolExpr:
        return f"isinstance({var}, list)"

    def is_str(self, var: Var) -> BoolExpr:
        return f"isinstance({var}, str)"

    def is_num(self, var: Var) -> BoolExpr:
        return f"isinstance({var}, (int, float)) and not isinstance({var}, bool)"

    def is_flt(self, var: Var, loose: bool = False) -> BoolExpr:
        return self.is_num(var) if loose else f"isinstance({var}, float)"

    def is_int(self, var: Var, loose: bool = False) -> BoolExpr:
        is_an_int = f"isinstance({var}, int) and not isinstance({var}, bool)"
        if loose:
            is_an_int = f"({is_an_int} or isinstance({var}, float) and var == int({var}))" 
        return is_an_int

    def is_bool(self, var: Var) -> BoolExpr:
        return f"isinstance({var}, bool)"

    def is_null(self, var: Var) -> BoolExpr:
        return f"{var} is None"

    #
    # predefs
    #
    def predef(self, var: Var, name: str) -> BoolExpr:
        if name == "$ANY":
            return self.bool_cst(True)
        elif name == "$NONE":
            return self.bool_cst(False)
        elif name == "$NULL":
            return self.is_null(var)
        elif name in ("$BOOL", "$BOOLEAN"):
            return self.is_bool(var)
        elif name in ("$INT", "$INTEGER", "$I32", "$I64"):
            return self.is_int(var)
        elif name in ("$U32", "$U64"):
            return self.and_op(self.is_int(var),
                               self.num_ge(self.int_val(var), self.int_cst(0)))
        elif name in ("$FLOAT", "$F32", "$F64"):
            return self.is_flt(var)
        elif name == "$NUMBER":
            return self.is_num(var)
        elif name == "$STRING":
            return self.is_str(var)
        elif name in ("$DATE", "$URL", "$REGEX"):
            raise NotImplementedError(f"TODO predef {name}")
        else:
            raise NotImplementedError(f"unexpected predef {name}")
 
    #
    # constants
    #
    def bool_cst(self, b: bool) -> BoolExpr:
        return "True" if b else "False"

    def int_cst(self, i: int) -> IntExpr:
        return str(i)

    def flt_cst(self, f: float) -> FloatExpr:
        return str(f)

    def str_cst(self, s: str) -> StrExpr:
        return self.esc(s)

    def json_cst(self, j: Jsonable) -> JsonExpr:
        return str(j)

    #
    # inline json scalar value extraction
    #
    def bool_val(self, var: Var) -> BoolExpr:
        return var

    def int_val(self, var: Var) -> IntExpr:
        return var

    def flt_val(self, var: Var) -> FloatExpr:
        return var

    def str_val(self, var: Var) -> StrExpr:
        return var

    def arr_item_val(self, arr: Var, idx: IntExpr) -> Expr:
        return f"{arr}[{idx}]"

    def obj_prop_val(self, obj: Var, prop: Var) -> Expr:
        return f"{obj}[{prop}]"

    #
    # inlined length computation
    #
    def obj_len(self, var: Var) -> IntExpr:
        return f"len({var})"

    def arr_len(self, var: Var) -> IntExpr:
        return f"len({var})"

    def str_len(self, var: Var) -> IntExpr:
        return f"len({var})"

    def any_len(self, var: Var) -> IntExpr:
        return f"len({var})"

    #
    # boolean expression
    #
    def check_call(self, name) -> BoolExpr:
        return f"{name}(val, path, rep)"
        
    def ternary(self, cond: BoolExpr, true: BoolExpr, false: BoolExpr) -> BoolExpr:
        return f"{true} if {cond} else {false}"

    #
    # logical expressions
    #
    def not_op(self, e: BoolExpr) -> BoolExpr:
        return f"{self._not} {e}"

    def and_op(self, e1: BoolExpr, e2: BoolExpr) -> BoolExpr:
        return f"{e1} {self._and} {e2}"

    def or_op(self, e1: BoolExpr, e2: BoolExpr) -> BoolExpr:
        return f"{e1} {self._or} {e2}"

    def paren(self, e: Expr) -> Expr:
        return f"({e})"

    #
    # inline comparison expressions for numbers
    #
    def num_eq(self, e1: NumExpr, e2: NumExpr) -> BoolExpr:
        return f"{e1} {self._eq} {e2}"

    def num_ne(self, e1: NumExpr, e2: NumExpr) -> BoolExpr:
        return f"{e1} {self._ne} {e2}"

    def num_ge(self, e1: NumExpr, e2: NumExpr) -> BoolExpr:
        return f"{e1} {self._ge} {e2}"

    def num_gt(self, e1: NumExpr, e2: NumExpr) -> BoolExpr:
        return f"{e1} {self._gt} {e2}"

    def num_le(self, e1: NumExpr, e2: NumExpr) -> BoolExpr:
        return f"{e1} {self._le} {e2}"

    def num_lt(self, e1: NumExpr, e2: NumExpr) -> BoolExpr:
        return f"{e1} {self._lt} {e2}"

    #
    # inline comparison expressions for strings
    #
    def str_eq(self, e1: StrExpr, e2: StrExpr) -> BoolExpr:
        return f"{e1} {self._eq} {e2}"

    def str_ne(self, e1: StrExpr, e2: StrExpr) -> BoolExpr:
        return f"{e1} {self._ne} {e2}"

    def str_ge(self, e1: StrExpr, e2: StrExpr) -> BoolExpr:
        return f"{e1} {self._ge} {e2}"

    def str_gt(self, e1: StrExpr, e2: StrExpr) -> BoolExpr:
        return f"{e1} {self._gt} {e2}"

    def str_le(self, e1: StrExpr, e2: StrExpr) -> BoolExpr:
        return f"{e1} {self._le} {e2}"

    def str_lt(self, e1: StrExpr, e2: StrExpr) -> BoolExpr:
        return f"{e1} {self._lt} {e2}"

    #
    # for JSON values
    #
    def json_eq(self, e1: Expr, e2: Expr) -> BoolExpr:
        return f"e1 {self._eq} {e2}"

    def json_ne(self, e1: Expr, e2: Expr) -> BoolExpr:
        return f"e1 {self._ne} {e2}"

    #
    # simple instructions
    #
    def lcom(self, text: str = "") -> Inst:
        return f"{self._lcom} {text}" if text else self._lcom

    def decl_json_var(self, var: Var) -> Inst:
        return f"{var}: Jsonable{self._eoi}"

    def decl_bool_var(self, var: Var) -> Inst:
        return f"{var}: bool{self._eoi}"

    def json_var_val(self, var: Var, expr: Expr) -> Inst:
        return f"{var} = {expr}{self._eoi}"

    def bool_var_val(self, var: Var, expr: BoolExpr) -> Inst:
        return f"{var} = {expr}{self._eoi}"

    def decl_json_var_val(self, var: Var, expr: Expr) -> Inst:
        return f"{var}: Jsonable = {expr}{self._eoi}"

    def decl_bool_var_val(self, var: Var, expr: BoolExpr) -> Inst:
        return f"{var}: bool = {expr}{self._eoi}"

    def ret(self, res: BoolExpr) -> Inst:
        return f"return {res}{self._eoi}"

    def esc(self, s: str) -> str:
        return '"' + s.replace('"', r'\"') + '"'

    #
    # blocks
    #
    def report(self, msg: str) -> Block:
        return [ f"rep is None or rep.append(f{self.esc(msg)})" ]

    def indent(self, block: Block) -> Block:
        return [ (self._indent + line) for line in block ]

    def arr_loop(self, arr: Var, idx: Var, val: Var, body: Block) -> Block:
        return [ f"for {idx}, {val} in enumerate({arr}):" ] + self.indent(body)

    def obj_loop(self, obj: Var, key: Var, val: Var, body: Block) -> Block:
        return [ f"for {key}, {val} in {obj}.items():" ] + self.indent(body)

    def if_stmt(self, cond: BoolExpr, true: Block, false: Block = []) -> Block:
        if true and false:
            return [ f"if {cond}:" ] + self.indent(true) + ["else:"] + self.indent(false)
        elif true:
            return [ f"if {cond}:" ] + self.indent(true)
        else:
            return [ f"if not ({cond}):" ] + self.indent(false)

    def mif(self, cond_true: list[tuple[BoolExpr, Block]], false: Block = []) -> Block:
        code, op = [], "if"
        for cond, true in cond_true:
            code += [ f"{op} {cond}:" ]
            code += self.indent(true)
            op = "elif"
        if false:
            if op != "if":
                code += [ "else:" ]
                code += self.indent(false)
            else:
                code += false
        return code

    #
    # stuff
    #
    def decl_fun(self, name: str, local: bool = False) -> Block:
        return []

    def gen_fun(self, name: str, body: Block, local: bool = False) -> Block:
        return [
            f"def {name}(val: Jsonable, path: Path, rep: Report) -> bool:"
        ] + self.indent(body)

    def decl_re(self, name: str, regex: str) -> Block:
        sregex = self.esc(regex)
        return [
            f"_{name}_search = {self._relib}.compile(r{sregex}).search",
            f"{name}: RegexFun = lambda s: _{name}_search(s) is not None"
        ]

    def gen_re(self, name: str, regex: str) -> Block:
        return []

    def init_re(self, name: str, regex: str) -> Block:
        return []

    def decl_map(self, name: str) -> Block:
        return [ f"{name}: PropMap" ]

    def init_map(self, name: str, pmap: PropMap) -> Block:
        return [ f"global {name}", f"{name} = {pmap}" ]

    def gen_init(self, init: Block) -> Block:
        raise NotImplementedError("gen_init")


class Code:
    """Hold generated source code.

    - `language`: language generator
    """

    def __init__(self, lang: Language):
        self._lang = lang
        self._head: Block = []  # headers
        self._defs: Block = []  # definitions/declarations
        self._help: Block = []  # helper functions
        self._init: Block = []  # constant initialization code
        self._subs: Block = []  # object and model functions

    def clear(self):
        """Clear all contents."""
        self._head.clear()
        self._defs.clear()
        self._help.clear()
        self._subs.clear()
        self._init.clear()
    
    def head(self, b: Block = [""]):
        """Add lines to headers."""
        self._head += b

    def defs(self, b: Block = [""]):
        """Add lines to definitions."""
        self._defs += b
    
    def help(self, b: Block = [""]):
        """Add lines to helpers."""
        self._help += b

    def subs(self, b: Block = [""]):
        """Add lines to subroutines."""
        self._subs += b

    def init(self, b: Block = [""]):
        """Add lines to initialization code."""
        self._init += b

    def sub(self, name: str, body: Block, *, comment: str = "", local: bool = False):
        """Add a function definition with a comment."""
        self.defs(self._lang.decl_fun(name, local))
        fun = [ self._lang.lcom(comment) ] if comment else []
        fun += self._lang.gen_fun(name, body, local)
        self.subs(([""] if self._subs else []) + fun)

    def pmap(self, name: str, mapping, PropMap):
        """Add an object property mapping definition."""
        self.defs(self._lang.decl_map(name))
        self.init(self._lang.init_map(name, mapping))

    def __str__(self):
        code = (self._lang.file_header() + self._head + self._help + self._defs +
            self._subs + self._lang.gen_init(self._init) + self._lang.file_footer())
        return self._lang._isep.join(code)
